[
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/overview/",
    "title": "Overview",
    "tags": [],
    "description": "BFF",
    "content": "Duende.BFF is a library for building services that solve security and identity problems in browser based applications such as SPAs and Blazor WASM applications. It is used to create a backend host that is paired with a frontend application. This backend is called the Backend For Frontend (BFF) host, and is responsible for all of the OAuth and OIDC protocol interactions. Moving the protocol handling out of JavaScript provides important security benefits and works around changes in browser privacy rules that increasingly disrupt OAuth and OIDC protocol flows in browser based applications. The Duende.BFF library makes it easy to build and secure BFF hosts by providing session and token management, API endpoint protection, and logout notifications.\nThreats against browser based applications Browser based applications have a relatively large attack surface. Security risks come not only from the application\u0026rsquo;s own code, which must be protected against cross site scripting, cross site request forgery, and other vulnerabilities, but also from the frameworks, libraries, and other NPM packages it uses, as well as all of their transitive dependencies. Additionally, other applications running on the same site must also be secured. The recent Spectre attacks against browsers serve as a reminder that new threats are constantly emerging. Given all of these risks, we do not recommend storing high-value access tokens or refresh tokens in JavaScript-accessible locations.\nIn Duende.BFF, tokens are only accessible server-side and sessions are managed using encrypted and signed HTTP-only cookies. This greatly simplifies the threat model and reduces risk. While content injection attacks are still possible, the BFF limits the attacker\u0026rsquo;s ability to abuse APIs by constraining access through a well-defined interface to the backend which eliminates the possibility of arbitrary API calls.\nChanges in browser privacy rules Browsers are increasingly restricting the use of cookies across site boundaries to protect user privacy. This can be a problem for legitimate OAuth and OpenID Connect interactions, as some interactions in these protocols are indistinguishable from common tracking mechanisms from a browser\u0026rsquo;s perspective. When the identity provider and client application are hosted on 3rd party sites, this affects several flows, including:\nFront-channel logout notifications OpenID Connect Session Management The \u0026ldquo;silent renew\u0026rdquo; technique for session-bound token refreshing Using a BFF removes or mitigates all of these problems in the design. The backend component makes backchannel logout notifications possible, while still allowing the option of front-channel notifications for 1st party clients. Robust server-side session and token management with optional server-side sessions and refresh tokens take the place of OIDC Session Management and older token refresh mechanisms. As an ASP.NET Core server-side application, the BFF has access to a full featured and stable OpenID Connect client library that supports all the necessary protocol mechanisms and provides an excellent extensibility model for advanced features like Mutual TLS, DPoP, JWT secured authorization requests, and JWT-based client authentication.\nLogical and Physical Sessions When implemented correctly, a user will think of their time interacting with a solution as \u0026ldquo;one session\u0026rdquo; also known as the \u0026ldquo;logical session\u0026rdquo;. The user should be unaware of the steps taken by developers to provide the experience and rightfully so. Users want to use the app, get their tasks completed, and log out happy.\nsequenceDiagram actor Alice Alice-\u003e\u003eApp: /login App-\u003e\u003eAlice: /account box logical session participant App end So while the user will only see only (and care about) a single session, it\u0026rsquo;s entirely possible that there will be multiple physical sessions active. For most distributed applications, including those implemented with BFF, sessions are managed independently by each component of an application architecture. This means that there are N+1 physical sessions possible, where N is the number of sessions for each service in your solution, and the +1 being the session managed on the BFF host. Since we are focusing on ASP.NET Core, those sessions typically are stored using the Cookie Authentication handler features of .NET.\nsequenceDiagram actor Alice Alice-\u003e\u003eApp: /login App-\u003e\u003eAlice: /account App-\u003e\u003eService 1: request App--\u003e\u003eService N...: N... request box App session participant App end box Service 1 session participant Service 1 end box Service N... session participant Service N... end The separation allows each service to manage its session to its specific needs. While it can depend on your requirements, we find most developers want to coordinate the physical session lifetimes, creating a more predictable logical session. If that is your case, we recommend you first start by turning each physical session into a more powerful server-side session.\nServer-side sessions are instances that are persisted to data storage and allow for visibility into currently active sessions and better management techniques. Let\u0026rsquo;s take a look at the advantages of server-side sessions. Server-side sessions at each component allows for:\nReceiving back channel logout notifications Forcibly end a user\u0026rsquo;s session of that node Store and view information about a session lifetime Coordinate sessions across an application\u0026rsquo;s components Different claims data Server-side sessions at IdentityServer allow for more powerful features:\nReceive back channel logout notifications from upstream identity providers in a federation Forcibly end a user\u0026rsquo;s session at IdentityServer Global inactivity timeout across SSO apps and session coordination Coordinate sessions to registered clients Keep in mind the distinctions between logical and physical sessions and you will better understand the interplay between elements in your solution.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/extensibility/management/login/",
    "title": "BFF Login Endpoint Extensibility",
    "tags": [],
    "description": "",
    "content": "The BFF login endpoint has extensibility points in two interfaces. The ILoginService is the top level abstraction that processes requests to the endpoint. This service can be used to add custom request processing logic. The IReturnUrlValidator ensures that the returnUrl parameter passed to the login endpoint is safe to use.\nRequest Processing ProcessRequestAsync is the top level function called in the endpoint service and can be used to add arbitrary logic to the endpoint.\nFor example, you could take whatever actions you need before normal processing of the request like this:\npublic override Task ProcessRequestAsync(HttpContext context) { // Custom logic here return base.ProcessRequestAsync(context); } Return URL Validation To prevent open redirector attacks, the returnUrl parameter to the login endpoint must be validated. You can customize this validation by implementing the IReturnUrlValidator interface. The default implementation enforces that return urls are local.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/architecture/",
    "title": "Architecture",
    "tags": [],
    "description": "",
    "content": "A BFF host is an ASP.NET Core application with the following components:\nThese components handle OIDC and OAuth protocol requests and responses, manage user sessions and tokens, secure API endpoints for the front end, and optionally serve UI assets.\nDuende.BFF builds on widely used tools and frameworks, including ASP.NET Core\u0026rsquo;s OpenID Connect and cookie authentication handlers, YARP, and Duende.AccessTokenManagement. Duende.BFF combines these tools and adds additional security and application features that are useful with a BFF architecture so that you can focus on providing application logic instead of security logic:\nASP.NET OpenID Connect Handler Duende.BFF uses ASP.NET\u0026rsquo;s OpenID Connect handler for OIDC and OAuth protocol processing. As long-term users of and contributors to this library, we think it is a well implemented and flexible implementation of the protocols.\nASP.NET Cookie Handler Duende.BFF uses ASP.NET\u0026rsquo;s Cookie handler for session management. The Cookie handler provides a claims-based identity to the application persisted in a digitally signed and encrypted cookie that is protected with modern cookie security features, including the Secure, HttpOnly and SameSite attributes. The handler also provides absolute and sliding session support, and has a flexible extensibility model, which Duende.BFF uses to implement server-side session management and back-channel logout support.\nDuende.AccessTokenManagement Duende.BFF uses the Duende.AccessTokenManagement library for access token management and storage. This includes storage and retrieval of tokens, refreshing tokens as needed, and revoking tokens on logout. The library provides integration with the ASP.NET HTTP client to automatically attach tokens to outgoing HTTP requests, and its underlying management actions can also be programmatically invoked through an imperative API.\nAPI Endpoints In the BFF architecture, the frontend makes API calls to backend services via the BFF host exclusively. Typically the BFF acts as a reverse proxy to remote APIs, providing session and token management. Implementing local APIs within the BFF host is also possible. Regardless, requests to APIs are authenticated with the session cookie and need to be secured with an anti-forgery protection header.\nYARP Duende.BFF proxies requests to remote APIs using Microsoft\u0026rsquo;s YARP (Yet Another Reverse Proxy). You can set up YARP using a simplified developer-centric configuration API provided by Duende.BFF, or if you have more complex requirements, you can use the full YARP configuration system directly. If you are using YARP directly, Duende.BFF provides YARP integration to add BFF security and identity features.\nUI Assets The BFF host typically serves at least some of the UI assets of the frontend, which can be HTML/JS/CSS, WASM, and/or server-rendered content. Serving the UI assets, or at least the index page of the UI from the same origin as the backend simplifies requests from the frontend to the backend. Doing so makes the two components same-origin, so that browsers will allow requests with no need to use CORS and automatically include cookies (including the crucial authentication cookie). This also avoids issues where third-party cookie blocking or the SameSite cookie attribute prevents the frontend from sending the authentication cookie to the backend.\nIt is also possible to separate the BFF and UI and host them separately. See here for more discussion of UI hosting architecture.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/session/handlers/",
    "title": "ASP.NET Core Authentication System",
    "tags": [],
    "description": "",
    "content": "You typically use the following two ASP.NET Core authentication handlers to implement remote authentication:\nthe OpenID Connect authentication handler to interact with the remote OIDC / OAuth token service, e.g. Duende IdentityServer the cookie handler to do local session management Furthermore the BFF plumbing relies on the configuration of the ASP.NET Core default authentication schemes. This describes how the two handlers share the work.\nOpenID Connect for challenge and signout - cookies for all the other operations:\nbuilder.Services.AddAuthentication(options =\u0026gt; { options.DefaultScheme = \u0026#34;cookie\u0026#34;; options.DefaultChallengeScheme = \u0026#34;oidc\u0026#34;; options.DefaultSignOutScheme = \u0026#34;oidc\u0026#34;; }) .AddCookie(\u0026#34;cookie\u0026#34;, options =\u0026gt; { ... }) .AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { ... }); The OpenID Connect Authentication Handler The OIDC handler connects the application to the authentication / access token system.\nThe exact settings depend on the OIDC provider and its configuration settings. We recommend:\nuse authorization code flow with PKCE use a response_mode of query since this plays nicer with SameSite cookies use a strong client secret. Since the BFF can be a confidential client, it is totally possible to use strong client authentication like JWT assertions, JAR or MTLS. Shared secrets work as well of course. turn off inbound claims mapping save the tokens into the authentication session so they can be automatically managed request a refresh token using the offline_access scope builder.Services.AddAuthentication().AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { options.Authority = \u0026#34;https://demo.duendesoftware.com\u0026#34;; // confidential client using code flow + PKCE options.ClientId = \u0026#34;spa\u0026#34;; options.ClientSecret = \u0026#34;secret\u0026#34;; options.ResponseType = \u0026#34;code\u0026#34;; // query response type is compatible with strict SameSite mode options.ResponseMode = \u0026#34;query\u0026#34;; // get claims without mappings options.MapInboundClaims = false; options.GetClaimsFromUserInfoEndpoint = true; // save tokens into authentication session // to enable automatic token management options.SaveTokens = true; // request scopes options.Scope.Clear(); options.Scope.Add(\u0026#34;openid\u0026#34;); options.Scope.Add(\u0026#34;profile\u0026#34;); options.Scope.Add(\u0026#34;api\u0026#34;); // and refresh token options.Scope.Add(\u0026#34;offline_access\u0026#34;); }); The OIDC handler will use the default sign-in handler (the cookie handler) to establish a session after successful validation of the OIDC response.\nThe Cookie Handler The cookie handler is responsible for establishing the session and manage authentication session related data.\nThings to consider:\ndetermine the session lifetime and if the session lifetime should be sliding or absolute it is recommended to use a cookie name prefix if compatible with your application use the highest available SameSite mode that is compatible with your application, e.g. strict, but at least lax builder.Services.AddAuthentication().AddCookie(\u0026#34;cookie\u0026#34;, options =\u0026gt; { // set session lifetime options.ExpireTimeSpan = TimeSpan.FromHours(8); // sliding or absolute options.SlidingExpiration = false; // host prefixed cookie name options.Cookie.Name = \u0026#34;__Host-spa\u0026#34;; // strict SameSite handling options.Cookie.SameSite = SameSiteMode.Strict; }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/extensibility/management/",
    "title": "BFF Management Endpoints Extensibility",
    "tags": [],
    "description": "",
    "content": "The behavior of each management endpoint is defined in a service. When you add Duende.BFF to DI, a default implementation for every management endpoint gets registered:\n// management endpoints builder.Services.AddTransient\u0026lt;ILoginService, DefaultLoginService\u0026gt;(); builder.Services.AddTransient\u0026lt;ISilentLoginService, DefaultSilentLoginService\u0026gt;(); builder.Services.AddTransient\u0026lt;ISilentLoginCallbackService, DefaultSilentLoginCallbackService\u0026gt;(); builder.Services.AddTransient\u0026lt;ILogoutService, DefaultLogoutService\u0026gt;(); builder.Services.AddTransient\u0026lt;IUserService, DefaultUserService\u0026gt;(); builder.Services.AddTransient\u0026lt;IBackchannelLogoutService, DefaultBackchannelLogoutService\u0026gt;(); builder.Services.AddTransient\u0026lt;IDiagnosticsService, DefaultDiagnosticsService\u0026gt;(); You can add your own implementation by overriding the default after calling AddBff().\nThe management endpoint services all inherit from the IBffEndpointService, which provides a general-purpose mechanism to add custom logic to the endpoints.\npublic interface IBffEndpointService { Task ProcessRequestAsync(HttpContext context); } None of the endpoint services contain additional members beyond ProcessRequestAsync.\nYou can customize the behavior of the endpoints either by implementing the appropriate interface or by extending the default implementation of that interface. In many cases, extending the default implementation is preferred, as this allows you to keep most of the default behavior by calling the base ProcessRequestAsync from your derived class. Several of the default endpoint service implementations also define virtual methods that can be overridden to customize their behavior with more granularity. See the following pages for details on those extension points.\nBFF Login Endpoint Extensibility BFF Silent Login Endpoint Extensibility BFF Silent Login Callback Extensibility BFF Logout Endpoint Extensibility BFF User Endpoint Extensibility BFF Back-Channel Logout Endpoint Extensibility BFF Diagnostics Endpoint Extensibility "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/apis/local/",
    "title": "Local APIs",
    "tags": [],
    "description": "",
    "content": "A Local API is an API that is located within the BFF host. Local APIs are implemented with the familiar ASP.NET abstractions of API controllers or minimal API endpoints.\nThere are two styles of local APIs:\nSelf-contained Local APIs Local APIs that Make Requests using Managed Access Tokens Self-Contained Local APIs These APIs reside within the BFF and don\u0026rsquo;t make HTTP requests to other APIs. They access data controlled by the BFF itself, which can simplify the architecture of the system by reducing the number of APIs that must be deployed and managed. They are suitable for scenarios where the BFF is the sole consumer of the data. If you require data accessibility from other applications or services, this approach is probably not suitable.\nLocal APIs that Make Requests using Managed Access Tokens Alternatively, you can make the data available as a service and make HTTP requests to that service from your BFF\u0026rsquo;s local endpoints. The benefits of this style of Local Endpoint include\nYour frontend\u0026rsquo;s network access can be simplified into an aggregated call for the specific data that it needs, which reduces the amount of data that must be sent to the client. Your BFF endpoint can expose a subset of your remote APIs so that they are called in a more controlled manner than if the BFF proxied all requests to the endpoint. Your BFF endpoint can include business logic to call the appropriate endpoints, which simplifies your front end code. Your local endpoints can leverage services like the HTTP client factory and Duende.BFF token management to make the outgoing calls. The following is a simplified example showing how local endpoints can obtain managed access tokens and use them to make requests to remote APIs.\n[Route(\u0026#34;myApi\u0026#34;)] public class MyApiController : ControllerBase { private readonly IHttpClientFactory _httpClientFactory; public MyApiController(IHttpClientFactory httpClientFactory) { _httpClientFactory = httpClientFactory; } public async Task\u0026lt;IActionResult\u0026gt; Get(string id) { // create HTTP client var client = _httpClientFactory.CreateClient(); // get current user access token and set it on HttpClient var token = await HttpContext.GetUserAccessTokenAsync(); client.SetBearerToken(token); // call remote API var response = await client.GetAsync($\u0026#34;https://remoteServer/remoteApi?id={id}\u0026#34;); // maybe process response and return to frontend return new JsonResult(await response.Content.ReadAsStringAsync()); } } The example above is simplified to demonstrate the way that you might obtain a token. Real local endpoints will typically enforce constraints on the way the API is called, aggregate multiple calls, or perform other business logic. Local endpoints that merely forward requests from the frontend to the remote API may not be needed at all. Instead, you could proxy the requests through the BFF using either the simple http forwarder or YARP.\nSecuring Local API Endpoints Regardless of the style of data access used by a local API, it must be protected against threats such as CSRF (Cross-Site Request Forgery) attacks. To defend against such attacks and ensure that only the frontend can access these endpoints, we recommend implementing two layers of protection.\nSameSite cookies The SameSite cookie attribute is a feature of modern browsers that restricts cookies so that they are only sent to pages originating from the site where the cookie was originally issued.\nThis is a good first layer of defense, but makes the assumption that you can trust all subdomains of your site. All subdomains within a registrable domain are considered the same site for purposes of SameSite cookies. Thus, if another application hosted on a subdomain within your site is infected with malware, it can make CSRF attacks against your application.\nAnti-forgery header For this reason, we recommend requiring an additional custom header on API endpoints, for example:\nGET /endpoint x-csrf: 1 The value of the header is not important, but its presence, combined with the cookie requirement, triggers a CORS preflight request for cross-origin calls. This effectively isolates the caller to the same origin as the backend, providing a robust security guarantee.\nAdditionally, API endpoints should handle scenarios where the session has expired or authorization fails without triggering an authentication redirect to the upstream identity provider. Instead, they should return Ajax-friendly status codes.\nSetup Duende.BFF can automate both the pre-processing step of requiring the custom anti-forgery header and the post-processing step of converting response codes for API endpoints. To do so, first add the BFF middleware to the pipeline, and then decorate your endpoints to indicate that they should receive BFF pre and post processing.\nAdd Middleware Add the BFF middleware to the pipeline by calling UseBFF. Note that the middleware must be placed before the authorization middleware, but after routing.\napp.UseAuthentication(); app.UseRouting(); app.UseBff(); app.UseAuthorization(); //map endpoints Decorate Endpoints Endpoints that require the pre and post processing described above must be decorated with a call to AsBffApiEndpoint().\nFor minimal API endpoints, you can apply BFF pre- and post-processing when they are mapped.\napp.MapPost(\u0026#34;/foo\u0026#34;, context =\u0026gt; { ... }) .RequireAuthorization() // no anonymous access .AsBffApiEndpoint(); // BFF pre/post processing For MVC controllers, you can similarly apply BFF pre- and post-processing to controller actions when they are mapped.\napp.MapControllers() .RequireAuthorization() // no anonymous access .AsBffApiEndpoint(); // BFF pre/post processing Alternatively, you can apply the [BffApi] attribute directly to the controller or action.\n[Route(\u0026#34;myApi\u0026#34;)] [BffApi] public class MyApiController : ControllerBase { ... } Disabling Anti-forgery Protection Disabling anti-forgery protection is possible but not recommended. Antiforgery protection defends against CSRF attacks, so opting out may cause security vulnerabilities.\nHowever, if you are defending against CSRF attacks with some other mechanism, you can opt-out of Duende.BFF\u0026rsquo;s CSRF protection. Depending on the version of Duende.BFF, use one of the following approaches.\nFor version 1.x, set the requireAntiForgeryCheck parameter to false when adding the endpoint. For example:\n// MVC controllers app.MapControllers() .RequireAuthorization() // WARNING: Disabling antiforgery protection may make // your APIs vulnerable to CSRF attacks .AsBffApiEndpoint(requireAntiforgeryCheck: false); // simple endpoint app.MapPost(\u0026#34;/foo\u0026#34;, context =\u0026gt; { /* ... */ }) .RequireAuthorization() // WARNING: Disabling antiforgery protection may make // your APIs vulnerable to CSRF attacks .AsBffApiEndpoint(requireAntiforgeryCheck: false); On MVC controllers and actions you can set the RequireAntiForgeryCheck as a flag in the BffApiAttribute, like this:\n[Route(\u0026#34;sample\u0026#34;)] // WARNING: Disabling antiforgery protection may make // your APIs vulnerable to CSRF attacks [BffApi(requireAntiForgeryCheck: false)] public class SampleApiController : ControllerBase { /* ... */ } In version 2.x, use the SkipAntiforgery fluent API when adding the endpoint. For example:\n// MVC controllers app.MapControllers() .RequireAuthorization() .AsBffApiEndpoint() // WARNING: Disabling antiforgery protection may make // your APIs vulnerable to CSRF attacks .SkipAntiforgery(); // simple endpoint app.MapPost(\u0026#34;/foo\u0026#34;, context =\u0026gt; { /* ... */ }) .RequireAuthorization() .AsBffApiEndpoint() // WARNING: Disabling antiforgery protection may make // your APIs vulnerable to CSRF attacks .SkipAntiforgery(); MVC controllers and actions can use the BffApiSkipAntiforgeryAttribute (which is independent of the BffApiAttribute), like this:\n[Route(\u0026#34;sample\u0026#34;)] // WARNING: Disabling antiforgery protection may make // your APIs vulnerable to CSRF attacks [BffApiSkipAntiforgeryAttribute] public class SampleApiController : ControllerBase { /* ... */ } "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/architecture/ui-hosting/",
    "title": "UI Hosting",
    "tags": [],
    "description": "",
    "content": "Hosting Options for the UI There are several options for hosting the UI assets when using a BFF.\nHost the assets within the BFF host using the static file middleware Host the assets within the BFF host using the Microsoft SPA Templates Host the UI and BFF separately on subdomains of the same site and use CORS to allow cross origin requests Serves the index page of the UI from the BFF host, and all other assets are loaded from another domain, such as a CDN Static File Middleware Hosting the UI together with the BFF is the simplest choice, as requests from the front end to the backend will automatically include the authentication cookie and not require CORS headers. If you create a BFF host using our templates, the UI will be hosted in this way:\ndotnet new bffremoteapi # or dotnet new bfflocalapi Host UI in the BFF using Microsoft Templates Many frontend applications require a build process, which complicates the use of the static file middleware at development time. Visual Studio includes SPA templates that start up a SPA and proxy requests to it during development. Samples of Duende.BFF that take this approach using React and Angular are available.\nMicrosoft\u0026rsquo;s templates are easy to use at dev time from Visual Studio. They allow you to simply run the solution, and the template proxies requests to the front end for you. At deploy time, that proxy is removed and the static assets of the site are served by the static file middleware.\nHost the UI separately You may want to host the UI outside of the BFF. At development time, UI developers might prefer to run the frontend outside of Visual Studio (e.g., using the node cli). You might also want to have separate deployments of the frontend and the BFF, and you might want your static UI assets hosted on a CDN. If that is your preference, there are a couple of options for hosting the frontend outside of the C# project.\nFirst, you can host the BFF and SPA entirely separately, and use CORS to make requests from the frontend to the backend. In order to include the auth cookie in those requests, the frontend code will have to declare that it should send credentials using the credentials: \u0026ldquo;include\u0026rdquo; option. You\u0026rsquo;ll also need to ensure that the two components are hosted on subdomains of the same domain so that third party cookie blocking doesn\u0026rsquo;t prevent the frontend from including cookies in its requests to the BFF host.\nA sample of this approach is available.\nServe the index page from the BFF host Secondly, you could serve the index page of the SPA from the BFF, but have all of the other static assets hosted on another host (presumably a CDN). This technique makes the UI and BFF have exactly the same origin, so the authentication cookie will be sent from the frontend to the BFF automatically, and third party cookie blocking and the SameSite cookie attribute won\u0026rsquo;t present any problems.\nSetting this up for local development takes a bit of effort however. As you make changes to the frontend, the UI\u0026rsquo;s build process might generate a change to the index page. If it does, you\u0026rsquo;ll need to arrange for the index page being served by the BFF host to reflect that change.\nAdditionally, the front end will need to be configurable so that it is able to load its assets from other hosts. The mechanism for doing so will vary depending on the technology used to build the frontend. For instance, Angular includes a number of deployment options that allow you to control where it expects to find assets.\nThe added complexity of this technique is justified when there is a requirement to host the front end on a different site (typically a CDN) from the BFF.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/architecture/third-party-cookies/",
    "title": "Third Party Cookies",
    "tags": [],
    "description": "",
    "content": "If the BFF and OpenID Connect Provider (OP) are hosted on different sites, then some browsers will block cookies from being sent during navigation between those sites. Almost all browsers have the option of blocking third party cookies. Safari and Firefox are the most widely used browsers that do so by default, while Chrome is planning to do so in the future. This change is being made to protect user privacy, but it also impacts OIDC flows traditionally used by SPAs.\nA couple of particularly notable OIDC flows that don\u0026rsquo;t work for SPAs when third party cookies are blocked are OIDC Session Management and OIDC Silent Login via the prompt=none parameter.\nSession Management OIDC Session Management allows a client SPA to monitor the session at the OP by reading a cookie from the OP in a hidden iframe. If third party cookie blocking prevents the iframe from seeing that cookie, the SPA will not be able to monitor the session. The BFF solves this problem using OIDC back-channel logout.\nThe BFF is able to operate server side, and is therefore able to have a back channel to the OP. When the session ends at the OP, it can send a back-channel message to the BFF, ending the session at the BFF.\nSilent Login OIDC Silent Login allows a client application to start its session without needing any user interaction if the OP has an ongoing session. The main benefit is that a SPA can load in the browser and then start a session without navigating away from the SPA for an OIDC flow, preventing the need to reload the SPA.\nSimilarly to OIDC Session Management, OIDC Silent Login relies on a hidden iframe, though in this case, the hidden iframe makes requests to the OP, passing the prompt=none parameter to indicate that user interaction isn\u0026rsquo;t sensible. If that request includes the OP\u0026rsquo;s session cookie, the OP can respond successfully and the application can obtain tokens. But if the request does not include a session - either because no session has been started or because the cookie has been blocked - then the silent login will fail, and the user will have to be redirected to the OP for an interactive login.\nBFF with a Federation Gateway The BFF supports silent login from the SPA with the /bff/silent-login endpoint. This endpoint is intended to be invoked in an iframe and issues a challenge to login non-interactively with prompt=none. Just as in a traditional SPA, this technique will be disrupted by third party cookie blocking when the BFF and OP are third parties.\nIf you need silent login with a third party OP, we recommend that you use the Federation Gateway pattern. In the federation gateway pattern, one identity provider (the gateway) federates with other remote identity providers. Because the client applications only interact with the gateway, the implementation details of the remote identity providers are abstracted. In this case, we shield the client application from the fact that the remote identity provider is a third party by hosting the gateway as a first party to the client. This makes the client application\u0026rsquo;s requests for silent login always first party.\nAlternatives Alternatively, you can accomplish a similar goal (logging in without needing to initially load the SPA, only to redirect away from it) by detecting that the user is not authenticated in the BFF and issuing a challenge before the site is ever loaded. This approach is not typically our first recommendation, because it makes allowing anonymous access to parts of the UI difficult and because it requires samesite=lax cookies (see below).\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/extensibility/management/silent-login/",
    "title": "BFF Silent Login Endpoint Extensibility",
    "tags": [],
    "description": "",
    "content": "The BFF silent login endpoint can be customized by implementing the ISilentLoginService or by extending DefaultSilentLoginService, its default implementation.\nRequest Processing ProcessRequestAsync is the top level function called in the endpoint service and can be used to add arbitrary logic to the endpoint.\nFor example, you could take whatever actions you need before normal processing of the request like this:\npublic override Task ProcessRequestAsync(HttpContext context) { // Custom logic here return base.ProcessRequestAsync(context); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/session/management/",
    "title": "BFF Session Management Endpoints",
    "tags": [],
    "description": "",
    "content": "Duende.BFF adds endpoints for performing typical session-management operations such as triggering login and logout and getting information about the currently logged-on user. These endpoint are meant to be called by the frontend.\nIn addition Duende.BFF adds an implementation of the OpenID Connect back-channel notification endpoint to overcome the restrictions of third party cookies in front-channel notification in modern browsers.\nYou enable the endpoints by adding the relevant services into the DI container:\n// Add BFF services to DI - also add server-side session management builder.Services.AddBff(options =\u0026gt; { // default value options.ManagementBasePath = \u0026#34;/bff\u0026#34;; }; The management endpoints need to be mapped:\napp.MapBffManagementEndpoints(); MapBffManagementEndpoints adds all BFF management endpoints. You can also map each endpoint individually by calling the various MapBffManagementXxxEndpoint methods, for example endpoints.MapBffManagementLoginEndpoint().\nThe following pages describe the default behavior of the management endpoints. See the extensibility section for information about how to customize the behavior of the endpoints.\nBFF Login Endpoint BFF User Endpoint BFF Logout Endpoint BFF Silent Login Endpoint BFF Diagnostics Endpoint BFF Back-Channel Logout Endpoint "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/session/management/login/",
    "title": "BFF Login Endpoint",
    "tags": [],
    "description": "",
    "content": "The /bff/login endpoint begins the authentication process. To use it, typically javascript code will navigate away from the frontend application to the login endpoint:\nwindow.location = \u0026#34;/login\u0026#34;; In Blazor, instead use the NavigationManager to navigate to the login endpoint:\nNavigation.NavigateTo($\u0026#34;bff/login\u0026#34;, forceLoad: true); The login endpoint triggers an authentication challenge using the default challenge scheme, which will typically use the OpenID Connect handler.\nReturn Url After authentication is complete, the login endpoint will redirect back to your front end application. By default, this redirect goes to the root of the application. You can use a different URL instead by including a local URL as the returnUrl query parameter.\nwindow.location = \u0026#34;/login?returnUrl=/logged-in\u0026#34;; "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/extensibility/sessions/",
    "title": "Session Management",
    "tags": [],
    "description": "BFF Extensibility",
    "content": "User Session Store If using the server-side sessions feature, you will need to have a store for the session data. An Entity Framework Core based implementation of this store is provided. If you wish to use some other type of store, then you can implement the IUserSessionStore interface:\n/// \u0026lt;summary\u0026gt; /// User session store /// \u0026lt;/summary\u0026gt; public interface IUserSessionStore { /// \u0026lt;summary\u0026gt; /// Retrieves a user session /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;cancellationToken\u0026#34;\u0026gt;A token that can be used to request cancellation of the asynchronous operation.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task\u0026lt;UserSession?\u0026gt; GetUserSessionAsync(string key, CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// Creates a user session /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;session\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;cancellationToken\u0026#34;\u0026gt;A token that can be used to request cancellation of the asynchronous operation.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task CreateUserSessionAsync(UserSession session, CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// Updates a user session /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;session\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;cancellationToken\u0026#34;\u0026gt;A token that can be used to request cancellation of the asynchronous operation.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task UpdateUserSessionAsync(string key, UserSessionUpdate session, CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// Deletes a user session /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;cancellationToken\u0026#34;\u0026gt;A token that can be used to request cancellation of the asynchronous operation.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task DeleteUserSessionAsync(string key, CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// Queries user sessions based on the filter. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;filter\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;cancellationToken\u0026#34;\u0026gt;A token that can be used to request cancellation of the asynchronous operation.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task\u0026lt;IReadOnlyCollection\u0026lt;UserSession\u0026gt;\u0026gt; GetUserSessionsAsync(UserSessionsFilter filter, CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// Deletes user sessions based on the filter. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;filter\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;cancellationToken\u0026#34;\u0026gt;A token that can be used to request cancellation of the asynchronous operation.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task DeleteUserSessionsAsync(UserSessionsFilter filter, CancellationToken cancellationToken = default); } Once you have an implementation, you can register it when you enable server-side sessions:\nbuilder.Services.AddBff() .AddServerSideSessions\u0026lt;YourStoreClassName\u0026gt;(); User Session Store Cleanup The IUserSessionStoreCleanup interface is used to model cleaning up expired sessions.\n/// \u0026lt;summary\u0026gt; /// User session store cleanup /// \u0026lt;/summary\u0026gt; public interface IUserSessionStoreCleanup { /// \u0026lt;summary\u0026gt; /// Deletes expired sessions /// \u0026lt;/summary\u0026gt; Task DeleteExpiredSessionsAsync(CancellationToken cancellationToken = default); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/session/",
    "title": "Authentication &amp; Session Management",
    "tags": [],
    "description": "",
    "content": "Authentication \u0026amp; Session Management This section deals with setting up the following components\nthe ASP.NET Core authentication system the OpenID Connect handler the cookie handler the BFF session management endpoints server-side sessions back-channel logout support "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/apis/remote/",
    "title": "Remote APIs",
    "tags": [],
    "description": "",
    "content": "A Remote API is an API that is deployed separately from the BFF host. Remote APIs use access tokens to authenticate and authorize requests, but the frontend does not possess an access token to make requests to remote APIs directly. Instead, all access to remote APIs is proxied through the BFF, which authenticates the frontend using its authentication cookie, obtains the appropriate access token, and forwards the request to the Remote API with the token attached.\nThere are two different ways to set up Remote API proxying in Duende.BFF. This page describes the built-in simple HTTP forwarder. Alternatively, you can integrate Duende.BFF with Microsoft\u0026rsquo;s reverse proxy YARP, which allows for more complex reverse proxy features provided by YARP combined with the security and identity features of Duende.BFF.\nSimple HTTP forwarder Duende.BFF\u0026rsquo;s simple HTTP forwarder maps routes in the BFF to a remote API surface. It uses Microsoft YARP internally, but is much simpler to configure than YARP. The intent is to provide a developer-centric and simplified way to proxy requests from the BFF to remote APIs when more complex reverse proxy features are not needed.\nThese routes receive automatic anti-forgery protection and integrate with automatic token management.\nTo enable this feature, add a reference to the Duende.BFF.Yarp NuGet package, add the remote APIs service to DI, and call the MapRemoteBFFApiEndpoint method to create the mappings.\nAdd Remote API Service to DI builder.Services.AddBff() .AddRemoteApis(); Map Remote APIs Use the MapRemoteBffApiEndpoint extension method to describe how to map requests coming into the BFF out to remote APIs and the RequireAccessToken method to specify token requirements. MapRemoteBffApiEndpoint takes two parameters: the base path of requests that will be mapped externally, and the address to the external API where the requests will be mapped. MapRemoteBffApiEndpoint maps a path and all sub-paths below it. The intent is to allow easy mapping of groups of URLs. For example, you can set up mappings for the /users, /users/{userId}, /users/{userId}/books, and /users/{userId}/books/{bookId} endpoints like this:\napp.MapRemoteBffApiEndpoint(\u0026#34;/api/users\u0026#34;, \u0026#34;https://remoteHost/users\u0026#34;) .RequireAccessToken(TokenType.User); This example opens up the complete /users API namespace to the frontend and thus to the outside world. Try to be as specific as possible when designing the forwarding paths.\nSecuring Remote APIs Remote APIs typically require access control and must be protected against threats such as CSRF (Cross-Site Request Forgery) attacks.\nTo provide access control, you can specify authorization policies on the mapped routes, and configure them with access token requirements.\nTo defend against CSRF attacks, you should use SameSite cookies to authenticate calls from the frontend to the BFF. As an additional layer of defense, APIs mapped with MapRemoteBffApiEndpoint are automatically protected with an anti-forgery header.\nSameSite cookies The SameSite cookie attribute is a feature of modern browsers that restricts cookies so that they are only sent to pages originating from the site where the cookie was originally issued. This prevents CSRF attacks and helps with improving privacy, because cross site requests will no longer implicitly include the user\u0026rsquo;s credentials.\nThis is a good first layer of defense, but makes the assumption that you can trust all subdomains of your site. All subdomains within a registrable domain are considered the same site for purposes of SameSite cookies. Thus, if another application hosted on a subdomain within your site is infected with malware, it can make CSRF attacks against your application.\nAnti-forgery header For this reason, remote APIs automatically require an additional custom header on API endpoints. For example:\nGET /endpoint x-csrf: 1 The value of the header is not important, but its presence, combined with the cookie requirement, triggers a CORS preflight request for cross-origin calls. This effectively isolates the caller to the same origin as the backend, providing a robust security guarantee.\nRequire authorization The MapRemoteBffApiEndpoint method returns the appropriate type to integrate with the ASP.NET Core authorization system. You can attach authorization policies to remote endpoints using RequireAuthorization, just as you would for a standard ASP.NET core endpoint created with MapGet, and the authorization middleware will then enforce that policy before forwarding requests on that route to the remote endpoint.\nAccess token requirements Remote APIs sometimes allow anonymous access, but usually require an access token, and the type of access token (user or client) will vary as well. You can specify access token requirements via the RequireAccessToken extension method. Its TokenType parameter has three options:\nUser\nA valid user access token is required and will be forwarded to the remote API. A user access token is an access token obtained during an OIDC flow (or subsequent refresh), and is associated with a particular user. User tokens are obtained when the user initially logs in, and will be automatically refreshed using a refresh token when they expire.\nClient\nA valid client access token is required and will be forwarded to the remote API. A client access token is an access token obtained through the client credentials flow, and is associated with the client application, not any particular user. Client tokens can be obtained even if the user is not logged in.\nUserOrClient\nEither a valid user access token or a valid client access token (as fallback) is required and will be forwarded to the remote API.\nYou can also use the WithOptionalUserAccessToken extension method to specify that the API should be called with a user access token if one is available and anonymously if not.\nThese settings only specify the logic that is applied before the API call gets proxied. The remote APIs you are calling should always specify their own authorization and token requirements.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/session/management/user/",
    "title": "BFF User Endpoint",
    "tags": [],
    "description": "",
    "content": "The /bff/user endpoint returns data about the currently logged-on user and the session. It is typically invoked at application startup to check if the user has authenticated, and if so, to get profile data about the user. It can also be used to periodically query if the session is still valid.\nOutput If there is no current session, the user endpoint returns a response indicating that the user is anonymous. By default, this is a 401 status code, but this can be configured.\nIf there is a current session, the user endpoint returns a JSON array containing the claims in the ASP.NET Core authentication session as well as several BFF specific claims. For example:\n[ { \u0026#34;type\u0026#34;: \u0026#34;sid\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;173E788068FFB728806501F4F46C52D6\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;sub\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;88421113\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;idp\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;local\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Bob Smith\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;bff:logout_url\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;/logout?sid=173E788068FFB728806501F4F46C52D6\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;bff:session_expires_in\u0026#34;, \u0026#34;value\u0026#34;: 28799 }, { \u0026#34;type\u0026#34;: \u0026#34;bff:session_state\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;q-Hl1V9a7FCZE5o-vH9qpmyVKOaeVfMQBUJLrq-lDJU.013E58C33C7409C6011011B8291EF78A\u0026#34; } ] User Claims Since the user endpoint returns the claims that are in the ASP.NET Core session, anything that changes the session will be reflected in its output. You can customize the contents of the session via the OpenID Connect handler\u0026rsquo;s ClaimAction infrastructure, or by using claims transformation. For example, if you add a claim to the userinfo endpoint at IdentityServer that you would like to include in the /bff/user endpoint, you need to add a corresponding ClaimAction in the BFF\u0026rsquo;s OpenID Connect Handler to include the claim in the BFF\u0026rsquo;s session.\nManagement Claims In addition to the claims in the ASP.NET Core Session, Duende.BFF adds three additional claims:\nbff:session_expires_in\nThis is the number of seconds the current session will be valid for.\nbff:session_state\nThis is the session state value of the upstream OIDC provider that can be use for the JavaScript check_session mechanism (if provided).\nbff:logout_url\nThis is the URL to trigger logout. If the upstream provider includes a sid claim, the BFF logout endpoint requires this value as a query string parameter for CSRF protection. This behavior can be configured with the RequireLogoutSessionId in the options.\nTypical Usage To use the endpoint, make an http GET request to it from your frontend javascript code. For example, your application could use the fetch api to make requests to the user endpoint like this:\nvar req = new Request(\u0026#34;/user\u0026#34;, { headers: new Headers({ \u0026#34;X-CSRF\u0026#34;: \u0026#34;1\u0026#34;, }), }); var resp = await fetch(req); if (resp.ok) { userClaims = await resp.json(); console.log(\u0026#34;user logged in\u0026#34;, userClaims); } else if (resp.status === 401) { console.log(\u0026#34;user not logged in\u0026#34;); } Cross-Site Request Forgery To protect against cross-site request forgery, you need to add a static header to the GET request. The header\u0026rsquo;s name and required value can be configured in the options.\nAnonymous Session Response Option The AnonymousSessionResponse option allows you to change the behavior of the user endpoint to return 200 instead of 401 when the user is anonymous. If AnonymousSessionResponse is set to AnonymousSessionResponse.Response200, then the endpoint\u0026rsquo;s response will set its status code to 200 and its payload will contain the literal null (the response body will be the characters \u0026rsquo;n\u0026rsquo;, \u0026lsquo;u\u0026rsquo;, \u0026rsquo;l\u0026rsquo;, \u0026rsquo;l\u0026rsquo; without quotes).\nCookie Sliding If your ASP.NET Core session cookie is configured to use a sliding expiration, you need to be able to query the session state without extending the session\u0026rsquo;s lifetime; a periodic check for user activity shouldn\u0026rsquo;t itself count as user activity. To prevent the call to the user endpoint from sliding the cookie, add the slide=false parameter to the request.\nvar req = new Request(\u0026#34;/user?slide=false\u0026#34;, { headers: new Headers({ \u0026#34;X-CSRF\u0026#34;: \u0026#34;1\u0026#34;, }), }); The cookie sliding prevention feature requires either usage of server-side sessions or .NET 6 or higher (or both).\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/extensibility/management/silent-login-callback/",
    "title": "BFF Silent Login Callback Extensibility",
    "tags": [],
    "description": "",
    "content": "The BFF silent login callback endpoint can be customized by implementing the ISilentLoginCallbackService or by extending DefaultSilentLoginCallbackService, its default implementation.\nRequest Processing ProcessRequestAsync is the top level function called in the endpoint service and can be used to add arbitrary logic to the endpoint.\nFor example, you could take whatever actions you need before normal processing of the request like this:\npublic override Task ProcessRequestAsync(HttpContext context) { // Custom logic here return base.ProcessRequestAsync(context); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/session/management/logout/",
    "title": "BFF Logout Endpoint",
    "tags": [],
    "description": "",
    "content": "The /bff/logout endpoint signs out of the appropriate ASP.NET Core authentication schemes to both delete the BFF\u0026rsquo;s session cookie and to sign out from the remote identity provider. To use the logout endpoint, typically your javascript code will navigate away from your front end to the logout endpoint, similar to the login endpoint. However, unlike the login endpoint, the logout endpoint requires CSRF protection, otherwise an attacker could destroy sessions by making cross-site GET requests. The session id is used to provide this CSRF protection by requiring it as a query parameter to the logout endpoint (assuming that a session id was included during login). For convenience, the correct logout url is made available as a claim in the /bff/user endpoint, making typical logout usage look like this:\nvar logoutUrl = userClaims[\u0026#34;bff:logout_url\u0026#34;]; // assumes userClaims is the result of a call to /bff/user window.location = logoutUrl; Return Url After signout is complete, the logout endpoint will redirect back to your front end application. By default, this redirect goes to the root of the application. You can use a different URL instead by including a local URL as the returnUrl query parameter.\nvar logoutUrl = userClaims[\u0026#34;bff:logout_url\u0026#34;]; window.location = `${logoutUrl}\u0026amp;returnUrl=/logged-out`; Revocation of Refresh Tokens If the user has a refresh token, the logout endpoint can revoke it. This is enabled by default because revoking refresh tokens that will not be used any more is generally good practice. Normally any refresh tokens associated with the current session won\u0026rsquo;t be used after logout, as the session where they are stored is deleted as part of logout. However, you can disable this revocation with the RevokeRefreshTokenOnLogout option.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/extensibility/tokens/",
    "title": "Token Management",
    "tags": [],
    "description": "BFF - Customization",
    "content": "The token management library does essentially two things:\nstores access and refresh tokens in the current session refreshes access tokens automatically at the token service when needed Both aspects can be customized.\nToken service communication The token management library uses a named HTTP client from the HTTP client factory for all token service communication. You can provide a customized HTTP client yourself using the well-known name after calling AddBff:\nbuilder.Services.AddHttpClient(AccessTokenManagementDefaults.BackChannelHttpClientName, configureClient =\u0026gt; { ... }); You can also supply client assertions to the token management library. See this sample for JWT-based client authentication.\nCustom token storage We recommend that you use the default storage mechanism, as this will automatically be compatible with the Duende.BFF server-side sessions.\nIf you do not use server-side sessions, then the access and refresh token will be stored in the protected session cookie. If you want to change this, you can take over token storage completely.\nThis would involve two steps\nturn off the SaveTokens flag on the OpenID Connect handler and handle the relevant events manually to store the tokens in your custom store implement and register the Duende.AccessTokenManagement.IUserTokenStore interface The interface is responsible to storing, retrieving and clearing tokens for the automatic token management:\npublic interface IUserTokenStore { /// \u0026lt;summary\u0026gt; /// Stores tokens /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;user\u0026#34;\u0026gt;User the tokens belong to\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;token\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;parameters\u0026#34;\u0026gt;Extra optional parameters\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task StoreTokenAsync( ClaimsPrincipal user, UserToken token, UserTokenRequestParameters? parameters = null); /// \u0026lt;summary\u0026gt; /// Retrieves tokens from store /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;user\u0026#34;\u0026gt;User the tokens belong to\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;parameters\u0026#34;\u0026gt;Extra optional parameters\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;access and refresh token and access token expiration\u0026lt;/returns\u0026gt; Task\u0026lt;UserToken\u0026gt; GetTokenAsync( ClaimsPrincipal user, UserTokenRequestParameters? parameters = null); /// \u0026lt;summary\u0026gt; /// Clears the stored tokens for a given user /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;user\u0026#34;\u0026gt;User the tokens belong to\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;parameters\u0026#34;\u0026gt;Extra optional parameters\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task ClearTokenAsync( ClaimsPrincipal user, UserTokenRequestParameters? parameters = null); } Per-route customized token retrieval The token store defines how tokens are retrieved globally. However, you can add custom logic that changes the way that access tokens are retrieved on a per-route basis. For example, you might need to exchange a token to perform delegation or impersonation for some API calls, depending on the remote API. The interface that describes this extension point is the IAccessTokenRetriever.\n/// \u0026lt;summary\u0026gt; /// Retrieves access tokens /// \u0026lt;/summary\u0026gt; public interface IAccessTokenRetriever { /// \u0026lt;summary\u0026gt; /// Asynchronously gets the access token. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;context\u0026#34;\u0026gt;Context used to retrieve the token.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;A task that contains the access token result, which is an /// object model that can represent various types of tokens (bearer, dpop), /// the absence of an optional token, or an error. \u0026lt;/returns\u0026gt; Task\u0026lt;AccessTokenResult\u0026gt; GetAccessToken(AccessTokenRetrievalContext context); } You can implement this interface yourself or extend the DefaultAccessTokenRetriever. The AccessTokenResult class represents the result of this operation. It is an abstract class with concrete implementations that represent successfully retrieving a bearer token (BearerTokenResult), successfully retrieving a DPoP token (DPoPTokenResult), failing to find an optional token (NoAccessTokenResult), which is not an error, and failure to retrieve a token (AccessTokenRetrievalError). Your implementation of GetAccessToken should return one of those types.\nImplementations of the IAccessTokenRetriever can be added to endpoints when they are mapped using the WithAccessTokenRetriever extension method:\napp.MapRemoteBffApiEndpoint(\u0026#34;/api/impersonation\u0026#34;, \u0026#34;https://api.example.com/endpoint/requiring/impersonation\u0026#34;) .RequireAccessToken(TokenType.User) .WithAccessTokenRetriever\u0026lt;ImpersonationAccessTokenRetriever\u0026gt;(); The GetAccessToken method will be invoked on every call to APIs that use the access token retriever. If retrieving the token is an expensive operation, you may need to cache it. It is up to your retriever code to perform caching.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/apis/yarp/",
    "title": "YARP extensions",
    "tags": [],
    "description": "",
    "content": "Duende.BFF integrates with Microsoft\u0026rsquo;s full-featured reverse proxy YARP.\nYARP includes many advanced features such as load balancing, service discovery, and session affinity. It also has its own extensibility mechanism. Duende.BFF includes YARP extensions for token management and anti-forgery protection so that you can combine the security and identity features of Duende.BFF with the flexible reverse proxy features of YARP.\nAdding YARP To enable Duende.BFF\u0026rsquo;s YARP integration, add a reference to the Duende.BFF.Yarp Nuget package to your project and add YARP and the BFF\u0026rsquo;s YARP extensions to DI:\nbuilder.Services.AddBff(); // adds YARP with BFF extensions var yarpBuilder = services.AddReverseProxy() .AddBffExtensions(); Configuring YARP YARP is most commonly configured by a config file. The following simple example forwards a local URL to a remote API:\n\u0026#34;ReverseProxy\u0026#34;: { \u0026#34;Routes\u0026#34;: { \u0026#34;todos\u0026#34;: { \u0026#34;ClusterId\u0026#34;: \u0026#34;cluster1\u0026#34;, \u0026#34;Match\u0026#34;: { \u0026#34;Path\u0026#34;: \u0026#34;/todos/{**catch-all}\u0026#34;, } } }, \u0026#34;Clusters\u0026#34;: { \u0026#34;cluster1\u0026#34;: { \u0026#34;Destinations\u0026#34;: { \u0026#34;destination1\u0026#34;: { \u0026#34;Address\u0026#34;: \u0026#34;https://api.mycompany.com/todos\u0026#34; } } } } } See the Microsoft documentation for the complete configuration schema.\nAnother option is to configure YARP in code using the in-memory config provider included in the BFF extensions for YARP. The above configuration as code would look like this:\nyarpBuilder.LoadFromMemory( new[] { new RouteConfig() { RouteId = \u0026#34;todos\u0026#34;, ClusterId = \u0026#34;cluster1\u0026#34;, Match = new() { Path = \u0026#34;/todos/{**catch-all}\u0026#34; } } }, new[] { new ClusterConfig { ClusterId = \u0026#34;cluster1\u0026#34;, Destinations = new Dictionary\u0026lt;string, DestinationConfig\u0026gt;(StringComparer.OrdinalIgnoreCase) { { \u0026#34;destination1\u0026#34;, new() { Address = \u0026#34;https://api.mycompany.com/todos\u0026#34; } }, } } }); Token management Duende.BFF\u0026rsquo;s YARP extensions provide access token management and attach user or client access tokens automatically to proxied API calls. To enable this, add metadata with the name Duende.Bff.Yarp.TokenType to the route or cluster configuration:\n\u0026#34;ReverseProxy\u0026#34;: { \u0026#34;Routes\u0026#34;: { \u0026#34;todos\u0026#34;: { \u0026#34;ClusterId\u0026#34;: \u0026#34;cluster1\u0026#34;, \u0026#34;Match\u0026#34;: { \u0026#34;Path\u0026#34;: \u0026#34;/todos/{**catch-all}\u0026#34;, }, \u0026#34;Metadata\u0026#34;: { \u0026#34;Duende.Bff.Yarp.TokenType\u0026#34;: \u0026#34;User\u0026#34; } } }, // rest omitted } Similarly to the simple HTTP forwarder, the allowed values for the token type are User, Client, UserOrClient.\nRoutes that set the Duende.Bff.Yarp.TokenType metadata require the given type of access token. If it is unavailable (for example, if the User token type is specified but the request to the BFF is anonymous), then the proxied request will not be sent, and the BFF will return an HTTP 401: Unauthorized response.\nIf you are using the code config method, call the WithAccessToken extension method to achieve the same thing:\nyarpBuilder.LoadFromMemory( new[] { new RouteConfig() { RouteId = \u0026#34;todos\u0026#34;, ClusterId = \u0026#34;cluster1\u0026#34;, Match = new RouteMatch { Path = \u0026#34;/todos/{**catch-all}\u0026#34; } }.WithAccessToken(TokenType.User) }, // rest omitted ); Again, the WithAccessToken method causes the route to require the given type of access token. If it is unavailable, the proxied request will not be made and the BFF will return an HTTP 401: Unauthorized response.\nOptional User Access Tokens You can also attach user access tokens optionally by adding metadata named \u0026ldquo;Duende.Bff.Yarp.OptionalUserToken\u0026rdquo; to a YARP route.\n\u0026#34;ReverseProxy\u0026#34;: { \u0026#34;Routes\u0026#34;: { \u0026#34;todos\u0026#34;: { \u0026#34;ClusterId\u0026#34;: \u0026#34;cluster1\u0026#34;, \u0026#34;Match\u0026#34;: { \u0026#34;Path\u0026#34;: \u0026#34;/todos/{**catch-all}\u0026#34;, }, \u0026#34;Metadata\u0026#34;: { \u0026#34;Duende.Bff.Yarp.OptionalUserToken\u0026#34;: \u0026#34;true\u0026#34; } } }, // rest omitted } This metadata causes the user\u0026rsquo;s access token to be sent with the proxied request when the user is logged in, but makes the request anonymously when the user is not logged in. It is an error to set both Duende.Bff.Yarp.TokenType and Duende.Bff.Yarp.OptionalUserToken, since they have conflicting semantics (TokenType requires the token, OptionalUserToken makes it optional).\nIf you are using the code config method, call the WithOptionalUserAccessToken extension method to achieve the same thing:\nyarpBuilder.LoadFromMemory( new[] { new RouteConfig() { RouteId = \u0026#34;todos\u0026#34;, ClusterId = \u0026#34;cluster1\u0026#34;, Match = new RouteMatch { Path = \u0026#34;/todos/{**catch-all}\u0026#34; } }.WithOptionalUserAccessToken() }, // rest omitted ); Anti-forgery protection Duende.BFF\u0026rsquo;s YARP extensions can also add anti-forgery protection to proxied API calls. Anti-forgery protection defends against CSRF attacks by requiring a custom header on API endpoints, for example:\nGET /endpoint x-csrf: 1 The value of the header is not important, but its presence, combined with the cookie requirement, triggers a CORS preflight request for cross-origin calls. This effectively isolates the caller to the same origin as the backend, providing a robust security guarantee.\nYou can add the anti-forgery protection to all YARP routes by calling the AsBffApiEndpoint extension method:\napp.MapReverseProxy() .AsBffApiEndpoint(); // or shorter app.MapBffReverseProxy(); If you need more fine grained control over which routes should enforce the anti-forgery header, you can also annotate the route configuration by adding the Duende.Bff.Yarp.AntiforgeryCheck metadata to the route config:\n\u0026#34;ReverseProxy\u0026#34;: { \u0026#34;Routes\u0026#34;: { \u0026#34;todos\u0026#34;: { \u0026#34;ClusterId\u0026#34;: \u0026#34;cluster1\u0026#34;, \u0026#34;Match\u0026#34;: { \u0026#34;Path\u0026#34;: \u0026#34;/todos/{**catch-all}\u0026#34;, }, \u0026#34;Metadata\u0026#34;: { \u0026#34;Duende.Bff.Yarp.AntiforgeryCheck\u0026#34; : \u0026#34;true\u0026#34; } } }, // rest omitted } This is also possible in code:\nyarpBuilder.LoadFromMemory( new[] { new RouteConfig() { RouteId = \u0026#34;todos\u0026#34;, ClusterId = \u0026#34;cluster1\u0026#34;, Match = new RouteMatch { Path = \u0026#34;/todos/{**catch-all}\u0026#34; } }.WithAntiforgeryCheck() }, // rest omitted ); You can combine the token management feature with the anti-forgery check.\nTo enforce the presence of the anti-forgery headers, you need to add a middleware to the YARP pipeline:\napp.MapReverseProxy(proxyApp =\u0026gt; { proxyApp.UseAntiforgeryCheck(); }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/session/management/silent-login/",
    "title": "BFF Silent Login Endpoint",
    "tags": [],
    "description": "",
    "content": "Added in v1.2.0.\nThe /bff/silent-login endpoint triggers authentication similarly to the login endpoint, but in a non-interactive way.\nThe expected usage pattern is that the application code loads in the browser and triggers a request to the User Endpoint. If that indicates that there is no BFF session, then the Silent Login Endpoint can be requested to attempt to automatically log the user in, using an existing session at the remote identity provider.\nThis non-interactive design relies upon the use of an iframe to make the silent login request. The result of the silent login request in the iframe will then use postMessage to notify the parent window of the outcome. If the result is that a session has been established, then the application logic can either re-trigger a call to the User Endpoint, or simply reload the entire page (depending on the preferred design). If the result is that a session has not been established, then the application redirects to the login endpoint to log the user in interactively.\nTo trigger the silent login, the application code must have an iframe and then set its src to the silent login endpoint. For example in your HTML:\n\u0026lt;iframe id=\u0026#34;bff-silent-login\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; And then in JavaScript:\ndocument.querySelector(\u0026#39;#bff-silent-login\u0026#39;).src = \u0026#39;/bff/silent-login\u0026#39;; To receive the result, the application should handle the message event in the browser and look for the data.isLoggedIn property on the event object:\nwindow.addEventListener(\u0026#34;message\u0026#34;, e =\u0026gt; { if (e.data \u0026amp;\u0026amp; e.data.source === \u0026#39;bff-silent-login\u0026#39; \u0026amp;\u0026amp; e.data.isLoggedIn) { // we now have a user logged in silently, so reload this window window.location.reload(); } }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/extensibility/management/logout/",
    "title": "BFF Logout Endpoint Extensibility",
    "tags": [],
    "description": "",
    "content": "The BFF logout endpoint has extensibility points in two interfaces. The ILogoutService is the top level abstraction that processes requests to the endpoint. This service can be used to add custom request processing logic. The IReturnUrlValidator ensures that the returnUrl parameter passed to the logout endpoint is safe to use.\nRequest Processing ProcessRequestAsync is the top level function called in the endpoint service and can be used to add arbitrary logic to the endpoint.\nFor example, you could take whatever actions you need before normal processing of the request like this:\npublic override Task ProcessRequestAsync(HttpContext context) { // Custom logic here return base.ProcessRequestAsync(context); } Return URL Validation To prevent open redirector attacks, the returnUrl parameter to the logout endpoint must be validated. You can customize this validation by implementing the IReturnUrlValidator interface. The default implementation enforces that return urls are local.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/session/management/diagnostics/",
    "title": "BFF Diagnostics Endpoint",
    "tags": [],
    "description": "",
    "content": "The /bff/diagnostics endpoint returns the current user and client access token for testing purposes. The endpoint tries to retrieve and show current tokens. It may invoke both a refresh token flow for the user access token and a client credential flow for the client access token.\nTo use the diagnostics endpoint, make a GET request to /bff/diagnostics. Typically this is done in a browser to diagnose a problem during development.\nThis endpoint is only enabled in Development mode.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/extensibility/http_forwarder/",
    "title": "HTTP Forwarder",
    "tags": [],
    "description": "",
    "content": "You can customize the HTTP forwarder behavior in two ways\nprovide a customized HTTP client for outgoing calls provide custom request/response transformation Custom HTTP clients By default, Duende.BFF will create and cache an HTTP client per configured route or local path.\nThis invoker is setup like this:\nvar client = new HttpMessageInvoker(new SocketsHttpHandler { UseProxy = false, AllowAutoRedirect = false, AutomaticDecompression = DecompressionMethods.None, UseCookies = false }); If you want to customize the HTTP client for specific paths, you can either implement the IHttpMessageInvokerFactory interface or derive from the DefaultHttpMessageInvokerFactory, e.g.:\npublic class MyInvokerFactory : DefaultHttpMessageInvokerFactory { public override HttpMessageInvoker CreateClient(string localPath) { if (localPath == \u0026#34;/foo\u0026#34;) { return Clients.GetOrAdd(localPath, (key) =\u0026gt; { return new HttpMessageInvoker(new SocketsHttpHandler { // this API needs a proxy UseProxy = true, Proxy = new WebProxy(\u0026#34;https://myproxy\u0026#34;), AllowAutoRedirect = false, AutomaticDecompression = DecompressionMethods.None, UseCookies = false }); }); } return base.CreateClient(localPath); } } ..and override our registration:\nservices.AddSingleton\u0026lt;IHttpMessageInvokerFactory, MyInvokerFactory\u0026gt;(); Custom transformations In the standard configuration, BFF uses the YARP default behavior for forwarding HTTP requests. In addition we\nremove the sensitive session cookie add the current access token If you want to modify this behavior you can either implement IHttpTransformerFactory from scratch:\npublic interface IHttpTransformerFactory { /// \u0026lt;summary\u0026gt; /// Creates a HTTP transformer based on the local path /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;localPath\u0026#34;\u0026gt;Local path the remote API is mapped to\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;accessToken\u0026#34;\u0026gt;The access token to attach to the request (if present)\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; HttpTransformer CreateTransformer(string localPath, string accessToken = null); } \u0026hellip;or derive from the DefaultHttpTransformerFactory.\nThe transformations are based on YARP\u0026rsquo;s transform library and are extensible. See here for a full list of built-in transforms.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/apis/",
    "title": "API Endpoints",
    "tags": [],
    "description": "",
    "content": "Securing and Accessing API Endpoints A frontend application using the BFF pattern can call two types of APIs:\nRemote APIs These APIs are deployed on a different host than the BFF, which allows them to be shared between multiple frontends or (more generally speaking) multiple clients. These APIs can only be called via the BFF host acting as a proxy.\nLocal APIs These APIs only exist to support the specific frontend; they are not shared with other frontends or services. They are located in the BFF host and can be called directly by the frontend.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/samples/bff/",
    "title": "Backend for Frontend Pattern",
    "tags": [],
    "description": "",
    "content": "This section contains a collection of clients using our BFF security framework.\nJavaScript Frontend This sample shows how to use the BFF framework with a JavaScript-based frontend (e.g. SPA).\nlink to source code\nReactJs Frontend This sample shows how to use the BFF framework with the .NET 6 React template.\nlink to source code\nAngular Frontend This sample shows how to use the BFF framework with the .NET 6 Angular template.\nlink to source code\nBlazor WASM This sample shows how to use the BFF framework with Blazor WASM.\nlink to source code\nYARP Integration This sample shows how to use the BFF extensions for Microsoft YARP\nlink to source code\nSeparate Host for UI This sample shows how to have separate projects from the frontend and backend, using CORS to allow cross-site requests from the frontend to the backend.\nlink to source code\nDPoP This sample shows how to configure the BFF to use DPoP to obtain sender-constrained tokens.\nlink to source code\nToken Exchange using the IAccessTokenRetriever This sample shows how to extend the BFF with an IAccessTokenRetriever. This example of an IAccessTokenRetriever performs token exchange for impersonation. If you are logged in as alice you will get a token for bob, and vice versa.\nlink to source code\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/session/server_side_sessions/",
    "title": "Server-side Sessions",
    "tags": [],
    "description": "BFF",
    "content": "By default, ASP.NET Core\u0026rsquo;s cookie handler will store all user session data in a protected cookie. This works very well unless cookie size or revocation becomes an issue.\nDuende.BFF includes all the plumbing to store your sessions server-side. The cookie will then only be used to transmit the session ID between the browser and the BFF host. This has the following advantages\nthe cookie size will be very small and constant - regardless how much data (e.g. token or claims) is stored in the authentication session the session can be also revoked outside the context of a browser interaction, for example when receiving a back-channel logout notification from the upstream OpenID Connect provider Configuring Server-side Sessions Server-side sessions can be enabled in the application\u0026rsquo;s startup:\nbuilder.Services.AddBff() .AddServerSideSessions(); The default implementation stores the session in-memory. This is useful for testing, but for production you typically want a more robust storage mechanism. We provide an implementation of the session store built with EntityFramework (EF) that can be used with any database with an EF provider (e.g. Microsoft SQL Server). You can also use a custom store. See extensibility for more information.\nUsing Entity Framework for the Server-side Session Store To use the EF session store, install the Duende.BFF.EntityFramework NuGet package and register it by calling AddEntityFrameworkServerSideSessions, like this:\nvar cn = _configuration.GetConnectionString(\u0026#34;db\u0026#34;); builder.Services.AddBff() .AddEntityFrameworkServerSideSessions(options=\u0026gt; { options.UseSqlServer(cn); }); Entity Framework Migrations Most datastores that you might use with Entity Framework use a schema to define the structure of their data. Duende.BFF.EntityFramework doesn\u0026rsquo;t make any assumptions about the underlying datastore, how (or indeed even if) it defines its schema, or how schema changes are managed by your organization. For these reasons, Duende does not directly support database creation, schema changes, or data migration by publishing database scripts. You are expected to manage your database in the way your organization sees fit. Using EF migrations is one possible approach to that, which Duende facilitates by publishing entity classes in each version of Duende.BFF.EntityFramework. An example project that uses those entities to create migrations is here.\nSession Store Cleanup Added in v1.2.0.\nAbandoned sessions will remain in the store unless something removes the stale entries. If you wish to have such sessions cleaned up periodically, then you can configure the EnableSessionCleanup and SessionCleanupInterval options:\nbuilder.Services.AddBff(options =\u0026gt; { options.EnableSessionCleanup = true; options.SessionCleanupInterval = TimeSpan.FromMinutes(5); }) .AddServerSideSessions(); This requires an implementation of IUserSessionStoreCleanup in the DI system.\nIf using Entity Framework Core, then the IUserSessionStoreCleanup implementation is provided for you when you use AddEntityFrameworkServerSideSessions. Just enable session cleanup:\nvar cn = _configuration.GetConnectionString(\u0026#34;db\u0026#34;); builder.Services.AddBff(options =\u0026gt; { options.EnableSessionCleanup = true; }) .AddEntityFrameworkServerSideSessions(options=\u0026gt; { options.UseSqlServer(cn); }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/extensibility/management/user/",
    "title": "BFF User Endpoint Extensibility",
    "tags": [],
    "description": "",
    "content": "The BFF user endpoint can be customized by implementing the IUserService or by extending DefaultUserService, its default implementation. In most cases, extending the default implementation is preferred, as it has several virtual methods that can be overridden to customize particular aspects of how the request is processed. The DefaultUserService\u0026rsquo;s virtual methods are ProcessRequestAsync, GetUserClaims, and GetManagementClaims.\nRequest Processing ProcessRequestAsync is the top level function called in the endpoint service and can be used to add arbitrary logic to the endpoint.\nFor example, you could take whatever actions you need before normal processing of the request like this:\npublic override Task ProcessRequestAsync(HttpContext context) { // Custom logic here return base.ProcessRequestAsync(context); } User Claims GetUserClaims produces the collection of claims that describe the user. The default implementation returns all the claims in the user\u0026rsquo;s session. Your override could add claims from some other source or manipulate the claims in arbitrary ways.\nFor example, you could add additional claims to the user endpoint that would not be part of the session like this:\nprotected override IEnumerable\u0026lt;ClaimRecord\u0026gt; GetUserClaims(AuthenticateResult authenticateResult) { var baseClaims = base.GetUserClaims(authenticateResult); var sub = authenticateResult.Principal.FindFirstValue(\u0026#34;sub\u0026#34;); var otherClaims = getAdditionalClaims(sub); // Retrieve claims from some data store return baseClaims.Append(otherClaims); } Management Claims GetManagementClaims is responsible for producing additional claims that are useful for user management. The default implementation creates bff:session_expires_in, bff:session_state, and bff:logout_url claims. Your implementation could change those claims or add additional custom claims.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/session/management/back-channel-logout/",
    "title": "BFF Back-Channel Logout Endpoint",
    "tags": [],
    "description": "",
    "content": "The /bff/backchannel endpoint is an implementation of the OpenID Connect Back-Channel Logout specification. The remote identity provider can use this endpoint to end the BFF\u0026rsquo;s session via a server to server call, without involving the user\u0026rsquo;s browser. This design avoids problems with 3rd party cookies associated with front-channel logout.\nTypical Usage The back-channel logout endpoint is invoked by the remote identity provider when it determines that sessions should be ended. IdentityServer will send back-channel logout requests if you configure your client\u0026rsquo;s BackChannelLogoutUri. When a session ends at IdentityServer, any client that was participating in that session that has a back-channel logout URI configured will be sent a back-channel logout request. This typically happens when another application signs out. Expiration of IdentityServer server side sessions can also be configured to send back-channel logout requests, though this is disabled by default.\nDependencies The back-channel logout endpoint depends on server-side sessions in the BFF, which must be enabled to use this endpoint. Note that such server-side sessions are distinct from server-side sessions in IdentityServer.\nRevoke all sessions Back-channel logout tokens include a sub (subject ID) and sid (session ID) claim to describe which session should be revoked. By default, the back-channel logout endpoint will only revoke the specific session for the given subject ID and session ID. Alternatively, you can configure the endpoint to revoke every session that belongs to the given subject ID by setting the BackchannelLogoutAllUserSessions option to true.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/tokens/",
    "title": "Token Management",
    "tags": [],
    "description": "BFF - Overview",
    "content": "Duende.BFF includes an automatic token management feature. This uses the access and refresh token stored in the authentication session to always provide a current access token for outgoing API calls.\nFor most scenarios, there is no additional configuration necessary. The token management will infer the configuration and token endpoint URL from the metadata of the OpenID Connect provider.\nThe easiest way to retrieve the current access token is to use an extension method on HttpContext:\nvar token = await HttpContext.GetUserAccessTokenAsync(); You can then use the token to set it on an HttpClient instance:\nvar client = new HttpClient(); client.SetBearerToken(token); We recommend to leverage the HttpClientFactory to fabricate HTTP clients that are already aware of the token management plumbing. For this you would register a named client in your application startup e.g. like this:\n// registers HTTP client that uses the managed user access token builder.Services.AddUserAccessTokenHttpClient(\u0026#34;apiClient\u0026#34;, configureClient: client =\u0026gt; { client.BaseAddress = new Uri(\u0026#34;https://remoteServer/\u0026#34;); }); And then retrieve a client instance like this:\n[Route(\u0026#34;myApi\u0026#34;)] public class MyApiController : ControllerBase { private readonly IHttpClientFactory _httpClientFactory; public MyController(IHttpClientFactory httpClientFactory) { _httpClientFactory = httpClientFactory; } public async Task\u0026lt;IActionResult\u0026gt; Get(string id) { // create HTTP client with automatic token management var client = _httpClientFactory.CreateClient(\u0026#34;apiClient\u0026#34;); // call remote API var response = await client.GetAsync(\u0026#34;remoteApi\u0026#34;); // rest omitted } } If you prefer to use typed clients, you can do that as well:\n// registers a typed HTTP client with token management support services.AddHttpClient\u0026lt;MyTypedApiClient\u0026gt;(client =\u0026gt; { client.BaseAddress = new Uri(\u0026#34;https://remoteServer/\u0026#34;); }) .AddUserAccessTokenHandler(); And then use that client, for example like this on a controller\u0026rsquo;s action method:\npublic async Task\u0026lt;IActionResult\u0026gt; CallApiAsUserTyped( [FromServices] MyTypedClient client) { var response = await client.GetData(); // rest omitted } The client will internally always try to use a current and valid access token. If for any reason this is not possible, the 401 status code will be returned to the caller.\nReuse of Refresh Tokens We recommend that you configure IdentityServer to issue reusable refresh tokens to BFF clients. Because the BFF is a confidential client, it does not need one-time use refresh tokens. Reusable refresh tokens are desirable because they avoid performance and user experience problems associated with one time use tokens. See the discussion on rotating refresh tokens and the OAuth 2.0 Security Best Current Practice for more details.\nManually revoking refresh tokens Duende.BFF revokes refresh tokens automatically at logout time. This behavior can be disabled with the RevokeRefreshTokenOnLogout option.\nIf you want to manually revoke the current refresh token, you can use the following code:\nawait HttpContext.RevokeUserRefreshTokenAsync(); This will invalidate the refresh token at the token service.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/extensibility/management/back-channel-logout/",
    "title": "BFF Back-Channel Logout Endpoint Extensibility",
    "tags": [],
    "description": "",
    "content": "The back-channel logout endpoint has several extensibility points organized into two interfaces and their default implementations. The IBackchannelLogoutService is the top level abstraction that processes requests to the endpoint. This service can be used to add custom request processing logic or to change how it validates incoming requests. When the back-channel logout endpoint receives a valid request, it revokes sessions using the ISessionRevocationService.\nRequest Processing You can add custom logic to the endpoint by implementing the IBackchannelLogoutService or by extending its default implementation (Duende.Bff.DefaultBackchannelLogoutService). In most cases, extending the default implementation is preferred, as it has several virtual methods that can be overridden to customize particular aspects of how the request is processed.\nProcessRequestAsync is the top level function called in the endpoint service and can be used to add arbitrary logic to the endpoint.\npublic class CustomizedBackchannelLogoutService : DefaultBackchannelLogoutService { public override Task ProcessRequestAsync(HttpContext context) { // Custom logic here return base.ProcessRequestAsync(context); } Validation Validation of the incoming request can be customized by overriding one of several virtual methods in the DefaultBackchannelLogoutService. GetTokenValidationParameters allows you to specify the TokenValidationParameters used to validate the incoming logout token. The default implementation creates token validation parameters based on the authentication scheme\u0026rsquo;s configuration. Your override could begin by calling the base method and then make changes to those parameters or completely customize how token validation parameters are created. For example:\npublic class CustomizedBackchannelLogoutService : DefaultBackchannelLogoutService { protected override async Task\u0026lt;TokenValidationParameters\u0026gt; GetTokenValidationParameters() { var tokenValidationParams = await base.GetTokenValidationParameters(); // Set custom parameters here // For example, make clock skew more permissive than it is by default: tokenValidationParams.ClockSkew = TimeSpan.FromMinutes(15); return tokenValidationParams; } If you need more control over the validation of the logout token, you can override ValidateJwt. The default implementation of ValidateJwt validates the token and produces a ClaimsIdentity using a JsonWebTokenHandler and the token validation parameters returned from GetTokenValidationParameters. Your override could call the base method and then manipulate this ClaimsIdentity or add a completely custom method for producing the ClaimsIdentity from the logout token.\nValidateLogoutTokenAsync is the coarsest-grained validation method. It is is responsible for validating the incoming logout token and determining if logout should proceed, based on claims in the token. It returns a ClaimsIdentity if logout should proceed or null if it should not. Your override could prevent logout in certain circumstances by returning null. For example:\npublic class CustomizedBackchannelLogoutService : DefaultBackchannelLogoutService { protected override async Task\u0026lt;ClaimsIdentity?\u0026gt; ValidateLogoutTokenAsync(string logoutToken) { var identity = await base.ValidateLogoutTokenAsync(logoutToken); // Perform custom logic here // For example, prevent logout based on certain conditions if(identity?.FindFirst(\u0026#34;sub\u0026#34;)?.Value == \u0026#34;12345\u0026#34;) { return null; } else { return identity; } } Session Revocation The back-channel logout service will call the registered session revocation service to revoke the user session when it receives a valid logout token. To customize the revocation process, implement the ISessionRevocationService.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/extensibility/management/diagnostics/",
    "title": "BFF Diagnostics Endpoint Extensibility",
    "tags": [],
    "description": "",
    "content": "The BFF diagnostics endpoint can be customized by implementing the IDiagnosticsService or by extending DefaultDiagnosticsService, its default implementation.\nRequest Processing ProcessRequestAsync is the top level function called in the endpoint service and can be used to add arbitrary logic to the endpoint.\nFor example, you could take whatever actions you need before normal processing of the request like this:\npublic override Task ProcessRequestAsync(HttpContext context) { // Custom logic here return base.ProcessRequestAsync(context); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/options/",
    "title": "Configuration Options",
    "tags": [],
    "description": "BFF",
    "content": "The Duende.BFF.BffOptions allows to configure several aspects of the BFF framework.\nYou set the options at startup time:\nbuilder.Services.AddBff(options =\u0026gt; { // configure options here.. }) General EnforceBffMiddleware\nEnables checks in the user management endpoints that ensure that the BFF middleware has been added to the pipeline. Since the middleware performs important security checks, this protects from accidental configuration errors. You can disable this check if it interferes with some custom logic you might have. Defaults to true.\nLicenseKey\nThis sets the license key for Duende.BFF. A business edition or higher license key is required for production deployments. The same license key is used in IdentityServer and the BFF. Just as in the IdentityServer host, you can either set the license key using this option in code or include Duende_License.key in the same directory as your BFF host.\nAnonymousSessionResponse (added in 2.0)\nThis sets the response status code behavior on the user endpoint to either return 401 or 200 with a null payload when the user is anonymous.\nDiagnosticsEnvironments\nThe ASP.NET environment names that enable the diagnostics endpoint. Defaults to \u0026ldquo;Development\u0026rdquo;.\nPaths LoginPath\nSets the path to the login endpoint. Defaults to /bff/login.\nSilentLoginPath\nSets the path to the silent login endpoint. Defaults to /bff/silent-login.\nSilentLoginCallbackPath\nSets the path to the silent login callback endpoint. Defaults to /bff/silent-login-callback.\nLogoutPath\nSets the path to the logout endpoint. Defaults to /bff/logout.\nUserPath\nSets the path to the user endpoint. Defaults to /bff/user.\nBackChannelLogoutPath\nSets the path to the backchannel logout endpoint. Defaults to /bff/backchannel.\nDiagnosticsPath\nSets the path to the diagnostics endpoint. Defaults to /bff/diagnostics.\nSession Management ManagementBasePath\nBase path for management endpoints. Defaults to /bff.\nRequireLogoutSessionId\nFlag that specifies if the sid claim needs to be present in the logout request as query string parameter. Used to prevent cross site request forgery. Defaults to true.\nRevokeRefreshTokenOnLogout\nSpecifies if the user\u0026rsquo;s refresh token is automatically revoked at logout time. Defaults to true.\nBackchannelLogoutAllUserSessions\nSpecifies if during backchannel logout all matching user sessions are logged out. If true, all sessions for the subject will be revoked. If false, just the specific session will be revoked. Defaults to false.\nEnableSessionCleanup\nIndicates if expired server side sessions should be cleaned up. This requires an implementation of IUserSessionStoreCleanup to be registered in the DI system. Defaults to false.\nSessionCleanupInterval\nInterval at which expired sessions are cleaned up. Defaults to 10 minutes.\nAPIs AntiForgeryHeaderName\nSpecifies the name of the header used for anti-forgery header protection. Defaults to X-CSRF.\nAntiForgeryHeaderValue\nSpecifies the expected value of Anti-forgery header. Defaults to 1.\nDPoPJsonWebKey\nSpecifies the Json Web Key to use when creating DPoP proof tokens. Defaults to null, which is appropriate when not using DPoP.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/",
    "title": "BFF Security Framework",
    "tags": [],
    "description": "",
    "content": "BFF Security Framework The Duende.BFF (Backend for Frontend) security framework packages the necessary components to secure browser-based frontends (e.g. SPAs or Blazor WASM applications) with ASP.NET Core backends.\nThe source code for the BFF framework can be found here. Builds are distributed through NuGet here, and samples are available here.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/extensibility/",
    "title": "Extensibility",
    "tags": [],
    "description": "",
    "content": "Extensibility Duende.BFF can be extended in the following areas\ncustom logic at the session management endpoints custom logic and configuration for HTTP forwarding custom data storage for server-side sessions and access/refresh tokens "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v2/samples/",
    "title": "Samples",
    "tags": [],
    "description": "",
    "content": "Samples We have a collection of runnable samples that show how to use IdentityServer and configure client applications in a variety of scenarios. Most of the samples include both their own IdentityServer implementation and the clients and APIs needed to demonstrate the illustrated functionality. The \u0026ldquo;Basics\u0026rdquo; samples use a shared IdentityServer implementation, and some of the BFF samples use our public demo instance of IdentityServer.\nBackend for Frontend Pattern The source code for the samples is in our samples repository.\nFeel free to ask the developer community if you are looking for a particular sample and can\u0026rsquo;t find it here.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/overview/",
    "title": "Overview",
    "tags": [],
    "description": "BFF Security Framework",
    "content": "Single-Page Applications (SPAs) are increasingly common, offering rich functionality within the browser. Front-end development has rapidly evolved with new frameworks and changing browser security requirements. Consequently, best practices for securing these applications have also shifted dramatically.\nWhile implementing OAuth logic directly in the browser was once considered acceptable, this is no longer recommended. Storing any authentication state in the browser (such as access tokens) has proven to be inherently risky (see Threats against browser based applications). Because of this, the IETF is currently recommending delegating all authentication logic to a server-based host via a Backend-For-Frontend pattern as the preferred approach to securing modern web applications.\u0026quot;.\nThe Backend For Frontend Pattern The BFF pattern (Backend-For-Frontend) pattern states that every browser based application should also have a server side application that handles all authentication requirements, including performing authentication flows and securing access to api’s.\nThe server will now expose http endpoints that the browser can use to login, logout or interrogate the active session. With this, the browser based application can trigger an authentication flow by redirecting to a URL, such as /bff/login. Once the authentication process is completed, the server places a secure authentication cookie in the browser. This cookie is then used to authenticate all subsequent requests, until the user is logged out again.\nThe BFF should expose all api’s that the front-end wants to access securely. So it can either host api’s locally, or act as a reverse proxy towards external api’s.\nWith this approach, the browser based application will not have direct access to the access token. So if the browser based application is compromised, for example with XSS attacks, there is no risk of the attacker stealing the access tokens.\nAs the name of this pattern already implies, the BFF backend is the (only) Backend for the Frontend. They should be considered part of the same application. It should only expose the api’s that the front-end needs to function.\n3rd party cookies In recent years, several browsers (notably Safari and Firefox) have started to block 3rd party cookies. Chrome is planning to do the same in the future. While this is done for valid privacy reasons, it also limits some of the functionality a browser based application can provide. A couple of particularly notable OIDC flows that don’t work for SPAs when third party cookies are blocked are OIDC Session Management and OIDC Silent Login via the prompt=none parameter.\nCSRF protection There is one thing to keep an eye out for with this pattern, and that’s Cross Site Request Forgery (CSRF). The browser automatically sends the authentication cookie for safe-listed cross origin requests, which exposes the application to CORS Attacks. Fortunately, this threat can easily be mitigated by a BFF solution by requiring a custom header to be passed along. See more on CORS protection.\nThe Duende BFF framework Duende.BFF is a library for building services that comply with the BFF pattern and solve security and identity problems in browser based applications such as SPAs and Blazor based applications. It is used to create a backend host that is paired with a frontend application. This backend is called the Backend For Frontend (BFF) host, and is responsible for all of the OAuth and OIDC protocol interactions. It completely implements the latest recommendations from the IETF with regards to security for browser based applications.\nIt offers the following functionality:\nProtection from Token Extraction attacks Built-in CSRF Attack protection Server Side OAuth2 Authentication User Management api’s Back-channel logout Securing access to both local and external Api’s by serving as a reverse proxy. Server side Session State Management Blazor Authentication State Management The BFF Framework in an application architecture The following diagram illustrates how the Duende BFF Security Framework fits into a typical application architecture.\nThe browser based application runs inside the browser’s secure sandbox. It can be built using any type of front-end technology, such as via Vanilla-JS, React, Vue, WebComponents, Blazor, etc.\nWhen the user wants to log in, the app can redirect the browser to the authentication endpoints. This will trigger an OpenID Connect authentication flow, at the end of which, it will place an authentication cookie in the browser. This cookie has to be a HTTP Only Same Site and Secure cookie. This makes sure that the browser application cannot get the contents of the cookie, which makes stealing the session much more difficult.\nThe browser will now automatically add the authentication cookie to all calls to the BFF, so all calls to the api’s are secured. This means that local api’s are already automatically secured.\nThe app cannot access external Api’s directly, because the authentication cookie won’t be sent to 3rd party applications. To overcome this, the BFF can proxy requests through the BFF host, while exchanging the authentication cookie for a bearer token that’s issued from the identity provider. This can be configured to include or exclude the user’s credentials.\nAs mentioned earlier, the BFF needs protection against CSRF attacks, because of the nature of using authentication cookies. While .net has various built-in methods for protecting against CSRF attacks, they often require a bit of work to implement. The easiest way to protect (just as effective as the .Net provided security mechanisms) is just to require the use of a custom header. The BFF Security framework by default requires the app to add a custom header called x-csrf=1 to the application. Just the fact that this header must be present is enough to protect the BFF from CSRF attacks.\nLogical and Physical Sessions When implemented correctly, a user will think of their time interacting with a solution as \u0026ldquo;one session\u0026rdquo; also known as the \u0026ldquo;logical session\u0026rdquo;. The user should not be concerned with the steps developers take to provide a seamless experience. Users want to use the app, get their tasks completed, and log out happy.\nsequenceDiagram actor Alice Alice-\u003e\u003eApp: /login App-\u003e\u003eAlice: /account box logical session participant App end So while the user will only see only (and care about) a single session, it\u0026rsquo;s entirely possible that there will be multiple physical sessions active. For most distributed applications, including those implemented with BFF, sessions are managed independently by each component of an application architecture. This means that there are N+1 physical sessions possible, where N is the number of sessions for each service in your solution, and the +1 being the session managed on the BFF host. Since we are focusing on ASP.NET Core, those sessions typically are stored using the Cookie Authentication handler features of .NET.\nsequenceDiagram actor Alice Alice-\u003e\u003eApp: /login App-\u003e\u003eAlice: /account App-\u003e\u003eService 1: request App--\u003e\u003eService N...: N... request box App session participant App end box Service 1 session participant Service 1 end box Service N... session participant Service N... end The separation allows each service to manage its session to its specific needs. While it can depend on your requirements, we find most developers want to coordinate the physical session lifetimes, creating a more predictable logical session. If that is your case, we recommend you first start by turning each physical session into a more powerful server-side session.\nServer-side sessions are instances that are persisted to data storage and allow for visibility into currently active sessions and better management techniques. Let\u0026rsquo;s take a look at the advantages of server-side sessions. Server-side sessions at each component allows for:\nReceiving back channel logout notifications Forcibly end a user\u0026rsquo;s session of that node Store and view information about a session lifetime Coordinate sessions across an application\u0026rsquo;s components Different claims data Server-side sessions at IdentityServer allow for more powerful features:\nReceive back channel logout notifications from upstream identity providers in a federation Forcibly end a user\u0026rsquo;s session at IdentityServer Global inactivity timeout across SSO apps and session coordination Coordinate sessions to registered clients Keep in mind the distinctions between logical and physical sessions and you will better understand the interplay between elements in your solution.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/overview/threats-against-browser-based-applications/",
    "title": "Threats against browser-based applications",
    "tags": [],
    "description": "BFF Security Framework",
    "content": "In this paragraph, let’s look at some of the common ways browser-based apps are typically attacked and what their consequences would be.\nToken theft Often, malicious actors are trying to steal access tokens. In this paragraph, we’ll look into several techniques how this is often done and what the consequences are. But it’s important to note that all of these techniques rely on the browser-based application having access to the access token. Therefore, these attacks can be prevented by implementing the BFF pattern.\nScript injection attacks The most common way malicious actors steal access tokens is by injecting malicious JavaScript code into the browser. This can happen in many different ways. Script injection attacks or supply chain attacks (via compromised NPM packages or cloud-hosted scripts) are just some examples.\nSince the malicious code runs in the same security sandbox as the application’s code, it has exactly the same privileges as the application code. This means there is no way to securely store and handle access tokens in the browser.\nThere have been attempts to place the code that accesses and uses web tokens in more highly isolated storage areas, such as Web Workers, but these attempts have also been proven to be vulnerable to token exfiltration attacks, so they are not suitable as an alternative.\nIf the browser-based application has access to your access token, so can malicious actors.\nOther ways of compromising browser security Injecting code is not the only way that browser security can be broken. Sometimes the browser sandbox itself is under attack. Browsers attempt to provide a secure environment in which web pages and their scripts can safely be loaded and executed in isolation. On many occasions, this browser sandbox has been breached by exploits. A recent example is the POC from Google on Browser-Based Spectre Attacks.\nBy bypassing the security sandbox, the attackers are able to read the memory from your application and steal the access tokens. The best way to protect yourself from this is not having any access tokens stored in the application’s memory at all by following the BFF pattern.\nConsequences of token theft Once an attacker is able to inject malicious code, there are a number of things the attacker can do. At a minimum, the attacker can take over the current user’s session and in the background perform malicious actions under the credentials of the user. This would only be possible as long as the user has the application open, which limits how long the attacker can misuse the session.\nIt’s worse if the attacker is able to extract the authentication token. The attacker can now access the application directly from his own computer, as long as the access token is valid. For this reason, it’s recommended to keep access token lifetimes short.\nIf the attacker is also able to acquire the refresh token or worse, is able to request new tokens, then the attacker can use the credentials indefinitely.\nAttacks at OAuth Implicit Grant Sometimes there are vulnerabilities discovered even in the protocols that are underlying most of the web’s security. As a result, these protocols are constantly evolving and updated to reflect the latest knowledge and known vulnerabilities.\nOne example of this is OAuth Implicit grant. This was once a recommended pattern and many applications have implemented this since. However, in recent years it’s become clear that this protocol is no longer deemed secure and in the words of the IETF:\nBrowser-based clients MUST use the Authorization Code grant type and MUST NOT use the Implicit grant type to obtain access tokens\nCSRF Attacks Cookie-based authentication (when using Secure and HTTP Only cookies) effectively prevents browser-based token stealing attacks. But this approach is vulnerable to a different type of attack, namely CSRF attacks. This is similar but different from CORS attacks which lies in the definition of what the browser considers a Site vs an Origin and what kind of request a browser considers \u0026lsquo;safe\u0026rsquo; for Cross Origin requests.\nOrigins and Sites To a browser, a site is defined as TLD (top-level domain - 1). So, a single segment under a top-level domain, such as example in example.co.uk, where co.uk is the top-level domain. Any subdomain under that (so site1.example.co.uk and www.example.co.uk) are considered to be from the same site. Contrast this to an origin, which is the scheme + hostname + port. In the previous example, the origins would be https://example.co.uk and https://www.example.co.uk. The site is the same, but the origin is different.\nBrowsers have built-in control when cookies should be sent. For example, by setting SameSite=strict, the browser will only send along cookies if you are navigating within the same site (not origins).\nBrowsers also have built-in Cross Origin protection. Most requests that go across different origins (not sites) will by default be subjected to CORS protection. This means that the server needs to say if the requests are safe to use cross origin. The exclusion to this are requests that the browser considers safe. The following diagram (created based on this article wikipedia) shows this quite clearly:\nflowchart LR; A[JavaScript makes a cross-domain XHR call] --\u003e B{Is it a GET or HEAD?}; subgraph cors-safe B --\u003e|Yes| X[Make actual XHR]; B --\u003e|No| C{Is it a POST?}; C --\u003e|Yes| E{Is the content-type standard?}; C --\u003e|No| D[Make OPTIONS call to server with all custom details]; E --\u003e|No| D; E --\u003e|Yes| F{Are there custom HTTP headers?}; F --\u003e|No| X; F --\u003e|Yes| D; end subgraph cors-verify D --\u003e G{Did server respond with appropriate Access-Control-* headers?}; G --\u003e|No| H[ERROR]; end G --\u003e|Yes| X; style cors-safe fill:#d9ead3,stroke:#6aa84f; style cors-verify fill:#f4cccc,stroke:#cc0000; So some requests, like regular GET or POSTs with a standard content type are NOT subject to CORS validation, but others (IE: deletes or requests with a custom HTTP header) are.\nCSRF Attack inner workings CSRF attacks exploit the fact that browsers automatically send authentication cookies with requests to the same site. Should an attacker trick a user that’s logged in to an application into visiting a malicious website, that browser can make malicious requests to the application under the credentials of the user.\nSame Site cookies already drastically reduce the attack surface because they ensure the browser only sends the cookies when the user is on the same site. So a user logged in to an application at app.company.com will not be vulnerable when visiting malicious-site.com.\nHowever, the application can still be at risk. Should other applications running under different subdomains of the same site be compromised, then you are still vulnerable to CSRF attacks. Luring a user to a compromised site under a subdomain will bypass this Same Site protection and leave the application still vulnerable to CSRF attacks. Unfortunately, compromised applications running under different subdomains is a common attack vector, not to be underestimated.\nProtection against CSRF Attacks Many frameworks, including dotnet, have built in protection against CSRF attacks. These mitigations require you to make certain changes to your application, such as embedding specific form fields in your application which needs to be re-submitted or reading a specific cookie value. While these protections are effective, there is a simpler and more straight forward solution to preventing to preventing any CSRF attack.\nThe trick is to require a custom header on the API\u0026rsquo;s that you wish to protect. It doesn’t matter what that custom header is or what the value is, for example, some-header=1. The browser-based application now MUST send this header along with every request. However, if a page on the malicious subdomain wants to call this API, it also has to add this custom header. This custom header now triggers a CORS Preflight check. This pre-flight check will fail because it detects that the request is cross-origin. Now the API developer has to develop a CORS policy that will protect against CORS attacks.\nSo, effective CSRF attack protection relies on these pillars:\nUsing Same-Site=strict Cookies Requiring a specific header to be sent on every API request (IE: x-csrf=1) having a cors policy that restricts the cookies only to a list of white-listed origins. Session Hijacking In session hijacking, a malicious actor somehow gets access to the user\u0026rsquo;s session cookie and is then able to exploit it by effectively cloning the session.\nBefore HTTPS was widespread, session hijacking was a common occurrence, especially when using public Wi-Fi networks. However, since SSL connections are pretty much widespread, this has become more difficult. Not impossible, because there have been cases where trusted certificate authorities have been compromised.\nEven if SSL is not compromised, there are other ways for malicious actors to hijack the session. For example, if the user’s computer is compromised then browser security can still be bypassed. There have also been occurrences of session hijacking where (malicious) helpdesk employees asked for ‘har’ files (which are effectively complete request traces, including the authentication cookies), which were then used to hijack sessions.\nRight now, it’s very difficult to completely protect against this type of attack. However, there are interesting new standards being discussed, such as Device Bound Session Credentials. This standard aims to make sure that a session is cryptographically bound to a single device. Even if stolen, it can’t be used by a different device.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/upgrading/",
    "title": "Upgrading",
    "tags": [],
    "description": "Upgrading BFF",
    "content": " Duende BFF Security Framework v2.x to v3.0 "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/extensibility/management/login/",
    "title": "BFF Login Endpoint Extensibility",
    "tags": [],
    "description": "",
    "content": "The BFF login endpoint has extensibility points in two interfaces. The ILoginService is the top level abstraction that processes requests to the endpoint. This service can be used to add custom request processing logic. The IReturnUrlValidator ensures that the returnUrl parameter passed to the login endpoint is safe to use.\nRequest Processing ProcessRequestAsync is the top level function called in the endpoint service and can be used to add arbitrary logic to the endpoint.\nFor example, you could take whatever actions you need before normal processing of the request like this:\npublic override Task ProcessRequestAsync(HttpContext context) { // Custom logic here return base.ProcessRequestAsync(context); } Return URL Validation To prevent open redirector attacks, the returnUrl parameter to the login endpoint must be validated. You can customize this validation by implementing the IReturnUrlValidator interface. The default implementation enforces that return urls are local.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/architecture/",
    "title": "Architecture",
    "tags": [],
    "description": "",
    "content": "A BFF host is an ASP.NET Core application, tied to a single browser based application. It performs the following functions:\nAuthenticate the user using OpenID Connect Manages the user\u0026rsquo;s session using Secure Cookies and optional Server-side Session Management. Optionally, provides access to the UI assets. Server-side Token Management Blazor support with unified authentication state management across rendering modes. Duende.BFF builds on widely used tools and frameworks, including ASP.NET Core\u0026rsquo;s OpenID Connect and cookie authentication handlers, YARP, and Duende.AccessTokenManagement. Duende.BFF combines these tools and adds additional security and application features that are useful with a BFF architecture so that you can focus on providing application logic instead of security logic:\nASP.NET OpenID Connect Handler Duende.BFF uses ASP.NET\u0026rsquo;s OpenID Connect handler for OIDC and OAuth protocol processing. As long-term users of and contributors to this library, we think it is a well implemented and flexible implementation of the protocols.\nASP.NET Cookie Handler Duende.BFF uses ASP.NET\u0026rsquo;s Cookie handler for session management. The Cookie handler provides a claims-based identity to the application persisted in a digitally signed and encrypted cookie that is protected with modern cookie security features, including the Secure, HttpOnly and SameSite attributes. The handler also provides absolute and sliding session support, and has a flexible extensibility model, which Duende.BFF uses to implement server-side session management and back-channel logout support.\nDuende.AccessTokenManagement Duende.BFF uses the Duende.AccessTokenManagement library for access token management and storage. This includes storage and retrieval of tokens, refreshing tokens as needed, and revoking tokens on logout. The library provides integration with the ASP.NET HTTP client to automatically attach tokens to outgoing HTTP requests, and its underlying management actions can also be programmatically invoked through an imperative API.\nAPI Endpoints In the BFF architecture, the frontend makes API calls to backend services via the BFF host exclusively. Typically the BFF acts as a reverse proxy to remote APIs, providing session and token management. Implementing local APIs within the BFF host is also possible. Regardless, requests to APIs are authenticated with the session cookie and need to be secured with an anti-forgery protection header.\nYARP Duende.BFF proxies requests to remote APIs using Microsoft\u0026rsquo;s YARP (Yet Another Reverse Proxy). You can set up YARP using a simplified developer-centric configuration API provided by Duende.BFF, or if you have more complex requirements, you can use the full YARP configuration system directly. If you are using YARP directly, Duende.BFF provides YARP integration to add BFF security and identity features.\nUI Assets The BFF host typically serves at least some of the UI assets of the frontend, which can be HTML/JS/CSS, WASM, and/or server-rendered content. Serving the UI assets, or at least the index page of the UI from the same origin as the backend simplifies requests from the frontend to the backend. Doing so makes the two components same-origin, so that browsers will allow requests with no need to use CORS and automatically include cookies (including the crucial authentication cookie). This also avoids issues where third-party cookie blocking or the SameSite cookie attribute prevents the frontend from sending the authentication cookie to the backend.\nIt is also possible to separate the BFF and UI and host them separately. See here for more discussion of UI hosting architecture.\nBlazor Support Blazor based applications have unique challenges when it comes to authentication state. It\u0026rsquo;s possible to mix various rendering models in a single application. Auto mode even starts off server rendered, then transitions to WASM when the code has loaded.\nBFF Security Framework has built support for Blazor, where it helps to unify access to authentication state and to secure access to backend services.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/fundamentals/session/handlers/",
    "title": "ASP.NET Core Authentication System",
    "tags": [],
    "description": "",
    "content": "You typically use the following two ASP.NET Core authentication handlers to implement remote authentication:\nthe OpenID Connect authentication handler to interact with the remote OIDC / OAuth token service, e.g. Duende IdentityServer the cookie handler to do local session management Furthermore the BFF plumbing relies on the configuration of the ASP.NET Core default authentication schemes. This describes how the two handlers share the work.\nOpenID Connect for challenge and signout - cookies for all the other operations:\nbuilder.Services.AddAuthentication(options =\u0026gt; { options.DefaultScheme = \u0026#34;cookie\u0026#34;; options.DefaultChallengeScheme = \u0026#34;oidc\u0026#34;; options.DefaultSignOutScheme = \u0026#34;oidc\u0026#34;; }) .AddCookie(\u0026#34;cookie\u0026#34;, options =\u0026gt; { ... }) .AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { ... }); The OpenID Connect Authentication Handler The OIDC handler connects the application to the authentication / access token system.\nThe exact settings depend on the OIDC provider and its configuration settings. We recommend:\nuse authorization code flow with PKCE use a response_mode of query since this plays nicer with SameSite cookies use a strong client secret. Since the BFF can be a confidential client, it is totally possible to use strong client authentication like JWT assertions, JAR or MTLS. Shared secrets work as well of course. turn off inbound claims mapping save the tokens into the authentication session so they can be automatically managed request a refresh token using the offline_access scope builder.Services.AddAuthentication().AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { options.Authority = \u0026#34;https://demo.duendesoftware.com\u0026#34;; // confidential client using code flow + PKCE options.ClientId = \u0026#34;spa\u0026#34;; options.ClientSecret = \u0026#34;secret\u0026#34;; options.ResponseType = \u0026#34;code\u0026#34;; // query response type is compatible with strict SameSite mode options.ResponseMode = \u0026#34;query\u0026#34;; // get claims without mappings options.MapInboundClaims = false; options.GetClaimsFromUserInfoEndpoint = true; // save tokens into authentication session // to enable automatic token management options.SaveTokens = true; // request scopes options.Scope.Clear(); options.Scope.Add(\u0026#34;openid\u0026#34;); options.Scope.Add(\u0026#34;profile\u0026#34;); options.Scope.Add(\u0026#34;API\u0026#34;); // and refresh token options.Scope.Add(\u0026#34;offline_access\u0026#34;); }); The OIDC handler will use the default sign-in handler (the cookie handler) to establish a session after successful validation of the OIDC response.\nThe Cookie Handler The cookie handler is responsible for establishing the session and manage authentication session related data.\nThings to consider:\ndetermine the session lifetime and if the session lifetime should be sliding or absolute it is recommended to use a cookie name prefix if compatible with your application use the highest available SameSite mode that is compatible with your application, e.g. strict, but at least lax builder.Services.AddAuthentication().AddCookie(\u0026#34;cookie\u0026#34;, options =\u0026gt; { // set session lifetime options.ExpireTimeSpan = TimeSpan.FromHours(8); // sliding or absolute options.SlidingExpiration = false; // host prefixed cookie name options.Cookie.Name = \u0026#34;__Host-spa\u0026#34;; // strict SameSite handling options.Cookie.SameSite = SameSiteMode.Strict; }); Choosing between SameSite.Lax and SameSite.Strict The SameSite cookie is a feature of modern browsers that restricts cookies so that they are only sent to pages originating from the site where the cookie was originally issued. This prevents CSRF attacks and helps with improving privacy, because cross-site requests will no longer implicitly include the user\u0026rsquo;s credentials.\nIf you configure SameSiteMode.Strict, this means that if a user originates from an external site and is redirected or linked to the BFF application, then the authentication cookie is not sent automatically. So, the application will consider the user to be not logged in, even though there may be a valid authentication cookie in the cookie jar. If the user refreshes the page, or visits a link on your site that forces a complete page reload, then the authentication cookie will be sent along normally again.\nThis also happens when you have an identity provider that\u0026rsquo;s hosted on a different site than the BFF, in combination with SameSiteMode.Strict. After successful authentication at the IdP, the user will be redirected back to the BFF site. The server will then place an authentication cookie in the browser, but the browser will not automatically include it in subsequent requests until the full page is manually reloaded by the user. This means the user appears to still be logged out, even though the cookie is there.\nSo, if you have an Identity Provider that\u0026rsquo;s hosted under a different site than your BFF, you may want to configure your cookie policy to be SameSiteMode.Lax.\nChrome will make an exception for cookies set without a SameSite attribute less than 2 minutes ago. Such cookies will also be sent with non-idempotent (e.g. POST) top-level cross-site requests despite normal SameSite=Lax cookies requiring top-level cross-site requests to have a safe (e.g. GET) HTTP method. Support for this intervention (\u0026ldquo;Lax + POST\u0026rdquo;) will be removed in the future. (source: chromestatus)\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/extensibility/management/",
    "title": "BFF Management Endpoints Extensibility",
    "tags": [],
    "description": "",
    "content": "The behavior of each management endpoint is defined in a service. When you add Duende.BFF to DI, a default implementation for every management endpoint gets registered:\n// management endpoints builder.Services.AddTransient\u0026lt;ILoginService, DefaultLoginService\u0026gt;(); builder.Services.AddTransient\u0026lt;ISilentLoginService, DefaultSilentLoginService\u0026gt;(); builder.Services.AddTransient\u0026lt;ISilentLoginCallbackService, DefaultSilentLoginCallbackService\u0026gt;(); builder.Services.AddTransient\u0026lt;ILogoutService, DefaultLogoutService\u0026gt;(); builder.Services.AddTransient\u0026lt;IUserService, DefaultUserService\u0026gt;(); builder.Services.AddTransient\u0026lt;IBackchannelLogoutService, DefaultBackchannelLogoutService\u0026gt;(); builder.Services.AddTransient\u0026lt;IDiagnosticsService, DefaultDiagnosticsService\u0026gt;(); You can add your own implementation by overriding the default after calling AddBff().\nThe management endpoint services all inherit from the IBffEndpointService, which provides a general-purpose mechanism to add custom logic to the endpoints.\npublic interface IBffEndpointService { Task ProcessRequestAsync(HttpContext context); } None of the endpoint services contain additional members beyond ProcessRequestAsync.\nYou can customize the behavior of the endpoints either by implementing the appropriate interface or by extending the default implementation of that interface. In many cases, extending the default implementation is preferred, as this allows you to keep most of the default behavior by calling the base ProcessRequestAsync from your derived class. Several of the default endpoint service implementations also define virtual methods that can be overridden to customize their behavior with more granularity. See the following pages for details on those extension points.\nBFF Login Endpoint Extensibility BFF Silent Login Endpoint Extensibility BFF Silent Login Callback Extensibility BFF Logout Endpoint Extensibility BFF User Endpoint Extensibility BFF Back-Channel Logout Endpoint Extensibility BFF Diagnostics Endpoint Extensibility "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/fundamentals/blazor/rendering-modes/",
    "title": "Blazor Rendering modes",
    "tags": [],
    "description": "",
    "content": "Blazor supports several rendering modes:\nStatic Server - Static server-side rendering (static SSR) Interactive Server - Interactive server-side rendering (interactive SSR) using Blazor Server. Interactive WebAssembly - Client-side rendering (CSR) using Blazor WebAssembly. Interactive Auto - Interactive SSR using Blazor Server initially and then CSR on subsequent visits after the Blazor bundle is downloaded. While these options give a lot of flexibility on how sites and components are rendered, it also provides some complexity.\nIt\u0026rsquo;s important to understand that, if you use a rendering mode that uses WebAssembly (so InteractiveWebAssembly or Auto), that you\u0026rsquo;re effectively building two applications. One is a server process that renders HTML, the other is a WASM application that runs in the browser.\nIf you have a component that\u0026rsquo;s rendered both on the server AND on the client, then you effectively need to make sure that all the services it requires are available both on the server AND on the client.\nFetching data from local APIs If your BFF application can directly access data (for example from a database), then you have to decide where this information is rendered.\nFor server side rendering, you\u0026rsquo;ll typically abstract your data access logic into a separate class (such as a repository or a query object) and inject this into your component for rendering.\nFor web assembly rendering, you\u0026rsquo;ll need to make the data available via a web service on the server. Then on the client, you\u0026rsquo;ll need a configured HTTP client that accesses this information securely.\nWhen using auto-rendering mode, you\u0026rsquo;ll need to make sure that the component get\u0026rsquo;s a different \u0026lsquo;data access\u0026rsquo; component for server rendering vs client rendering. Consider the following diagram:\nIn this diagram, you\u0026rsquo;ll see the example IDataAccessor that has two implementations. One that accesses the data via a HTTP client (for use in WASM) and one that directly accesses the data.\nThe data is also exposed (and secured by the BFF) via a local api.\nBelow is an example of registering an abstraction\n// Setup on the server // Register the server implementation for accessing some data builder.Services.AddSingleton\u0026lt;IDataAccessor, ServerDataAccessor\u0026gt;(); // Register an api that will access the data app.MapGet(\u0026#34;/some_data\u0026#34;, async (IDataAccessor dataAccessor) =\u0026gt; await dataAccessor.GetData()) .RequireAuthorization() .AsBffApiEndpoint(); // Create a class that would actually get the data from the database internal class ServerWeatherClient() : IDataAccessor { public Task\u0026lt;Data[]\u0026gt; GetData() { // get the actual data from the database } } // setup on the client // Register a http client that can access the data via a local api. builder.Services.AddLocalApiHttpClient\u0026lt;DataAccessHttpClient\u0026gt;(); // Register an adapter that would abstract between the data accessor and the http client. builder.Services.AddSingleton\u0026lt;IDataAccessor\u0026gt;(sp =\u0026gt; sp.GetRequiredService\u0026lt;HttpClientDataAccessor\u0026gt;()); internal class HttpClientDataAccessor(HttpClient client) : IDataAccessor { public async Task\u0026lt;Data[]\u0026gt; GetSomeData() =\u0026gt; await client.GetFromJsonAsync\u0026lt;Data[]\u0026gt;(\u0026#34;/some_data\u0026#34;) ?? throw new JsonException(\u0026#34;Failed to deserialize\u0026#34;); } Fetching data from remote APIs If your BFF needs to secure access to remote api\u0026rsquo;s, then your components can both directly use a (typed) HttpClient. How this HttpClient is configured is quite different on the client vs the server though.\nOn the Client, the http client needs to be secured with the authentication cookie and CORS protection headers. This then calls the http endpoint on the server.\nOn the Server, you\u0026rsquo;d need to expose the proxied http endpoint. This then uses a http client that\u0026rsquo;s configured to send access tokens. These may or may not contain a user token.\nThis diagram shows this in more detail:\n// setup on the server app.MapRemoteBffApiEndpoint(\u0026#34;/remote-apis/user-token\u0026#34;, \u0026#34;https://localhost:5010\u0026#34;) builder.Services.AddUserAccessTokenHttpClient(\u0026#34;callApi\u0026#34;, configureClient: client =\u0026gt; client.BaseAddress = new Uri(\u0026#34;https://localhost:5010/\u0026#34;)); // setup on the client builder.services.AddRemoteApiHttpClient(\u0026#34;callApi\u0026#34;); "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/fundamentals/",
    "title": "Fundamentals",
    "tags": [],
    "description": "",
    "content": " Authentication \u0026amp; Session Management API Endpoints Token Management Configuration Options Blazor applications "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/fundamentals/apis/local/",
    "title": "Local APIs",
    "tags": [],
    "description": "",
    "content": "A Local API is an API that is located within the BFF host. Local APIs are implemented with the familiar ASP.NET abstractions of API controllers or Minimal API endpoints.\nThere are two styles of local APIs:\nSelf-contained Local APIs Local APIs that Make Requests using Managed Access Tokens Self-Contained Local APIs These APIs reside within the BFF and don\u0026rsquo;t make HTTP requests to other APIs. They access data controlled by the BFF itself, which can simplify the architecture of the system by reducing the number of APIs that must be deployed and managed. They are suitable for scenarios where the BFF is the sole consumer of the data. If you require data accessibility from other applications or services, this approach is probably not suitable.\nLocal APIs that Make Requests using Managed Access Tokens Alternatively, you can make the data available as a service and make HTTP requests to that service from your BFF\u0026rsquo;s local endpoints. The benefits of this style of Local Endpoint include\nYour frontend\u0026rsquo;s network access can be simplified into an aggregated call for the specific data that it needs, which reduces the amount of data that must be sent to the client. Your BFF endpoint can expose a subset of your remote APIs so that they are called in a more controlled manner than if the BFF proxied all requests to the endpoint. Your BFF endpoint can include business logic to call the appropriate endpoints, which simplifies your front end code. Your local endpoints can leverage services like the HTTP client factory and Duende.BFF token management to make the outgoing calls. The following is a simplified example showing how local endpoints can obtain managed access tokens and use them to make requests to remote APIs.\n[Route(\u0026#34;myApi\u0026#34;)] public class MyApiController : ControllerBase { private readonly IHttpClientFactory _httpClientFactory; public MyApiController(IHttpClientFactory httpClientFactory) { _httpClientFactory = httpClientFactory; } public async Task\u0026lt;IActionResult\u0026gt; Get(string id) { // create HTTP client var client = _httpClientFactory.CreateClient(); // get current user access token and set it on HttpClient var token = await HttpContext.GetUserAccessTokenAsync(); client.SetBearerToken(token); // call remote API var response = await client.GetAsync($\u0026#34;https://remoteServer/remoteApi?id={id}\u0026#34;); // maybe process response and return to frontend return new JsonResult(await response.Content.ReadAsStringAsync()); } } The example above is simplified to demonstrate the way that you might obtain a token. Real local endpoints will typically enforce constraints on the way the API is called, aggregate multiple calls, or perform other business logic. Local endpoints that merely forward requests from the frontend to the remote API may not be needed at all. Instead, you could proxy the requests through the BFF using either the simple http forwarder or YARP.\nSecuring Local API Endpoints Regardless of the style of data access used by a local API, it must be protected against threats such as CSRF (Cross-Site Request Forgery) attacks. To defend against such attacks and ensure that only the frontend can access these endpoints, we recommend implementing two layers of protection.\nSameSite cookies The SameSite cookie attribute is a feature of modern browsers that restricts cookies so that they are only sent to pages originating from the site where the cookie was originally issued.\nThis is a good first layer of defense, but makes the assumption that you can trust all subdomains of your site. All subdomains within a registrable domain are considered the same site for purposes of SameSite cookies. Thus, if another application hosted on a subdomain within your site is infected with malware, it can make CSRF attacks against your application.\nAnti-forgery header For this reason, we recommend requiring an additional custom header on API endpoints, for example:\nGET /endpoint x-csrf: 1 The value of the header is not important, but its presence, combined with the cookie requirement, triggers a CORS preflight request for cross-origin calls. This effectively isolates the caller to the same origin as the backend, providing a robust security guarantee.\nAdditionally, API endpoints should handle scenarios where the session has expired or authorization fails without triggering an authentication redirect to the upstream identity provider. Instead, they should return Ajax-friendly status codes.\nSetup Duende.BFF can automate both the pre-processing step of requiring the custom anti-forgery header and the post-processing step of converting response codes for API endpoints. To do so, first add the BFF middleware to the pipeline, and then decorate your endpoints to indicate that they should receive BFF pre and post processing.\nAdd Middleware Add the BFF middleware to the pipeline by calling UseBFF. Note that the middleware must be placed before the authorization middleware, but after routing.\napp.UseAuthentication(); app.UseRouting(); app.UseBff(); app.UseAuthorization(); //map endpoints Decorate Endpoints Endpoints that require the pre and post processing described above must be decorated with a call to AsBffApiEndpoint().\nFor Minimal API endpoints, you can apply BFF pre- and post-processing when they are mapped.\napp.MapPost(\u0026#34;/foo\u0026#34;, context =\u0026gt; { ... }) .RequireAuthorization() // no anonymous access .AsBffApiEndpoint(); // BFF pre/post processing For MVC controllers, you can similarly apply BFF pre- and post-processing to controller actions when they are mapped.\napp.MapControllers() .RequireAuthorization() // no anonymous access .AsBffApiEndpoint(); // BFF pre/post processing Alternatively, you can apply the [BffApi] attribute directly to the controller or action.\n[Route(\u0026#34;myApi\u0026#34;)] [BffApi] public class MyApiController : ControllerBase { ... } Disabling Anti-forgery Protection Disabling anti-forgery protection is possible but not recommended. Antiforgery protection defends against CSRF attacks, so opting out may cause security vulnerabilities.\nHowever, if you are defending against CSRF attacks with some other mechanism, you can opt-out of Duende.BFF\u0026rsquo;s CSRF protection. Depending on the version of Duende.BFF, use one of the following approaches.\nFor version 1.x, set the requireAntiForgeryCheck parameter to false when adding the endpoint. For example:\n// MVC controllers app.MapControllers() .RequireAuthorization() // WARNING: Disabling antiforgery protection may make // your APIs vulnerable to CSRF attacks .AsBffApiEndpoint(requireAntiforgeryCheck: false); // simple endpoint app.MapPost(\u0026#34;/foo\u0026#34;, context =\u0026gt; { /* ... */ }) .RequireAuthorization() // WARNING: Disabling antiforgery protection may make // your APIs vulnerable to CSRF attacks .AsBffApiEndpoint(requireAntiforgeryCheck: false); On MVC controllers and actions you can set the RequireAntiForgeryCheck as a flag in the BffApiAttribute, like this:\n[Route(\u0026#34;sample\u0026#34;)] // WARNING: Disabling antiforgery protection may make // your APIs vulnerable to CSRF attacks [BffApi(requireAntiForgeryCheck: false)] public class SampleApiController : ControllerBase { /* ... */ } In version 2.x, use the SkipAntiforgery fluent API when adding the endpoint. For example:\n// MVC controllers app.MapControllers() .RequireAuthorization() .AsBffApiEndpoint() // WARNING: Disabling antiforgery protection may make // your APIs vulnerable to CSRF attacks .SkipAntiforgery(); // simple endpoint app.MapPost(\u0026#34;/foo\u0026#34;, context =\u0026gt; { /* ... */ }) .RequireAuthorization() .AsBffApiEndpoint() // WARNING: Disabling antiforgery protection may make // your APIs vulnerable to CSRF attacks .SkipAntiforgery(); MVC controllers and actions can use the BffApiSkipAntiforgeryAttribute (which is independent of the BffApiAttribute), like this:\n[Route(\u0026#34;sample\u0026#34;)] // WARNING: Disabling antiforgery protection may make // your APIs vulnerable to CSRF attacks [BffApiSkipAntiforgeryAttribute] public class SampleApiController : ControllerBase { /* ... */ } "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/architecture/ui-hosting/",
    "title": "UI Hosting",
    "tags": [],
    "description": "",
    "content": "Hosting Options for the UI There are several options for hosting the UI assets when using a BFF.\nHost the assets within the BFF host using the static file middleware Host the UI and BFF separately on subdomains of the same site and use CORS to allow cross origin requests Serves the index page of the UI from the BFF host, and all other assets are loaded from another domain, such as a CDN Serving SPA assets from BFF host Hosting the UI together with the BFF is the simplest choice, as requests from the front end to the backend will automatically include the authentication cookie and not require CORS headers. This makes the BFF and the front-end application a single deployable unit. Below shows a graphical overview of what that would look like:\nIf you create a BFF host using our templates, the UI will be hosted in this way:\ndotnet new bffremoteapi # or dotnet new bfflocalapi Many frontend applications require a build process, which complicates the use of the static file middleware at development time. Visual Studio includes SPA templates that start up a SPA and proxy requests to it during development. Samples of Duende.BFF that take this approach using React and Angular are available.\nMicrosoft\u0026rsquo;s templates are easy to use at dev time from Visual Studio. They allow you to simply run the solution, and the template proxies requests to the front end for you. At deploy time, that proxy is removed and the static assets of the site are served by the static file middleware.\nHost the UI separately You may want to host the UI outside of the BFF. At development time, UI developers might prefer to run the frontend outside of Visual Studio (e.g., using the node cli). You might also want to have separate deployments of the frontend and the BFF, and you might want your static UI assets hosted on a CDN. Below is a schematic overview of what that would look like:\nThe browser accesses the application via the BFF. The BFF proxies the calls to index.html to the CDN. The browser can then download all static assets from the CDN, but then use the BFF (and it’s API’s and user management API’s) secured by the authentication cookie as normal.\nEffectively, this turns your front-end and BFF Host into two separately deployable units. You\u0026rsquo;ll need to ensure that the two components are hosted on subdomains of the same domain so that third party cookie blocking doesn\u0026rsquo;t prevent the frontend from including cookies in its requests to the BFF host.\nIn order for this architecture to work, the following things are needed:\nTo make sure that client side routing works, there should be a catch-all route configured that proxies calls to the index.html. Once the index.html is served, the front-end will take over the application specific routing.\nThe API’s hosted by the BFF and the applications API’s should be excluded from this catch-all routing. However, they should not be visited by the browser directly.\nThe CDN needs to be configured to allow CORS requests from the application’s origin.\nIn order to include the auth cookie in those requests, the frontend code will have to declare that it should send credentials using the credentials: \u0026ldquo;include\u0026rdquo; option.\nA sample of this approach is available.\nServe the index page from the BFF host Lastly, you could serve the index page of the SPA from the BFF, but have all of the other static assets hosted on another host (presumably a CDN). This technique makes the UI and BFF have exactly the same origin, so the authentication cookie will be sent from the frontend to the BFF automatically, and third party cookie blocking and the SameSite cookie attribute won\u0026rsquo;t present any problems. The following diagram shows how that would work:\nSetting this up for local development takes a bit of effort however. As you make changes to the frontend, the UI\u0026rsquo;s build process might generate a change to the index page. If it does, you\u0026rsquo;ll need to arrange for the index page being served by the BFF host to reflect that change.\nAdditionally, the front end will need to be configurable so that it is able to load its assets from other hosts. The mechanism for doing so will vary depending on the technology used to build the frontend. For instance, Angular includes a number of deployment options that allow you to control where it expects to find assets.\nThe added complexity of this technique is justified when there is a requirement to host the front end on a different site (typically a CDN) from the BFF.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/architecture/third-party-cookies/",
    "title": "Third Party Cookies",
    "tags": [],
    "description": "",
    "content": "If the BFF and OpenID Connect Provider (OP) are hosted on different sites, then some browsers will block cookies from being sent during navigation between those sites. Almost all browsers have the option of blocking third party cookies. Safari and Firefox are the most widely used browsers that do so by default, while Chrome is planning to do so in the future. This change is being made to protect user privacy, but it also impacts OIDC flows traditionally used by SPAs.\nA couple of particularly notable OIDC flows that don\u0026rsquo;t work for SPAs when third party cookies are blocked are OIDC Session Management and OIDC Silent Login via the prompt=none parameter.\nSession Management OIDC Session Management allows a client SPA to monitor the session at the OP by reading a cookie from the OP in a hidden iframe. If third party cookie blocking prevents the iframe from seeing that cookie, the SPA will not be able to monitor the session. The BFF solves this problem using OIDC back-channel logout.\nThe BFF is able to operate server side, and is therefore able to have a back channel to the OP. When the session ends at the OP, it can send a back-channel message to the BFF, ending the session at the BFF.\nSilent Login OIDC Silent Login allows a client application to start its session without needing any user interaction if the OP has an ongoing session. The main benefit is that a SPA can load in the browser and then start a session without navigating away from the SPA for an OIDC flow, preventing the need to reload the SPA.\nSimilarly to OIDC Session Management, OIDC Silent Login relies on a hidden iframe, though in this case, the hidden iframe makes requests to the OP, passing the prompt=none parameter to indicate that user interaction isn\u0026rsquo;t sensible. If that request includes the OP\u0026rsquo;s session cookie, the OP can respond successfully and the application can obtain tokens. But if the request does not include a session - either because no session has been started or because the cookie has been blocked - then the silent login will fail, and the user will have to be redirected to the OP for an interactive login.\nBFF with a Federation Gateway The BFF supports silent login from the SPA with the /bff/silent-login endpoint. This endpoint is intended to be invoked in an iframe and issues a challenge to login non-interactively with prompt=none. Just as in a traditional SPA, this technique will be disrupted by third party cookie blocking when the BFF and OP are third parties.\nIf you need silent login with a third party OP, we recommend that you use the Federation Gateway pattern. In the federation gateway pattern, one identity provider (the gateway) federates with other remote identity providers. Because the client applications only interact with the gateway, the implementation details of the remote identity providers are abstracted. In this case, we shield the client application from the fact that the remote identity provider is a third party by hosting the gateway as a first party to the client. This makes the client application\u0026rsquo;s requests for silent login always first party.\nAlternatives Alternatively, you can accomplish a similar goal (logging in without needing to initially load the SPA, only to redirect away from it) by detecting that the user is not authenticated in the BFF and issuing a challenge before the site is ever loaded. This approach is not typically our first recommendation, because it makes allowing anonymous access to parts of the UI difficult and because it requires samesite=lax cookies (see below).\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/extensibility/management/silent-login/",
    "title": "BFF Silent Login Endpoint Extensibility",
    "tags": [],
    "description": "",
    "content": "The BFF silent login endpoint can be customized by implementing the ISilentLoginService or by extending DefaultSilentLoginService, its default implementation.\nRequest Processing ProcessRequestAsync is the top level function called in the endpoint service and can be used to add arbitrary logic to the endpoint.\nFor example, you could take whatever actions you need before normal processing of the request like this:\npublic override Task ProcessRequestAsync(HttpContext context) { // Custom logic here return base.ProcessRequestAsync(context); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/fundamentals/session/management/",
    "title": "BFF Session Management Endpoints",
    "tags": [],
    "description": "",
    "content": "Duende.BFF adds endpoints for performing typical session-management operations such as triggering login and logout and getting information about the currently logged-on user. These endpoint are meant to be called by the frontend.\nIn addition Duende.BFF adds an implementation of the OpenID Connect back-channel notification endpoint to overcome the restrictions of third party cookies in front-channel notification in modern browsers.\nYou enable the endpoints by adding the relevant services into the DI container:\n// Add BFF services to DI - also add server-side session management builder.Services.AddBff(options =\u0026gt; { // default value options.ManagementBasePath = \u0026#34;/bff\u0026#34;; }; The management endpoints need to be mapped:\napp.MapBffManagementEndpoints(); MapBffManagementEndpoints adds all BFF management endpoints. You can also map each endpoint individually by calling the various MapBffManagementXxxEndpoint methods, for example endpoints.MapBffManagementLoginEndpoint().\nThe following pages describe the default behavior of the management endpoints. See the extensibility section for information about how to customize the behavior of the endpoints.\nBFF Login Endpoint BFF User Endpoint BFF Logout Endpoint BFF Silent Login Endpoint BFF Diagnostics Endpoint BFF Back-Channel Logout Endpoint "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/fundamentals/session/management/login/",
    "title": "BFF Login Endpoint",
    "tags": [],
    "description": "",
    "content": "The /bff/login endpoint begins the authentication process. To use it, typically javascript code will navigate away from the frontend application to the login endpoint:\nwindow.location = \u0026#34;/login\u0026#34;; In Blazor, instead use the NavigationManager to navigate to the login endpoint:\nNavigation.NavigateTo($\u0026#34;bff/login\u0026#34;, forceLoad: true); The login endpoint triggers an authentication challenge using the default challenge scheme, which will typically use the OpenID Connect handler.\nReturn Url After authentication is complete, the login endpoint will redirect back to your front end application. By default, this redirect goes to the root of the application. You can use a different URL instead by including a local URL as the returnUrl query parameter.\nwindow.location = \u0026#34;/login?returnUrl=/logged-in\u0026#34;; "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/extensibility/sessions/",
    "title": "Session Management",
    "tags": [],
    "description": "BFF Extensibility",
    "content": "User Session Store If using the server-side sessions feature, you will need to have a store for the session data. An Entity Framework Core based implementation of this store is provided. If you wish to use some other type of store, then you can implement the IUserSessionStore interface:\n/// \u0026lt;summary\u0026gt; /// User session store /// \u0026lt;/summary\u0026gt; public interface IUserSessionStore { /// \u0026lt;summary\u0026gt; /// Retrieves a user session /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;cancellationToken\u0026#34;\u0026gt;A token that can be used to request cancellation of the asynchronous operation.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task\u0026lt;UserSession?\u0026gt; GetUserSessionAsync(string key, CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// Creates a user session /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;session\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;cancellationToken\u0026#34;\u0026gt;A token that can be used to request cancellation of the asynchronous operation.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task CreateUserSessionAsync(UserSession session, CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// Updates a user session /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;session\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;cancellationToken\u0026#34;\u0026gt;A token that can be used to request cancellation of the asynchronous operation.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task UpdateUserSessionAsync(string key, UserSessionUpdate session, CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// Deletes a user session /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;cancellationToken\u0026#34;\u0026gt;A token that can be used to request cancellation of the asynchronous operation.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task DeleteUserSessionAsync(string key, CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// Queries user sessions based on the filter. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;filter\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;cancellationToken\u0026#34;\u0026gt;A token that can be used to request cancellation of the asynchronous operation.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task\u0026lt;IReadOnlyCollection\u0026lt;UserSession\u0026gt;\u0026gt; GetUserSessionsAsync(UserSessionsFilter filter, CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// Deletes user sessions based on the filter. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;filter\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;cancellationToken\u0026#34;\u0026gt;A token that can be used to request cancellation of the asynchronous operation.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task DeleteUserSessionsAsync(UserSessionsFilter filter, CancellationToken cancellationToken = default); } Once you have an implementation, you can register it when you enable server-side sessions:\nbuilder.Services.AddBff() .AddServerSideSessions\u0026lt;YourStoreClassName\u0026gt;(); User Session Store Cleanup The IUserSessionStoreCleanup interface is used to model cleaning up expired sessions.\n/// \u0026lt;summary\u0026gt; /// User session store cleanup /// \u0026lt;/summary\u0026gt; public interface IUserSessionStoreCleanup { /// \u0026lt;summary\u0026gt; /// Deletes expired sessions /// \u0026lt;/summary\u0026gt; Task DeleteExpiredSessionsAsync(CancellationToken cancellationToken = default); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/fundamentals/session/",
    "title": "Authentication &amp; Session Management",
    "tags": [],
    "description": "",
    "content": "Authentication \u0026amp; Session Management This section deals with setting up the following components\nthe ASP.NET Core authentication system the OpenID Connect handler the cookie handler the BFF session management endpoints server-side sessions back-channel logout support "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/fundamentals/apis/remote/",
    "title": "Remote APIs",
    "tags": [],
    "description": "",
    "content": "A Remote API is an API that is deployed separately from the BFF host. Remote APIs use access tokens to authenticate and authorize requests, but the frontend does not possess an access token to make requests to remote APIs directly. Instead, all access to remote APIs is proxied through the BFF, which authenticates the frontend using its authentication cookie, obtains the appropriate access token, and forwards the request to the Remote API with the token attached.\nThere are two different ways to set up Remote API proxying in Duende.BFF. This page describes the built-in simple HTTP forwarder. Alternatively, you can integrate Duende.BFF with Microsoft\u0026rsquo;s reverse proxy YARP, which allows for more complex reverse proxy features provided by YARP combined with the security and identity features of Duende.BFF.\nSimple HTTP forwarder Duende.BFF\u0026rsquo;s simple HTTP forwarder maps routes in the BFF to a remote API surface. It uses Microsoft YARP internally, but is much simpler to configure than YARP. The intent is to provide a developer-centric and simplified way to proxy requests from the BFF to remote APIs when more complex reverse proxy features are not needed.\nThese routes receive automatic anti-forgery protection and integrate with automatic token management.\nTo enable this feature, add a reference to the Duende.BFF.Yarp NuGet package, add the remote APIs service to DI, and call the MapRemoteBFFApiEndpoint method to create the mappings.\nAdd Remote API Service to DI builder.Services.AddBff() .AddRemoteApis(); Map Remote APIs Use the MapRemoteBffApiEndpoint extension method to describe how to map requests coming into the BFF out to remote APIs and the RequireAccessToken method to specify token requirements. MapRemoteBffApiEndpoint takes two parameters: the base path of requests that will be mapped externally, and the address to the external API where the requests will be mapped. MapRemoteBffApiEndpoint maps a path and all sub-paths below it. The intent is to allow easy mapping of groups of URLs. For example, you can set up mappings for the /users, /users/{userId}, /users/{userId}/books, and /users/{userId}/books/{bookId} endpoints like this:\napp.MapRemoteBffApiEndpoint(\u0026#34;/API/users\u0026#34;, \u0026#34;https://remoteHost/users\u0026#34;) .RequireAccessToken(TokenType.User); This example opens up the complete /users API namespace to the frontend and thus to the outside world. Try to be as specific as possible when designing the forwarding paths.\nSecuring Remote APIs Remote APIs typically require access control and must be protected against threats such as CSRF (Cross-Site Request Forgery) attacks.\nTo provide access control, you can specify authorization policies on the mapped routes, and configure them with access token requirements.\nTo defend against CSRF attacks, you should use SameSite cookies to authenticate calls from the frontend to the BFF. As an additional layer of defense, APIs mapped with MapRemoteBffApiEndpoint are automatically protected with an anti-forgery header.\nSameSite cookies The SameSite cookie attribute is a feature of modern browsers that restricts cookies so that they are only sent to pages originating from the site where the cookie was originally issued. This prevents CSRF attacks, because cross site requests will no longer implicitly include the user\u0026rsquo;s credentials.\nThis is a good first layer of defense, but makes the assumption that you can trust all subdomains of your site. All subdomains within a registrable domain are considered the same site for purposes of SameSite cookies. Thus, if another application hosted on a subdomain within your site is infected with malware, it can make CSRF attacks against your application.\nAnti-forgery header For this reason, remote APIs automatically require an additional custom header on API endpoints. For example:\nGET /endpoint x-csrf: 1 The value of the header is not important, but its presence, combined with the cookie requirement, triggers a CORS preflight request for cross-origin calls. This effectively isolates the caller to the same origin as the backend, providing a robust security guarantee.\nRequire authorization The MapRemoteBffApiEndpoint method returns the appropriate type to integrate with the ASP.NET Core authorization system. You can attach authorization policies to remote endpoints using RequireAuthorization, just as you would for a standard ASP.NET core endpoint created with MapGet, and the authorization middleware will then enforce that policy before forwarding requests on that route to the remote endpoint.\nAccess token requirements Remote APIs sometimes allow anonymous access, but usually require an access token, and the type of access token (user or client) will vary as well. You can specify access token requirements via the RequireAccessToken extension method. Its TokenType parameter has three options:\nUser\nA valid user access token is required and will be forwarded to the remote API. A user access token is an access token obtained during an OIDC flow (or subsequent refresh), and is associated with a particular user. User tokens are obtained when the user initially logs in, and will be automatically refreshed using a refresh token when they expire.\nClient\nA valid client access token is required and will be forwarded to the remote API. A client access token is an access token obtained through the client credentials flow, and is associated with the client application, not any particular user. Client tokens can be obtained even if the user is not logged in.\nUserOrClient\nEither a valid user access token or a valid client access token (as fallback) is required and will be forwarded to the remote API.\nYou can also use the WithOptionalUserAccessToken extension method to specify that the API should be called with a user access token if one is available and anonymously if not.\nThese settings only specify the logic that is applied before the API call gets proxied. The remote APIs you are calling should always specify their own authorization and token requirements.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/fundamentals/session/management/user/",
    "title": "BFF User Endpoint",
    "tags": [],
    "description": "",
    "content": "The /bff/user endpoint returns data about the currently logged-on user and the session. It is typically invoked at application startup to check if the user has authenticated, and if so, to get profile data about the user. It can also be used to periodically query if the session is still valid.\nOutput If there is no current session, the user endpoint returns a response indicating that the user is anonymous. By default, this is a 401 status code, but this can be configured.\nIf there is a current session, the user endpoint returns a JSON array containing the claims in the ASP.NET Core authentication session as well as several BFF specific claims. For example:\n[ { \u0026#34;type\u0026#34;: \u0026#34;sid\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;173E788068FFB728806501F4F46C52D6\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;sub\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;88421113\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;idp\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;local\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Bob Smith\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;bff:logout_url\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;/logout?sid=173E788068FFB728806501F4F46C52D6\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;bff:session_expires_in\u0026#34;, \u0026#34;value\u0026#34;: 28799 }, { \u0026#34;type\u0026#34;: \u0026#34;bff:session_state\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;q-Hl1V9a7FCZE5o-vH9qpmyVKOaeVfMQBUJLrq-lDJU.013E58C33C7409C6011011B8291EF78A\u0026#34; } ] User Claims Since the user endpoint returns the claims that are in the ASP.NET Core session, anything that changes the session will be reflected in its output. You can customize the contents of the session via the OpenID Connect handler\u0026rsquo;s ClaimAction infrastructure, or by using claims transformation. For example, if you add a claim to the userinfo endpoint at IdentityServer that you would like to include in the /bff/user endpoint, you need to add a corresponding ClaimAction in the BFF\u0026rsquo;s OpenID Connect Handler to include the claim in the BFF\u0026rsquo;s session.\nManagement Claims In addition to the claims in the ASP.NET Core Session, Duende.BFF adds three additional claims:\nbff:session_expires_in\nThis is the number of seconds the current session will be valid for.\nbff:session_state\nThis is the session state value of the upstream OIDC provider that can be use for the JavaScript check_session mechanism (if provided).\nbff:logout_url\nThis is the URL to trigger logout. If the upstream provider includes a sid claim, the BFF logout endpoint requires this value as a query string parameter for CSRF protection. This behavior can be configured with the RequireLogoutSessionId in the options.\nTypical Usage To use the endpoint, make an http GET request to it from your frontend javascript code. For example, your application could use the fetch API to make requests to the user endpoint like this:\nvar req = new Request(\u0026#34;/user\u0026#34;, { headers: new Headers({ \u0026#34;X-CSRF\u0026#34;: \u0026#34;1\u0026#34;, }), }); var resp = await fetch(req); if (resp.ok) { userClaims = await resp.json(); console.log(\u0026#34;user logged in\u0026#34;, userClaims); } else if (resp.status === 401) { console.log(\u0026#34;user not logged in\u0026#34;); } Cross-Site Request Forgery To protect against cross-site request forgery, you need to add a static header to the GET request. The header\u0026rsquo;s name and required value can be configured in the options.\nAnonymous Session Response Option The AnonymousSessionResponse option allows you to change the behavior of the user endpoint to return 200 instead of 401 when the user is anonymous. If AnonymousSessionResponse is set to AnonymousSessionResponse.Response200, then the endpoint\u0026rsquo;s response will set its status code to 200 and its payload will contain the literal null (the response body will be the characters \u0026rsquo;n\u0026rsquo;, \u0026lsquo;u\u0026rsquo;, \u0026rsquo;l\u0026rsquo;, \u0026rsquo;l\u0026rsquo; without quotes).\nCookie Sliding If your ASP.NET Core session cookie is configured to use a sliding expiration, you need to be able to query the session state without extending the session\u0026rsquo;s lifetime; a periodic check for user activity shouldn\u0026rsquo;t itself count as user activity. To prevent the call to the user endpoint from sliding the cookie, add the slide=false parameter to the request.\nvar req = new Request(\u0026#34;/user?slide=false\u0026#34;, { headers: new Headers({ \u0026#34;X-CSRF\u0026#34;: \u0026#34;1\u0026#34;, }), }); The cookie sliding prevention feature requires either usage of server-side sessions or .NET 6 or higher (or both).\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/upgrading/bff_v2_to_v3/",
    "title": "Duende BFF Security Framework v2.x to v3.0",
    "tags": [],
    "description": "",
    "content": "What\u0026rsquo;s New Duende BFF Security Framework v3.0 is a significant release that includes:\n.NET 9 support Blazor support Several fixes and improvements Upgrading If you rely on the default extension methods for wiring up the BFF, then V3 should be a drop-in replacement.\nMigrating from custom implementations of IHttpMessageInvokerFactory In Duende.BFF V2, there was an interface called IHttpMessageInvokerFactory. This class was responsible for creating and wiring up yarp\u0026rsquo;s HttpMessageInvoker. This interface has been removed in favor yarp\u0026rsquo;s IForwarderHttpClientFactory.\nOne common scenario for creating a custom implementation of this class was for mocking the http client during unit testing.\nIf you wish to inject a http handler for unit testing, you should now inject a custom IForwarderHttpClientFactory. For example:\n// A Forwarder factory that forwards the messages to a message handler (which can be easily retrieved from a testhost) public class BackChannelHttpMessageInvokerFactory(HttpMessageHandler backChannel) : IForwarderHttpClientFactory { public HttpMessageInvoker CreateClient(ForwarderHttpClientContext context) =\u0026gt; new HttpMessageInvoker(backChannel); } // Wire up the forwarder in your application\u0026#39;s test host: services.AddSingleton\u0026lt;IForwarderHttpClientFactory\u0026gt;( new BackChannelHttpMessageInvokerFactory(_apiHost.Server.CreateHandler())); Migrating from custom implementations IHttpTransformerFactory The IHttpTransformerFactory was a way to globally configure the YARP tranform pipeline. In V3, the way that the default endpoints.MapRemoteBffApiEndpoint() method builds up the YARP transform has been simplified significantly. Most of the logic has been pushed down to the AccessTokenRequestTransform.\nHere are common scenario\u0026rsquo;s for implementing your own IHttpTransformerFactory and how to upgrade:\nReplacing defaults\nIf you used a custom implementation of IHttpTransformerFactory to change the default behavior of MapRemoteBffApiEndpoint(), for example to add additional transforms, then you can now inject a custom delegate into the di container:\nservices.AddSingleton\u0026lt;BffYarpTransformBuilder\u0026gt;(CustomDefaultYarpTransforms); //... // This is an example of how to add a response header to ALL invocations of MapRemoteBffApiEndpoint() private void CustomDefaultBffTransformBuilder(string localpath, TransformBuilderContext context) { context.AddResponseHeader(\u0026#34;added-by-custom-default-transform\u0026#34;, \u0026#34;some-value\u0026#34;); DefaultBffYarpTransformerBuilders.DirectProxyWithAccessToken(localpath, context); } Another way of doing this is to create a custom extensionmethod MyCustomMapRemoteBffApiEndpoint() that wraps the MapRemoteBffApiEndpoint() and use that everywhere in your application. This is a great way to add other defaults that should apply to all endpoints, such as requiring a specific type of access token.\nConfiguring transforms for a single route Another common usecase for overriding the IHttpTransformerFactory was to have a custom transform for a single route, by applying a switch statement and testing for specific routes.\nNow, there is an overload on the endpoints.MapRemoteBffApiEndpoint() that allows you to configure the pipeline directly:\nendpoints.MapRemoteBffApiEndpoint( \u0026#34;/local-path\u0026#34;, _apiHost.Url(), context =\u0026gt; { // do something custom: IE: copy request headers context.CopyRequestHeaders = true; // wire up the default transformer logic DefaultTransformers.DirectProxyWithAccessToken(\u0026#34;/local-path\u0026#34;, context); }) // Continue with normal BFF configuration, for example, allowing optional user access tokens .WithOptionalUserAccessToken(); Removed method RemoteApiEndpoint.Map(localpath, apiAddress). The Map method was no longer needed as most of the logic had been moved to either the MapRemoteBffApiEndpoint and the DefaultTransformers. The map method also wasn\u0026rsquo;t very explicit about what it did and a number of test scenario\u0026rsquo;s tried to verify if it wasn\u0026rsquo;t called wrongly. You are now expected to call the method MapRemoteBffApiEndpoint. This method now has a nullable parameter that allows you to inject your own transformers.\nAccessTokenRetrievalContext properties are now typed The LocalPath and ApiAddress properties are now typed. They used to be strings. If you rely on these, for example for implementing a custom IAccessTokenRetriever, then you should adjust their usage accordingly.\n/// \u0026lt;summary\u0026gt; /// The locally requested path. /// \u0026lt;/summary\u0026gt; public required PathString LocalPath { get; set; } /// \u0026lt;summary\u0026gt; /// The remote address of the API. /// \u0026lt;/summary\u0026gt; public required Uri ApiAddress { get; set; } AddAddEntityFrameworkServerSideSessionsServices has been renamed to AddEntityFrameworkServerSideSessionsServices If you used the method AddAddEntityFrameworkServerSideSessionsServices() in your code, please replace it with the corrected AddEntityFrameworkServerSideSessionsServices()\nStateProviderPollingDelay and StateProviderPollingInterval have been split into separate options for WebAssembly and Server. If you used BffBlazorOptions.StateProviderPollingInterval or BffBlazorOptions.StateProviderPollingDelay to configure different polling settings, you should now consider if this same setting applies to either Server, WASM or both. Set the appropriate properties accordingly.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/extensibility/management/silent-login-callback/",
    "title": "BFF Silent Login Callback Extensibility",
    "tags": [],
    "description": "",
    "content": "The BFF silent login callback endpoint can be customized by implementing the ISilentLoginCallbackService or by extending DefaultSilentLoginCallbackService, its default implementation.\nRequest Processing ProcessRequestAsync is the top level function called in the endpoint service and can be used to add arbitrary logic to the endpoint.\nFor example, you could take whatever actions you need before normal processing of the request like this:\npublic override Task ProcessRequestAsync(HttpContext context) { // Custom logic here return base.ProcessRequestAsync(context); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/fundamentals/session/management/logout/",
    "title": "BFF Logout Endpoint",
    "tags": [],
    "description": "",
    "content": "The /bff/logout endpoint signs out of the appropriate ASP.NET Core authentication schemes to both delete the BFF\u0026rsquo;s session cookie and to sign out from the remote identity provider. To use the logout endpoint, typically your javascript code will navigate away from your front end to the logout endpoint, similar to the login endpoint. However, unlike the login endpoint, the logout endpoint requires CSRF protection, otherwise an attacker could destroy sessions by making cross-site GET requests. The session id is used to provide this CSRF protection by requiring it as a query parameter to the logout endpoint (assuming that a session id was included during login). For convenience, the correct logout url is made available as a claim in the /bff/user endpoint, making typical logout usage look like this:\nvar logoutUrl = userClaims[\u0026#34;bff:logout_url\u0026#34;]; // assumes userClaims is the result of a call to /bff/user window.location = logoutUrl; Return Url After signout is complete, the logout endpoint will redirect back to your front end application. By default, this redirect goes to the root of the application. You can use a different URL instead by including a local URL as the returnUrl query parameter.\nvar logoutUrl = userClaims[\u0026#34;bff:logout_url\u0026#34;]; window.location = `${logoutUrl}\u0026amp;returnUrl=/logged-out`; Revocation of Refresh Tokens If the user has a refresh token, the logout endpoint can revoke it. This is enabled by default because revoking refresh tokens that will not be used any more is generally good practice. Normally any refresh tokens associated with the current session won\u0026rsquo;t be used after logout, as the session where they are stored is deleted as part of logout. However, you can disable this revocation with the RevokeRefreshTokenOnLogout option.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/extensibility/tokens/",
    "title": "Token Management",
    "tags": [],
    "description": "BFF - Customization",
    "content": "The token management library does essentially two things:\nstores access and refresh tokens in the current session refreshes access tokens automatically at the token service when needed Both aspects can be customized.\nToken service communication The token management library uses a named HTTP client from the HTTP client factory for all token service communication. You can provide a customized HTTP client yourself using the well-known name after calling AddBff:\nbuilder.Services.AddHttpClient(AccessTokenManagementDefaults.BackChannelHttpClientName, configureClient =\u0026gt; { ... }); You can also supply client assertions to the token management library. See this sample for JWT-based client authentication.\nCustom token storage We recommend that you use the default storage mechanism, as this will automatically be compatible with the Duende.BFF server-side sessions.\nIf you do not use server-side sessions, then the access and refresh token will be stored in the protected session cookie. If you want to change this, you can take over token storage completely.\nThis would involve two steps\nturn off the SaveTokens flag on the OpenID Connect handler and handle the relevant events manually to store the tokens in your custom store implement and register the Duende.AccessTokenManagement.IUserTokenStore interface The interface is responsible to storing, retrieving and clearing tokens for the automatic token management:\npublic interface IUserTokenStore { /// \u0026lt;summary\u0026gt; /// Stores tokens /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;user\u0026#34;\u0026gt;User the tokens belong to\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;token\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;parameters\u0026#34;\u0026gt;Extra optional parameters\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task StoreTokenAsync( ClaimsPrincipal user, UserToken token, UserTokenRequestParameters? parameters = null); /// \u0026lt;summary\u0026gt; /// Retrieves tokens from store /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;user\u0026#34;\u0026gt;User the tokens belong to\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;parameters\u0026#34;\u0026gt;Extra optional parameters\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;access and refresh token and access token expiration\u0026lt;/returns\u0026gt; Task\u0026lt;UserToken\u0026gt; GetTokenAsync( ClaimsPrincipal user, UserTokenRequestParameters? parameters = null); /// \u0026lt;summary\u0026gt; /// Clears the stored tokens for a given user /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;user\u0026#34;\u0026gt;User the tokens belong to\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;parameters\u0026#34;\u0026gt;Extra optional parameters\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task ClearTokenAsync( ClaimsPrincipal user, UserTokenRequestParameters? parameters = null); } Per-route customized token retrieval The token store defines how tokens are retrieved globally. However, you can add custom logic that changes the way that access tokens are retrieved on a per-route basis. For example, you might need to exchange a token to perform delegation or impersonation for some API calls, depending on the remote API. The interface that describes this extension point is the IAccessTokenRetriever.\n/// \u0026lt;summary\u0026gt; /// Retrieves access tokens /// \u0026lt;/summary\u0026gt; public interface IAccessTokenRetriever { /// \u0026lt;summary\u0026gt; /// Asynchronously gets the access token. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;context\u0026#34;\u0026gt;Context used to retrieve the token.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;A task that contains the access token result, which is an /// object model that can represent various types of tokens (bearer, dpop), /// the absence of an optional token, or an error. \u0026lt;/returns\u0026gt; Task\u0026lt;AccessTokenResult\u0026gt; GetAccessToken(AccessTokenRetrievalContext context); } You can implement this interface yourself or extend the DefaultAccessTokenRetriever. The AccessTokenResult class represents the result of this operation. It is an abstract class with concrete implementations that represent successfully retrieving a bearer token (BearerTokenResult), successfully retrieving a DPoP token (DPoPTokenResult), failing to find an optional token (NoAccessTokenResult), which is not an error, and failure to retrieve a token (AccessTokenRetrievalError). Your implementation of GetAccessToken should return one of those types.\nImplementations of the IAccessTokenRetriever can be added to endpoints when they are mapped using the WithAccessTokenRetriever extension method:\napp.MapRemoteBffApiEndpoint(\u0026#34;/API/impersonation\u0026#34;, \u0026#34;https://API.example.com/endpoint/requiring/impersonation\u0026#34;) .RequireAccessToken(TokenType.User) .WithAccessTokenRetriever\u0026lt;ImpersonationAccessTokenRetriever\u0026gt;(); The GetAccessToken method will be invoked on every call to APIs that use the access token retriever. If retrieving the token is an expensive operation, you may need to cache it. It is up to your retriever code to perform caching.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/fundamentals/apis/yarp/",
    "title": "YARP extensions",
    "tags": [],
    "description": "",
    "content": "Duende.BFF integrates with Microsoft\u0026rsquo;s full-featured reverse proxy YARP.\nYARP includes many advanced features such as load balancing, service discovery, and session affinity. It also has its own extensibility mechanism. Duende.BFF includes YARP extensions for token management and anti-forgery protection so that you can combine the security and identity features of Duende.BFF with the flexible reverse proxy features of YARP.\nAdding YARP To enable Duende.BFF\u0026rsquo;s YARP integration, add a reference to the Duende.BFF.Yarp Nuget package to your project and add YARP and the BFF\u0026rsquo;s YARP extensions to DI:\nbuilder.Services.AddBff(); // adds YARP with BFF extensions var yarpBuilder = services.AddReverseProxy() .AddBffExtensions(); Configuring YARP YARP is most commonly configured by a config file. The following simple example forwards a local URL to a remote API:\n\u0026#34;ReverseProxy\u0026#34;: { \u0026#34;Routes\u0026#34;: { \u0026#34;todos\u0026#34;: { \u0026#34;ClusterId\u0026#34;: \u0026#34;cluster1\u0026#34;, \u0026#34;Match\u0026#34;: { \u0026#34;Path\u0026#34;: \u0026#34;/todos/{**catch-all}\u0026#34;, } } }, \u0026#34;Clusters\u0026#34;: { \u0026#34;cluster1\u0026#34;: { \u0026#34;Destinations\u0026#34;: { \u0026#34;destination1\u0026#34;: { \u0026#34;Address\u0026#34;: \u0026#34;https://API.mycompany.com/todos\u0026#34; } } } } } See the Microsoft documentation for the complete configuration schema.\nAnother option is to configure YARP in code using the in-memory config provider included in the BFF extensions for YARP. The above configuration as code would look like this:\nyarpBuilder.LoadFromMemory( new[] { new RouteConfig() { RouteId = \u0026#34;todos\u0026#34;, ClusterId = \u0026#34;cluster1\u0026#34;, Match = new() { Path = \u0026#34;/todos/{**catch-all}\u0026#34; } } }, new[] { new ClusterConfig { ClusterId = \u0026#34;cluster1\u0026#34;, Destinations = new Dictionary\u0026lt;string, DestinationConfig\u0026gt;(StringComparer.OrdinalIgnoreCase) { { \u0026#34;destination1\u0026#34;, new() { Address = \u0026#34;https://API.mycompany.com/todos\u0026#34; } }, } } }); Token management Duende.BFF\u0026rsquo;s YARP extensions provide access token management and attach user or client access tokens automatically to proxied API calls. To enable this, add metadata with the name Duende.Bff.Yarp.TokenType to the route or cluster configuration:\n\u0026#34;ReverseProxy\u0026#34;: { \u0026#34;Routes\u0026#34;: { \u0026#34;todos\u0026#34;: { \u0026#34;ClusterId\u0026#34;: \u0026#34;cluster1\u0026#34;, \u0026#34;Match\u0026#34;: { \u0026#34;Path\u0026#34;: \u0026#34;/todos/{**catch-all}\u0026#34;, }, \u0026#34;Metadata\u0026#34;: { \u0026#34;Duende.Bff.Yarp.TokenType\u0026#34;: \u0026#34;User\u0026#34; } } }, // rest omitted } Similarly to the simple HTTP forwarder, the allowed values for the token type are User, Client, UserOrClient.\nRoutes that set the Duende.Bff.Yarp.TokenType metadata require the given type of access token. If it is unavailable (for example, if the User token type is specified but the request to the BFF is anonymous), then the proxied request will not be sent, and the BFF will return an HTTP 401: Unauthorized response.\nIf you are using the code config method, call the WithAccessToken extension method to achieve the same thing:\nyarpBuilder.LoadFromMemory( new[] { new RouteConfig() { RouteId = \u0026#34;todos\u0026#34;, ClusterId = \u0026#34;cluster1\u0026#34;, Match = new RouteMatch { Path = \u0026#34;/todos/{**catch-all}\u0026#34; } }.WithAccessToken(TokenType.User) }, // rest omitted ); Again, the WithAccessToken method causes the route to require the given type of access token. If it is unavailable, the proxied request will not be made and the BFF will return an HTTP 401: Unauthorized response.\nOptional User Access Tokens You can also attach user access tokens optionally by adding metadata named \u0026ldquo;Duende.Bff.Yarp.OptionalUserToken\u0026rdquo; to a YARP route.\n\u0026#34;ReverseProxy\u0026#34;: { \u0026#34;Routes\u0026#34;: { \u0026#34;todos\u0026#34;: { \u0026#34;ClusterId\u0026#34;: \u0026#34;cluster1\u0026#34;, \u0026#34;Match\u0026#34;: { \u0026#34;Path\u0026#34;: \u0026#34;/todos/{**catch-all}\u0026#34;, }, \u0026#34;Metadata\u0026#34;: { \u0026#34;Duende.Bff.Yarp.OptionalUserToken\u0026#34;: \u0026#34;true\u0026#34; } } }, // rest omitted } This metadata causes the user\u0026rsquo;s access token to be sent with the proxied request when the user is logged in, but makes the request anonymously when the user is not logged in. It is an error to set both Duende.Bff.Yarp.TokenType and Duende.Bff.Yarp.OptionalUserToken, since they have conflicting semantics (TokenType requires the token, OptionalUserToken makes it optional).\nIf you are using the code config method, call the WithOptionalUserAccessToken extension method to achieve the same thing:\nyarpBuilder.LoadFromMemory( new[] { new RouteConfig() { RouteId = \u0026#34;todos\u0026#34;, ClusterId = \u0026#34;cluster1\u0026#34;, Match = new RouteMatch { Path = \u0026#34;/todos/{**catch-all}\u0026#34; } }.WithOptionalUserAccessToken() }, // rest omitted ); Anti-forgery protection Duende.BFF\u0026rsquo;s YARP extensions can also add anti-forgery protection to proxied API calls. Anti-forgery protection defends against CSRF attacks by requiring a custom header on API endpoints, for example:\nGET /endpoint x-csrf: 1 The value of the header is not important, but its presence, combined with the cookie requirement, triggers a CORS preflight request for cross-origin calls. This effectively isolates the caller to the same origin as the backend, providing a robust security guarantee.\nYou can add the anti-forgery protection to all YARP routes by calling the AsBffApiEndpoint extension method:\napp.MapReverseProxy() .AsBffApiEndpoint(); // or shorter app.MapBffReverseProxy(); If you need more fine grained control over which routes should enforce the anti-forgery header, you can also annotate the route configuration by adding the Duende.Bff.Yarp.AntiforgeryCheck metadata to the route config:\n\u0026#34;ReverseProxy\u0026#34;: { \u0026#34;Routes\u0026#34;: { \u0026#34;todos\u0026#34;: { \u0026#34;ClusterId\u0026#34;: \u0026#34;cluster1\u0026#34;, \u0026#34;Match\u0026#34;: { \u0026#34;Path\u0026#34;: \u0026#34;/todos/{**catch-all}\u0026#34;, }, \u0026#34;Metadata\u0026#34;: { \u0026#34;Duende.Bff.Yarp.AntiforgeryCheck\u0026#34; : \u0026#34;true\u0026#34; } } }, // rest omitted } This is also possible in code:\nyarpBuilder.LoadFromMemory( new[] { new RouteConfig() { RouteId = \u0026#34;todos\u0026#34;, ClusterId = \u0026#34;cluster1\u0026#34;, Match = new RouteMatch { Path = \u0026#34;/todos/{**catch-all}\u0026#34; } }.WithAntiforgeryCheck() }, // rest omitted ); You can combine the token management feature with the anti-forgery check.\nTo enforce the presence of the anti-forgery headers, you need to add a middleware to the YARP pipeline:\napp.MapReverseProxy(proxyApp =\u0026gt; { proxyApp.UseAntiforgeryCheck(); }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/fundamentals/session/management/silent-login/",
    "title": "BFF Silent Login Endpoint",
    "tags": [],
    "description": "",
    "content": "Added in v1.2.0.\nThe /bff/silent-login endpoint triggers authentication similarly to the login endpoint, but in a non-interactive way.\nThe expected usage pattern is that the application code loads in the browser and triggers a request to the User Endpoint. If that indicates that there is no BFF session, then the Silent Login Endpoint can be requested to attempt to automatically log the user in, using an existing session at the remote identity provider.\nThis non-interactive design relies upon the use of an iframe to make the silent login request. The result of the silent login request in the iframe will then use postMessage to notify the parent window of the outcome. If the result is that a session has been established, then the application logic can either re-trigger a call to the User Endpoint, or simply reload the entire page (depending on the preferred design). If the result is that a session has not been established, then the application redirects to the login endpoint to log the user in interactively.\nTo trigger the silent login, the application code must have an iframe and then set its src to the silent login endpoint. For example in your HTML:\n\u0026lt;iframe id=\u0026#34;bff-silent-login\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; And then in JavaScript:\ndocument.querySelector(\u0026#39;#bff-silent-login\u0026#39;).src = \u0026#39;/bff/silent-login\u0026#39;; To receive the result, the application should handle the message event in the browser and look for the data.isLoggedIn property on the event object:\nwindow.addEventListener(\u0026#34;message\u0026#34;, e =\u0026gt; { if (e.data \u0026amp;\u0026amp; e.data.source === \u0026#39;bff-silent-login\u0026#39; \u0026amp;\u0026amp; e.data.isLoggedIn) { // we now have a user logged in silently, so reload this window window.location.reload(); } }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/extensibility/management/logout/",
    "title": "BFF Logout Endpoint Extensibility",
    "tags": [],
    "description": "",
    "content": "The BFF logout endpoint has extensibility points in two interfaces. The ILogoutService is the top level abstraction that processes requests to the endpoint. This service can be used to add custom request processing logic. The IReturnUrlValidator ensures that the returnUrl parameter passed to the logout endpoint is safe to use.\nRequest Processing ProcessRequestAsync is the top level function called in the endpoint service and can be used to add arbitrary logic to the endpoint.\nFor example, you could take whatever actions you need before normal processing of the request like this:\npublic override Task ProcessRequestAsync(HttpContext context) { // Custom logic here return base.ProcessRequestAsync(context); } Return URL Validation To prevent open redirector attacks, the returnUrl parameter to the logout endpoint must be validated. You can customize this validation by implementing the IReturnUrlValidator interface. The default implementation enforces that return urls are local.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/fundamentals/session/management/diagnostics/",
    "title": "BFF Diagnostics Endpoint",
    "tags": [],
    "description": "",
    "content": "The /bff/diagnostics endpoint returns the current user and client access token for testing purposes. The endpoint tries to retrieve and show current tokens. It may invoke both a refresh token flow for the user access token and a client credential flow for the client access token.\nTo use the diagnostics endpoint, make a GET request to /bff/diagnostics. Typically this is done in a browser to diagnose a problem during development.\nThis endpoint is only enabled in Development mode.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/extensibility/http_forwarder/",
    "title": "HTTP Forwarder",
    "tags": [],
    "description": "",
    "content": "You can customize the HTTP forwarder behavior in two ways\nprovide a customized HTTP client for outgoing calls provide custom request/response transformation Custom HTTP clients By default, Duende.BFF will create and cache an HTTP client per configured route or local path.\nThis invoker is setup like this:\nvar client = new HttpMessageInvoker(new SocketsHttpHandler { UseProxy = false, AllowAutoRedirect = false, AutomaticDecompression = DecompressionMethods.None, UseCookies = false }); If you want to customize the HTTP client for specific paths, you can either implement the IHttpMessageInvokerFactory interface or derive from the DefaultHttpMessageInvokerFactory, e.g.:\npublic class MyInvokerFactory : DefaultHttpMessageInvokerFactory { public override HttpMessageInvoker CreateClient(string localPath) { if (localPath == \u0026#34;/foo\u0026#34;) { return Clients.GetOrAdd(localPath, (key) =\u0026gt; { return new HttpMessageInvoker(new SocketsHttpHandler { // this API needs a proxy UseProxy = true, Proxy = new WebProxy(\u0026#34;https://myproxy\u0026#34;), AllowAutoRedirect = false, AutomaticDecompression = DecompressionMethods.None, UseCookies = false }); }); } return base.CreateClient(localPath); } } ..and override our registration:\nservices.AddSingleton\u0026lt;IHttpMessageInvokerFactory, MyInvokerFactory\u0026gt;(); Custom transformations In the standard configuration, BFF uses the YARP default behavior for forwarding HTTP requests. In addition we\nremove the sensitive session cookie add the current access token If you want to modify this behavior you can either implement IHttpTransformerFactory from scratch:\npublic interface IHttpTransformerFactory { /// \u0026lt;summary\u0026gt; /// Creates a HTTP transformer based on the local path /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;localPath\u0026#34;\u0026gt;Local path the remote API is mapped to\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;accessToken\u0026#34;\u0026gt;The access token to attach to the request (if present)\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; HttpTransformer CreateTransformer(string localPath, string accessToken = null); } \u0026hellip;or derive from the DefaultHttpTransformerFactory.\nThe transformations are based on YARP\u0026rsquo;s transform library and are extensible. See here for a full list of built-in transforms.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/fundamentals/apis/",
    "title": "API Endpoints",
    "tags": [],
    "description": "",
    "content": "Securing and Accessing API Endpoints A frontend application using the BFF pattern can call two types of APIs:\nRemote APIs These APIs are deployed on a different host than the BFF, which allows them to be shared between multiple frontends or (more generally speaking) multiple clients. These APIs can only be called via the BFF host acting as a proxy.\nLocal APIs These APIs only exist to support the specific frontend; they are not shared with other frontends or services. They are located in the BFF host and can be called directly by the frontend.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/fundamentals/session/server_side_sessions/",
    "title": "Server-side Sessions",
    "tags": [],
    "description": "BFF",
    "content": "By default, ASP.NET Core\u0026rsquo;s cookie handler will store all user session data in a protected cookie. This works very well unless cookie size or revocation becomes an issue.\nDuende.BFF includes all the plumbing to store your sessions server-side. The cookie will then only be used to transmit the session ID between the browser and the BFF host. This has the following advantages\nthe cookie size will be very small and constant - regardless how much data (e.g. token or claims) is stored in the authentication session the session can be also revoked outside the context of a browser interaction, for example when receiving a back-channel logout notification from the upstream OpenID Connect provider Configuring Server-side Sessions Server-side sessions can be enabled in the application\u0026rsquo;s startup:\nbuilder.Services.AddBff() .AddServerSideSessions(); The default implementation stores the session in-memory. This is useful for testing, but for production you typically want a more robust storage mechanism. We provide an implementation of the session store built with EntityFramework (EF) that can be used with any database with an EF provider (e.g. Microsoft SQL Server). You can also use a custom store. See extensibility for more information.\nUsing Entity Framework for the Server-side Session Store To use the EF session store, install the Duende.BFF.EntityFramework NuGet package and register it by calling AddEntityFrameworkServerSideSessions, like this:\nvar cn = _configuration.GetConnectionString(\u0026#34;db\u0026#34;); builder.Services.AddBff() .AddEntityFrameworkServerSideSessions(options=\u0026gt; { options.UseSqlServer(cn); }); Entity Framework Migrations Most datastores that you might use with Entity Framework use a schema to define the structure of their data. Duende.BFF.EntityFramework doesn\u0026rsquo;t make any assumptions about the underlying datastore, how (or indeed even if) it defines its schema, or how schema changes are managed by your organization. For these reasons, Duende does not directly support database creation, schema changes, or data migration by publishing database scripts. You are expected to manage your database in the way your organization sees fit. Using EF migrations is one possible approach to that, which Duende facilitates by publishing entity classes in each version of Duende.BFF.EntityFramework. An example project that uses those entities to create migrations is here.\nSession Store Cleanup Added in v1.2.0.\nAbandoned sessions will remain in the store unless something removes the stale entries. If you wish to have such sessions cleaned up periodically, then you can configure the EnableSessionCleanup and SessionCleanupInterval options:\nbuilder.Services.AddBff(options =\u0026gt; { options.EnableSessionCleanup = true; options.SessionCleanupInterval = TimeSpan.FromMinutes(5); }) .AddServerSideSessions(); This requires an implementation of IUserSessionStoreCleanup in the DI system.\nIf using Entity Framework Core, then the IUserSessionStoreCleanup implementation is provided for you when you use AddEntityFrameworkServerSideSessions. Just enable session cleanup:\nvar cn = _configuration.GetConnectionString(\u0026#34;db\u0026#34;); builder.Services.AddBff(options =\u0026gt; { options.EnableSessionCleanup = true; }) .AddEntityFrameworkServerSideSessions(options=\u0026gt; { options.UseSqlServer(cn); }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/extensibility/management/user/",
    "title": "BFF User Endpoint Extensibility",
    "tags": [],
    "description": "",
    "content": "The BFF user endpoint can be customized by implementing the IUserService or by extending DefaultUserService, its default implementation. In most cases, extending the default implementation is preferred, as it has several virtual methods that can be overridden to customize particular aspects of how the request is processed. The DefaultUserService\u0026rsquo;s virtual methods are ProcessRequestAsync, GetUserClaims, and GetManagementClaims.\nRequest Processing ProcessRequestAsync is the top level function called in the endpoint service and can be used to add arbitrary logic to the endpoint.\nFor example, you could take whatever actions you need before normal processing of the request like this:\npublic override Task ProcessRequestAsync(HttpContext context) { // Custom logic here return base.ProcessRequestAsync(context); } User Claims GetUserClaims produces the collection of claims that describe the user. The default implementation returns all the claims in the user\u0026rsquo;s session. Your override could add claims from some other source or manipulate the claims in arbitrary ways.\nFor example, you could add additional claims to the user endpoint that would not be part of the session like this:\nprotected override IEnumerable\u0026lt;ClaimRecord\u0026gt; GetUserClaims(AuthenticateResult authenticateResult) { var baseClaims = base.GetUserClaims(authenticateResult); var sub = authenticateResult.Principal.FindFirstValue(\u0026#34;sub\u0026#34;); var otherClaims = getAdditionalClaims(sub); // Retrieve claims from some data store return baseClaims.Append(otherClaims); } Management Claims GetManagementClaims is responsible for producing additional claims that are useful for user management. The default implementation creates bff:session_expires_in, bff:session_state, and bff:logout_url claims. Your implementation could change those claims or add additional custom claims.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/fundamentals/session/management/back-channel-logout/",
    "title": "BFF Back-Channel Logout Endpoint",
    "tags": [],
    "description": "",
    "content": "The /bff/backchannel endpoint is an implementation of the OpenID Connect Back-Channel Logout specification. The remote identity provider can use this endpoint to end the BFF\u0026rsquo;s session via a server to server call, without involving the user\u0026rsquo;s browser. This design avoids problems with 3rd party cookies associated with front-channel logout.\nTypical Usage The back-channel logout endpoint is invoked by the remote identity provider when it determines that sessions should be ended. IdentityServer will send back-channel logout requests if you configure your client\u0026rsquo;s BackChannelLogoutUri. When a session ends at IdentityServer, any client that was participating in that session that has a back-channel logout URI configured will be sent a back-channel logout request. This typically happens when another application signs out. Expiration of IdentityServer server side sessions can also be configured to send back-channel logout requests, though this is disabled by default.\nDependencies The back-channel logout endpoint depends on server-side sessions in the BFF, which must be enabled to use this endpoint. Note that such server-side sessions are distinct from server-side sessions in IdentityServer.\nRevoke all sessions Back-channel logout tokens include a sub (subject ID) and sid (session ID) claim to describe which session should be revoked. By default, the back-channel logout endpoint will only revoke the specific session for the given subject ID and session ID. Alternatively, you can configure the endpoint to revoke every session that belongs to the given subject ID by setting the BackchannelLogoutAllUserSessions option to true.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/fundamentals/tokens/",
    "title": "Token Management",
    "tags": [],
    "description": "BFF - Overview",
    "content": "Duende.BFF includes an automatic token management feature. This uses the access and refresh token stored in the authentication session to always provide a current access token for outgoing API calls.\nFor most scenarios, there is no additional configuration necessary. The token management will infer the configuration and token endpoint URL from the metadata of the OpenID Connect provider.\nThe easiest way to retrieve the current access token is to use an extension method on HttpContext:\nvar token = await HttpContext.GetUserAccessTokenAsync(); You can then use the token to set it on an HttpClient instance:\nvar client = new HttpClient(); client.SetBearerToken(token); We recommend to leverage the HttpClientFactory to fabricate HTTP clients that are already aware of the token management plumbing. For this you would register a named client in your application startup e.g. like this:\n// registers HTTP client that uses the managed user access token builder.Services.AddUserAccessTokenHttpClient(\u0026#34;apiClient\u0026#34;, configureClient: client =\u0026gt; { client.BaseAddress = new Uri(\u0026#34;https://remoteServer/\u0026#34;); }); And then retrieve a client instance like this:\n[Route(\u0026#34;myApi\u0026#34;)] public class MyApiController : ControllerBase { private readonly IHttpClientFactory _httpClientFactory; public MyController(IHttpClientFactory httpClientFactory) { _httpClientFactory = httpClientFactory; } public async Task\u0026lt;IActionResult\u0026gt; Get(string id) { // create HTTP client with automatic token management var client = _httpClientFactory.CreateClient(\u0026#34;apiClient\u0026#34;); // call remote API var response = await client.GetAsync(\u0026#34;remoteApi\u0026#34;); // rest omitted } } If you prefer to use typed clients, you can do that as well:\n// registers a typed HTTP client with token management support services.AddHttpClient\u0026lt;MyTypedApiClient\u0026gt;(client =\u0026gt; { client.BaseAddress = new Uri(\u0026#34;https://remoteServer/\u0026#34;); }) .AddUserAccessTokenHandler(); And then use that client, for example like this on a controller\u0026rsquo;s action method:\npublic async Task\u0026lt;IActionResult\u0026gt; CallApiAsUserTyped( [FromServices] MyTypedClient client) { var response = await client.GetData(); // rest omitted } The client will internally always try to use a current and valid access token. If for any reason this is not possible, the 401 status code will be returned to the caller.\nReuse of Refresh Tokens We recommend that you configure IdentityServer to issue reusable refresh tokens to BFF clients. Because the BFF is a confidential client, it does not need one-time use refresh tokens. Reusable refresh tokens are desirable because they avoid performance and user experience problems associated with one time use tokens. See the discussion on rotating refresh tokens and the OAuth 2.0 Security Best Current Practice for more details.\nManually revoking refresh tokens Duende.BFF revokes refresh tokens automatically at logout time. This behavior can be disabled with the RevokeRefreshTokenOnLogout option.\nIf you want to manually revoke the current refresh token, you can use the following code:\nawait HttpContext.RevokeUserRefreshTokenAsync(); This will invalidate the refresh token at the token service.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/extensibility/management/back-channel-logout/",
    "title": "BFF Back-Channel Logout Endpoint Extensibility",
    "tags": [],
    "description": "",
    "content": "The back-channel logout endpoint has several extensibility points organized into two interfaces and their default implementations. The IBackchannelLogoutService is the top level abstraction that processes requests to the endpoint. This service can be used to add custom request processing logic or to change how it validates incoming requests. When the back-channel logout endpoint receives a valid request, it revokes sessions using the ISessionRevocationService.\nRequest Processing You can add custom logic to the endpoint by implementing the IBackchannelLogoutService or by extending its default implementation (Duende.Bff.DefaultBackchannelLogoutService). In most cases, extending the default implementation is preferred, as it has several virtual methods that can be overridden to customize particular aspects of how the request is processed.\nProcessRequestAsync is the top level function called in the endpoint service and can be used to add arbitrary logic to the endpoint.\npublic class CustomizedBackchannelLogoutService : DefaultBackchannelLogoutService { public override Task ProcessRequestAsync(HttpContext context) { // Custom logic here return base.ProcessRequestAsync(context); } Validation Validation of the incoming request can be customized by overriding one of several virtual methods in the DefaultBackchannelLogoutService. GetTokenValidationParameters allows you to specify the TokenValidationParameters used to validate the incoming logout token. The default implementation creates token validation parameters based on the authentication scheme\u0026rsquo;s configuration. Your override could begin by calling the base method and then make changes to those parameters or completely customize how token validation parameters are created. For example:\npublic class CustomizedBackchannelLogoutService : DefaultBackchannelLogoutService { protected override async Task\u0026lt;TokenValidationParameters\u0026gt; GetTokenValidationParameters() { var tokenValidationParams = await base.GetTokenValidationParameters(); // Set custom parameters here // For example, make clock skew more permissive than it is by default: tokenValidationParams.ClockSkew = TimeSpan.FromMinutes(15); return tokenValidationParams; } If you need more control over the validation of the logout token, you can override ValidateJwt. The default implementation of ValidateJwt validates the token and produces a ClaimsIdentity using a JsonWebTokenHandler and the token validation parameters returned from GetTokenValidationParameters. Your override could call the base method and then manipulate this ClaimsIdentity or add a completely custom method for producing the ClaimsIdentity from the logout token.\nValidateLogoutTokenAsync is the coarsest-grained validation method. It is is responsible for validating the incoming logout token and determining if logout should proceed, based on claims in the token. It returns a ClaimsIdentity if logout should proceed or null if it should not. Your override could prevent logout in certain circumstances by returning null. For example:\npublic class CustomizedBackchannelLogoutService : DefaultBackchannelLogoutService { protected override async Task\u0026lt;ClaimsIdentity?\u0026gt; ValidateLogoutTokenAsync(string logoutToken) { var identity = await base.ValidateLogoutTokenAsync(logoutToken); // Perform custom logic here // For example, prevent logout based on certain conditions if(identity?.FindFirst(\u0026#34;sub\u0026#34;)?.Value == \u0026#34;12345\u0026#34;) { return null; } else { return identity; } } Session Revocation The back-channel logout service will call the registered session revocation service to revoke the user session when it receives a valid logout token. To customize the revocation process, implement the ISessionRevocationService.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/extensibility/management/diagnostics/",
    "title": "BFF Diagnostics Endpoint Extensibility",
    "tags": [],
    "description": "",
    "content": "The BFF diagnostics endpoint can be customized by implementing the IDiagnosticsService or by extending DefaultDiagnosticsService, its default implementation.\nRequest Processing ProcessRequestAsync is the top level function called in the endpoint service and can be used to add arbitrary logic to the endpoint.\nFor example, you could take whatever actions you need before normal processing of the request like this:\npublic override Task ProcessRequestAsync(HttpContext context) { // Custom logic here return base.ProcessRequestAsync(context); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/fundamentals/options/",
    "title": "Configuration Options",
    "tags": [],
    "description": "BFF",
    "content": "BFF Options The Duende.BFF.BffOptions allows to configure several aspects of the BFF framework.\nYou set the options at startup time:\nbuilder.Services.AddBff(options =\u0026gt; { // configure options here.. }) General EnforceBffMiddleware\nEnables checks in the user management endpoints that ensure that the BFF middleware has been added to the pipeline. Since the middleware performs important security checks, this protects from accidental configuration errors. You can disable this check if it interferes with some custom logic you might have. Defaults to true.\nLicenseKey\nThis sets the license key for Duende.BFF. A business edition or higher license key is required for production deployments. The same license key is used in IdentityServer and the BFF. Just as in the IdentityServer host, you can either set the license key using this option in code or include Duende_License.key in the same directory as your BFF host.\nAnonymousSessionResponse (added in 2.0)\nThis sets the response status code behavior on the user endpoint to either return 401 or 200 with a null payload when the user is anonymous.\nDiagnosticsEnvironments\nThe ASP.NET environment names that enable the diagnostics endpoint. Defaults to \u0026ldquo;Development\u0026rdquo;.\nPaths LoginPath\nSets the path to the login endpoint. Defaults to /bff/login.\nSilentLoginPath\nSets the path to the silent login endpoint. Defaults to /bff/silent-login.\nSilentLoginCallbackPath\nSets the path to the silent login callback endpoint. Defaults to /bff/silent-login-callback.\nLogoutPath\nSets the path to the logout endpoint. Defaults to /bff/logout.\nUserPath\nSets the path to the user endpoint. Defaults to /bff/user.\nBackChannelLogoutPath\nSets the path to the backchannel logout endpoint. Defaults to /bff/backchannel.\nDiagnosticsPath\nSets the path to the diagnostics endpoint. Defaults to /bff/diagnostics.\nSession Management ManagementBasePath\nBase path for management endpoints. Defaults to /bff.\nRequireLogoutSessionId\nFlag that specifies if the sid claim needs to be present in the logout request as query string parameter. Used to prevent cross site request forgery. Defaults to true.\nRevokeRefreshTokenOnLogout\nSpecifies if the user\u0026rsquo;s refresh token is automatically revoked at logout time. Defaults to true.\nBackchannelLogoutAllUserSessions\nSpecifies if during backchannel logout all matching user sessions are logged out. If true, all sessions for the subject will be revoked. If false, just the specific session will be revoked. Defaults to false.\nEnableSessionCleanup\nIndicates if expired server side sessions should be cleaned up. This requires an implementation of IUserSessionStoreCleanup to be registered in the DI system. Defaults to false.\nSessionCleanupInterval\nInterval at which expired sessions are cleaned up. Defaults to 10 minutes.\nAPIs AntiForgeryHeaderName\nSpecifies the name of the header used for anti-forgery header protection. Defaults to X-CSRF.\nAntiForgeryHeaderValue\nSpecifies the expected value of Anti-forgery header. Defaults to 1.\nDPoPJsonWebKey\nSpecifies the Json Web Key to use when creating DPoP proof tokens. Defaults to null, which is appropriate when not using DPoP.\nRemoveSessionAfterRefreshTokenExpiration Flag that specifies if a user session should be removed after an attempt to use a Refresh Token to acquire a new Access Token fails. This behavior is only triggered when proxying requests to remote APIs with TokenType.User or TokenType.UserOrClient. Defaults to True.\nBFF Blazor Server Options In the Blazor Server, you configure the BffBlazorServerOptions by using the AddBlazorServer method.\nbuilder.Services.AddBlazorServer(opt =\u0026gt; { // configure options here.. }) The following options are available: * ***ServerStateProviderPollingInterval*** The delay, in milliseconds, between polling requests by the BffServerAuthenticationStateProvider to the /bff/user endpoint. Defaults to 5000 ms. # BFF Blazor Client Options In WASM, you configure the **BffBlazorClientOptions** using the **AddBffBlazorClient** method: ```csharp builder.Services.AddBffBlazorClient(opt =\u0026gt; { // configure options here.. }) The following options are available:\nRemoteApiPath The base path to use for remote APIs.\nRemoteApiBaseAddress The base address to use for remote APIs. If unset (the default), the blazor hosting environment\u0026rsquo;s base address is used.\nStateProviderBaseAddress The base address to use for the state provider\u0026rsquo;s calls to the /bff/user endpoint. If unset (the default), the blazor hosting environment\u0026rsquo;s base address is used.\nWebAssemblyStateProviderPollingDelay\nThe delay, in milliseconds, before the BffClientAuthenticationStateProvider will start polling the /bff/user endpoint. Defaults to 1000 ms.\nWebAssemblyStateProviderPollingInterval The delay, in milliseconds, between polling requests by the BffClientAuthenticationStateProvider to the /bff/user endpoint. Defaults to 5000 ms.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/",
    "title": "BFF Security Framework",
    "tags": [],
    "description": "",
    "content": "BFF Security Framework The Duende.BFF (Backend for Frontend) security framework packages the necessary components to secure browser-based frontends (e.g. SPAs or Blazor applications) with ASP.NET Core backends.\nDuende.BFF is free for development, testing and personal projects, but production use requires a license. Special offers may apply.\nThe source code for the BFF framework can be found on github. Builds are distributed through NuGet. Also check out the samples.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/extensibility/",
    "title": "Extensibility",
    "tags": [],
    "description": "",
    "content": "Extensibility Duende.BFF can be extended in the following areas\ncustom logic at the session management endpoints custom logic and configuration for HTTP forwarding custom data storage for server-side sessions and access/refresh tokens "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/fundamentals/blazor/",
    "title": "Blazor applications",
    "tags": [],
    "description": "",
    "content": "Blazor support in the BFF Security Framework Microsoft Blazor is a framework for building interactive web applications using C# and .NET. Blazor allows developers to create rich, dynamic web UIs with the same ease as building desktop applications.\nThe Duende BFF (Backend for Frontend) Security Framework addresses common security challenges faced by Blazor applications. It provides a unified approach to managing authentication and authorization, ensuring secure interactions between the client and server.\nArchitecture The following diagram shows how the support for Blazor applications in the Duende BFF Security Framework works:\nThe BFF exposes endpoints to perform login / logout functionality. The actual authentication (to an identity server) is handled by the OpenIDConnectHandler. Once succesfully authenticated, the CookieAuthenticationHandler stores a secure, httponly cookie in the browser. This cookie is then responsible for authenticating all requests from the front-end to the BFF.\nHandling the various blazor rendering modes Blazor is very flexible in how it renders applications (and even individual components) and where code is actually executed:\nServer Side Rendering: All rendering (and interactivity) happens on the server. Interactive Server Side Rendering: All rendering happens on the server, but a streaming connection to the server allows parts of the UI to be updated when the user interacts with the application. This does mean that all interactivity still actually executes on the server. WASM It\u0026rsquo;s possible to create web assembly components that render completely in the browser. All interactivity is executed in the browser. Auto It\u0026rsquo;s even possible to create components that initially render on the server, but then transition to WASM based rendering (and interactivity) when the WASM Components have been downloaded by the browser. These rendering modes are very powerful, but also add additional complexity when it comes to authentication and authorization. Any code that executes on the server can directly access local resources, such has a database, but code that executes on the client needs to through a local http endpoint (that requires authentication). Accessing external API\u0026rsquo;s is also different between server and client, where the client needs to go through a proxy which performs a token exchange.\nFor more information on this, see rendering-modes\nAuthentication State The **AuthenticationState ** is contains information about the currently logged in user. This is partly populated from information from the user, but is also enriched with several management claims, such as the Logout URL.\nBlazor uses AuthenticationStateProviders to make authentication state available to components. On the server, the authentication state is already mostly managed by the authentication framework. However, the BFF will add the Logout url to the claims using the AddServerManagementClaimsTransform. On the client, there are some other claims that might be useful. The BffClientAuthenticationStateProvider will poll the server to update the client on the latest authentication state, such as the user\u0026rsquo;s claims. This also notifies the front-end if the session is terminated on the server.\nServer Side Token Store Blazor Server applications have the same token management requirements as a regular ASP.NET Core web application. Because Blazor Server streams content to the application over a websocket, there often is no HTTP request or response to interact with during the execution of a Blazor Server application. You therefore cannot use HttpContext in a Blazor Server application as you would in a traditional ASP.NET Core web application.\nThis means:\nyou cannot use HttpContext extension methods you cannot use the ASP.NET authentication session to store tokens the normal mechanism used to automatically attach tokens to Http Clients making API calls won\u0026rsquo;t work The ServerSideTokenStore, together with the Blazor Server functionality in Duende.AccessTokenManagement is automatically registered when you register Blazor Server.\nFor more information on this, see Blazor Server\nAdding the BFF Security framework to your Blazor application Adding\nbuilder.Services.AddBff() .AddServerSideSessions() // Add in-memory implementation of server side sessions .AddBlazorServer(); // ... \u0026lt;snip\u0026gt;.. // Add the BFF middleware which performs anti forgery protection app.UseBff(); app.UseAuthorization(); app.UseAntiforgery(); // Add the BFF management endpoints, such as login, logout, etc. // This has to be added after \u0026#39;UseAuthorization()\u0026#39; app.MapBffManagementEndpoints(); // .. \u0026lt;snip\u0026gt; var builder = WebAssemblyHostBuilder.CreateDefault(args); builder.Services .AddBffBlazorClient() // Provides auth state provider that polls the /bff/user endpoint .AddCascadingAuthenticationState(); builder.Services.AddLocalApiHttpClient\u0026lt;WeatherHttpClient\u0026gt;(); "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/samples/quickstarts/",
    "title": "Bff Blazor App",
    "tags": [],
    "description": "",
    "content": "This quickstart walks you through how to create a BFF Blazor application. The sourcecode for this quickstart is available on [github](link to source code)\nCreating the project structure The first step is to create a Blazor app. You can do so using the command line:\nmkdir BlazorBffApp cd BlazorBffApp dotnet new blazor --interactivity auto --all-interactive This creates a blazor application with a Server project and a client project.\nConfiguring the BffApp server project To configure the server, the first step is to add the BFF Blazor package.\ncd BlazorBffApp dotnet add package Duende.BFF.Blazor --version 3.0.0 Then you need to configure the application to use the BFF Blazor application. Add this to your services:\n// BFF setup for blazor builder.Services.AddBff() .AddServerSideSessions() // Add in-memory implementation of server side sessions .AddBlazorServer(); // Configure the authentication builder.Services.AddAuthentication(options =\u0026gt; { options.DefaultScheme = \u0026#34;cookie\u0026#34;; options.DefaultChallengeScheme = \u0026#34;oidc\u0026#34;; options.DefaultSignOutScheme = \u0026#34;oidc\u0026#34;; }) .AddCookie(\u0026#34;cookie\u0026#34;, options =\u0026gt; { options.Cookie.Name = \u0026#34;__Host-blazor\u0026#34;; // Because we use an identity server that\u0026#39;s configured on a different site // (duendesoftware.com vs localhost), we need to configure the SameSite property to Lax. // Setting it to Strict would cause the authentication cookie not to be sent after loggin in. // The user would have to refresh the page to get the cookie. // Recommendation: Set it to \u0026#39;strict\u0026#39; if your IDP is on the same site as your BFF. options.Cookie.SameSite = SameSiteMode.Lax; }) .AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { options.Authority = \u0026#34;https://demo.duendesoftware.com\u0026#34;; options.ClientId = \u0026#34;interactive.confidential\u0026#34;; options.ClientSecret = \u0026#34;secret\u0026#34;; options.ResponseType = \u0026#34;code\u0026#34;; options.ResponseMode = \u0026#34;query\u0026#34;; options.GetClaimsFromUserInfoEndpoint = true; options.SaveTokens = true; options.MapInboundClaims = false; options.Scope.Clear(); options.Scope.Add(\u0026#34;openid\u0026#34;); options.Scope.Add(\u0026#34;profile\u0026#34;); options.Scope.Add(\u0026#34;api\u0026#34;); options.Scope.Add(\u0026#34;offline_access\u0026#34;); options.TokenValidationParameters.NameClaimType = \u0026#34;name\u0026#34;; options.TokenValidationParameters.RoleClaimType = \u0026#34;role\u0026#34;; }); // Make sure authentication state is available to all components. builder.Services.AddCascadingAuthenticationState(); builder.Services.AddAuthorization(); To configure the web app pipeline. Replace the app.UseAntiforgery() with the code below:\napp.UseRouting(); app.UseAuthentication(); // Add the BFF middleware which performs anti forgery protection app.UseBff(); app.UseAuthorization(); app.UseAntiforgery(); // Add the BFF management endpoints, such as login, logout, etc. app.MapBffManagementEndpoints(); Configuring the BffApp.Client project To add the BFF to the client project, add the following:\ncd .. cd BlazorBffApp.Client dotnet add package Duende.BFF.Blazor.Client --version 3.0.0 Then add the following to your program.cs:\nbuilder.Services .AddBffBlazorClient(); // Provides auth state provider that polls the /bff/user endpoint builder.Services .AddCascadingAuthenticationState(); Your application is ready to use BFF now.\nConfiguring your application to use bff\u0026rsquo;s features Add the following components to your BlazorBffApp.Client\u0026rsquo;s Component folder:\nLoginDisplay.razor The following code shows a login / logout button depending on your state. Note, you\u0026rsquo;ll need to use the logout link from the LogoutUrl claim, because this contains both the correct route and the session id. Add it to the BffBlazorApp.Client/Components folder\n@using Duende.Bff.Blazor.Client @using Microsoft.AspNetCore.Components.Authorization @using Microsoft.Extensions.Options @rendermode InteractiveAuto @inject IOptions\u0026lt;BffBlazorClientOptions\u0026gt; Options \u0026lt;AuthorizeView\u0026gt; \u0026lt;Authorized\u0026gt; \u0026lt;strong\u0026gt;Hello, @context.User.Identity?.Name\u0026lt;/strong\u0026gt; \u0026lt;a class=\u0026#34;nav-link btn btn-link\u0026#34; href=\u0026#34;@BffLogoutUrl(context)\u0026#34;\u0026gt;Log Out\u0026lt;/a\u0026gt; \u0026lt;/Authorized\u0026gt; \u0026lt;Authorizing\u0026gt; \u0026lt;a class=\u0026#34;nav-link btn btn-link disabled\u0026#34;\u0026gt;Log in\u0026lt;/a\u0026gt; \u0026lt;/Authorizing\u0026gt; \u0026lt;NotAuthorized\u0026gt; \u0026lt;a class=\u0026#34;nav-link btn btn-link\u0026#34; href=\u0026#34;bff/login\u0026#34;\u0026gt;Log in\u0026lt;/a\u0026gt; \u0026lt;/NotAuthorized\u0026gt; \u0026lt;/AuthorizeView\u0026gt; @code { string BffLogoutUrl(AuthenticationState context) { var logoutUrl = context.User.FindFirst(Constants.ClaimTypes.LogoutUrl); return $\u0026#34;{Options.Value.StateProviderBaseAddress}{logoutUrl?.Value}\u0026#34;; } } RedirectToLogin.razor The following code will redirect users to Identity Server for authentication. Once authentication is complete, the users will be redirected back to where they came from. Add it to the BffBlazorApp.Client/Components folder\n@inject NavigationManager Navigation @rendermode InteractiveAuto @code { protected override void OnInitialized() { var returnUrl = Uri.EscapeDataString(\u0026#34;/\u0026#34; + Navigation.ToBaseRelativePath(Navigation.Uri)); Navigation.NavigateTo($\u0026#34;bff/login?returnUrl={returnUrl}\u0026#34;, forceLoad: true); } } Modifications to Routes.razor Replace the contents of routes.razor so it matches below:\n@using Microsoft.AspNetCore.Components.Authorization @using BlazorBffApp.Client.Components \u0026lt;Router AppAssembly=\u0026#34;typeof(Program).Assembly\u0026#34; AdditionalAssemblies=\u0026#34;new[] { typeof(Client._Imports).Assembly }\u0026#34;\u0026gt; \u0026lt;Found Context=\u0026#34;routeData\u0026#34;\u0026gt; \u0026lt;AuthorizeRouteView RouteData=\u0026#34;routeData\u0026#34; DefaultLayout=\u0026#34;typeof(Layout.MainLayout)\u0026#34;\u0026gt; \u0026lt;NotAuthorized\u0026gt; @if (context.User.Identity?.IsAuthenticated != true) { \u0026lt;RedirectToLogin /\u0026gt; } else { \u0026lt;p role=\u0026#34;alert\u0026#34;\u0026gt;You (@context.User.Identity?.Name) are not authorized to access this resource.\u0026lt;/p\u0026gt; } \u0026lt;/NotAuthorized\u0026gt; \u0026lt;/AuthorizeRouteView\u0026gt; \u0026lt;FocusOnNavigate RouteData=\u0026#34;routeData\u0026#34; Selector=\u0026#34;h1\u0026#34; /\u0026gt; \u0026lt;/Found\u0026gt; \u0026lt;/Router\u0026gt; This makes sure that, if you\u0026rsquo;re accessing a page that requires authorization, that you are automatically redirected to Identity Server for authentication.\nModifications to MainLayout.razor Modify your MainLayout so it matches below:\n@inherits LayoutComponentBase @using BlazorBffApp.Client.Components \u0026lt;div class=\u0026#34;page\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;sidebar\u0026#34;\u0026gt; \u0026lt;NavMenu /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;main\u0026gt; \u0026lt;div class=\u0026#34;top-row px-4\u0026#34;\u0026gt; \u0026lt;LoginDisplay /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;article class=\u0026#34;content px-4\u0026#34;\u0026gt; @Body \u0026lt;/article\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;blazor-error-ui\u0026#34; data-nosnippet\u0026gt; An unhandled error has occurred. \u0026lt;a href=\u0026#34;.\u0026#34; class=\u0026#34;reload\u0026#34;\u0026gt;Reload\u0026lt;/a\u0026gt; \u0026lt;span class=\u0026#34;dismiss\u0026#34;\u0026gt;🗙\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; This adds the LoginDisplay to the header.\nNow your application supports logging in / out.\nExposing APIs Now we\u0026rsquo;re going to expose a local api for weather forecasts to Blazor wasm and call it via a HttpClient.\nBy default, the system will perform both pre-rendering on the server AND WASM based rendering on the client. For this reason, you\u0026rsquo;ll need to register both a server and client version of a component that retrieves data. See the Microsoft documentation for more information on this.\nConfiguring the Client app Add a class called WeatherClient to the BffBlazorApp.Client project:\npublic class WeatherHttpClient(HttpClient client) : IWeatherClient { public async Task\u0026lt;WeatherForecast[]\u0026gt; GetWeatherForecasts() =\u0026gt; await client.GetFromJsonAsync\u0026lt;WeatherForecast[]\u0026gt;(\u0026#34;WeatherForecast\u0026#34;) ?? throw new JsonException(\u0026#34;Failed to deserialize\u0026#34;); } public class WeatherForecast { public DateOnly Date { get; set; } public int TemperatureC { get; set; } public string? Summary { get; set; } public int TemperatureF =\u0026gt; 32 + (int)(TemperatureC / 0.5556); } // The IWeatherClient interface will form an abstraction between \u0026#39;server\u0026#39; logic and client logic. public interface IWeatherClient { Task\u0026lt;WeatherForecast[]\u0026gt; GetWeatherForecasts(); } Then register this as a component in program.cs.\nbuilder.Services .AddBffBlazorClient()// Provides auth state provider that polls the /bff/user endpoint // Register a HTTP Client that\u0026#39;s configured to fetch data from the server. .AddLocalApiHttpClient\u0026lt;WeatherHttpClient\u0026gt;() ; // Register the concrete implementation with the abstraction builder.Services.AddSingleton\u0026lt;IWeatherClient, WeatherHttpClient\u0026gt;(); Configuring the server Add a class called ServerWeatherClient to your BlazorBffApp server project:\npublic class ServerWeatherClient : IWeatherClient { public Task\u0026lt;WeatherForecast[]\u0026gt; GetWeatherForecasts() { var startDate = DateOnly.FromDateTime(DateTime.Now); string[] summaries = [ \u0026#34;Freezing\u0026#34;, \u0026#34;Bracing\u0026#34;, \u0026#34;Chilly\u0026#34;, \u0026#34;Cool\u0026#34;, \u0026#34;Mild\u0026#34;, \u0026#34;Warm\u0026#34;, \u0026#34;Balmy\u0026#34;, \u0026#34;Hot\u0026#34;, \u0026#34;Sweltering\u0026#34;, \u0026#34;Scorching\u0026#34; ]; return Task.FromResult(Enumerable.Range(1, 5).Select(index =\u0026gt; new WeatherForecast { Date = startDate.AddDays(index), TemperatureC = Random.Shared.Next(-20, 55), Summary = summaries[Random.Shared.Next(summaries.Length)] }).ToArray()); } } Then add an endpoint to your http pipeline:\napp.MapGet(\u0026#34;/WeatherForecast\u0026#34;, (IWeatherClient weatherClient) =\u0026gt; weatherClient.GetWeatherForecasts()); Also register the \u0026lsquo;server abstraction.\nbuilder.Services.AddSingleton\u0026lt;IWeatherClient, ServerWeatherClient\u0026gt;(); Displaying weather information from the api By default, the blazor template ships with a weather page.\nChange the content of the Weather.razor like this:\n@page \u0026#34;/weather\u0026#34; @using BlazorBffApp.Client.Components @using Microsoft.AspNetCore.Authorization @rendermode InteractiveWebAssembly @attribute [Authorize] \u0026lt;PageTitle\u0026gt;Weather\u0026lt;/PageTitle\u0026gt; \u0026lt;WeatherComponent @rendermode=\u0026#34;new InteractiveWebAssemblyRenderMode()\u0026#34; /\u0026gt; Now add a component called WeatherComponent\n@inject IWeatherClient WeatherClient \u0026lt;h1\u0026gt;Weather\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This component demonstrates showing data.\u0026lt;/p\u0026gt; @if (forecasts == null) { \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Loading...\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; } else { \u0026lt;table class=\u0026#34;table\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;Date\u0026lt;/th\u0026gt; \u0026lt;th aria-label=\u0026#34;Temperature in Celsius\u0026#34;\u0026gt;Temp. (C)\u0026lt;/th\u0026gt; \u0026lt;th aria-label=\u0026#34;Temperature in Farenheit\u0026#34;\u0026gt;Temp. (F)\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Summary\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; @foreach (var forecast in forecasts) { \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;@forecast.Date.ToShortDateString()\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;@forecast.TemperatureC\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;@forecast.TemperatureF\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;@forecast.Summary\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; } \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; } @code { private WeatherForecast[]? forecasts; protected override async Task OnInitializedAsync() { forecasts = await WeatherClient.GetWeatherForecasts(); } } "
  },
  {
    "uri": "https://docs.duendesoftware.com/bff/v3/samples/",
    "title": "Samples",
    "tags": [],
    "description": "",
    "content": "Samples This section contains a collection of clients using our BFF security framework.\nJavaScript Frontend This sample shows how to use the BFF framework with a JavaScript-based frontend (e.g. SPA).\nlink to source code\nReactJs Frontend This sample shows how to use the BFF framework with the .NET 6 React template.\nlink to source code\nAngular Frontend This sample shows how to use the BFF framework with the .NET 6 Angular template.\nlink to source code\nBlazor WASM This sample shows how to use the BFF framework with Blazor WASM.\nlink to source code\nBlazor Auto Rendering This sample shows how to use Authentication in combination with Blazor\u0026rsquo;s AutoRendering feature.\nlink to source code\nYARP Integration This sample shows how to use the BFF extensions for Microsoft YARP\nlink to source code\nSeparate Host for UI This sample shows how to have separate projects from the frontend and backend, using CORS to allow cross-site requests from the frontend to the backend.\nlink to source code\nDPoP This sample shows how to configure the BFF to use DPoP to obtain sender-constrained tokens.\nlink to source code\nToken Exchange using the IAccessTokenRetriever This sample shows how to extend the BFF with an IAccessTokenRetriever. This example of an IAccessTokenRetriever performs token exchange for impersonation. If you are logged in as alice you will get a token for bob, and vice versa.\nlink to source code\nFeedback Feel free to ask the developer community if you are looking for a particular sample and can\u0026rsquo;t find it here.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/accesstokenmanagement/",
    "title": "AccessTokenManagement",
    "tags": [],
    "description": "",
    "content": "Duende.AccessTokenManagement This library provides automatic access token management features for .NET worker and ASP.NET Core web applications:\nautomatic acquisition and lifetime management of client credentials based access tokens for machine to machine communication automatic access token lifetime management using a refresh token for API calls on-behalf of the currently logged-in user revocation of access tokens The following tutorials are available:\nWorkers Web Applications Blazor Server Advanced "
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/accesstokenmanagement/advanced/client_credentials/",
    "title": "Customizing Client Credentials Token Management",
    "tags": [],
    "description": "",
    "content": "The most common way to use the access token management for machine to machine communication is described here - however you may want to customize certain aspects of it - here\u0026rsquo;s what you can do.\nClient options You can add token client definitions to your host while configuring the DI container, e.g.:\nservices.AddClientCredentialsTokenManagement() .AddClient(\u0026#34;invoices\u0026#34;, client =\u0026gt; { client.TokenEndpoint = \u0026#34;https://sts.company.com/connect/token\u0026#34;; client.ClientId = \u0026#34;4a632e2e-0466-4e5a-a094-0455c6105f57\u0026#34;; client.ClientSecret = \u0026#34;e8ae294a-d5f3-4907-88fa-c83b3546b70c\u0026#34;; client.ClientCredentialStyle = ClientCredentialStyle.AuthorizationHeader; client.Scope = \u0026#34;list\u0026#34;; client.Resource = \u0026#34;urn:invoices\u0026#34;; }) You can set the following options:\nTokenEndpoint - URL of the OAuth token endpoint where this token client requests tokens from ClientId - client ID ClientSecret - client secret (if a shared secret is used) ClientCredentialStyle - Specifies how the client ID / secret is sent to the token endpoint. Options are using using the authorization header, or POST body values (defaults to header) Scope - the requested scope of access (if any) Resource - the resource indicator (if any) Internally the standard .NET options system is used to register the configuration. This means you can also register clients like this:\nservices.Configure\u0026lt;ClientCredentialsClient\u0026gt;(\u0026#34;invoices\u0026#34;, client =\u0026gt; { client.TokenEndpoint = \u0026#34;https://sts.company.com/connect/token\u0026#34;; client.ClientId = \u0026#34;4a632e2e-0466-4e5a-a094-0455c6105f57\u0026#34;; client.ClientSecret = \u0026#34;e8ae294a-d5f3-4907-88fa-c83b3546b70c\u0026#34;; client.Scope = \u0026#34;list\u0026#34;; client.Resource = \u0026#34;urn:invoices\u0026#34;; }); Or use the IConfigureNamedOptions if you need access to the DI container during registration, e.g.:\npublic class ClientCredentialsClientConfigureOptions : IConfigureNamedOptions\u0026lt;ClientCredentialsClient\u0026gt; { private readonly DiscoveryCache _cache; public ClientCredentialsClientConfigureOptions(DiscoveryCache cache) { _cache = cache; } public void Configure(string name, ClientCredentialsClient options) { if (name == \u0026#34;invoices\u0026#34;) { var disco = _cache.GetAsync().GetAwaiter().GetResult(); options.TokenEndpoint = disco.TokenEndpoint; client.ClientId = \u0026#34;4a632e2e-0466-4e5a-a094-0455c6105f57\u0026#34;; client.ClientSecret = \u0026#34;e8ae294a-d5f3-4907-88fa-c83b3546b70c\u0026#34;; client.Scope = \u0026#34;list\u0026#34;; client.Resource = \u0026#34;urn:invoices\u0026#34;; } } } ..and register the config options e.g. like this:\nservices.AddClientCredentialsTokenManagement(); services.AddSingleton(new DiscoveryCache(\u0026#34;https://sts.company.com\u0026#34;)); services.AddSingleton\u0026lt;IConfigureOptions\u0026lt;ClientCredentialsClient\u0026gt;, ClientCredentialsClientConfigureOptions\u0026gt;(); Backchannel communication By default all backchannel communication will be done using a named client from the HTTP client factory. The name is Duende.AccessTokenManagement.BackChannelHttpClient which is also a constant called ClientCredentialsTokenManagementDefaults.BackChannelHttpClientName.\nYou can register your own HTTP client with the factory using the above name and thus provide your own custom HTTP client.\nThe client registration object has two additional properties to customize the HTTP client:\nHttpClientName - if set, this HTTP client name from the factory will be used instead of the default one HttpClient - allows setting an instance of HttpClient to use. Will take precedence over a client name Token caching By default, tokens will be cached using the IDistributedCache abstraction in ASP.NET Core. You can either use the in-memory cache version, or a real distributed cache like Redis.\nFor development purposes, you can use the MemoryDistributedCache:\nservices.AddDistributedMemoryCache(); Note that MemoryDistributedCache will be cleared whenever the process is restarted. It won\u0026rsquo;t be shared between multiple instances of your application in a load-balanced environment. As a result, a new token will have to be obtained when you restart your application, and each instance will obtain a different token.\nFor production deployments, we recommend using a distributed cache.\nThe built-in cache in Duende.AccessTokenManagment uses two settings from the options, which apply with any IDistributedCache:\nservices.AddClientCredentialsTokenManagement(options =\u0026gt; { options.CacheLifetimeBuffer = 60; options.CacheKeyPrefix = \u0026#34;Duende.AccessTokenManagement.Cache::\u0026#34;; }); CacheLifetimeBuffer is a value in seconds that will be subtracted from the token lifetime, e.g. if a token is valid for one hour, it will be cached for 59 minutes only. The cache key prefix is used to construct the unique key for the cache item based on client name, requested scopes and resource.\nFinally, you can also replace the caching implementation altogether by registering your own IClientCredentialsTokenCache.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/",
    "title": "Duende Open Source",
    "tags": [],
    "description": "",
    "content": "Welcome to Duende Open Source Duende Software sponsors a series of free open source libraries under the Apache 2 license.\nThese libraries help with building OAuth 2.0 and OpenID Connect clients.\nDuende.AccessTokenManagement A set of .NET libraries that manage OAuth and OpenId Connect access tokens. These tools automatically acquire new tokens when old tokens are about to expire, provide conveniences for using the current token with HTTP clients, and can revoke tokens that are no longer needed.\nThe latest version of Duende.AccessTokenManagement targets .NET 8 and is available on GitHub and NuGet.\nDuende.IdentityModel The Duende.IdentityModel package is the base library for OIDC and OAuth 2.0 related protocol operations. It provides an object model to interact with the endpoints defined in the various OAuth and OpenId Connect specifications in the form of types to represent the requests and responses, extension methods to invoke requests constants defined in the specifications, such as standard scope, claim, and parameter names, and other convenience methods for performing common identity related operations.\nDuende.IdentityModel targets .NET Standard 2.0, making it suitable for .NET and .NET Framework and is available on GitHub and NuGet.\nDuende.IdentityModel.OidcClient Duende.IdentityModel.OidcClient is an OpenID Connect (OIDC) client library for mobile and native applications in .NET. It is a certified OIDC relying party and implements RFC 8252, \u0026ldquo;OAuth 2.0 for native Applications\u0026rdquo;. It provides types that describe OIDC requests and responses, low level methods to construct protocol state and handle responses, and higher level methods for logging in, logging out, retrieving userinfo, and refreshing tokens.\nDuende.IdentityModel.OidcClient targets .NET Standard 2.0, making it suitable for .NET and .NET Framework and is available on GitHub and NuGet.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/identitymodel/endpoints/",
    "title": "Endpoints",
    "tags": [],
    "description": "",
    "content": "Endpoints General Usage Discovery Endpoint Token Endpoint Token Introspection Endpoint Token Revocation Endpoint UserInfo Endpoint Dynamic Client Registration Device Authorization Endpoint "
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/identitymodel/endpoints/general_usage/",
    "title": "General Usage",
    "tags": [],
    "description": "",
    "content": "IdentityModel contains client libraries for many interactions with endpoints defined in OpenID Connect and OAuth 2.0. All of these libraries have a common design, let's examine the various layers using the client for the token endpoint.\nRequest and response objects All protocol request are modelled as request objects and have a common base class called ProtocolRequest which has properties to set the endpoint address, client ID, client secret, client assertion, and the details of how client secrets are transmitted (e.g. authorization header vs POST body). ProtocolRequest derives from HttpRequestMessage and thus also allows setting custom headers etc.\nThe following code snippet creates a request for a client credentials grant type:\nvar request = new ClientCredentialsTokenRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/token\u0026#34;, ClientId = \u0026#34;client\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34; }; While in theory you could now call Prepare (which internally sets the headers, body and address) and send the request via a plain HttpClient, typically there are more parameters with special semantics and encoding required. That's why we provide extension methods to do the low level work.\nEqually, a protocol response has a corresponding ProtocolResponse implementation that parses the status codes and response content. The following code snippet would parse the raw HTTP response from a token endpoint and turn it into a TokenResponse object:\nvar tokenResponse = await ProtocolResponse .FromHttpResponseAsync\u0026lt;TokenResponse\u0026gt;(httpResponse); Again these steps are automated using the extension methods. So let's have a look at an example next.\nExtension methods For each protocol interaction, an extension method for HttpMessageInvoker (that\u0026rsquo;s the base class of HttpClient) exists. The extension methods expect a request object and return a response object.\nIt is your responsibility to setup and manage the lifetime of the HttpClient, e.g. manually:\nvar client = new HttpClient(); var response = await client.RequestClientCredentialsTokenAsync( new ClientCredentialsTokenRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/token\u0026#34;, ClientId = \u0026#34;client\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34; }); You might want to use other techniques to obtain an HttpClient, e.g. via the HTTP client factory:\nvar client = HttpClientFactory.CreateClient(\u0026#34;my_named_token_client\u0026#34;); var response = await client.RequestClientCredentialsTokenAsync( new ClientCredentialsTokenRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/token\u0026#34;, ClientId = \u0026#34;client\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34; }); All other endpoint client follow the same design.\nSome client libraries also include a stateful client object (e.g. TokenClient and IntrospectionClient). See the corresponding section to find out more.\nClient Credential Style We recommend only changing the Client Credential Style if you\u0026rsquo;re experiencing HTTP Basic authentication encoding issues.\nAny request type implementing ProtocolRequest has the ability to configure the client credential style, which specifies how the client will transmit the client ID and secret. ClientCredentialStyle options include PostBody and the default value of AuthorizationHeader.\nvar client = HttpClientFactory.CreateClient(\u0026#34;my_named_token_client\u0026#34;); var response = await client.RequestClientCredentialsTokenAsync( new ClientCredentialsTokenRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/token\u0026#34;, ClientId = \u0026#34;client\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, // set the client credential style ClientCredentialStyle = ClientCredentialStyle.AuthorizationHeader }); For interoperability between OAuth implementations, we allow you to choose either approach, depending on which specification version you are targeting. When using IdentityServer, both header and body approaches are supported and \u0026ldquo;it just works\u0026rdquo;.\nRFC 6749, the original OAuth spec, says that support for the basic auth header is mandatory, and that the POST body is optional. OAuth 2.1 reverses this - now the body is mandatory and the header is optional.\nIn the previous OAuth specification version, the header caused bugs and interoperability problems. To follow both RFC 6749 and RFC 2617 (which is where basic auth headers are specified), you have to form url encode the client id and client secret, concatenate them both with a colon in between, and then base64 encode the final value. To try to avoid that complex process, OAuth 2.1 now prefers the POST body mechanism.\nReferences:\nRFC 6749 section 2.3.1 RFC 2617 section 2 OAuth 2.1 Draft Here is a complete list of ProtocolRequest implementors that expose the ClientCredentialStyle option:\nDuende.IdentityModel.Client.AuthorizationCodeTokenRequest Duende.IdentityModel.Client.BackchannelAuthenticationRequest Duende.IdentityModel.Client.BackchannelAuthenticationTokenRequest Duende.IdentityModel.Client.ClientCredentialsTokenRequest Duende.IdentityModel.Client.DeviceAuthorizationRequest Duende.IdentityModel.Client.DeviceTokenRequest Duende.IdentityModel.Client.DiscoveryDocumentRequest Duende.IdentityModel.Client.DynamicClientRegistrationRequest Duende.IdentityModel.Client.JsonWebKeySetRequest Duende.IdentityModel.Client.PasswordTokenRequest Duende.IdentityModel.Client.PushedAuthorizationRequest Duende.IdentityModel.Client.RefreshTokenRequest Duende.IdentityModel.Client.TokenExchangeTokenRequest Duende.IdentityModel.Client.TokenIntrospectionRequest Duende.IdentityModel.Client.TokenRequest Duende.IdentityModel.Client.TokenRevocationRequest Duende.IdentityModel.Client.UserInfoRequest "
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/identitymodel.oidcclient/manual/",
    "title": "Manual Mode",
    "tags": [],
    "description": "",
    "content": "In manual mode, OidcClient helps you with creating the necessary start URL and state parameters, but you need to coordinate with whatever browser you want to use, e.g.:\nvar options = new OidcClientOptions { Authority = \u0026#34;https://demo.duendesoftware.com\u0026#34;, ClientId = \u0026#34;native\u0026#34;, RedirectUri = redirectUri, Scope = \u0026#34;openid profile api\u0026#34; }; var client = new OidcClient(options); // generate start URL, state, nonce, code challenge var state = await client.PrepareLoginAsync(); When the browser work is done, OidcClient can take over to process the response, get the access/refresh tokens, contact userinfo endpoint etc..:\nvar result = await client.ProcessResponseAsync(data, state); The result will contain the tokens and the claims of the user.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/identitymodel/utils/constants/",
    "title": "Protocol and Claim Type Constants",
    "tags": [],
    "description": "",
    "content": "When working with OAuth 2.0, OpenID Connect and claims, there are a lot of \u0026quot;magic strings\u0026quot; for claim types and protocol values. IdentityModel provides a couple of constant strings classes to help with that.\nOAuth 2.0 and OpenID Connect Protocol Values The OidcConstants class has all the values for grant types, parameter names, error names etc.\nJWT Claim Types The JwtClaimTypes class has all standard claim types found in the OpenID Connect, JWT and OAuth 2.0 specs -many of them are also aggregated at IANA.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/accesstokenmanagement/workers/",
    "title": "Workers",
    "tags": [],
    "description": "",
    "content": "Overview A common scenario in worker applications or background tasks (or really any demon-style applications) is to call APIs using an OAuth token obtained via the client credentials flow.\nThe access tokens need to be requested and cached (either locally or shared between multiple instances) and made available to the code calling the APIs. In case of expiration (or other token invalidation reasons), a new access token needs to be requested.\nThe actual business code should not need to be aware of any of this.\nHave a look for the Worker project in the samples folder for running code.\nSetup Start by adding a reference to the Duende.AccessTokenManagement Nuget package to your application.\nYou can add the necessary services to the DI system by calling AddClientCredentialsTokenManagement(). After that you can add one or more named client definitions by calling AddClient.\n// default cache services.AddDistributedMemoryCache(); services.AddClientCredentialsTokenManagement() .AddClient(\u0026#34;catalog.client\u0026#34;, client =\u0026gt; { client.TokenEndpoint = \u0026#34;https://demo.duendesoftware.com/connect/token\u0026#34;; client.ClientId = \u0026#34;6f59b670-990f-4ef7-856f-0dd584ed1fac\u0026#34;; client.ClientSecret = \u0026#34;d0c17c6a-ba47-4654-a874-f6d576cdf799\u0026#34;; client.Scope = \u0026#34;catalog inventory\u0026#34;; }) .AddClient(\u0026#34;invoice.client\u0026#34;, client =\u0026gt; { client.TokenEndpoint = \u0026#34;https://demo.duendesoftware.com/connect/token\u0026#34;; client.ClientId = \u0026#34;ff8ac57f-5ade-47f1-b8cd-4c2424672351\u0026#34;; client.ClientSecret = \u0026#34;4dbbf8ec-d62a-4639-b0db-aa5357a0cf46\u0026#34;; client.Scope = \u0026#34;invoice customers\u0026#34;; }); HTTP Client Factory You can register HTTP clients with the factory that will automatically use the above client definitions to request and use access tokens.\nThe following code registers an HTTP client called invoices to automatically use the invoice.client definition:\nservices.AddClientCredentialsHttpClient(\u0026#34;invoices\u0026#34;, \u0026#34;invoice.client\u0026#34;, client =\u0026gt; { client.BaseAddress = new Uri(\u0026#34;https://apis.company.com/invoice/\u0026#34;); }); You can also setup a typed HTTP client to use a token client definition, e.g.:\nservices.AddHttpClient\u0026lt;CatalogClient\u0026gt;(client =\u0026gt; { client.BaseAddress = new Uri(\u0026#34;https://apis.company.com/catalog/\u0026#34;); }) .AddClientCredentialsTokenHandler(\u0026#34;catalog.client\u0026#34;); Usage There are two fundamental ways to interact with token management - manually, or via the HTTP factory.\nManual You can retrieve the current access token for a given token client via IClientCredentialsTokenManagementService.GetAccessTokenAsync.\npublic class WorkerManual : BackgroundService { private readonly IHttpClientFactory _clientFactory; private readonly IClientCredentialsTokenManagementService _tokenManagementService; public WorkerManualIHttpClientFactory factory, IClientCredentialsTokenManagementService tokenManagementService) { _clientFactory = factory; _tokenManagementService = tokenManagementService; } protected override async Task ExecuteAsync(CancellationToken stoppingToken) { while (!stoppingToken.IsCancellationRequested) { var client = _clientFactory.CreateClient(); client.BaseAddress = new Uri(\u0026#34;https://apis.company.com/catalog/\u0026#34;); // get access token for client and set on HttpClient var token = await _tokenManagementService.GetAccessTokenAsync(\u0026#34;catalog.client\u0026#34;); client.SetBearerToken(token.Value); var response = await client.GetAsync(\u0026#34;list\u0026#34;, stoppingToken); // rest omitted } } } You can customize some of the per-request parameters by passing in an instance of ClientCredentialsTokenRequestParameters. This allows forcing a fresh token request (even if a cached token would exist) and also allows setting a per request scope, resource and client assertion.\nHTTP factory If you have setup HTTP clients in the HTTP factory, then no token related code is needed at all, e.g.:\npublic class WorkerHttpClient : BackgroundService { private readonly ILogger\u0026lt;WorkerHttpClient\u0026gt; _logger; private readonly IHttpClientFactory _clientFactory; public WorkerHttpClient(ILogger\u0026lt;WorkerHttpClient\u0026gt; logger, IHttpClientFactory factory) { _logger = logger; _clientFactory = factory; } protected override async Task ExecuteAsync(CancellationToken stoppingToken) { while (!stoppingToken.IsCancellationRequested) { var client = _clientFactory.CreateClient(\u0026#34;invoices\u0026#34;); var response = await client.GetAsync(\u0026#34;test\u0026#34;, stoppingToken); // rest omitted } } } remark The clients in the factory have a message handler attached to them that automatically re-tries the request in case of a 401 response code. The request get re-sent with a newly requested access token. If this still results in a 401, the response is returned to the caller.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/identitymodel.oidcclient/automatic/",
    "title": "Automatic Mode",
    "tags": [],
    "description": "",
    "content": "In automatic mode, you can encapsulate all browser interactions by implementing the IBrowser interface:\nvar options = new OidcClientOptions { Authority = \u0026#34;https://demo.duendesoftware.com\u0026#34;, ClientId = \u0026#34;native\u0026#34;, RedirectUri = redirectUri, Scope = \u0026#34;openid profile api\u0026#34;, Browser = new SystemBrowser() }; var client = new OidcClient(options); Once that is done, authentication and token requests become one line of code:\nvar result = await client.LoginAsync(); "
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/identitymodel/utils/",
    "title": "Constants and Utilities",
    "tags": [],
    "description": "",
    "content": " Protocol and Claim Type Constants Base64 URL Encoding Epoch Time Conversion Creating Authorize and EndSession URLs Fluent X.509 Certificate Store API Time-Constant String Comparison "
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/accesstokenmanagement/advanced/user_tokens/",
    "title": "Customizing User Token Management",
    "tags": [],
    "description": "",
    "content": "The most common way to use the access token management for interactive web applications is described here - however you may want to customise certain aspects of it - here\u0026rsquo;s what you can do.\nGeneral options You can pass in some global options when registering token management in DI.\nChallengeScheme - by default the OIDC configuration is inferred from the default challenge scheme. This is recommended approach. If for some reason your OIDC handler is not the default challenge scheme, you can set the scheme name on the options UseChallengeSchemeScopedTokens - the general assumption is that you only have one OIDC handler configured. If that is not the case, token management needs to maintain multiple sets of token artefacts simultaneously. You can opt-in to that feature using this setting. ClientCredentialsScope - when requesting client credentials tokens from the OIDC provider, the scope parameter will not be set since its value cannot be inferred from the OIDC configuration. With this setting you can set the value of the scope parameter. ClientCredentialsResource - same as previous, but for the resource parameter ClientCredentialStyle - specifies how client credentials are transmitted to the OIDC provider builder.Services.AddOpenIdConnectAccessTokenManagement(options =\u0026gt; { options.ChallengeScheme = \u0026#34;schmeName\u0026#34;; options.UseChallengeSchemeScopedTokens = false; options.ClientCredentialsScope = \u0026#34;api1 api2\u0026#34;; options.ClientCredentialsResource = \u0026#34;urn:resource\u0026#34;; options.ClientCredentialStyle = ClientCredentialStyle.PostBody; }); Per request parameters You can also modify token management parameters on a per-request basis.\nThe UserTokenRequestParameters class can be used for that:\nSignInScheme - allows specifying a sign-in scheme. This is used by the default token store ChallengeScheme - allows specifying a challenge scheme. This is used to infer token service configuration ForceRenewal - forces token retrieval even if a cached token would be available Scope - overrides the globally configured scope parameter Resource - override the globally configured resource parameter Assertion - allows setting a client assertion for the request The request parameters can be passed via the manual API\nvar token = await _tokenManagementService.GetAccessTokenAsync(User, new UserAccessTokenRequestParameters { ... }); ..the extension methods\nvar token = await HttpContext.GetUserAccessTokenAsync( new UserTokenRequestParameters { ... }); \u0026hellip;or the HTTP client factory\n// registers HTTP client that uses the managed user access token builder.Services.AddUserAccessTokenHttpClient(\u0026#34;invoices\u0026#34;, parameters: new UserTokenRequestParameters { ... }, configureClient: client =\u0026gt; { client.BaseAddress = new Uri(\u0026#34;https://api.company.com/invoices/\u0026#34;); }); // registers a typed HTTP client with token management support builder.Services.AddHttpClient\u0026lt;InvoiceClient\u0026gt;(client =\u0026gt; { client.BaseAddress = new Uri(\u0026#34;https://api.company.com/invoices/\u0026#34;); }) .AddUserAccessTokenHandler(new UserTokenRequestParameters { ... }); Token storage By default the user\u0026rsquo;s access and refresh token will be store in the ASP.NET Core autentication session (implemented by the cookie handler).\nYou can modify this in two ways\nthe cookie handler itself has an extensible storage mechanism via the TicketStore mechanism replace the store altogether by providing an IUserTokenStore implementation "
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/identitymodel/endpoints/discovery/",
    "title": "Discovery Endpoint",
    "tags": [],
    "description": "",
    "content": "The client library for the OpenID Connect discovery endpoint is provided as an extension method for HttpClient. The GetDiscoveryDocumentAsync method returns a DiscoveryResponse object that has both strong and weak typed accessors for the various elements of the discovery document.\nYou should always check the IsError and Error properties before accessing the contents of the document.\nExample:\nvar client = new HttpClient(); var disco = await client.GetDiscoveryDocumentAsync(\u0026#34;https://demo.duendesoftware.com\u0026#34;); if (disco.IsError) throw new Exception(disco.Error); Standard elements can be accessed by using properties:\nvar tokenEndpoint = disco.TokenEndpoint; var keys = disco.KeySet.Keys; Custom elements (or elements not covered by the standard properties) can be accessed like this:\n// returns string or null var stringValue = disco.TryGetString(\u0026#34;some_string_element\u0026#34;); // return a nullable boolean var boolValue = disco.TryGetBoolean(\u0026#34;some_boolean_element\u0026#34;); // return array (maybe empty) var arrayValue = disco.TryGetStringArray(\u0026#34;some_array_element\u0026#34;); // returns JToken var rawJson = disco.TryGetValue(\u0026#34;some_element\u0026#34;); Discovery Policy By default, the discovery response is validated before it is returned to the client, validation includes:\nenforce that HTTPS is used (except for localhost addresses) enforce that the issuer matches the authority enforce that the protocol endpoints are on the same DNS name as the authority enforce the existence of a keyset Policy violation errors will set the ErrorType property on the DiscoveryResponse to PolicyViolation.\nAll of the standard validation rules can be modified using the DiscoveryPolicy class, e.g. disabling the issuer name check:\nvar disco = await client.GetDiscoveryDocumentAsync(new DiscoveryDocumentRequest { Address = \u0026#34;https://demo.duendesoftware.com\u0026#34;, Policy = { ValidateIssuerName = false } }); When the URIs in the discovery document are on a different base address than the issuer URI, you may encounter the error Endpoint is on a different host than authority. For such scenario, additional endpoint base addresses can be configured:\nvar disco = await client.GetDiscoveryDocumentAsync(new DiscoveryDocumentRequest { Address = \u0026#34;https://demo.duendesoftware.com\u0026#34;, Policy = { AdditionalEndpointBaseAddresses = [ \u0026#34;https://auth.domain.tld\u0026#34; ] } }); You can also customize validation strategy based on the authority with your own implementation of IAuthorityValidationStrategy. By default, comparison uses ordinal string comparison. To switch to Uri comparison:\nvar disco = await client.GetDiscoveryDocumentAsync(new DiscoveryDocumentRequest { Address = \u0026#34;https://demo.duendesoftware.com\u0026#34;, Policy = { AuthorityValidationStrategy = new AuthorityUrlValidationStrategy() } }); Caching the Discovery Document You should periodically update your local copy of the discovery document, to be able to react to configuration changes on the server. This is especially important for playing nice with automatic key rotation.\nThe DiscoveryCache class can help you with that.\nThe following code will set-up the cache, retrieve the document the first time it is needed, and then cache it for 24 hours:\nvar cache = new DiscoveryCache(\u0026#34;https://demo.duendesoftware.com\u0026#34;); You can then access the document like this:\nvar disco = await cache.GetAsync(); if (disco.IsError) throw new Exception(disco.Error); You can specify the cache duration using the CacheDuration property and also specify a custom discovery policy by passing in a DiscoveryPolicy to the constructor.\nCaching and HttpClient Instances By default the discovery cache will create a new instance of HttpClient every time it needs to access the discovery endpoint. You can modify this behavior in two ways, either by passing in a pre-created instance into the constructor, or by providing a function that will return an HttpClient when needed.\nThe following code will setup the discovery cache in DI and will use the HttpClientFactory to create clients:\nservices.AddSingleton\u0026lt;IDiscoveryCache\u0026gt;(r =\u0026gt; { var factory = r.GetRequiredService\u0026lt;IHttpClientFactory\u0026gt;(); return new DiscoveryCache(Constants.Authority, () =\u0026gt; factory.CreateClient()); }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/identitymodel/",
    "title": "IdentityModel",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityModel The Duende.IdentityModel package is the base library for OIDC and OAuth 2.0 related protocol operations. It provides an object model to interact with the endpoints defined in the various OAuth and OpenId Connect specifications in the form of types to represent the requests and responses, extension methods to invoke requests constants defined in the specifications, such as standard scope, claim, and parameter names, and other convenience methods for performing common identity related operations.\nDuende.IdentityModel targets .NET Standard 2.0, making it suitable for .NET and .NET Framework.\nEndpoints Constants and Utilities "
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/accesstokenmanagement/web_apps/",
    "title": "Web Applications",
    "tags": [],
    "description": "",
    "content": "Overview This library automates all the tasks around access token lifetime management for user-centric web applications.\nWhile many of the details can be customized, by default the following is assumed:\nASP.NET Core web application cookie authentication handler for session management OpenID Connect authentication handler for authentication and access token requests against an OpenID Connect compliant token service the token service returns a refresh token Setup By default, the token management library will use the ASP.NET Core default authentication scheme for token storage (this is typically the cookie handler and its authentication session), and the default challenge scheme for deriving token client configuration for refreshing tokens or requesting client credential tokens (this is typically the OpenID Connect handler pointing to your trusted authority).\n// setting up default schemes and handlers builder.Services.AddAuthentication(options =\u0026gt; { options.DefaultScheme = \u0026#34;cookie\u0026#34;; options.DefaultChallengeScheme = \u0026#34;oidc\u0026#34;; }) .AddCookie(\u0026#34;cookie\u0026#34;, options =\u0026gt; { options.Cookie.Name = \u0026#34;web\u0026#34;; // automatically revoke refresh token at signout time options.Events.OnSigningOut = async e =\u0026gt; { await e.HttpContext.RevokeRefreshTokenAsync(); }; }) .AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { options.Authority = \u0026#34;https://sts.company.com\u0026#34;; options.ClientId = \u0026#34;webapp\u0026#34;; options.ClientSecret = \u0026#34;secret\u0026#34;; options.ResponseType = \u0026#34;code\u0026#34;; options.ResponseMode = \u0026#34;query\u0026#34;; options.Scope.Clear(); // OIDC related scopes options.Scope.Add(\u0026#34;openid\u0026#34;); options.Scope.Add(\u0026#34;profile\u0026#34;); options.Scope.Add(\u0026#34;email\u0026#34;); // API scopes options.Scope.Add(\u0026#34;invoice\u0026#34;); options.Scope.Add(\u0026#34;customer\u0026#34;); // requests a refresh token options.Scope.Add(\u0026#34;offline_access\u0026#34;); options.GetClaimsFromUserInfoEndpoint = true; options.MapInboundClaims = false; // important! this store the access and refresh token in the authentication session // this is needed to the standard token store to manage the artefacts options.SaveTokens = true; options.TokenValidationParameters = new TokenValidationParameters { NameClaimType = \u0026#34;name\u0026#34;, RoleClaimType = \u0026#34;role\u0026#34; }; }); // adds services for token management builder.Services.AddOpenIdConnectAccessTokenManagement(); HTTP client factory Similar to the worker service support, you can register HTTP clients that automatically send the access token of the current user when making API calls. The message handler plumbing associated with those HTTP clients will try to make sure, the access token is always valid and not expired.\n// registers HTTP client that uses the managed user access token builder.Services.AddUserAccessTokenHttpClient(\u0026#34;invoices\u0026#34;, configureClient: client =\u0026gt; { client.BaseAddress = new Uri(\u0026#34;https://api.company.com/invoices/\u0026#34;); }); This could be also a typed client:\n// registers a typed HTTP client with token management support builder.Services.AddHttpClient\u0026lt;InvoiceClient\u0026gt;(client =\u0026gt; { client.BaseAddress = new Uri(\u0026#34;https://api.company.com/invoices/\u0026#34;); }) .AddUserAccessTokenHandler(); Of course, the ASP.NET Core web application host could also do machine to machine API calls that are independent of a user. In this case all the token client configuration can be inferred from the OpenID Connect handler configuration. The following registers an HTTP client that uses a client credentials token for outgoing calls:\n// registers HTTP client that uses the managed client access token builder.Services.AddClientAccessTokenHttpClient(\u0026#34;masterdata.client\u0026#34;, configureClient: client =\u0026gt; { client.BaseAddress = new Uri(\u0026#34;https://api.company.com/masterdata/\u0026#34;); }); ..and as a typed client:\nbuilder.Services.AddHttpClient\u0026lt;MasterDataClient\u0026gt;(client =\u0026gt; { client.BaseAddress = new Uri(\u0026#34;https://api.company.com/masterdata/\u0026#34;); }) .AddClientAccessTokenHandler(); Usage There are three ways to interact with the token management service:\nmanually HTTP context extension methods HTTP client factory Manually You can get the current user and client access token manually by writing code against the IUserTokenManagementService.\npublic class HomeController : Controller { private readonly IHttpClientFactory _httpClientFactory; private readonly IUserTokenManagementService _tokenManagementService; public HomeController(IHttpClientFactory httpClientFactory, IUserTokenManagementService tokenManagementService) { _httpClientFactory = httpClientFactory; _tokenManagementService = tokenManagementService; } public async Task\u0026lt;IActionResult\u0026gt; CallApi() { var token = await _tokenManagementService.GetAccessTokenAsync(User); var client = _httpClientFactory.CreateClient(); client.SetBearerToken(token.Value); var response = await client.GetAsync(\u0026#34;https://api.company.com/invoices\u0026#34;); // rest omitted } } HTTP context extension methods There are three extension methods on the HTTP context that simplify interaction with the token management service:\nGetUserAccessTokenAsync - returns an access token representing the user. If the current access token is expired, it will be refreshed. GetClientAccessTokenAsync - returns an access token representing the client. If the current access token is expired, a new one will be requested RevokeRefreshTokenAsync - revokes the refresh token public async Task\u0026lt;IActionResult\u0026gt; CallApi() { var token = await HttpContext.GetUserAccessTokenAsync(); var client = _httpClientFactory.CreateClient(); client.SetBearerToken(token.Value); var response = await client.GetAsync(\u0026#34;https://api.company.com/invoices\u0026#34;); // rest omitted } HTTP client factory Last but not least, if you registered clients with the factory, you can simply use them. They will try to make sure that a current access token is always sent along. If that is not possible, ultimately a 401 will be returned to the calling code.\npublic async Task\u0026lt;IActionResult\u0026gt; CallApi() { var client = _httpClientFactory.CreateClient(\u0026#34;invoices\u0026#34;); var response = await client.GetAsync(\u0026#34;list\u0026#34;); // rest omitted } \u0026hellip;or for a typed client:\npublic async Task\u0026lt;IActionResult\u0026gt; CallApi([FromServices] InvoiceClient client) { var response = await client.GetList(); // rest omitted } "
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/accesstokenmanagement/blazor_server/",
    "title": "Blazor Server",
    "tags": [],
    "description": "",
    "content": "Overview Blazor Server applications have the same token management requirements as a regular ASP.NET Core web application. Because Blazor Server streams content to the application over a websocket, there often is no HTTP request or response to interact with during the execution of a Blazor Server application. You therefore cannot use HttpContext in a Blazor Server application as you would in a traditional ASP.NET Core web application.\nThis means:\nyou cannot use HttpContext extension methods you cannot use the ASP.NET authentication session to store tokens the normal mechanism used to automatically attach tokens to Http Clients making API calls won\u0026rsquo;t work Fortunately, Duende.AccessTokenManagement provides a straightforward solution to these problems. Also see the BlazorServer sample for source code of a full example.\nToken storage Since the tokens cannot be managed in the authentication session, you need to store them somewhere else. The options include an in-memory data structure, a distributed cache like redis, or a database. Duende.AccessTokenManagement describes this store for tokens with the IUserTokenStore interface. In non-blazor scenarios, the default implementation that stores the tokens in the session is used. In your Blazor server application, you\u0026rsquo;ll need to decide where you want to store the tokens and implement the store interface.\nThe store interface is very simple. StoreTokenAsync adds a token to the store for a particular user, GetTokenAsync retrieves the user\u0026rsquo;s token, and ClearTokenAsync clears the tokens stored for a particular user. A sample implementation that stores the tokens in memory can be found in the ServerSideTokenStore in the BlazorServer sample.\nRegister your token store in the DI container and tell Duende.AccessTokenManagement to integrate with Blazor by calling AddBlazorServerAccessTokenManagement:\nbuilder.Services.AddOpenIdConnectAccessTokenManagement() .AddBlazorServerAccessTokenManagement\u0026lt;ServerSideTokenStore\u0026gt;(); Once you\u0026rsquo;ve registered your token store, you need to use it. You initialize the token store with the TokenValidated event in the OpenID Connect handler:\npublic class OidcEvents : OpenIdConnectEvents { private readonly IUserTokenStore _store; public OidcEvents(IUserTokenStore store) { _store = store; } public override async Task TokenValidated(TokenValidatedContext context) { var exp = DateTimeOffset.UtcNow.AddSeconds(Double.Parse(context.TokenEndpointResponse!.ExpiresIn)); await _store.StoreTokenAsync(context.Principal!, new UserToken { AccessToken = context.TokenEndpointResponse.AccessToken, AccessTokenType = context.TokenEndpointResponse.TokenType, Expiration = exp, RefreshToken = context.TokenEndpointResponse.RefreshToken, Scope = context.TokenEndpointResponse.Scope }); await base.TokenValidated(context); } } Once registered and initialized, Duende.AccessTokenManagement will keep the store up to date automatically as tokens are refreshed.\nRetrieving and using tokens If you\u0026rsquo;ve registered your token store with AddBlazorServerAccessTokenManagement, Duende.AccessTokenManagement will register the services necessary to attach tokens to outgoing HTTP requests automatically, using the same API as a non-blazor application. You inject an HTTP client factory and resolve named HTTP clients where ever you need to make HTTP requests, and you register the HTTP client\u0026rsquo;s that use access tokens in the DI system with our extension method:\nbuilder.Services.AddUserAccessTokenHttpClient(\u0026#34;demoApiClient\u0026#34;, configureClient: client =\u0026gt; { client.BaseAddress = new Uri(\u0026#34;https://demo.duendesoftware.com/api/\u0026#34;); }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/accesstokenmanagement/advanced/client_assertions/",
    "title": "Client Assertions",
    "tags": [],
    "description": "",
    "content": "If your token client is using a client assertion instead of a shared secret, you can provide the assertion in two ways\nuse the request parameter mechanism to pass a client assertion to the management implement the IClientAssertionService interface to centralize client assertion creation Here\u0026rsquo;s a sample client assertion service using the Microsoft JWT library:\npublic class ClientAssertionService : IClientAssertionService { private readonly IOptionsSnapshot\u0026lt;ClientCredentialsClient\u0026gt; _options; public ClientAssertionService(IOptionsSnapshot\u0026lt;ClientCredentialsClient\u0026gt; options) { _options = options; } public Task\u0026lt;ClientAssertion?\u0026gt; GetClientAssertionAsync( string? clientName = null, TokenRequestParameters? parameters = null) { if (clientName == \u0026#34;invoice\u0026#34;) { var options = _options.Get(clientName); var descriptor = new SecurityTokenDescriptor { Issuer = options.ClientId, Audience = options.TokenEndpoint, Expires = DateTime.UtcNow.AddMinutes(1), SigningCredentials = GetSigningCredential(), Claims = new Dictionary\u0026lt;string, object\u0026gt; { { JwtClaimTypes.JwtId, Guid.NewGuid().ToString() }, { JwtClaimTypes.Subject, options.ClientId! }, { JwtClaimTypes.IssuedAt, DateTime.UtcNow.ToEpochTime() } }, AdditionalHeaderClaims = new Dictionary\u0026lt;string, object\u0026gt; { { JwtClaimTypes.TokenType, \u0026#34;client-authentication+jwt\u0026#34; } } }; var handler = new JsonWebTokenHandler(); var jwt = handler.CreateToken(descriptor); return Task.FromResult\u0026lt;ClientAssertion?\u0026gt;(new ClientAssertion { Type = OidcConstants.ClientAssertionTypes.JwtBearer, Value = jwt }); } return Task.FromResult\u0026lt;ClientAssertion?\u0026gt;(null); } } "
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/identitymodel.oidcclient/",
    "title": "IdentityModel.OidcClient",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityModel.OidcClient Duende.IdentityModel.OidcClient is an OpenID Connect (OIDC) client library for mobile and native applications in .NET. It is a certified OIDC relying party and implements RFC 8252, \u0026ldquo;OAuth 2.0 for native Applications\u0026rdquo;. It provides types that describe OIDC requests and responses, low level methods to construct protocol state and handle responses, and higher level methods for logging in, logging out, retrieving userinfo, and refreshing tokens.\nOidcClient can be used with .NET and .NET Framework. We support .NET 6.0 or later and .NET Framework 4.6.2 or later.\nYou can use OidcClient to build:\nAndroid and iPhone apps with .NET MAUI Windows Desktop Applications with WPF or WinForms Cross Platform Console Applications Please refer to the following sections for details on how to use this library:\nManual Mode Automatic Mode Logging Samples "
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/identitymodel.oidcclient/logging/",
    "title": "Logging",
    "tags": [],
    "description": "",
    "content": "OidcClient logs errors, warnings, and diagnostic information using Microsoft.Extensions.Logging.ILogger, the standard .NET logging library. You can use any logging provider to store your logs however you like. For example, you could configure Serilog like this:\nvar serilog = new LoggerConfiguration() .MinimumLevel.Verbose() .Enrich.FromLogContext() .WriteTo.LiterateConsole(outputTemplate: \u0026#34;[{Timestamp:HH:mm:ss} {Level}] {SourceContext}{NewLine}{Message}{NewLine}{Exception}{NewLine}\u0026#34;) .CreateLogger(); options.LoggerFactory.AddSerilog(serilog); "
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/identitymodel/endpoints/token/",
    "title": "Token Endpoint",
    "tags": [],
    "description": "",
    "content": "The client library for the token endpoint (OAuth 2.0 and OpenID Connect) is provided as a set of extension methods for HttpClient. This allows creating and managing the lifetime of the HttpClient the way you prefer - e.g. statically or via a factory like the Microsoft HttpClientFactory.\nRequesting a token The main extension method is called RequestTokenAsync - it has direct support for standard parameters like client ID/secret (or assertion) and grant type, but it also allows setting arbitrary other parameters via a dictionary. All other extensions methods ultimately call this method internally:\nvar client = new HttpClient(); var response = await client.RequestTokenAsync(new TokenRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/token\u0026#34;, GrantType = \u0026#34;custom\u0026#34;, ClientId = \u0026#34;client\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Parameters = { { \u0026#34;custom_parameter\u0026#34;, \u0026#34;custom value\u0026#34;}, { \u0026#34;scope\u0026#34;, \u0026#34;api1\u0026#34; } } }); The response is of type TokenResponse and has properties for the standard token response parameters like access_token, expires_in etc. You also have access to the the raw response as well as to a parsed JSON document (via the Raw and Json properties).\nBefore using the response, you should always check the IsError property to make sure the request was successful:\nif (response.IsError) throw new Exception(response.Error); var token = response.AccessToken; var custom = response.Json.TryGetString(\u0026#34;custom_parameter\u0026#34;); Requesting a token using the client_credentials Grant Type The RequestClientCredentialsToken extension method has convenience properties for the client_credentials grant type:\nvar response = await client.RequestClientCredentialsTokenAsync(new ClientCredentialsTokenRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/token\u0026#34;, ClientId = \u0026#34;client\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Scope = \u0026#34;api1\u0026#34; }); Requesting a token using the password Grant Type The RequestPasswordToken extension method has convenience properties for the password grant type:\nvar response = await client.RequestPasswordTokenAsync(new PasswordTokenRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/token\u0026#34;, ClientId = \u0026#34;client\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Scope = \u0026#34;api1\u0026#34;, UserName = \u0026#34;bob\u0026#34;, Password = \u0026#34;bob\u0026#34; }); Requesting a token using the authorization_code Grant Type The RequestAuthorizationCodeToken extension method has convenience properties for the authorization_code grant type and PKCE:\nvar response = await client.RequestAuthorizationCodeTokenAsync(new AuthorizationCodeTokenRequest { Address = IdentityServerPipeline.TokenEndpoint, ClientId = \u0026#34;client\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Code = code, RedirectUri = \u0026#34;https://app.com/callback\u0026#34;, // optional PKCE parameter CodeVerifier = \u0026#34;xyz\u0026#34; }); Requesting a token using the refresh_token Grant Type The RequestRefreshToken extension method has convenience properties for the refresh_token grant type:\nvar response = await _client.RequestRefreshTokenAsync(new RefreshTokenRequest { Address = TokenEndpoint, ClientId = \u0026#34;client\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, RefreshToken = \u0026#34;xyz\u0026#34; }); Requesting a Device Token The RequestDeviceToken extension method has convenience properties for the urn:ietf:params:oauth:grant-type:device_code grant type:\nvar response = await client.RequestDeviceTokenAsync(new DeviceTokenRequest { Address = disco.TokenEndpoint, ClientId = \u0026#34;device\u0026#34;, DeviceCode = authorizeResponse.DeviceCode }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/identitymodel/utils/base64/",
    "title": "Base64 URL Encoding",
    "tags": [],
    "description": "",
    "content": "JWT tokens are serialized using Base64 URL encoding.\nIdentityModel includes the Base64Url class to help with encoding/decoding:\nvar text = \u0026#34;hello\u0026#34;; var b64url = Base64Url.Encode(text); text = Base64Url.Decode(b64url); ASP.NET Core has built-in support via WebEncoders.Base64UrlEncode and WebEncoders.Base64UrlDecode.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/accesstokenmanagement/advanced/dpop/",
    "title": "DPoP",
    "tags": [],
    "description": "",
    "content": "DPoP specifies how to bind an asymmetric key stored within a JSON Web Key (JWK) to an access token. This will make the access token bound to the key such that if the access token were to leak, it cannot be used without also having access to the private key of the corresponding JWK.\nThe \u0026ldquo;Duende.AccessTokenManagement\u0026rdquo; library supports DPoP.\nDPoP Key The main piece that your hosting application needs to concern itself with is how to obtain (and manage) the DPoP key. This key (and signing algorithm) will be either a \u0026ldquo;RS\u0026rdquo;, \u0026ldquo;PS\u0026rdquo;, or \u0026ldquo;ES\u0026rdquo; style key, and needs to be in the form of a JSON Web Key (or JWK). Consult the specification for more details.\nThe creation and management of this DPoP key is up to the policy of the client. For example is can be dynamically created when the client starts up, and can be periodically rotated. The main constraint is that it must be stored for as long as the client uses any access tokens (and possibly refresh tokens) that they are bound to, which this library will manage for you.\nCreating a JWK in .NET is simple:\nvar rsaKey = new RsaSecurityKey(RSA.Create(2048)); var jwkKey = JsonWebKeyConverter.ConvertFromSecurityKey(rsaKey); jwkKey.Alg = \u0026#34;PS256\u0026#34;; var jwk = JsonSerializer.Serialize(jwkKey); Key Configuration Once you have a JWK you wish to use, then it must be configured or made available to this library. That can be done in one of two ways:\nConfigure the key at startup by setting the DPoPJsonWebKey property on either the ClientCredentialsTokenManagementOptions or UserTokenManagementOptions (depending on which of the two styles you are using from this library). Implement the IDPoPKeyStore interface to produce the key at runtime. Here\u0026rsquo;s a sample configuring the key in an application using AddOpenIdConnectAccessTokenManagement in the startup code:\nservices.AddOpenIdConnectAccessTokenManagement(options =\u0026gt; { options.DPoPJsonWebKey = jwk; }); Similarly for an application using AddClientCredentialsTokenManagement it would look like this:\nservices.AddClientCredentialsTokenManagement() .AddClient(\u0026#34;client_name\u0026#34;, options =\u0026gt; { options.DPoPJsonWebKey = jwk; }); Proof Tokens at the token server\u0026rsquo;s token endpoint Once the key has been configured for the client, then the library will use it to produce a DPoP proof token when calling the token server (including token renewals if relevant). There is nothing explicit needed on behalf of the developer using this library.\ndpop_jkt at the token server\u0026rsquo;s authorize endpoint When using DPoP and AddOpenIdConnectAccessTokenManagement, this library will also automatically include the dpop_jkt parameter to the authorize endpoint.\nProof Tokens at the API Once the library has obtained a DPoP bound access token for the client, then if your application is using any of the HttpClient client factory helpers (e.g. AddClientCredentialsHttpClient or AddUserAccessTokenHttpClient) then those outbound HTTP requests will automatically include a DPoP proof token for the associated DPoP access token.\nConsiderations A point to keep in mind when using DPoP and AddOpenIdConnectAccessTokenManagement is that the DPoP proof key is created per user session. This proof key must be store somewhere, and the AuthenticationProperties used by both the OIDC and cookie handlers is what is used to store this key. This implies that the OIDC state parameter will increase in size, as well the resultant cookie that represents the user\u0026rsquo;s session. The storage of each of these can be customized with the properties on the options StateDataFormat and SessionStore respectively.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/identitymodel.oidcclient/samples/",
    "title": "Samples",
    "tags": [],
    "description": "",
    "content": "Samples of IdentityModel.OidcClient are available on GitHub. Our samples show how to use a OidcClient with a variety of platforms and UI tools, including:\n.NET MAUI WPF with the system browser WPF with an embedded browser WinForms with an embedded browser Cross Platform Console Applications (relies on kestrel for processing the callback) Windows Console Applications (relies on an HttpListener - a wrapper around the windows HTTP.sys driver) Windows Console Applications using custom uri schemes All samples use a demo instance of Duende.IdentityServer (https://demo.duendesoftware.com) as their OIDC Provider. You can see its source code here.\nYou can login with alice/alice or bob/bob\nAdditional samples Unity3D No longer maintained These samples are no longer maintained because their underlying technology is no longer supported.\nUWP Xamarin Xamarin Forms Xamarin iOS - AuthenticationServices Xamarin iOS - SafariServices "
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/identitymodel/endpoints/introspection/",
    "title": "Token Introspection Endpoint",
    "tags": [],
    "description": "",
    "content": "The client library for OAuth 2.0 token introspection is provided as an extension method for HttpClient.\nThe following code sends a reference token to an introspection endpoint:\nvar client = new HttpClient(); var response = await client.IntrospectTokenAsync(new TokenIntrospectionRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/introspect\u0026#34;, ClientId = \u0026#34;api1\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Token = accessToken }); The response is of type TokenIntrospectionResponse and has properties for the standard response parameters. You also have access to the the raw response as well as to a parsed JSON document (via the Raw and Json properties).\nBefore using the response, you should always check the IsError property to make sure the request was successful:\nif (response.IsError) throw new Exception(response.Error); var isActive = response.IsActive; var claims = response.Claims; "
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/accesstokenmanagement/advanced/",
    "title": "Advanced",
    "tags": [],
    "description": "",
    "content": "Advanced The following topics are available in this advanced section:\nCustomizing Client Credentials Token Management Customizing User Token Management Client Assertions DPoP "
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/identitymodel/utils/epoch_time/",
    "title": "Epoch Time Conversion",
    "tags": [],
    "description": "",
    "content": "JWT tokens use so called Epoch or Unix time to represent date/times.\nIdentityModel contains extensions methods for DateTime to convert to/from Unix time:\nvar dt = DateTime.UtcNow; var unix = dt.ToEpochTime(); Starting with .NET Framework 4.6 and .NET Core 1.0 this functionality is built-in via DateTimeOffset.FromUnixTimeSeconds and DateTimeOffset.ToUnixTimeSeconds.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/identitymodel/endpoints/revocation/",
    "title": "Token Revocation Endpoint",
    "tags": [],
    "description": "",
    "content": "The client library for OAuth 2.0 token revocation is provided as an extension method for HttpClient.\nThe following code revokes an access token token at a revocation endpoint:\nvar client = new HttpClient(); var result = await client.RevokeTokenAsync(new TokenRevocationRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/revocation\u0026#34;, ClientId = \u0026#34;client\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Token = accessToken }); The response is of type TokenRevocationResponse gives you access to the the raw response as well as to a parsed JSON document (via the Raw and Json properties).\nBefore using the response, you should always check the IsError property to make sure the request was successful:\nif (response.IsError) throw new Exception(response.Error); "
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/identitymodel/endpoints/userinfo/",
    "title": "UserInfo Endpoint",
    "tags": [],
    "description": "",
    "content": "The client library for the OpenID Connect UserInfo endpoint is provided as an extension method for HttpClient.\nThe following code sends an access token to the UserInfo endpoint:\nvar client = new HttpClient(); var response = await client.GetUserInfoAsync(new UserInfoRequest { Address = disco.UserInfoEndpoint, Token = token }); The response is of type UserInfoResponse and has properties for the standard response parameters. You also have access to the the raw response as well as to a parsed JSON document (via the Raw and Json properties).\nBefore using the response, you should always check the IsError property to make sure the request was successful:\nif (response.IsError) throw new Exception(response.Error); var claims = response.Claims; "
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/identitymodel/utils/request_url/",
    "title": "Creating Authorize and EndSession URLs",
    "tags": [],
    "description": "",
    "content": "The RequestUrl class is a helper for creating URLs with query string parameters, e.g.:\nvar ru = new RequestUrl(\u0026#34;https://server/endpoint\u0026#34;); // produces https://server/endpoint?foo=foo\u0026amp;bar=bar var url = ru.Create(new { foo: \u0026#34;foo\u0026#34;, bar: \u0026#34;bar\u0026#34; }); As a parameter to the Create method you can either pass in an object, or a string dictionary. In both cases the properties/values will be serialized to key/value pairs.\nAll values will be URL encoded.\nAuthorization Endpoint For most cases, the OAuth 2.0 and OpenID Connect authorization endpoint expects a GET request with a number of query string parameters.\nThe CreateAuthorizeUrl extension method creates URLs for the authorize endpoint - it has support the most common parameters:\n/// \u0026lt;summary\u0026gt; /// Creates an authorize URL. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;request\u0026#34;\u0026gt;The request.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;clientId\u0026#34;\u0026gt;The client identifier.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;responseType\u0026#34;\u0026gt;The response type.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;scope\u0026#34;\u0026gt;The scope.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;redirectUri\u0026#34;\u0026gt;The redirect URI.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;state\u0026#34;\u0026gt;The state.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;nonce\u0026#34;\u0026gt;The nonce.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;loginHint\u0026#34;\u0026gt;The login hint.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;acrValues\u0026#34;\u0026gt;The acr values.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;prompt\u0026#34;\u0026gt;The prompt.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;responseMode\u0026#34;\u0026gt;The response mode.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;codeChallenge\u0026#34;\u0026gt;The code challenge.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;codeChallengeMethod\u0026#34;\u0026gt;The code challenge method.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;display\u0026#34;\u0026gt;The display option.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;maxAge\u0026#34;\u0026gt;The max age.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;uiLocales\u0026#34;\u0026gt;The ui locales.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;idTokenHint\u0026#34;\u0026gt;The id_token hint.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;extra\u0026#34;\u0026gt;Extra parameters.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static string CreateAuthorizeUrl(this RequestUrl request, string clientId, string responseType, string scope = null, string redirectUri = null, string state = null, string nonce = null, string loginHint = null, string acrValues = null, string prompt = null, string responseMode = null, string codeChallenge = null, string codeChallengeMethod = null, string display = null, int? maxAge = null, string uiLocales = null, string idTokenHint = null, object extra = null) { ... } Example:\nvar ru = new RequestUrl(\u0026#34;https://demo.duendesoftware.com/connect/authorize\u0026#34;); var url = ru.CreateAuthorizeUrl( clientId: \u0026#34;client\u0026#34;, responseType: \u0026#34;implicit\u0026#34;, redirectUri: \u0026#34;https://app.com/callback\u0026#34;, nonce: \u0026#34;xyz\u0026#34;, scope: \u0026#34;openid\u0026#34;); The extra parameter can either be a string dictionary or an arbitrary other type with properties. In both cases the values will be serialized as keys/values.\nEndSession Endpoint The CreateEndSessionUrl extensions methods supports the most common parameters:\n/// \u0026lt;summary\u0026gt; /// Creates a end_session URL. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;request\u0026#34;\u0026gt;The request.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;idTokenHint\u0026#34;\u0026gt;The id_token hint.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;postLogoutRedirectUri\u0026#34;\u0026gt;The post logout redirect URI.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;state\u0026#34;\u0026gt;The state.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;extra\u0026#34;\u0026gt;The extra parameters.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static string CreateEndSessionUrl(this RequestUrl request, string idTokenHint = null, string postLogoutRedirectUri = null, string state = null, object extra = null) { ... } The extra parameter can either be a string dictionary or an arbitrary other type with properties. In both cases the values will be serialized as keys/values.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/identitymodel/endpoints/dynamic_registration/",
    "title": "Dynamic Client Registration",
    "tags": [],
    "description": "",
    "content": "The client library for OpenID Connect Dynamic Client Registration is provided as an extension method for HttpClient.\nThe following code sends a registration request:\nvar client = new HttpClient(); var response = await client.RegisterClientAsync(new DynamicClientRegistrationRequest { Address = Endpoint, Document = new DynamicClientRegistrationDocument { RedirectUris = { redirectUri }, ApplicationType = \u0026#34;native\u0026#34; } }); The DynamicClientRegistrationDocument class has strongly typed properties for all standard registration parameters as defines by the specification. If you want to add custom parameters, it is recommended to derive from this class and add your own properties.\nThe response is of type RegistrationResponse and has properties for the standard response parameters. You also have access to the the raw response as well as to a parsed JSON document (via the Raw and Json properties).\nBefore using the response, you should always check the IsError property to make sure the request was successful:\nif (response.IsError) throw new Exception(response.Error); var clientId = response.ClientId; var secret = response.ClientSecret; "
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/identitymodel/utils/x509store/",
    "title": "Fluent X.509 Certificate Store API",
    "tags": [],
    "description": "",
    "content": "A common place to store X.509 certificates is the Windows X.509 certificate store. The raw APIs for the store are a bit arcane (and also slightly changed between .NET Framework and .NET Core).\nThe X509 class is a simplified API to load certificates from the store. The following code loads a certificate by name from the personal machine store:\nvar cert = X509 .LocalMachine .My .SubjectDistinguishedName .Find(\u0026#34;CN=sts\u0026#34;) .FirstOrDefault(); You can load certs from the machine or user store and from My, AddressBook, TrustedPeople, CertificateAuthority and TrustedPublisher respectively. You can search for subject name, thumbprint, issuer name or serial number.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/identitymodel/utils/time_constant_comparison/",
    "title": "Time-Constant String Comparison",
    "tags": [],
    "description": "",
    "content": "When comparing strings in a security context (e.g. comparing keys), you should avoid leaking timing information.\nStandard string comparison algorithms are optimized to stop comparing characters as soon as a difference is found. An attacker can exploit this by making many requests with strings that all differ in the first character. The strings that begin with an incorrect first character will make a single character comparison and stop. However, the strings that begin with a correct first character will need to make additional string comparisons, and thus take more time before they stop. Sophisticated attackers can measure this difference and use it to deduce the characters that their input is being compared to.\nThe TimeConstantComparer class defends against these timing attacks by implementing a constant-time string comparison. The string comparison is a constant-time operation in the sense that comparing strings of equal length always performs the same amount of work.\nUsage example:\nvar isEqual = TimeConstantComparer.IsEqual(key1, key2); Starting with .NET Core 2.1 this functionality is built in via CryptographicOperations.FixedTimeEquals\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/foss/identitymodel/endpoints/device_authorize/",
    "title": "Device Authorization Endpoint",
    "tags": [],
    "description": "",
    "content": "The client library for the OAuth 2.0 device flow device authorization is provided as an extension method for HttpClient.\nThe following code sends a device authorization request:\nvar client = new HttpClient(); var response = await client.RequestDeviceAuthorizationAsync(new DeviceAuthorizationRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/device_authorize\u0026#34;, ClientId = \u0026#34;device\u0026#34; }); The response is of type DeviceAuthorizationResponse and has properties for the standard response parameters. You also have access to the the raw response as well as to a parsed JSON document (via the Raw and Json properties).\nBefore using the response, you should always check the IsError property to make sure the request was successful:\nif (response.IsError) throw new Exception(response.Error); var userCode = response.UserCode; var deviceCode = response.DeviceCode; var verificationUrl = response.VerificationUri; var verificationUrlComplete = response.VerificationUriComplete; "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/endpoints/discovery/",
    "title": "Discovery Endpoint",
    "tags": [],
    "description": "",
    "content": "The discovery endpoint can be used to retrieve metadata about your IdentityServer - it returns information like the issuer name, key material, supported scopes etc.\nThe discovery endpoint is available via /.well-known/openid-configuration relative to the base address, e.g.:\nhttps://demo.duendesoftware.com/.well-known/openid-configuration .NET client library You can use the IdentityModel client library to programmatically interact with the protocol endpoint from .NET code.\nvar client = new HttpClient(); var disco = await client.GetDiscoveryDocumentAsync(\u0026#34;https://demo.duendesoftware.com\u0026#34;); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/",
    "title": "IdentityServer (v5)",
    "tags": [],
    "description": "",
    "content": "Duende IdentityServer v5 Documentation The most flexible \u0026amp; standards-compliant OpenID Connect and OAuth 2.0 framework for ASP.NET Core.\nThis is the documentation for version 5.x. You can find the v6.x documentation here and the v7.x documentation here.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/bff/overview/",
    "title": "Overview",
    "tags": [],
    "description": "",
    "content": "Writing a browser-based application is hard, and when it comes to security, the guidance changes every year. It all started with securing your Ajax calls with cookies until we learned that this is prone to CSRF attacks. Then the IETF made JS-based OAuth official by introducing the Implicit Flow; until we learned how hard it is to protect against XSS, token leakage and the threat of token exfiltration. Seems you cannot win.\nIn the meantime the IETF realized that Implicit Flow is an anachronism and will deprecate it. So what\u0026rsquo;s next?\nThere is ongoing work in the OAuth for browser-based Apps BCP document to give practical guidance on this very topic. The document distinguishes between two architectural approaches: \u0026ldquo;JavaScript Applications with a Backend\u0026rdquo; and \u0026ldquo;JavaScript Applications without a Backend\u0026rdquo;. If you don\u0026rsquo;t have the luxury of a backend, the more up-to-date recommendation is to use authorization code flow with PKCE and refresh tokens (with additional steps necessary in the token server to mitigate refresh token abuse). We think this approach is problematic because it encourages storing your tokens in the browser.\nSee Philippe\u0026rsquo;s webinar on XSS and storing tokens in the browser for a good background on why this is not secure enough.\nIf you have a backend, the backend can help out the frontend with many security related tasks like protocol flow, token storage, token lifetime management, and session management among other things. With the advent of more modern security features in browsers (e.g. anti-forgery countermeasures), this is our preferred approach and we already detailed this in January 2019 here. This is also often called the BFF (Backend for Frontend) pattern.\nLet\u0026rsquo;s have a closer look at all the problems the BFF pattern solves.\n\u0026ldquo;No tokens in the browser\u0026rdquo; Policy This is definitely the elephant in the room. More and more companies are coming to the conclusion that the threat of token exfiltration is too big of an unknown and that no high value access tokens should be stored in JavaScript accessible locations.\nIt\u0026rsquo;s not only your own code that must be XSS-proof. It\u0026rsquo;s also all the frameworks, libraries and NPM packages you are pulling in (as well as their dependencies). And even worse, you have to worry about other people\u0026rsquo;s code running on your domain. The recent work around Spectre attacks against browsers illustrates nicely that there is more to come.\nStoring tokens on the server-side and using encrypted/signed HTTP-only cookies for session management makes that threat model considerably easier. This is not to say that this makes the application \u0026ldquo;auto-magically\u0026rdquo; secure against content injection, but forcing the attacker through a well defined interface to the backend gives you way more leverage than being able to make arbitrary API calls with a stolen token.\nReact to changes in the browser security models We wrote about this before, but in a nutshell browsers are (and will be even more in the future) restricting the usage of cookies across site boundaries to protect users from privacy invasion techniques. The problem is that legitimate OAuth \u0026amp; OpenID Connect protocol interactions are from a browser\u0026rsquo;s point of view indistinguishable from common tracking mechanisms.\nThis affects:\nfront-channel logout notifications (used in pretty much every authentication protocol – like SAML, WS-Fed and OpenID Connect) the OpenID Connect JavaScript session management the “silent renew” technique that was recommended to give your application session bound token refreshing To overcome these limitations we need the help of an application backend to bridge the gap to the authentication system, do more robust server-side token management with refresh tokens, and provide support for more future proof mechanisms like back-channel logout notifications.\nSimplify the JavaScript frontend protocol interactions and make use of advanced features that only exist server-side And last but not least, writing a robust protocol library for JavaScript is not a trivial task. We are maintaining one of the original OpenID Connect certified JavaScript libraries, and there is a substantial amount of on-going maintenance necessary due to subtle behaviour changes between browsers and their versions.\nOn the server-side though (and especially in our case with ASP.NET Core), we have a full featured and stable OpenID Connect client library that supports all the necessary protocol mechanisms and provides an excellent extensibility model for advanced features like Mutual TLS, Proof-of-Possession, JWT secured authorization requests, and JWT-based client authentication.\nEnter Duende.BFF Duende.BFF is NuGet package that adds all the necessary features required to solve above problems to an ASP.NET Core host. It provides services for session and token management, API endpoint protection and logout notifications to your web-based frontends like SPAs or Blazor WASM applications. Let\u0026rsquo;s have a look at the building blocks in the next section.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/quickstarts/0_overview/",
    "title": "Overview",
    "tags": [],
    "description": "",
    "content": "The quickstarts provide step-by-step instructions for various common Duende IdentityServer scenarios. They start with the absolute basics and become more complex - it is recommended you do them in order.\nadding Duende IdentityServer to an ASP.NET Core application configuring Duende IdentityServer issuing tokens for various clients securing web applications and APIs adding support for EntityFramework based configuration adding support for ASP.NET Identity Every quickstart has a reference solution - you can find the code in the samples folder.\nPreparation The first thing you should do is install our templates:\ndotnet new --install Duende.IdentityServer.Templates They will be used as a starting point for the various tutorials.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/tokens/authentication/overview/",
    "title": "Overview",
    "tags": [],
    "description": "",
    "content": "Confidential and credentialed clients need to authenticate with your IdentityServer before they can request tokens.\nDuende IdentityServer has built-in support for various client credential types and authentication methods, and an extensible infrastructure to customize the authentication system.\nAll information in this section also applies to API secrets for introspection.\nWe recommend using asymmetric client credentials like the private key jwt or Mutual TLS authentication method over shared secrets.\nAssigning secrets A client secret is abstracted by the Secret class. It provides properties for setting the value and type as well as a description and expiration date.\nvar secret = new Secret { Value = \u0026#34;foo\u0026#34;, Type = \u0026#34;bar\u0026#34;, Description = \u0026#34;my custom secret\u0026#34;, Expiration = new DateTime(2021,12,31) } You can assign multiple secrets to a client to enable roll-over scenarios, e.g.:\nvar primary = new Secret(\u0026#34;foo\u0026#34;); var secondary = new Secret(\u0026#34;bar\u0026#34;); client.ClientSecrets = new[] { primary, secondary }; Secret parsing During request processing, the secret must be somehow extracted from the incoming request. The various specs describe a couple of options, e.g. as part of the authorization header or the body payload.\nIt is the job of implementations of the ISecretParser interface to accomplish this. You can add secret parsers by calling the AddSecretParser() DI extension method.\nThe following secret parsers are part of Duende IdentityServer:\nDuende.IdentityServer.Validation.BasicAuthenticationSecretParser\nparses an OAuth basic authentication formatted Authorization header. Enabled by default.\nDuende.IdentityServer.Validation.PostBodySecretParser\nParses from the client_id and client_secret body fields. Enabled by default.\nDuende.IdentityServer.Validation.JwtBearerClientAssertionSecretParser\nParses a JWT on the client_assertion body field. Can be enabled by calling the AddJwtBearerClientAuthentication DI extension method.\nDuende.IdentityServer.Validation.MutualTlsSecretParser\nParses the client_id body field and TLS client certificate. Can be enabled by calling the AddMutualTlsSecretValidators DI extension method.\nSecret validation It is the job of implementations of the ISecretValidator interface to validate the extracted credentials.\nYou can add secret parsers by calling the AddSecretValidator() DI extension method.\nThe following secret validators are part of Duende IdentityServer:\nDuende.IdentityServer.Validation.HashedSharedSecretValidator\nValidates shared secrets that are stored hashed. Enabled by default.\nDuende.IdentityServer.Validation.PlainTextSharedSecretValidator\nValidates shared secrets that are stored in plaintext.\nDuende.IdentityServer.Validation.PrivateKeyJwtSecretValidator\nValidates JWTs that are signed with either X.509 certificates or keys wrapped in a JWK. Can be enabled by calling the AddJwtBearerClientAuthentication DI extension method.\nDuende.IdentityServer.Validation.X509ThumbprintSecretValidator\nValidates X.509 client certificates based on a thumbprint. Can be enabled by calling the AddMutualTlsSecretValidators DI extension method.\nDuende.IdentityServer.Validation.X509NameSecretValidator\nValidates X.509 client certificates based on a common name. Can be enabled by calling the AddMutualTlsSecretValidators DI extension method.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/tokens/overview/",
    "title": "Overview",
    "tags": [],
    "description": "",
    "content": "Duende IdentityServer is a token service engine based on OAuth 2.x and OpenID Connect.\nHow to request tokens OIDC and OAuth contain two endpoints that can issue tokens - the authorize endpoint and the token endpoint.\nWhile the authorize endpoint can be used for some special cases, you typically use the token endpoint for issuing tokens.\nToken Types The following token types are supported.\nIdentity Token During user authentication, your IdentityServer collects data about the user, e.g. authentication method, authentication time, some protocol information and a unique identifier for the user that was authenticated, to communicate back to the client application “what happened at the token service”.\nThis data must be sent in a format that is both tamper proof and that allows the client to authenticate the issuer. In OIDC this format is JSON – and the way to add the above security properties to a JSON object is by wrapping it in a JWT (along with JWS, JWA and JWK) – hence the name identity token.\nThe data includes token lifetime information (exp, iat, nbf), the authentication method (amr) and time (auth_time), the authentication source (idp), the session ID (sid) and information about the user (sub and name).\n{ \u0026#34;iss\u0026#34;: \u0026#34;https://localhost:5001\u0026#34;, \u0026#34;nbf\u0026#34;: 1609932802, \u0026#34;iat\u0026#34;: 1609932802, \u0026#34;exp\u0026#34;: 1609933102, \u0026#34;aud\u0026#34;: \u0026#34;web_app\u0026#34;, \u0026#34;amr\u0026#34;: [ \u0026#34;pwd\u0026#34; ], \u0026#34;nonce\u0026#34;: \u0026#34;63745529591...I3ZTIyOTZmZTNj\u0026#34;, \u0026#34;sid\u0026#34;: \u0026#34;F6E6F2EDE86EB8731EF609A4FE40ED89\u0026#34;, \u0026#34;auth_time\u0026#34;: 1609932794, \u0026#34;idp\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;88421113\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Bob\u0026#34;, } This data is solely for the client application (the aud claim) that initiated the authentication request, and you never send it to an API to consume. The identity token also contains a nonce (a number used once) to make sure it is only consumed once at the client.\nSee the OpenID Connect specification for more information on identity tokens.\nAccess Token An access token is a data structure that allows a client to access a resource (e.g. an API - see the protecting APIs section for more details).\nThe data associated with an access token typically includes the client ID, the requested scopes, an expiration time, and user information in case of an interactive application. Access tokens come in two flavours: JSON Web Tokens (JWT) or reference tokens.\nIn the case of JWTs, all claims are embedded into the token itself, e.g.:\n{ \u0026#34;iss\u0026#34;: \u0026#34;https://localhost:5001\u0026#34;, \u0026#34;nbf\u0026#34;: 1609932801, \u0026#34;iat\u0026#34;: 1609932801, \u0026#34;exp\u0026#34;: 1609936401, \u0026#34;aud\u0026#34;: \u0026#34;urn:resource1\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;openid resource1.scope1 offline_access\u0026#34;, \u0026#34;amr\u0026#34;: [ \u0026#34;pwd\u0026#34; ], \u0026#34;client_id\u0026#34;: \u0026#34;web_app\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;88421113\u0026#34;, \u0026#34;auth_time\u0026#34;: 1609932794, \u0026#34;idp\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;sid\u0026#34;: \u0026#34;F6E6F2EDE86EB8731EF609A4FE40ED89\u0026#34;, \u0026#34;jti\u0026#34;: \u0026#34;2C56A356A306E64AFC7D2C6399E23A17\u0026#34; } A reference token does not contain any data, but is a pointer to the token data stored in the token service. Reference tokens allow for immediate revocation (by deleting the token data from your IdentityServer data store), whereas a JWT can only be invalidated via expiration.\nYou can control the access token format on a per-client basis using the AccessTokenType setting.\nSee the OAuth specification for more information on access tokens.\nRefresh Token Refresh tokens allow for token lifetime management of access tokens. Since an access token has a finite lifetime, the refresh token (usually with a significantly longer lifetime) can be used to request new access tokens. This mechanism serves three purposes\nit allows similar semantics as sliding expiration for cookies - just with access tokens lifetime management does not need to involve the end-user and thus provides a good UX refresh tokens can be revoked and thus provide a way to revoke long-lived API access (while allowing the above two features) See the OAuth specification for more information on refresh tokens.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/overview/big_picture/",
    "title": "The big Picture",
    "tags": [],
    "description": "",
    "content": "Most modern applications look more or less like this:\nThe most common interactions are:\nBrowsers communicate with web applications Web applications communicate with web APIs (sometimes on their own, sometimes on behalf of a user) Browser-based applications communicate with web APIs Native applications communicate with web APIs Server-based applications communicate with web APIs Web APIs communicate with web APIs (sometimes on their own, sometimes on behalf of a user) Typically each and every layer (front-end, middle-tier and back-end) has to protect resources and implement authentication and/or authorization – often against the same user store.\nOutsourcing these fundamental security functions to a security token service prevents duplicating that functionality across those applications and endpoints.\nRestructuring the application to support a security token service leads to the following architecture and protocols:\nSuch a design divides security concerns into two parts:\nAuthentication Authentication is needed when an application needs to know the identity of the current user. Typically these applications manage data on behalf of that user and need to make sure that this user can only access the data for which he is allowed. The most common example for that is (classic) web applications – but native and JS-based applications also have a need for authentication.\nThe most common authentication protocols are SAML2p, WS-Federation and OpenID Connect – SAML2p being the most popular and the most widely deployed.\nOpenID Connect is the newest of the three, but is considered to be the future because it has the most potential for modern applications. It was built for mobile application scenarios right from the start and is designed to be API friendly.\nAPI Access Applications have two fundamental ways with which they communicate with APIs – using the application identity, or delegating the user’s identity. Sometimes both methods need to be combined.\nOAuth2 is a protocol that allows applications to request access tokens from a security token service and use them to communicate with APIs. This delegation reduces complexity in both the client applications as well as the APIs since authentication and authorization can be centralized.\nOpenID Connect and OAuth 2.0 – better together OpenID Connect and OAuth 2.0 are very similar – in fact OpenID Connect is an extension on top of OAuth 2.0. The two fundamental security concerns, authentication and API access, are combined into a single protocol - often with a single round trip to the security token service.\nWe believe that the combination of OpenID Connect and OAuth 2.0 is the best approach to secure modern applications for the foreseeable future. Duende IdentityServer is an implementation of these two protocols and is highly optimized to solve the typical security problems of today’s mobile, native and web applications.\nHow Duende IdentityServer can help Duende IdentityServer is middleware that adds spec-compliant OpenID Connect and OAuth 2.0 endpoints to an arbitrary ASP.NET Core host.\nTypically, you build (or re-use) an application that contains login and logout pages (and optionally a consent page, depending on your needs) and add the IdentityServer middleware to that application. The middleware adds the necessary protocol heads to the application so that clients can talk to it using those standard protocols.\nThe hosting application can be as complex as you want, but we typically recommend to keep the attack surface as small as possible by including authentication/federation related UI only.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/overview/",
    "title": "Overview",
    "tags": [],
    "description": "",
    "content": "Overview The big Picture Terminology Supported Specifications Packaging and Builds Support and Issues Demo Server "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/quickstarts/js_clients/js_with_backend/",
    "title": "JavaScript applications with a backend",
    "tags": [],
    "description": "",
    "content": " For any pre-requisites (like e.g. templates) have a look at the Quickstarts Overview first.\nThis quickstart will show how to build a browser-based JavaScript client application with a backend. This means your application will have server-side code that can support the frontend application code.\nIn this quickstart we will be implementing the BFF pattern (with the help of the Duende.BFF library), which means the backend implements all of the security protocol interactions with the token server. This simplifies the JavaScript in the client-side, and reduces the attack surface of the application.\nThe features that will be shown in this quickstart will allow the user will login with IdentityServer, invoke a local API hosted in the backend (secured with cookie authentication), invoke a remote API running in a different host (secured with an access token), and logout of IdentityServer (again, all with the help of the backend).\nNew Project for the JavaScript client Create a new project for the JavaScript application. Since we expect the backend host to handle much of the protocol we will use an ASP.NET Core application.\nCreate a new \u0026ldquo;Empty\u0026rdquo; ASP.NET Core web application in the ~/src directory. You can use Visual Studio or do this from the command line:\nmd JavaScriptClient cd JavaScriptClient dotnet new web As we have done before, with other client projects, add this project also to your solution. Run this from the root folder which has the sln file:\ndotnet sln add .\\src\\JavaScriptClient\\JavaScriptClient.csproj Add additional NuGet packages To add BFF and OIDC support to the JavaScriptClient project, you’ll need the following NuGet packages:\ndotnet add package Microsoft.AspNetCore.Authentication.OpenIdConnect dotnet add package Duende.BFF --prerelease Modify hosting Modify the JavaScriptClient project to run on https://localhost:5003.\nAdd services With the BFF pattern, the server-side code is responsible for triggering and receiving the OpenID Connect requests and responses. This means that for our JavaScript application the configuration for session management and OpenID Connect is really no different than our prior MVC application quickstart. We will be using API controllers later, so we need a call to AddControllers(). Additionally, the BFF services need to be added with AddBff().\npublic void ConfigureServices(IServiceCollection services) { services.AddControllers(); services.AddAuthorization(); services.AddBff(); JwtSecurityTokenHandler.DefaultMapInboundClaims = false; services.AddAuthentication(options =\u0026gt; { options.DefaultScheme = \u0026#34;Cookies\u0026#34;; options.DefaultChallengeScheme = \u0026#34;oidc\u0026#34;; options.DefaultSignOutScheme = \u0026#34;oidc\u0026#34;; }) .AddCookie(\u0026#34;Cookies\u0026#34;) .AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { options.Authority = \u0026#34;https://localhost:5001\u0026#34;; options.ClientId = \u0026#34;bff\u0026#34;; options.ClientSecret = \u0026#34;secret\u0026#34;; options.ResponseType = \u0026#34;code\u0026#34;; options.Scope.Add(\u0026#34;api1\u0026#34;); options.SaveTokens = true; options.GetClaimsFromUserInfoEndpoint = true; }); } Add middleware Similarly, the middleware pipeline for this application will be fairly standard with the addition of the BFF middleware, and the BFF endpoints:\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } app.UseDefaultFiles(); app.UseStaticFiles(); app.UseRouting(); app.UseAuthentication(); app.UseBff(); app.UseAuthorization(); app.UseEndpoints(endpoints =\u0026gt; { endpoints.MapBffManagementEndpoints(); }); } Add your HTML and JavaScript files Next is to add your HTML and JavaScript files to ~/wwwroot. We will have an HTML file and an application-specific JavaScript file. In ~/wwwroot, add a HTML file named index.html and add a JavaScript file called app.js.\nindex.html\nThis will be the main page in our application. It will simply contain the HTML for the buttons for the user to login, logout, and call the web APIs. It will also contain the \u0026lt;script\u0026gt; tags to include our JavaScript file. It will also contain a \u0026lt;pre\u0026gt; used for showing messages to the user.\nIt should look like this:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=\u0026#34;login\u0026#34;\u0026gt;Login\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;local\u0026#34;\u0026gt;Call Local API\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;remote\u0026#34;\u0026gt;Call Remote API\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;logout\u0026#34;\u0026gt;Logout\u0026lt;/button\u0026gt; \u0026lt;pre id=\u0026#34;results\u0026#34;\u0026gt;\u0026lt;/pre\u0026gt; \u0026lt;script src=\u0026#34;app.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; app.js\nThis will contain the main code for our application. The first thing is to add a helper function to log messages to the \u0026lt;pre\u0026gt;:\nfunction log() { document.getElementById(\u0026#39;results\u0026#39;).innerText = \u0026#39;\u0026#39;; Array.prototype.forEach.call(arguments, function (msg) { if (typeof msg !== \u0026#39;undefined\u0026#39;) { if (msg instanceof Error) { msg = \u0026#34;Error: \u0026#34; + msg.message; } else if (typeof msg !== \u0026#39;string\u0026#39;) { msg = JSON.stringify(msg, null, 2); } document.getElementById(\u0026#39;results\u0026#39;).innerText += msg + \u0026#39;\\r\\n\u0026#39;; } }); } Next, we can use the BFF user management endpoint to query if the user is logged in or not. Notice the userClaims variable is global; it will be needed elsewhere.\nlet userClaims = null; (async function () { var req = new Request(\u0026#34;/bff/user\u0026#34;, { headers: new Headers({ \u0026#39;X-CSRF\u0026#39;: \u0026#39;1\u0026#39; }) }) try { var resp = await fetch(req); if (resp.ok) { userClaims = await resp.json(); log(\u0026#34;user logged in\u0026#34;, userClaims); } else if (resp.status === 401) { log(\u0026#34;user not logged in\u0026#34;); } } catch (e) { log(\u0026#34;error checking user status\u0026#34;); } })(); Next, add code to register click event handlers to the buttons:\ndocument.getElementById(\u0026#34;login\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, login, false); document.getElementById(\u0026#34;local\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, localApi, false); document.getElementById(\u0026#34;remote\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, remoteApi, false); document.getElementById(\u0026#34;logout\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, logout, false); Next, we want to implement the login and logout functions. Login is simple, as we redirect the user to the BFF login endpoint. Logout is more involved, as we need to redirect the user to the BFF logout endpoint, but it\u0026rsquo;s required that we pass an anti-forgery token to prevent cross site request forgery attacks. The userClaims that we populated earlier contains this token and the full URL in one of its claims, so we will use that:\nfunction login() { window.location = \u0026#34;/bff/login\u0026#34;; } function logout() { if (userClaims) { var logoutUrl = userClaims.find(claim =\u0026gt; claim.type === \u0026#39;bff:logout_url\u0026#39;).value; window.location = logoutUrl; } else { window.location = \u0026#34;/bff/logout\u0026#34;; } } Finally, add empty stubs for the other button event handler functions. We will fully implement those after we get login and logout working.\nasync function localApi() { } async function remoteApi() { } Add a client registration to IdentityServer for the JavaScript client Now that the client application is ready to go, we need to define a configuration entry in IdentityServer for this new JavaScript client. In the IdentityServer project locate the client configuration (in Config.cs). Add a new Client to the list for our new JavaScript application. Given that this client uses the BFF pattern, the configuration will be very smiliar to the MVC client. It should have the configuration listed below:\n// JavaScript BFF client new Client { ClientId = \u0026#34;bff\u0026#34;, ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, AllowedGrantTypes = GrantTypes.Code, // where to redirect to after login RedirectUris = { \u0026#34;https://localhost:5003/signin-oidc\u0026#34; }, // where to redirect to after logout PostLogoutRedirectUris = { \u0026#34;https://localhost:5003/signout-callback-oidc\u0026#34; }, AllowedScopes = new List\u0026lt;string\u0026gt; { IdentityServerConstants.StandardScopes.OpenId, IdentityServerConstants.StandardScopes.Profile, \u0026#34;api1\u0026#34; } } Run and test login and logout At this point, you should be able to run the JavaScriptClient application. You should see that the user is not logged in initially.\nOnce you click the login button, the user should be redirected to login at IdentityServer. Once the JavaScriptClient application receives the response from IdentityServer then the user should appear logged in and their claims should be displayed.\nFinally, the logout button should successfully get the user logged out.\nAdd API support Now that we have login and logout working, we will add support to invoke both local and remote APIs.\nA local API is an endpoint that is hosted in the same backend as the JavaScriptClient application. This would be perfect for APIs that only exist to support the JavaScript frontend (typically to provide UI specific data or aggregate data from other sources). The authentication for the local API will be based on the user\u0026rsquo;s session cookie in the JavaScriptClient application.\nA remote API is an API running in some other host other than the JavaScriptClient application. This would be typical for APIs that are shared by many different applications (e.g. mobile app, other web apps, etc). The authentication for remote APIs will use an access token. Fortunately the JavaScriptClient application has an access token stored in the user\u0026rsquo;s session. We will use the BFF proxy feature to accept a call from the JavaScript running in the browser authenticated with the user\u0026rsquo;s session cookie, locate the access token for the user based on the user\u0026rsquo;s session, and then proxy the call to the remote API sending the access token for authentication.\nDefine a local API Add a new class to the JavaScriptClient project that will contain the local API:\npublic class LocalApiController : ControllerBase { [Route(\u0026#34;local/identity\u0026#34;)] [Authorize] public IActionResult Get() { var name = User.FindFirst(\u0026#34;name\u0026#34;)?.Value ?? User.FindFirst(\u0026#34;sub\u0026#34;)?.Value; return new JsonResult(new { message = \u0026#34;Local API Success!\u0026#34;, user=name }); } } If while in the local API controller code you want to call out manually to a remote API and need the user\u0026rsquo;s access token, there is an extension method GetUserAccessTokenAsync on the HttpContext you can use. For example: var token = await HttpContext.GetUserAccessTokenAsync();\nUpdate routing to accept local and remote API calls We need to register both the local API and the BFF proxy for the remote API in the ASP.NET Core routing system. Add the code below to the UseEndpoints section in Configure in Startup.cs.\napp.UseEndpoints(endpoints =\u0026gt; { endpoints.MapControllers() .AsBffApiEndpoint(); endpoints.MapBffManagementEndpoints(); endpoints.MapRemoteBffApiEndpoint(\u0026#34;/remote\u0026#34;, \u0026#34;https://localhost:6001\u0026#34;) .RequireAccessToken(Duende.Bff.TokenType.User); }); The call to the AsBffApiEndpoint() fluent helper method adds BFF support to the local APIs. This includes anti-forgery protection as well as suppressing login redirects on authentication failures and instead returning 401 and 403 status codes under the appropriate circumstances.\nMapRemoteBffApiEndpoint() registers the BFF proxy for the remote API and configures it to pass the user\u0026rsquo;s access token.\nCall the APIs from JavaScript Back in site.js, implement the two API button event handlers as such:\nasync function localApi() { var req = new Request(\u0026#34;/local/identity\u0026#34;, { headers: new Headers({ \u0026#39;X-CSRF\u0026#39;: \u0026#39;1\u0026#39; }) }) try { var resp = await fetch(req); let data; if (resp.ok) { data = await resp.json(); } log(\u0026#34;Local API Result: \u0026#34; + resp.status, data); } catch (e) { log(\u0026#34;error calling local API\u0026#34;); } } async function remoteApi() { var req = new Request(\u0026#34;/remote/identity\u0026#34;, { headers: new Headers({ \u0026#39;X-CSRF\u0026#39;: \u0026#39;1\u0026#39; }) }) try { var resp = await fetch(req); let data; if (resp.ok) { data = await resp.json(); } log(\u0026#34;Remote API Result: \u0026#34; + resp.status, data); } catch (e) { log(\u0026#34;error calling remote API\u0026#34;); } } The local API path uses the path as configured in the Route attribute applied to the LocalApiController. The remote API path uses a \u0026ldquo;/remote\u0026rdquo; prefix to indicate that the BFF proxy should be used, and the remaining path is what\u0026rsquo;s then passed when invoking the remote API (\u0026quot;/identity\u0026quot; in this case). Notice both API calls require a \u0026lsquo;X-CSRF\u0026rsquo;: \u0026lsquo;1\u0026rsquo; header, which acts as the anti-forgery token.\nSee the client credentials quickstart for information on how to create the remote API used in the code above.\nRun and test the API calls At this point, you should be able to run the JavaScriptClient application and invoke the APIs. The local API should return something like this:\nAnd the remote API should return something like this:\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/endpoints/authorize/",
    "title": "Authorize Endpoint",
    "tags": [],
    "description": "",
    "content": "The authorize endpoint can be used to request tokens or authorization codes via the browser. This process typically involves authentication of the end-user and optionally consent.\nIdentityServer supports a subset of the OpenID Connect and OAuth 2.0 authorize request parameters. For a full list, see here.\nRequired parameters client_id\nidentifier of the client\nscope\none or more registered scopes\nredirect_uri\nmust exactly match one of the allowed redirect URIs for that client\nresponse_type\nspecifies the response type\nid_token\ntoken\nid_token token\ncode\ncode id_token\ncode id_token token\nOptional parameters response_mode\nspecifies the response mode\nquery\nfragment\nform_post\nstate\nechos back the state value on the token response, this is for round tripping state between client and provider, correlating request and response and CSRF/replay protection. (recommended)\nnonce\nechos back the nonce value in the identity token (for replay protection)\nRequired when identity tokens is transmitted via the browser channel\nprompt\nnone\nno UI will be shown during the request. If this is not possible (e.g. because the user has to sign in or consent) an error is returned\nlogin\nthe login UI will be shown, even if the user is already signed-in and has a valid session\ncode_challenge\nsends the code challenge for PKCE\ncode_challenge_method\nplain\nindicates that the challenge is using plain text (not recommended)\nS256\nindicates the challenge is hashed with SHA256\nlogin_hint\ncan be used to pre-fill the username field on the login page\nui_locales\ngives a hint about the desired display language of the login UI\nmax_age\nif the user\u0026rsquo;s logon session exceeds the max age (in seconds), the login UI will be shown\nacr_values\nallows passing in additional authentication related information - IdentityServer special cases the following proprietary acr_values:\nidp:name_of_idp\nbypasses the login/home realm screen and forwards the user directly to the selected identity provider (if allowed per client configuration)\ntenant:name_of_tenant\ncan be used to pass a tenant name to the login UI\nrequest\ninstead of providing all parameters as individual query string parameters, you can provide a subset or all of them as a JWT\nrequest_uri\nURL of a pre-packaged JWT containing request parameters\nGET /connect/authorize? client_id=client1\u0026amp; scope=openid email api1\u0026amp; response_type=id_token token\u0026amp; redirect_uri=https://myapp/callback\u0026amp; state=abc\u0026amp; nonce=xyz .NET client library You can use the IdentityModel client library to programmatically create authorize request URLs from .NET code.\nvar ru = new RequestUrl(\u0026#34;https://demo.duendesoftware.com/connect/authorize\u0026#34;); var url = ru.CreateAuthorizeUrl( clientId: \u0026#34;client\u0026#34;, responseType: \u0026#34;code\u0026#34;, redirectUri: \u0026#34;https://app.com/callback\u0026#34;, scope: \u0026#34;openid\u0026#34;); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/quickstarts/1_client_credentials/",
    "title": "Protecting an API using Client Credentials",
    "tags": [],
    "description": "",
    "content": "The following quickstart provides step-by-step instructions for various common Duende IdentityServer scenarios. These start with the absolute basics and become more complex as they progress. We recommend that you follow them in sequence.\nTo see the full list, please go to Quickstarts Overview.\nThis first quickstart is the most basic scenario: using Duende IdentityServer for protecting APIs for server-to-server communication.\nIn this quickstart you define an API and a Client with which to access it. The client will request an access token from the Identity Server using its client ID and secret and then use the token to gain access to the API.\nSource Code As with all of these quickstarts you can find the source code for it in the docs repository. The project for this quickstart is Quickstart #1: Securing an API using Client Credentials.\nPreparation The Duende IdentityServer templates for the dotnet CLI are a good starting point for the quickstarts.\nTo install the templates open a console window and type the following command:\ndotnet new --install Duende.IdentityServer.Templates They will be used as a starting point for the various tutorials.\nSetting up the ASP.NET Core application First create a directory for the application - then use our template to create an ASP.NET Core application that includes a basic Duende IdentityServer setup, e.g.:\nmd quickstart cd quickstart md src cd src dotnet new isempty -n IdentityServer This will create the following files:\nIdentityServer.csproj - the project file and a Properties\\launchSettings.json file Program.cs and Startup.cs - the main application entry point Config.cs - Duende IdentityServer resources and clients configuration file You can now use your favorite text editor to edit or view the files. If you want to have Visual Studio support, you can add a solution file like this:\ncd .. dotnet new sln -n Quickstart and let it add the IdentityServer project (keep this command in mind as we will create other projects below):\ndotnet sln add ./src/IdentityServer/IdentityServer.csproj The protocol used in this Template is https and the port is set to 5001 when running on Kestrel or a random one on IISExpress. You can change that in the Properties\\launchSettings.json file. For production scenarios you should always use https.\nDefining an API Scope An API is a resource in your system that you want to protect. Resource definitions can be loaded in many ways, the template you used to create the project above shows how to use a \u0026ldquo;code as configuration\u0026rdquo; approach.\nThe Config.cs is already created for you. Open it, update the code to look like this::\npublic static class Config { public static IEnumerable\u0026lt;ApiScope\u0026gt; ApiScopes =\u0026gt; new List\u0026lt;ApiScope\u0026gt; { new ApiScope(\u0026#34;api1\u0026#34;, \u0026#34;My API\u0026#34;) }; } (see the full file here).\nIf you will be using this in production it is important to give your API a logical name. Developers will be using this to connect to your api though your Identity server. It should describe your api in simple terms to both developers and users.\nDefining the client The next step is to define a client application that we will use to access our new API.\nFor this scenario, the client will not have an interactive user, and will authenticate using the so called client secret with Duende IdentityServer.\nFor this, add a client definition:\npublic static IEnumerable\u0026lt;Client\u0026gt; Clients =\u0026gt; new List\u0026lt;Client\u0026gt; { new Client { ClientId = \u0026#34;client\u0026#34;, // no interactive user, use the clientid/secret for authentication AllowedGrantTypes = GrantTypes.ClientCredentials, // secret for authentication ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, // scopes that client has access to AllowedScopes = { \u0026#34;api1\u0026#34; } } }; You can think of the ClientId and the ClientSecret as the login and password for your application itself.\nIt identifies your application to the identity server so that it knows which application is trying to connect to it.\nConfiguring IdentityServer Loading the resource and client definitions happens in Startup.cs - update the code to look like this\npublic void ConfigureServices(IServiceCollection services) { var builder = services.AddIdentityServer() .AddInMemoryApiScopes(Config.ApiScopes) .AddInMemoryClients(Config.Clients); // omitted for brevity } That\u0026rsquo;s it - your identity server should now be configured. If you run the server and navigate the browser to https://localhost:5001/.well-known/openid-configuration, you should see the so-called discovery document. The discovery document is a standard endpoint in identity servers. The discovery document will be used by your clients and APIs to download the necessary configuration data.\nAt first startup, IdentityServer will use its automatic key management feature to create a signing key for you, it is stored in the keys folder. You don\u0026rsquo;t have to check that folder into your source control, it will be re-created if it is not present.\nAdding an API Next, add an API to your solution.\nYou can either use the ASP.NET Core Web API template from Visual Studio or use the .NET CLI to create the API project as we do here. Run from within the src folder the following command:\ndotnet new webapi -n Api Then add it to the solution by running the following commands:\ncd .. dotnet sln add ./src/Api/Api.csproj Configure the API application to run on https://localhost:6001 only. You can do this by editing the launchSettings.json file inside the Properties folder. Change the application URL setting to be:\n\u0026quot;applicationUrl\u0026quot;: \u0026quot;https://localhost:6001\u0026quot; The controller Add a new class called IdentityController:\n[Route(\u0026#34;identity\u0026#34;)] [Authorize] public class IdentityController : ControllerBase { [HttpGet] public IActionResult Get() { return new JsonResult(from c in User.Claims select new { c.Type, c.Value }); } } This controller will be used later to test the authorization requirement, as well as visualize the claims identity through the eyes of the API.\nAdding a Nuget Dependency In order for the configuration step to work the NuGet package dependency has to be added, run this command in the root directory.\ndotnet add ./src/Api/Api.csproj package Microsoft.AspNetCore.Authentication.JwtBearer Configuration The last step is to add the authentication services to DI (dependency injection) and the authentication middleware to the pipeline. These will:\nvalidate the incoming token to make sure it is coming from a trusted issuer validate that the token is valid to be used with this api (aka audience) Update Startup to look like this:\npublic class Startup { public void ConfigureServices(IServiceCollection services) { services.AddControllers(); services.AddAuthentication(\u0026#34;Bearer\u0026#34;) .AddJwtBearer(\u0026#34;Bearer\u0026#34;, options =\u0026gt; { options.Authority = \u0026#34;https://localhost:5001\u0026#34;; options.TokenValidationParameters = new TokenValidationParameters { ValidateAudience = false }; }); } public void Configure(IApplicationBuilder app) { app.UseRouting(); app.UseAuthentication(); app.UseAuthorization(); app.UseEndpoints(endpoints =\u0026gt; { endpoints.MapControllers(); }); } } AddAuthentication adds the authentication services to DI and configures Bearer as the default scheme. UseAuthentication adds the authentication middleware to the pipeline so authentication will be performed automatically on every call into the host. UseAuthorization adds the authorization middleware to make sure, our API endpoint cannot be accessed by anonymous clients. Navigating to the controller https://localhost:6001/identity on a browser should return a 401 status code. This means your API requires a credential and is now protected by IdentityServer.\nIf you are wondering, why the above code disables audience validation, have a look here for a more in-depth discussion.\nCreating the client The last step is to write a client that requests an access token, and then uses this token to access the API. For that, add a console project to your solution, remember to create it in the src:\ndotnet new console -n Client Then as before, add it to your solution using:\ncd .. dotnet sln add .\\src\\Client\\Client.csproj The token endpoint at IdentityServer implements the OAuth 2.0 protocol, and you could use raw HTTP to access it. However, we have a client library called IdentityModel, that encapsulates the protocol interaction in an easy to use API.\nAdd the IdentityModel NuGet package to your client. This can be done either via Visual Studio\u0026rsquo;s Nuget Package manager or dotnet CLI::\ncd src cd client dotnet add package IdentityModel IdentityModel includes a client library to use with the discovery endpoint. This way you only need to know the base-address of IdentityServer - the actual endpoint addresses can be read from the metadata:\n// discover endpoints from metadata var client = new HttpClient(); var disco = await client.GetDiscoveryDocumentAsync(\u0026#34;https://localhost:5001\u0026#34;); if (disco.IsError) { Console.WriteLine(disco.Error); return; } If you get an error connecting it may be that you are running https and the development certificate for localhost is not trusted. You can run dotnet dev-certs https \u0026ndash;trust in order to trust the development certificate. This only needs to be done once.\nNext you can use the information from the discovery document to request a token to IdentityServer to access api1:\n// request token var tokenResponse = await client.RequestClientCredentialsTokenAsync(new ClientCredentialsTokenRequest { Address = disco.TokenEndpoint, ClientId = \u0026#34;client\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Scope = \u0026#34;api1\u0026#34; }); if (tokenResponse.IsError) { Console.WriteLine(tokenResponse.Error); return; } Console.WriteLine(tokenResponse.Json); (full file can be found here)\nCopy and paste the access token from the console to jwt.ms to inspect the raw token.\nCalling the API To send the access token to the API you typically use the HTTP Authorization header. This is done using the SetBearerToken extension method:\n// call api var apiClient = new HttpClient(); apiClient.SetBearerToken(tokenResponse.AccessToken); var response = await apiClient.GetAsync(\u0026#34;https://localhost:6001/identity\u0026#34;); if (!response.IsSuccessStatusCode) { Console.WriteLine(response.StatusCode); } else { var content = await response.Content.ReadAsStringAsync(); Console.WriteLine(JArray.Parse(content)); } If you are in Visual Studio you can right-click on the solution and select Multiple Startup Projects, and ensure the Api and IdentityServer will start; then run the solution; then, to step through the Client code, you can right-click on the Client project and select Debug\u0026hellip; Start New Instance.\nThe output should look like this:\nBy default an access token will contain claims about the scope, lifetime (nbf and exp), the client ID (client_id) and the issuer name (iss).\nAuthorization at the API Right now, the API accepts any access token issued by your identity server.\nIn the following we will add code that allows checking for the presence of the scope in the access token that the client asked for (and got granted). For this we will use the ASP.NET Core authorization policy system. Add the following to the ConfigureServices method in Startup:\nservices.AddAuthorization(options =\u0026gt; { options.AddPolicy(\u0026#34;ApiScope\u0026#34;, policy =\u0026gt; { policy.RequireAuthenticatedUser(); policy.RequireClaim(\u0026#34;scope\u0026#34;, \u0026#34;api1\u0026#34;); }); }); You can now enforce this policy at various levels, e.g.\nglobally for all API endpoints for specific controllers/actions Typically you setup the policy for all API endpoints in the routing system:\napp.UseEndpoints(endpoints =\u0026gt; { endpoints.MapControllers() .RequireAuthorization(\u0026#34;ApiScope\u0026#34;); }); Further experiments This walk-through focused on the success path so far\nclient was able to request token client could use the token to access the API You can now try to provoke errors to learn how the system behaves, e.g.\ntry to connect to IdentityServer when it is not running (unavailable) try to use an invalid client id or secret to request the token try to ask for an invalid scope during the token request try to call the API when it is not running (unavailable) don\u0026rsquo;t send the token to the API configure the API to require a different scope than the one in the token "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/quickstarts/js_clients/js_without_backend/",
    "title": "JavaScript applications without a backend",
    "tags": [],
    "description": "",
    "content": " For any pre-requisites (like e.g. templates) have a look at the Quickstarts Overview first.\nThis quickstart will show how to build a browser-based JavaScript client application without a backend. This means your application has no server-side code that can support the frontend application code, and thus all OpenID Connect/OAuth protocol interactions occur from the JavaScript code running in the browser. Also, invoking the API will be performed directly from the JavaScript in the browser.\nThis design adds complexity (and thus security concerns) to your application, so consider if the \u0026ldquo;BFF\u0026rdquo; pattern might be a better choice.\nIn this quickstart the user will login to IdentityServer, invoke the web API with an access token issued by IdentityServer, and logout of IdentityServer. All of this will be driven from the JavaScript running in the browser.\nNew Project for the JavaScript client Create a new project for the JavaScript application. It can simply be an empty web project, an empty ASP.NET Core application, or something else like a Node.js application. This quickstart will use an ASP.NET Core application.\nCreate a new \u0026ldquo;Empty\u0026rdquo; ASP.NET Core web application in the ~/src directory. You can use Visual Studio or do this from the command line:\nmd JavaScriptClient cd JavaScriptClient dotnet new web As we have done before, with other client projects, add this project also to your solution. Run this from the root folder which has the sln file:\ndotnet sln add .\\src\\JavaScriptClient\\JavaScriptClient.csproj Modify hosting Modify the JavaScriptClient project to run on https://localhost:5003.\nAdd the static file middleware Given that this project is designed to run client-side, all we need ASP.NET Core to do is to serve up the static HTML and JavaScript files that will make up our application. The static file middleware is designed to do this.\nRegister the static file middleware in Startup.cs in the Configure method (and at the same time remove everything else):\npublic void Configure(IApplicationBuilder app) { app.UseDefaultFiles(); app.UseStaticFiles(); } This middleware will now serve up static files from the application\u0026rsquo;s ~/wwwroot folder. This is where we will put our HTML and JavaScript files. If that folder does not exist in your project, create it now.\nReference oidc-client In one of the previous quickstarts in the ASP.NET Core MVC-based client project we used a library to handle the OpenID Connect protocol. In this quickstart in the JavaScriptClient project we need a similar library, except one that works in JavaScript and is designed to run in the browser. The oidc-client library is one such library. It is available via NPM, or as a direct download from github.\nNPM\nIf you want to use NPM to download oidc-client, then run these commands from your JavaScriptClient project directory:\nnpm i oidc-client copy node_modules\\oidc-client\\dist\\* wwwroot This downloads the latest oidc-client package locally, and then copies the relevant JavaScript files into ~/wwwroot so they can be served up by your application.\nManual download\nIf you want to simply download the oidc-client JavaScript files manually, browse to the GitHub repository and download the JavaScript files. Once downloaded, copy them into ~/wwwroot so they can be served up by your application.\nAdd your HTML and JavaScript files Next is to add your HTML and JavaScript files to ~/wwwroot. We will have two HTML files and one application-specific JavaScript file (in addition to the oidc-client.js library). In ~/wwwroot, add a HTML file named index.html and callback.html, and add a JavaScript file called app.js.\nindex.html\nThis will be the main page in our application. It will simply contain the HTML for the buttons for the user to login, logout, and call the web API. It will also contain the \u0026lt;script\u0026gt; tags to include our two JavaScript files. It will also contain a \u0026lt;pre\u0026gt; used for showing messages to the user.\nIt should look like this:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=\u0026#34;login\u0026#34;\u0026gt;Login\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;api\u0026#34;\u0026gt;Call API\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;logout\u0026#34;\u0026gt;Logout\u0026lt;/button\u0026gt; \u0026lt;pre id=\u0026#34;results\u0026#34;\u0026gt;\u0026lt;/pre\u0026gt; \u0026lt;script src=\u0026#34;oidc-client.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;app.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; app.js\nThis will contain the main code for our application. The first thing is to add a helper function to log messages to the \u0026lt;pre\u0026gt;:\nfunction log() { document.getElementById(\u0026#39;results\u0026#39;).innerText = \u0026#39;\u0026#39;; Array.prototype.forEach.call(arguments, function (msg) { if (msg instanceof Error) { msg = \u0026#34;Error: \u0026#34; + msg.message; } else if (typeof msg !== \u0026#39;string\u0026#39;) { msg = JSON.stringify(msg, null, 2); } document.getElementById(\u0026#39;results\u0026#39;).innerHTML += msg + \u0026#39;\\r\\n\u0026#39;; }); } Next, add code to register click event handlers to the three buttons:\ndocument.getElementById(\u0026#34;login\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, login, false); document.getElementById(\u0026#34;api\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, api, false); document.getElementById(\u0026#34;logout\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, logout, false); Next, we can use the UserManager class from the oidc-client library to manage the OpenID Connect protocol. It requires similar configuration that was necessary in the MVC Client (albeit with different values). Add this code to configure and instantiate the UserManager:\nvar config = { authority: \u0026#34;https://localhost:5001\u0026#34;, client_id: \u0026#34;js\u0026#34;, redirect_uri: \u0026#34;https://localhost:5003/callback.html\u0026#34;, response_type: \u0026#34;code\u0026#34;, scope:\u0026#34;openid profile api1\u0026#34;, post_logout_redirect_uri : \u0026#34;https://localhost:5003/index.html\u0026#34;, }; var mgr = new Oidc.UserManager(config); Next, the UserManager provides a getUser API to know if the user is logged into the JavaScript application. It uses a JavaScript Promise to return the results asynchronously. The returned User object has a profile property which contains the claims for the user. There\u0026rsquo;s also an event called UserSignedOut that can be handled to detect if the user signs out of the token server while the SPA application is being used (presumably in a different tab). Add this code to detect the user\u0026rsquo;s session status in JavaScript application:\nmgr.getUser().then(function (user) { if (user) { log(\u0026#34;User logged in\u0026#34;, user.profile); } else { log(\u0026#34;User not logged in\u0026#34;); } }); mgr.events.addUserSignedOut(function () { log(\u0026#34;User signed out of IdentityServer\u0026#34;); }); Next, we want to implement the login, api, and logout functions. The UserManager provides a signinRedirect to log the user in, and a signoutRedirect to log the user out. The User object that we obtained in the above code also has an access_token property which can be used to authenticate to a web API. The access_token will be passed to the web API via the Authorization header with the Bearer scheme. Add this code to implement those three functions in our application:\nfunction login() { mgr.signinRedirect(); } function api() { mgr.getUser().then(function (user) { var url = \u0026#34;https://localhost:6001/identity\u0026#34;; var xhr = new XMLHttpRequest(); xhr.open(\u0026#34;GET\u0026#34;, url); xhr.onload = function () { log(xhr.status, JSON.parse(xhr.responseText)); } xhr.setRequestHeader(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer \u0026#34; + user.access_token); xhr.send(); }); } function logout() { mgr.signoutRedirect(); } See the client credentials quickstart for information on how to create the api used in the code above.\ncallback.html\nThis HTML file is the designated redirect_uri page once the user has logged into IdentityServer. It will complete the OpenID Connect protocol sign-in handshake with IdentityServer. The code for this is all provided by the UserManager class we used earlier. Once the sign-in is complete, we can then redirect the user back to the main index.html page. Add this code to complete the signin process:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script src=\u0026#34;oidc-client.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; new Oidc.UserManager({response_mode:\u0026#34;query\u0026#34;}).signinRedirectCallback().then(function() { window.location = \u0026#34;index.html\u0026#34;; }).catch(function(e) { console.error(e); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Add a client registration to IdentityServer for the JavaScript client Now that the client application is ready to go, we need to define a configuration entry in IdentityServer for this new JavaScript client. In the IdentityServer project locate the client configuration (in Config.cs). Add a new Client to the list for our new JavaScript application. It should have the configuration listed below:\n// JavaScript Client new Client { ClientId = \u0026#34;js\u0026#34;, ClientName = \u0026#34;JavaScript Client\u0026#34;, AllowedGrantTypes = GrantTypes.Code, RequireClientSecret = false, RedirectUris = { \u0026#34;https://localhost:5003/callback.html\u0026#34; }, PostLogoutRedirectUris = { \u0026#34;https://localhost:5003/index.html\u0026#34; }, AllowedCorsOrigins = { \u0026#34;https://localhost:5003\u0026#34; }, AllowedScopes = { IdentityServerConstants.StandardScopes.OpenId, IdentityServerConstants.StandardScopes.Profile, \u0026#34;api1\u0026#34; } } Allowing Ajax calls to the Web API with CORS One last bit of configuration that is necessary is to configure CORS in the web API project. This will allow Ajax calls to be made from https://localhost:5003 to https://localhost:6001.\nConfigure CORS\nAdd the CORS services to the dependency injection system in ConfigureServices in Startup.cs:\npublic void ConfigureServices(IServiceCollection services) { // ... services.AddCors(options =\u0026gt; { // this defines a CORS policy called \u0026#34;default\u0026#34; options.AddPolicy(\u0026#34;default\u0026#34;, policy =\u0026gt; { policy.WithOrigins(\u0026#34;https://localhost:5003\u0026#34;) .AllowAnyHeader() .AllowAnyMethod(); }); }); } Add the CORS middleware to the pipeline in Configure (just after routing):\npublic void Configure(IApplicationBuilder app) { app.UseRouting(); app.UseCors(\u0026#34;default\u0026#34;); // ... } Run the JavaScript application Now you should be able to run the JavaScript client application:\nClick the \u0026ldquo;Login\u0026rdquo; button to sign the user in. Once the user is returned back to the JavaScript application, you should see their profile information:\nAnd click the \u0026ldquo;API\u0026rdquo; button to invoke the web API:\nAnd finally click \u0026ldquo;Logout\u0026rdquo; to sign the user out.\nYou now have the start of a JavaScript client application that uses IdentityServer for sign-in, sign-out, and authenticating calls to web APIs.\nSome browsers limit cross-site interactions (especially in iframes). If you were to test this sample in Safari, Chrome, or Brave you will notice that some important features will not work such as silent token renewal and check session monitoring.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/quickstarts/2_interactive/",
    "title": "Interactive Applications with ASP.NET Core",
    "tags": [],
    "description": "",
    "content": " For any pre-requisites (like e.g. templates) have a look at the Quickstarts Overview first.\nIn this quickstart we want to add support for interactive user authentication via the OpenID Connect protocol to our IdentityServer we built in the previous chapter.\nOnce that is in place, we will create an MVC application that will use Duende IdentityServer for authentication.\nAdding the UI All the protocol support needed for OpenID Connect is already built into Duende IdentityServer. You need to provide the necessary UI parts for login, logout, consent and error.\nWhile the look \u0026amp; feel as well as the exact workflows will probably always differ in every implementation, we provide an MVC-based sample UI that you can use as a starting point.\nThis UI can be found in the Quickstart UI repo. You can clone or download this repo and drop the controllers, views, models and CSS into your IdentityServer web application.\nAlternatively you can use the .NET CLI (run from within the src/IdentityServer folder):\ndotnet new isui Once you have added the MVC UI, you will also need to enable MVC, both in the DI system and in the pipeline. When you look at Startup.cs you will find comments in the ConfigureServices and Configure method that tell you how to enable MVC.\nThere is also a template called isinmem which combines a basic Duende IdentityServer including the standard UI.\nRun the IdentityServer application, you should now see a home page.\nSpend some time inspecting the controllers and models - especially the AccountController which is the main UI entry point. The better you understand them, the easier it will be to make future modifications. Most of the code lives in the Quickstart folder using a \u0026ldquo;feature folder\u0026rdquo; style. If this style doesn\u0026rsquo;t suit you, feel free to organize the code in any way you want.\nCreating an MVC client Next you will create an MVC application. Use the ASP.NET Core Web Application (i.e. MVC) template for that.\nrun from the src folder:\ndotnet new mvc -n MvcClient cd .. dotnet sln add .\\src\\MvcClient\\MvcClient.csproj We recommend using the self-host option over IIS Express. The rest of the docs assume you are using self-hosting on port 5002.\nTo add support for OpenID Connect authentication to the MVC application, you first need to add the NuGet package containing the OpenID Connect handler to your project, e.g.::\ndotnet add package Microsoft.AspNetCore.Authentication.OpenIdConnect ..then add the following to ConfigureServices in Startup:\nusing System.IdentityModel.Tokens.Jwt; // ... JwtSecurityTokenHandler.DefaultMapInboundClaims = false; services.AddAuthentication(options =\u0026gt; { options.DefaultScheme = \u0026#34;Cookies\u0026#34;; options.DefaultChallengeScheme = \u0026#34;oidc\u0026#34;; }) .AddCookie(\u0026#34;Cookies\u0026#34;) .AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { options.Authority = \u0026#34;https://localhost:5001\u0026#34;; options.ClientId = \u0026#34;mvc\u0026#34;; options.ClientSecret = \u0026#34;secret\u0026#34;; options.ResponseType = \u0026#34;code\u0026#34;; options.SaveTokens = true; }); AddAuthentication adds the authentication services to DI.\nWe are using a cookie to locally sign-in the user (via Cookies as the DefaultScheme), and we set the DefaultChallengeScheme to oidc because when we need the user to login, we will be using the OpenID Connect protocol.\nWe then use AddCookie to add the handler that can process cookies.\nFinally, AddOpenIdConnect is used to configure the handler that performs the OpenID Connect protocol. The Authority indicates where the trusted token service is located. We then identify this client via the ClientId and the ClientSecret. SaveTokens is used to persist the tokens from IdentityServer in the cookie (as they will be needed later).\nWe use the so called authorization code flow with PKCE to connect to the OpenID Connect provider. See here for more information on protocol flows.\nAnd then to ensure the execution of the authentication services on each request, add UseAuthentication to Configure in Startup:\napp.UseStaticFiles(); app.UseRouting(); app.UseAuthentication(); app.UseAuthorization(); app.UseEndpoints(endpoints =\u0026gt; { endpoints.MapDefaultControllerRoute() .RequireAuthorization(); }); The RequireAuthorization method disables anonymous access for the entire application. You can also use the [Authorize] attribute, if you want to specify authorization on a per controller or action method basis.\nAlso modify the home view to display the claims of the user as well as the cookie properties:\n@using Microsoft.AspNetCore.Authentication \u0026lt;h2\u0026gt;Claims\u0026lt;/h2\u0026gt; \u0026lt;dl\u0026gt; @foreach (var claim in User.Claims) { \u0026lt;dt\u0026gt;@claim.Type\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;@claim.Value\u0026lt;/dd\u0026gt; } \u0026lt;/dl\u0026gt; \u0026lt;h2\u0026gt;Properties\u0026lt;/h2\u0026gt; \u0026lt;dl\u0026gt; @foreach (var prop in (await Context.AuthenticateAsync()).Properties.Items) { \u0026lt;dt\u0026gt;@prop.Key\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;@prop.Value\u0026lt;/dd\u0026gt; } \u0026lt;/dl\u0026gt; If you now navigate to the application using the browser, a redirect attempt will be made to IdentityServer - this will result in an error because the MVC client is not registered yet.\nAdding support for OpenID Connect Identity Scopes Similar to OAuth 2.0, OpenID Connect also uses the scopes concept. Again, scopes represent something you want to protect and that clients want to access. In contrast to OAuth, scopes in OIDC don\u0026rsquo;t represent APIs, but identity data like user id, name or email address.\nAdd support for the standard openid (subject id) and profile (first name, last name etc..) scopes by amending the IdentityResources property in Config.cs:\npublic static IEnumerable\u0026lt;IdentityResource\u0026gt; IdentityResources =\u0026gt; new List\u0026lt;IdentityResource\u0026gt; { new IdentityResources.OpenId(), new IdentityResources.Profile(), }; Register the identity resources with IdentityServer in startup.cs:\nvar builder = services.AddIdentityServer() .AddInMemoryIdentityResources(Config.IdentityResources) .AddInMemoryApiScopes(Config.ApiScopes) .AddInMemoryClients(Config.Clients); All standard scopes and their corresponding claims can be found in the OpenID Connect specification.\nAdding Test Users The sample UI also comes with an in-memory \u0026ldquo;user database\u0026rdquo;. You can enable this in IdentityServer by adding the AddTestUsers extension method:\nvar builder = services.AddIdentityServer() .AddInMemoryIdentityResources(Config.IdentityResources) .AddInMemoryApiScopes(Config.ApiScopes) .AddInMemoryClients(Config.Clients) .AddTestUsers(TestUsers.Users); When you navigate to the TestUsers class, you can see that two users called alice and bob as well as some identity claims are defined. You can use those users to login.\nAdding the MVC Client to the IdentityServer Configuration The last step is to add a new configuration entry for the MVC client to the IdentityServer.\nOpenID Connect-based clients are very similar to the OAuth 2.0 clients we added so far. But since the flows in OIDC are always interactive, we need to add some redirect URLs to our configuration.\nThe client list should look like this:\npublic static IEnumerable\u0026lt;Client\u0026gt; Clients =\u0026gt; new List\u0026lt;Client\u0026gt; { // machine to machine client (from quickstart 1) new Client { ClientId = \u0026#34;client\u0026#34;, ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, AllowedGrantTypes = GrantTypes.ClientCredentials, // scopes that client has access to AllowedScopes = { \u0026#34;api1\u0026#34; } }, // interactive ASP.NET Core MVC client new Client { ClientId = \u0026#34;mvc\u0026#34;, ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, AllowedGrantTypes = GrantTypes.Code, // where to redirect to after login RedirectUris = { \u0026#34;https://localhost:5002/signin-oidc\u0026#34; }, // where to redirect to after logout PostLogoutRedirectUris = { \u0026#34;https://localhost:5002/signout-callback-oidc\u0026#34; }, AllowedScopes = new List\u0026lt;string\u0026gt; { IdentityServerConstants.StandardScopes.OpenId, IdentityServerConstants.StandardScopes.Profile } } }; Testing the client Now finally everything should be in place for the new MVC client.\nTrigger the authentication handshake by navigating to the protected controller action. You should see a redirect to the login page of the IdentityServer.\nAfter that, the IdentityServer will redirect back to the MVC client, where the OpenID Connect authentication handler processes the response and signs-in the user locally by setting a cookie. Finally the MVC view will show the contents of the cookie.\nAs you can see, the cookie has two parts, the claims of the user, and some metadata. This metadata also contains the original token that was issued by the IdentityServer. Feel free to copy this token to jwt.ms to inspect its content.\nAdding sign-out The very last step is to add sign-out to the MVC client.\nWith an authentication service like IdentityServer, it is not enough to clear the local application cookies. In addition you also need to make a roundtrip to the IdentityServer to clear the central single sign-on session.\nThe exact protocol steps are implemented inside the OpenID Connect handler, simply add the following code to some controller to trigger the sign-out:\npublic IActionResult Logout() { return SignOut(\u0026#34;Cookies\u0026#34;, \u0026#34;oidc\u0026#34;); } This will clear the local cookie and then redirect to the IdentityServer. The IdentityServer will clear its cookies and then give the user a link to return back to the MVC application.\nGetting claims from the UserInfo endpoint You might have noticed that even though we\u0026rsquo;ve configured the client to be allowed to retrieve the profile identity scope, the claims associated with that scope (such as name, family_name, website etc.) don\u0026rsquo;t appear in the returned token. We need to tell the client to pull remaining claims from the userinfo endpoint by specifying scopes that the client application needs to access and setting the GetClaimsFromUserInfoEndpoint option. In the following example we\u0026rsquo;re requesting the profile scope, but it could be any scope (or scopes) that the client is authorized to access:\n.AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { // ... options.Scope.Add(\u0026#34;profile\u0026#34;); options.GetClaimsFromUserInfoEndpoint = true; // ... }); After restarting the client app, logging out, and logging back in you should see additional user claims associated with the profile identity scope displayed on the page.\nFurther Experiments Feel free to add more claims to the test users - and also more identity resources.\nThe process for defining an identity resource is as follows:\nadd a new identity resource to the list - give it a name and specify which claims should be returned when this resource is requested give the client access to the resource via the AllowedScopes property on the client configuration request the resource by adding it to the Scopes collection on the OpenID Connect handler configuration in the client (optional) if the identity resource is associated with a non-standard claim (e.g. myclaim1), on the client side add the ClaimAction mapping between the claim appearing in JSON (returned from the userinfo endpoint) and the user claim. using Microsoft.AspNetCore.Authentication // ... .AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { // ... options.ClaimActions.MapUniqueJsonKey(\u0026#34;myclaim1\u0026#34;, \u0026#34;myclaim1\u0026#34;); // ... }); It is also noteworthy, that the retrieval of claims for tokens is an extensibility point - IProfileService. Since we are using AddTestUsers, the TestUserProfileService is used by default. You can inspect the source code here to see how it works.\nAdding Support for External Authentication Next we will add support for external authentication. This is really easy, because all you really need is an ASP.NET Core compatible authentication handler.\nASP.NET Core itself ships with support for Google, Facebook, Twitter, Microsoft Account and OpenID Connect. In addition you can find implementations for many other authentication providers here.\nAdding Google support To be able to use Google for authentication, you first need to register with them. This is done at their developer console.\nCreate a new project, enable the Google+ API and configure the callback address of your local IdentityServer by adding the /signin-google path to your base-address (e.g. https://localhost:5001/signin-google).\nThe developer console will show you a client ID and secret issued by Google - you will need that in the next step.\nAdd the Google authentication handler to the DI of the IdentityServer host. This is done by first adding the Microsoft.AspNetCore.Authentication.Google NuGet package and then adding this snippet to ConfigureServices in Startup:\nservices.AddAuthentication() .AddGoogle(\u0026#34;Google\u0026#34;, options =\u0026gt; { options.SignInScheme = IdentityServerConstants.ExternalCookieAuthenticationScheme; options.ClientId = \u0026#34;\u0026lt;insert here\u0026gt;\u0026#34;; options.ClientSecret = \u0026#34;\u0026lt;insert here\u0026gt;\u0026#34;; }); By default, IdentityServer configures a cookie handler specifically for the results of external authentication (with the scheme based on the constant IdentityServerConstants.ExternalCookieAuthenticationScheme). The configuration for the Google handler is then using that cookie handler.\nNow run the MVC client and try to authenticate - you will see a Google button on the login page:\n.. image:: images/4_login_page.png\nAfter authentication with the MVC client, you can see that the claims are now being sourced from Google data.\n.. note:: If you are interested in the magic that automatically renders the Google button on the login page, inspect the BuildLoginViewModel method on the AccountController.\nAdding an additional OpenID Connect-based external provider You can add an additional external provider. We have a cloud-hosted demo version of Duende IdentityServer which you can integrate using OpenID Connect.\nAdd the OpenId Connect handler to DI:\nservices.AddAuthentication() .AddGoogle(\u0026#34;Google\u0026#34;, options =\u0026gt; { options.SignInScheme = IdentityServerConstants.ExternalCookieAuthenticationScheme; options.ClientId = \u0026#34;\u0026lt;insert here\u0026gt;\u0026#34;; options.ClientSecret = \u0026#34;\u0026lt;insert here\u0026gt;\u0026#34;; }) .AddOpenIdConnect(\u0026#34;oidc\u0026#34;, \u0026#34;Demo IdentityServer\u0026#34;, options =\u0026gt; { options.SignInScheme = IdentityServerConstants.ExternalCookieAuthenticationScheme; options.SignOutScheme = IdentityServerConstants.SignoutScheme; options.SaveTokens = true; options.Authority = \u0026#34;https://demo.duendesoftware.com\u0026#34;; options.ClientId = \u0026#34;interactive.confidential\u0026#34;; options.ClientSecret = \u0026#34;secret\u0026#34;; options.ResponseType = \u0026#34;code\u0026#34;; options.TokenValidationParameters = new TokenValidationParameters { NameClaimType = \u0026#34;name\u0026#34;, RoleClaimType = \u0026#34;role\u0026#34; }; }); And now a user should be able to use the cloud-hosted demo identity provider.\nThe quickstart UI auto-provisions external users. As an external user logs in for the first time, a new local user is created, and all the external claims are copied over and associated with the new user. The way you deal with such a situation is completely up to you though. Maybe you want to show some sort of registration UI first. The source code for the default quickstart can be found here.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/endpoints/token/",
    "title": "Token Endpoint",
    "tags": [],
    "description": "",
    "content": "The token endpoint can be used to programmatically request tokens.\nDuende IdentityServer supports a subset of the OpenID Connect and OAuth 2.0 token request parameters. For a full list, see here.\nRequired parameters client_id\nclient identifier; not necessary in body if it is present in the authorization header\ngrant_type\nauthorization_code\nclient_credentials\npassword\nrefresh_token\nurn:ietf:params:oauth:grant-type:device_code\nextension grant\nOptional parameters client_secret\nclient secret for confidential/credentials clients - either in the post body, or as a basic authentication header.\nscope\none or more registered scopes. If not specified, a token for all explicitly allowed scopes will be issued.\nredirect_uri\nrequired for the authorization_code grant type\ncode\nthe authorization code (required for authorization_code grant type)\ncode_verifier\nPKCE proof key\nusername\nresource owner username (required for password grant type)\npassword\nresource owner password (required for password grant type)\nacr_values\nallows passing in additional authentication related information. Duende IdentityServer special cases the following proprietary acr_values\ntenant:name_of_tenant\ncan be used to pass a tenant name to the token endpoint\nrefresh_token\nthe refresh token (required for refresh_token grant type)\ndevice_code\nthe device code (required for urn:ietf:params:oauth:grant-type:device_code grant type)\nPOST /connect/token CONTENT-TYPE application/x-www-form-urlencoded client_id=client1\u0026amp; client_secret=secret\u0026amp; grant_type=authorization_code\u0026amp; code=hdh922\u0026amp; redirect_uri=https://myapp.com/callback .NET client library You can use the IdentityModel client library to programmatically interact with the protocol endpoint from .NET code.\nusing IdentityModel.Client; var client = new HttpClient(); var response = await client.RequestAuthorizationCodeTokenAsync(new AuthorizationCodeTokenRequest { Address = TokenEndpoint, ClientId = \u0026#34;client\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Code = \u0026#34;...\u0026#34;, CodeVerifier = \u0026#34;...\u0026#34;, RedirectUri = \u0026#34;https://app.com/callback\u0026#34; }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/quickstarts/3_api_access/",
    "title": "ASP.NET Core and API access",
    "tags": [],
    "description": "",
    "content": " For any pre-requisites (like e.g. templates) have a look at the Quickstarts Overview first.\nIn the previous quickstarts we explored both API access and user authentication. Now we want to bring the two parts together.\nThe beauty of the OpenID Connect \u0026amp; OAuth 2.0 combination is, that you can achieve both with a single protocol and a single exchange with the token service.\nSo far we only asked for identity resources during the token request, once we start also including API resources, Duende IdentityServer will return two tokens: the identity token containing the information about the authentication and session, and the access token to access APIs on behalf of the logged on user.\nModifying the client configuration Updating the client configuration in IdentityServer is straightforward - we simply need to add the api1 resource to the allowed scopes list. In addition we enable support for refresh tokens via the AllowOfflineAccess property:\nnew Client { ClientId = \u0026#34;mvc\u0026#34;, ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, AllowedGrantTypes = GrantTypes.Code, // where to redirect to after login RedirectUris = { \u0026#34;https://localhost:5002/signin-oidc\u0026#34; }, // where to redirect to after logout PostLogoutRedirectUris = { \u0026#34;https://localhost:5002/signout-callback-oidc\u0026#34; }, AllowOfflineAccess = true, AllowedScopes = new List\u0026lt;string\u0026gt; { IdentityServerConstants.StandardScopes.OpenId, IdentityServerConstants.StandardScopes.Profile, \u0026#34;api1\u0026#34; } } Modifying the MVC client All that\u0026rsquo;s left to do now in the client is to ask for the additional resources via the scope parameter. This is done in the OpenID Connect handler configuration:\nservices.AddAuthentication(options =\u0026gt; { options.DefaultScheme = \u0026#34;Cookies\u0026#34;; options.DefaultChallengeScheme = \u0026#34;oidc\u0026#34;; }) .AddCookie(\u0026#34;Cookies\u0026#34;) .AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { options.Authority = \u0026#34;https://localhost:5001\u0026#34;; options.ClientId = \u0026#34;mvc\u0026#34;; options.ClientSecret = \u0026#34;secret\u0026#34;; options.ResponseType = \u0026#34;code\u0026#34;; options.SaveTokens = true; options.Scope.Add(\u0026#34;api1\u0026#34;); options.Scope.Add(\u0026#34;offline_access\u0026#34;); }); Since SaveTokens is enabled, ASP.NET Core will automatically store the resulting access and refresh token in the authentication session. You should be able to inspect the data on the page that prints out the contents of the session that you created earlier.\nUsing the access token You can access the tokens in the session using the standard ASP.NET Core extension methods that you can find in the Microsoft.AspNetCore.Authentication namespace:\nvar accessToken = await HttpContext.GetTokenAsync(\u0026#34;access_token\u0026#34;); For accessing the API using the access token, all you need to do is retrieve the token, and set it on your HttpClient:\npublic async Task\u0026lt;IActionResult\u0026gt; CallApi() { var accessToken = await HttpContext.GetTokenAsync(\u0026#34;access_token\u0026#34;); var client = new HttpClient(); client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\u0026#34;Bearer\u0026#34;, accessToken); var content = await client.GetStringAsync(\u0026#34;https://localhost:6001/identity\u0026#34;); ViewBag.Json = JArray.Parse(content).ToString(); return View(\u0026#34;json\u0026#34;); } Create a view in MvcClient/Views/Home/json.cshtml that outputs the json like this:\n\u0026lt;pre\u0026gt;@ViewBag.Json\u0026lt;/pre\u0026gt; Make sure the API is running, start the MVC client and call /home/CallApi after authentication.\nManaging the access token By far the most complex task for a typical client is to manage the access token. You typically want to\nrequest the access and refresh token at login time cache those tokens use the access token to call APIs until it expires use the refresh token to get a new access token start over ASP.NET Core has many built-in facility that can help you with those tasks (like caching or sessions), but there is still quite some work left to do.\nFeel free to have a look at this library, which can automate many of the boilerplate tasks.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/endpoints/userinfo/",
    "title": "UserInfo Endpoint",
    "tags": [],
    "description": "",
    "content": "The UserInfo endpoint can be used to retrieve claims about a user (see spec).\nThe caller needs to send a valid access token. Depending on the granted scopes, the UserInfo endpoint will return the mapped claims (at least the openid scope is required).\nGET /connect/userinfo Authorization: Bearer \u0026lt;access_token\u0026gt; HTTP/1.1 200 OK Content-Type: application/json { \u0026#34;sub\u0026#34;: \u0026#34;248289761001\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Bob Smith\u0026#34;, \u0026#34;given_name\u0026#34;: \u0026#34;Bob\u0026#34;, \u0026#34;family_name\u0026#34;: \u0026#34;Smith\u0026#34; } .NET client library You can use the IdentityModel client library to programmatically interact with the protocol endpoint from .NET code.\nusing IdentityModel.Client; var client = new HttpClient(); var response = await client.GetUserInfoAsync(new UserInfoRequest { Address = disco.UserInfoEndpoint, Token = token }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/endpoints/introspection/",
    "title": "Introspection Endpoint",
    "tags": [],
    "description": "",
    "content": "The introspection endpoint is an implementation of RFC 7662.\nIt can be used to validate reference tokens (or JWTs if the consumer does not have support for appropriate JWT or cryptographic libraries). The introspection endpoint requires authentication - since the client of an introspection endpoint is an API, you configure the secret on the ApiResource.\nPOST /connect/introspect Authorization: Basic xxxyyy token=\u0026lt;token\u0026gt; A successful response will return a status code of 200 and either an active or inactive token::\n{ \u0026#34;active\u0026#34;: true, \u0026#34;sub\u0026#34;: \u0026#34;123\u0026#34; } Unknown or expired tokens will be marked as inactive::\n{ \u0026#34;active\u0026#34;: false, } An invalid request will return a 400, an unauthorized request 401.\n.NET client library You can use the IdentityModel client library to programmatically interact with the protocol endpoint from .NET code.\nusing IdentityModel.Client; var client = new HttpClient(); var response = await client.IntrospectTokenAsync(new TokenIntrospectionRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/introspect\u0026#34;, ClientId = \u0026#34;api1\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Token = accessToken }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/quickstarts/4_ef/",
    "title": "Using EntityFramework Core for configuration and operational data",
    "tags": [],
    "description": "",
    "content": " For any pre-requisites (like e.g. templates) have a look at the Quickstarts Overview first.\nIn the previous quickstarts, we created our client and scope data in code. On startup, IdentityServer loaded this configuration data into memory. If we wanted to modify this configuration data, we had to stop and start IdentityServer.\nIdentityServer also generates temporary data, such as authorization codes, consent choices, and refresh tokens. By default, these are also stored in-memory.\nTo move this data into a database that is persistent between restarts and across multiple IdentityServer instances, we can use the Duende IdentityServer Entity Framework library.\nIn addition to manually configuring EF support, there is also an IdentityServer template to create a new project with EF support, using dotnet new isef.\nOverview Our EF integration library implements the required stores and services using the following DbContexts:\nConfigurationDbContext: used for configuration data such as clients, resources, and scopes PersistedGrantDbContext: used for dynamic operational data such as authorization codes, and refresh tokens These contexts are suitable for any Entity Framework Core compatible relational database.\nYou can find the extension methods to register them in your IdentityServer in the Duende.IdentityServer.EntityFramework NuGet package, which we will add to the IdentityServer project now:\ndotnet add package Duende.IdentityServer.EntityFramework Using Sqlite For this quickstart, we will use Sqlite as the database provider. Of course, given EntityFramework Core\u0026rsquo;s flexibility, you can adjust this quickstart to use any EF supported provider.\nTo add Sqlite support to our IdentityServer project, you’ll need the following NuGet package:\ndotnet add package Microsoft.EntityFrameworkCore.Sqlite Database Schema Changes and Using EF Migrations The Duende.IdentityServer.EntityFramework.Storage Nuget package contains entity classes that map from Duende IdentityServer’s models. As IdentityServer’s models change, so will the entity classes in Duende.IdentityServer.EntityFramework.Storage. As you use Duende.IdentityServer.EntityFramework.Storage and upgrade over time, you are responsible for your database schema and changes necessary to that schema as the entity classes change.\nOne approach for managing those changes is to use EF migrations, which is what we’ll use in this quickstart. If migrations are not your preference, then you can manage the schema changes in any way you see fit.\nYou can find the latest SQL scripts for SqlServer in our EF repository.\nConfiguring the Stores To start using these stores, you’ll need to replace any existing calls to AddInMemoryClients, AddInMemoryIdentityResources, AddInMemoryApiScopes, AddInMemoryApiResources, and AddInMemoryPersistedGrants in your ConfigureServices method in Startup.cs with AddConfigurationStore and AddOperationalStore.\nThese methods each require a DbContextOptionsBuilder, meaning your code will look something like this:\nvar migrationsAssembly = typeof(Startup).GetTypeInfo().Assembly.GetName().Name; const string connectionString = @\u0026#34;Data Source=Duende.IdentityServer.Quickstart.EntityFramework.db\u0026#34;; services.AddIdentityServer() .AddTestUsers(TestUsers.Users) .AddConfigurationStore(options =\u0026gt; { options.ConfigureDbContext = b =\u0026gt; b.UseSqlite(connectionString, sql =\u0026gt; sql.MigrationsAssembly(migrationsAssembly)); }) .AddOperationalStore(options =\u0026gt; { options.ConfigureDbContext = b =\u0026gt; b.UseSqlite(connectionString, sql =\u0026gt; sql.MigrationsAssembly(migrationsAssembly)); }); You might need these namespaces added to the file:\nusing Microsoft.EntityFrameworkCore; using System.Reflection; Because we are using EF migrations in this quickstart, the call to MigrationsAssembly(\u0026hellip;) is used to inform Entity Framework that the host project will contain the migrations code. This is necessary since the host project is in a different assembly than the one that contains the DbContext classes.\nAdding Migrations Once the IdentityServer has been configured to use Entity Framework, we’ll need to generate some migrations.\nTo create migrations, you will need to install the Entity Framework Core CLI on your machine and the Microsoft.EntityFrameworkCore.Design NuGet package in IdentityServer:\ndotnet tool install --global dotnet-ef dotnet add package Microsoft.EntityFrameworkCore.Design To create the migrations, open a command prompt in the IdentityServer project directory and run the following two commands:\ndotnet ef migrations add InitialIdentityServerPersistedGrantDbMigration -c PersistedGrantDbContext -o Data/Migrations/IdentityServer/PersistedGrantDb dotnet ef migrations add InitialIdentityServerConfigurationDbMigration -c ConfigurationDbContext -o Data/Migrations/IdentityServer/ConfigurationDb You should now see a ~/Data/Migrations/IdentityServer folder in your project containing the code for your newly created migrations.\nInitializing the Database Now that we have the migrations, we can write code to create the database from the migrations. We can also seed the database with the in-memory configuration data that we already defined in the previous quickstarts.\nThe approach used in this quickstart is used to make it easy to get IdentityServer up and running. You should devise your own database creation and maintenance strategy that is appropriate for your architecture.\nIn Startup.cs add this method to help initialize the database::\nprivate void InitializeDatabase(IApplicationBuilder app) { using (var serviceScope = app.ApplicationServices.GetService\u0026lt;IServiceScopeFactory\u0026gt;().CreateScope()) { serviceScope.ServiceProvider.GetRequiredService\u0026lt;PersistedGrantDbContext\u0026gt;().Database.Migrate(); var context = serviceScope.ServiceProvider.GetRequiredService\u0026lt;ConfigurationDbContext\u0026gt;(); context.Database.Migrate(); if (!context.Clients.Any()) { foreach (var client in Config.Clients) { context.Clients.Add(client.ToEntity()); } context.SaveChanges(); } if (!context.IdentityResources.Any()) { foreach (var resource in Config.IdentityResources) { context.IdentityResources.Add(resource.ToEntity()); } context.SaveChanges(); } if (!context.ApiScopes.Any()) { foreach (var resource in Config.ApiScopes) { context.ApiScopes.Add(resource.ToEntity()); } context.SaveChanges(); } } } The above code may require you to add the following namespaces to your file::\nusing System.Linq; using Duende.IdentityServer.EntityFramework.DbContexts; using Duende.IdentityServer.EntityFramework.Mappers; And then we can invoke this from the Configure method:\npublic void Configure(IApplicationBuilder app) { // this will do the initial DB population InitializeDatabase(app); // the rest of the code that was already here // ... } Now if you run the IdentityServer project, the database should be created and seeded with the quickstart configuration data. You should be able to use a tool like SQL Lite Studio to connect and inspect the data.\nThe above InitializeDatabase helper API is convenient to seed the database, but this approach is not ideal to leave in to execute each time the application runs. Once your database is populated, consider removing the call to the API.\nRun the client applications You should now be able to run any of the existing client applications and sign-in, get tokens, and call the API \u0026ndash; all based upon the database configuration.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/quickstarts/js_clients/",
    "title": "Building JavaScript client applications",
    "tags": [],
    "description": "",
    "content": "JavaScript/SPA Client Applications When building JavaScript (or SPA) applications, there are two main styles. Those with a backend and those without.\nJavaScript applications with a backend allow for more security and thus is the preferred pattern (as described by the \u0026ldquo;OAuth 2.0 for Browser-Based Apps\u0026rdquo; IETF/OAuth working group BCP document). This style uses the \u0026ldquo;Backend For Frontend\u0026rdquo; pattern (or \u0026ldquo;BFF\u0026rdquo; for short) which relies on the backend host to implement all of the security protocol interactions with the token server. The Duende.BFF library is used in this quickstart to easily support the BFF pattern.\nJavaScript applications without a backend need to do all security interactions on the client-side code such as driving user authentication and token requests, session and token management, and token storage. This leads to more complex JavaScript, cross-browser incompatibilities and a considerably higher attack surface. Some of the newer browsers also recently added features that break some of those mechanisms.\nSince ultimately you need to store your security sensitive artifacts (like tokens) in JavaScript reachable locations, this style is not encouraged for applications dealing with sensitive data.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/endpoints/revocation/",
    "title": "Revocation Endpoint",
    "tags": [],
    "description": "",
    "content": "This endpoint allows revoking access tokens (reference tokens only) and refresh token. It implements the token revocation specification (RFC 7009).\ntoken\nthe token to revoke (required)\ntoken_type_hint\neither access_token or refresh_token (optional)\nPOST /connect/revocation HTTP/1.1 Host: server.example.com Content-Type: application/x-www-form-urlencoded Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW token=...\u0026amp;token_type_hint=refresh_token .NET client library You can use the IdentityModel client library to programmatically interact with the protocol endpoint from .NET code.\nusing IdentityModel.Client; var client = new HttpClient(); var result = await client.RevokeTokenAsync(new TokenRevocationRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/revocation\u0026#34;, ClientId = \u0026#34;client\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Token = token }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/quickstarts/5_aspnetid/",
    "title": "Using ASP.NET Core Identity",
    "tags": [],
    "description": "",
    "content": " For any pre-requisites (like e.g. templates) have a look at the Quickstarts Overview first.\nDuende IdentityServer is designed for flexibility and part of that is allowing you to use any database you want for your users and their data (including passwords). If you are starting with a new user database, then ASP.NET Core Identity is one option you could choose. This quickstart shows how to use ASP.NET Core Identity with Duende IdentityServer.\nThe approach this quickstart takes to using ASP.NET Core Identity is to create a new project for the IdentityServer host. This new project will replace the prior IdentityServer project we built up in the previous quickstarts. The reason for this new project is due to the differences in UI assets when using ASP.NET Core Identity (mainly around the differences in login and logout). All the other projects in this solution (for the clients and the API) will remain the same.\nThis quickstart assumes you are familiar with how ASP.NET Core Identity works. If you are not, it is recommended that you first learn about it.\nNew Project for ASP.NET Core Identity The first step is to add a new project for ASP.NET Core Identity to your solution. We provide a template that contains the minimal UI assets needed to use ASP.NET Core Identity with Duende IdentityServer. You will eventually delete the old project for Duende IdentityServer, but there are some items that you will need to migrate over.\nStart by creating a new IdentityServer project that will use ASP.NET Core Identity:\ncd quickstart/src dotnet new isaspid -n IdentityServerAspNetIdentity When prompted to \u0026ldquo;seed\u0026rdquo; the user database, choose \u0026ldquo;Y\u0026rdquo; for \u0026ldquo;yes\u0026rdquo;. This populates the user database with our \u0026ldquo;alice\u0026rdquo; and \u0026ldquo;bob\u0026rdquo; users. Their passwords are \u0026ldquo;Pass123$\u0026rdquo;.\nThe template uses Sqlite as the database for the users, and EF migrations are pre-created in the template. If you wish to use a different database provider, you will need to change the provider used in the code and re-create the EF migrations.\nInspect the new project Open the new project in the editor of your choice, and inspect the generated code. Be sure to look at:\nIdentityServerAspNetIdentity.csproj Notice the reference to Duende.IdentityServer.AspNetIdentity. This NuGet package contains the ASP.NET Core Identity integration components for Duende IdentityServer.\nStartup.cs In ConfigureServices notice the necessary AddDbContext() and AddIdentity\u0026lt;ApplicationUser, IdentityRole\u0026gt;() calls are done to configure ASP.NET Core Identity.\nAlso notice that much of the same IdentityServer configuration you did in the previous quickstarts is already done. The template uses the in-memory style for clients and resources, and those are sourced from Config.cs.\nFinally, notice the addition of the new call to AddAspNetIdentity(). AddAspNetIdentity() adds the integration layer to allow IdentityServer to access the user data for the ASP.NET Core Identity user database. This is needed when IdentityServer must add claims for the users into tokens.\nNote that AddIdentity\u0026lt;ApplicationUser, IdentityRole\u0026gt;() must be invoked before AddIdentityServer().\nConfig.cs Config.cs contains the hard-coded in-memory clients and resource definitions. To keep the same clients and API working as the prior quickstarts, we need to copy over the configuration data from the old IdentityServer project into this one. Do that now, and afterwards Config.cs should look like this:\npublic static class Config { public static IEnumerable\u0026lt;IdentityResource\u0026gt; IdentityResources =\u0026gt; new List\u0026lt;IdentityResource\u0026gt; { new IdentityResources.OpenId(), new IdentityResources.Profile(), }; public static IEnumerable\u0026lt;ApiScope\u0026gt; ApiScopes =\u0026gt; new List\u0026lt;ApiScope\u0026gt; { new ApiScope(\u0026#34;api1\u0026#34;, \u0026#34;My API\u0026#34;) }; public static IEnumerable\u0026lt;Client\u0026gt; Clients =\u0026gt; new List\u0026lt;Client\u0026gt; { // machine to machine client new Client { ClientId = \u0026#34;client\u0026#34;, ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, AllowedGrantTypes = GrantTypes.ClientCredentials, // scopes that client has access to AllowedScopes = { \u0026#34;api1\u0026#34; } }, // interactive ASP.NET Core MVC client new Client { ClientId = \u0026#34;mvc\u0026#34;, ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, AllowedGrantTypes = GrantTypes.Code, // where to redirect to after login RedirectUris = { \u0026#34;https://localhost:5002/signin-oidc\u0026#34; }, // where to redirect to after logout PostLogoutRedirectUris = { \u0026#34;https://localhost:5002/signout-callback-oidc\u0026#34; }, AllowedScopes = new List\u0026lt;string\u0026gt; { IdentityServerConstants.StandardScopes.OpenId, IdentityServerConstants.StandardScopes.Profile, \u0026#34;api1\u0026#34; } } }; } At this point, you no longer need the old IdentityServer project.\nProgram.cs and SeedData.cs The application entry function Main in Program.cs is a little different than most ASP.NET Core projects. Notice how this looks for a command line argument called /seed which is used as a flag to seed the users in the ASP.NET Core Identity database.\nLook at the SeedData class\u0026rsquo; code to see how the database is created and the first users are created.\nAccountController The last code to inspect in this template is the AccountController. This contains a slightly different login and logout code than the prior quickstart and templates. Notice the use of the SignInManager and UserManager from ASP.NET Core Identity to validate credentials and manage the authentication session.\nMuch of the rest of the code is the same from the prior quickstarts and templates.\nLogging in with the MVC client At this point, you should be able to run all of the existing clients and samples. Launch the MVC client application, and you should be able to click the \u0026ldquo;Secure\u0026rdquo; link to get logged in.\nYou should be redirected to the ASP.NET Core Identity login page. Login with your newly created user, and after that you will be redirected back to the MVC client application where your user\u0026rsquo;s claims should be listed.\nYou should also be able to click \u0026ldquo;Call API using application identity\u0026rdquo; to invoke the API on behalf of the user:\nAnd now you\u0026rsquo;re using users from ASP.NET Core Identity in Duende IdentityServer.\nWhat\u0026rsquo;s Missing? Much of the rest of the code in this template is similar to the other quickstart and templates we provide. The one thing you will notice that is missing from this template is UI code for user registration, password reset, and the other things you might expect from the Visual Studio ASP.NET Core Identity template.\nGiven the variety of requirements and different approaches to using ASP.NET Core Identity, our template deliberately does not provide those features. You are expected to know how ASP.NET Core Identity works sufficiently well to add those features to your project. Alternatively, you can create a new project based on the Visual Studio ASP.NET Core Identity template and add the IdentityServer features you have learned about in these quickstarts to that project.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/endpoints/end_session/",
    "title": "End Session Endpoint",
    "tags": [],
    "description": "",
    "content": "The end session endpoint can be used to trigger single sign-out in the browser (see spec.\nTo use the end session endpoint a client application will redirect the user\u0026rsquo;s browser to the end session URL. All applications that the user has logged into via the browser during the user\u0026rsquo;s session can participate in the sign-out.\nThe URL for the end session endpoint is available via discovery.\nid_token_hint\nWhen the user is redirected to the endpoint, they will be prompted if they really want to sign-out. This prompt can be bypassed by a client sending the original id_token received from authentication. This is passed as a query string parameter called id_token_hint.\npost_logout_redirect_uri\nIf a valid id_token_hint is passed, then the client may also send a post_logout_redirect_uri parameter. This can be used to allow the user to redirect back to the client after sign-out. The value must match one of the client\u0026rsquo;s pre-configured PostLogoutRedirectUris.\nstate\nIf a valid post_logout_redirect_uri is passed, then the client may also send a state parameter. This will be returned back to the client as a query string parameter after the user redirects back to the client. This is typically used by clients to roundtrip state across the redirect.\nGET /connect/endsession?id_token_hint=...\u0026amp;post_logout_redirect_uri=http%3A%2F%2Flocalhost%3A7017%2Findex.html .NET client library You can use the IdentityModel client library to programmatically create end sessions request URLs from .NET code.\nvar ru = new RequestUrl(\u0026#34;https://demo.duendesoftware.com/connect/end_session\u0026#34;); var url = ru.CreateEndSessionUrl( idTokenHint: \u0026#34;...\u0026#34;, postLogoutRedirectUri: \u0026#34;...\u0026#34;); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/endpoints/device_authorization/",
    "title": "Device Authorization Endpoint",
    "tags": [],
    "description": "",
    "content": "The device authorization endpoint can be used to request device and user codes. This endpoint is used to start the device flow authorization process.\nclient_id\nclient identifier (required)\nclient_secret\nclient secret either in the post body, or as a basic authentication header. Optional.\nscope\none or more registered scopes. If not specified, a token for all explicitly allowed scopes will be issued\nPOST /connect/deviceauthorization client_id=client1\u0026amp; client_secret=secret\u0026amp; scope=openid api1 .NET client library You can use the IdentityModel client library to programmatically interact with the protocol endpoint from .NET code.\nusing IdentityModel.Client; var client = new HttpClient(); var response = await client.RequestDeviceAuthorizationAsync(new DeviceAuthorizationRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/deviceauthorization\u0026#34;, ClientId = \u0026#34;device\u0026#34; }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/bff/architecture/",
    "title": "Architecture",
    "tags": [],
    "description": "",
    "content": "A BFF host is an ASP.NET Core application with the following logical building blocks:\nThese components deal with server-side protocol requests and responses, session and token management as well as providing and securing API endpoints for the frontend.\nIn addition, the host serves the UI assets which could be HTML/JS/CSS, WASM, and/or server-rendered content.\nPlain ASP.NET Core provides a good starting point to inject the additional security and application features that are typically associated with a BFF. This is where Duende.BFF comes in. We fill those gaps and add advanced functionality so you only have to focus on providing the application logic, and not the security logic:\nASP.NET OpenID Connect Handler\nWe leverage the built-in OpenID Connect handler for OIDC and OAuth protocol processing. We are both a long-term user and contributor of this library and think this is a very well implemented and flexible protocol library.\nASP.NET Cookie Handler\nThis library takes care of session management in ASP.NET Core. It has a good set of features around security (claims, cookie security features, digital signatures and encryption), provides both absolute and sliding session support, and has a good extensibility model. We leverage the library to add server-side session management and back-channel logout support.\nOn top of the cookie handler, we provide endpoints for login, logout and user/session data and query.\nIdentityModel.AspNetCore\nThis library plugs into both the OpenID Connect and cookie handler to provide automatic access token management and storage. It provides both an imperative API as well as integration with the ASP.NET HTTP client factory.\nAPI Endpoints\nThe frontend will call APIs. Frontend exclusive APIs can live directly in the BFF host. Remote (e.g. cross-site) APIs are called via the backend. Both types need to be secured with the session cookie and anti-forgery protection.\nThe remote API interfaces can be either created manually, or a reverse proxy approach can be used. Duende.BFF includes a developer-centric version of Microsoft\u0026rsquo;s YARP proxy that integrates with the automatic token management mentioned above. We also provide YARP-specific plumbing to add the BFF features to \u0026ldquo;standard\u0026rdquo; YARP directly.\nFrontend\nThe UI can be delivered over various mechanisms, e.g. via the ASP.NET static files middleware, MVC/Razor or server/WASM Blazor.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/bff/session/handlers/",
    "title": "ASP.NET Core Authentication System",
    "tags": [],
    "description": "",
    "content": "You typically use the following two ASP.NET Core authentication handlers to implement remote authentication:\nthe OpenID Connect authentication handler to interact with the remote OIDC / OAuth token service, e.g. Duende IdentityServer the cookie handler to do local session management Furthermore the BFF plumbing relies on the configuration of the ASP.NET Core default authentication schemes. This describes how the two handlers share the work.\nOpenID Connect for challenge and signout - cookies for all the other operations:\nservices.AddAuthentication(options =\u0026gt; { options.DefaultScheme = \u0026#34;cookie\u0026#34;; options.DefaultChallengeScheme = \u0026#34;oidc\u0026#34;; options.DefaultSignOutScheme = \u0026#34;oidc\u0026#34;; }) .AddCookie(\u0026#34;cookie\u0026#34;, options =\u0026gt; { ... }) .AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { ... }) ); The OpenID Connect Authentication Handler The OIDC handler connects the application to the authentication / access token system.\nThe exact settings depend on the OIDC provider and its configuration settings. We recommend:\nuse authorization code flow with PKCE use a response_mode of query since this plays nicer with SameSite cookies use a strong client secret. Since the BFF can be a confidential client, it is totally possible to use strong client authentication like JWT assertions, JAR or MTLS. Shared secrets work as well of course. turn off inbound claims mapping save the tokens into the authentication session so they can be automatically managed request a refresh token using the offline_access scope services.AddAuthentication().AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { options.Authority = \u0026#34;https://demo.duendesoftware.com\u0026#34;; // confidential client using code flow + PKCE options.ClientId = \u0026#34;spa\u0026#34;; options.ClientSecret = \u0026#34;secret\u0026#34;; options.ResponseType = \u0026#34;code\u0026#34;; // query response type is compatible with strict SameSite mode options.ResponseMode = \u0026#34;query\u0026#34;; // get claims without mappings options.MapInboundClaims = false; options.GetClaimsFromUserInfoEndpoint = true; // save tokens into authentication session // to enable automatic token management options.SaveTokens = true; // request scopes options.Scope.Clear(); options.Scope.Add(\u0026#34;openid\u0026#34;); options.Scope.Add(\u0026#34;profile\u0026#34;); options.Scope.Add(\u0026#34;api\u0026#34;); // and refresh token options.Scope.Add(\u0026#34;offline_access\u0026#34;); }); The OIDC handler will use the default sign-in handler (the cookie handler) to establish a session after successful validation of the OIDC response.\nThe Cookie Handler The cookie handler is responsible for establishing the session and manage authentication session related data.\nThings to consider:\ndetermine the session lifetime and if the session lifetime should be sliding or absolute it is recommended to use a cookie name prefix if compatible with your application use the highest available SameSite mode that is compatible with your application, e.g. strict, but at least lax services.AddAuthentication().AddCookie(\u0026#34;cookie\u0026#34;, options =\u0026gt; { // set session lifetime options.ExpireTimeSpan = TimeSpan.FromHours(8); // sliding or absolute options.SlidingExpiration = false; // host prefixed cookie name options.Cookie.Name = \u0026#34;__Host-spa\u0026#34;; // strict SameSite handling options.Cookie.SameSite = SameSiteMode.Strict; }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/samples/basics/",
    "title": "Basics",
    "tags": [],
    "description": "",
    "content": "This solution contains a collection of common scenarios.\nClient Credentials This sample shows how to use the client_credentials grant type. This is typically used for machine to machine communication.\nKey takeaways:\nhow to request a token using client credentials how to use a shared secret how to use access token link to source code\nJWT-based Client Authentication This sample shows how to use the client_credentials grant type with JWT-based client authentication. This authentication method is more recommended than shared secrets.\nKey takeaways:\ncreate a JWT for client authentication use a JWT as a client secret replacement configure IdentityServer to accept a JWT as a client secret link to source code\nIntrospection \u0026amp; Reference Tokens This sample shows how to use the reference tokens instead of JWTs.\nThings of interest:\nthe client registration uses AccessTokenType of value Reference the client requests scope2 - this scope is part of an API resource. API resources allow defining API secrets, which can then be used to access the introspection endpoint The API supports both JWT and reference tokens, this is achieved by forwarding the token to the right handler at runtime Key takeaways:\nconfiguring a client to receive reference tokens setup an API resource with an API secret configure an API to accept and validate reference tokens link to source code\nMVC Client Sample This sample shows how to use the authorization_code grant type. This is typically used for interactive applications like web applications.\nKey takeaways:\nconfigure an MVC client to use IdentityServer access tokens in ASP.NET Core\u0026rsquo;s authentication session call an API manually refresh tokens link to source code\nMVC Client with automatic Access Token Management This sample shows how to use IdentityModel.AspNetCore to automatically manage access tokens.\nThe sample uses a special client ID in the sample IdentityServer with a short token lifetime (75 seconds). When repeating the API call, make sure you inspect the returned iat and exp claims to observer how the token is slides.\nYou can also turn on debug tracing to get more insights in the token management library.\nKey takeaways:\nuse IdentityModel.AspNetCore to automate refreshing tokens link to source code\nMVC Client with JAR and JWT-based Authentication This sample shows how to use signed authorize requests, and JWT-based authentication for clients in MVC. It also show how to integrate that technique with automatic token management.\nKey takeaways:\nuse the ASP.NET Core extensibility points to add signed authorize requests and JWT-based authentication use JWT-based authentication for automatic token management configure a client in IdentityServer to share key material for both front- and back-channel link to source code\nMVC Client with Back-Channel Logout Notifications This sample shows how to use back-channel logout notifications.\nKey takeaways:\nhow to implement the back-channel notification endpoint how to leverage events on the cookie handler to invalidate the user session link to source code\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/fundamentals/resources/identity/",
    "title": "Identity Resources",
    "tags": [],
    "description": "",
    "content": "An identity resource is a named group of claims about a user that can be requested using the scope parameter.\nThe OpenID Connect specification suggests a couple of standard scope name to claim type mappings that might be useful to you for inspiration, but you can freely design them yourself.\nOne of them is actually mandatory, the openid scope, which tells the provider to return the sub (subject id) claim in the identity token.\nThis is how you could define the openid scope in code:\npublic static IEnumerable\u0026lt;IdentityResource\u0026gt; GetIdentityResources() { return new List\u0026lt;IdentityResource\u0026gt; { new IdentityResource( name: \u0026#34;openid\u0026#34;, userClaims: new[] { \u0026#34;sub\u0026#34; }, displayName: \u0026#34;Your user identifier\u0026#34;) }; } But since this is one of the standard scopes from the spec you can shorten that to:\npublic static IEnumerable\u0026lt;IdentityResource\u0026gt; GetIdentityResources() { return new List\u0026lt;IdentityResource\u0026gt; { new IdentityResources.OpenId() }; } See the reference section for more information on IdentityResource.\nThe following example shows a custom identity resource called profile that represents the display name, email address and website claim:\npublic static IEnumerable\u0026lt;IdentityResource\u0026gt; GetIdentityResources() { return new List\u0026lt;IdentityResource\u0026gt; { new IdentityResource( name: \u0026#34;profile\u0026#34;, userClaims: new[] { \u0026#34;name\u0026#34;, \u0026#34;email\u0026#34;, \u0026#34;website\u0026#34; }, displayName: \u0026#34;Your profile data\u0026#34;) }; } Once the resource is defined, you can give access to it to a client via the AllowedScopes option (other properties omitted):\nvar client = new Client { ClientId = \u0026#34;client\u0026#34;, AllowedScopes = { \u0026#34;openid\u0026#34;, \u0026#34;profile\u0026#34; } }; See the reference section for more information on the Client class.\nThe client can then request the resource using the scope parameter (other parameters omitted):\nhttps://demo.duendesoftware.com/connect/authorize?client_id=client\u0026amp;scope=openid profile IdentityServer will then use the scope names to create a list of requested claim types, and present that to your implementation of the profile service.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/options/",
    "title": "IdentityServer Options",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Configuration.IdentityServerOptions The IdentityServerOptions is the central place to configure fundamental settings in Duende IdentityServer.\nYou set the options at startup time in your ConfigureServices method:\nvar builder = services.AddIdentityServer(options =\u0026gt; { // configure options here.. }) Main Top-level settings.\nIssuerUri\nSet the issuer name that will appear in the discovery document and the issued JWT tokens. It is recommended to not set this property, which infers the issuer name from the host name that is used by the clients.\nLowerCaseIssuerUri\nSet to false to preserve the original casing of the IssuerUri. Defaults to true.\nAccessTokenJwtType\nSpecifies the value used for the JWT typ header for access tokens (defaults to at+jwt).\nEmitScopesAsSpaceDelimitedStringInJwt\nSpecifies whether scopes in JWTs are emitted as array or string\nHistorically scopes values were emitted as an array in JWT access tokens. The newer JWT for OAuth profile specifies a space delimited string instead. The behavior can be toggled here (defaults to false for backwards compatibility).\nEmitStaticAudienceClaim\nEmits a static aud claim in all access tokens with the format issuer/resources. Defaults to false.\nValidateTenantOnAuthorization\nSpecifies if a user\u0026rsquo;s tenant claim is compared to the tenant acr_values parameter value to determine if the login page is displayed. Defaults to false.\nKey management Controls the automatic key management settings.\nEnabled\nSpecifies if key management should be enabled. Defaults to true.\nSigningAlgorithms\nThe signing algorithms allowed. If none are specified, then \u0026ldquo;RS256\u0026rdquo; will be used as the default. The first in the collection will be used as the default.\nRotationInterval\nAge at which keys will no longer be used for signing, but will still be used in discovery for validation. Defaults to 90 days.\nPropagationTime\nTime expected to propagate new keys to all servers, and time expected all clients to refresh discovery. Defaults to 14 days.\nRetentionDuration\nDuration for keys to remain in discovery after rotation. Defaults to 14 days.\nDeleteRetiredKeys\nAutomatically delete retired keys. Defaults to true.\nKeyPath\nPath for storing keys when using the default file system store. Defaults to the \u0026ldquo;keys\u0026rdquo; directory relative to the hosting application.\nDataProtectKeys\nAutomatically protect keys in the storage using data protection. Defaults to true.\nKeyCacheDuration\nWhen in normal operation, duration to cache keys from store. Defaults to 24 hours.\nInitializationDuration\nWhen no keys have been created yet, this is the window of time considered to be an initialization period to allow all servers to synchronize if the keys are being created for the first time. Defaults to 5 minutes.\nInitializationSynchronizationDelay\nDelay used when re-loading from the store when the initialization period. It allows other servers more time to write new keys so other servers can include them. Defaults to 5 seconds.\nInitializationKeyCacheDuration\nCache duration when within the initialization period. Defaults to 1 minute.\nEndpoints Allows enabling/disabling individual endpoints, e.g. token, authorize, userinfo etc.\nvar builder = services.AddIdentityServer(options =\u0026gt; { // see endpoint section in docs for a list of endoints options.Endpoints.EnableAuthorizeEndpoint = true; options.Endpoints.EnableIntrospectionEndpoint = false; }) By default all endpoints are enabled, but you can lock down your server by disabling endpoint that you don\u0026rsquo;t need.\nEnableJwtRequestUri\nEnabling the request_uri parameter has some security implications (see spec). Thus support for this parameter is disabled by default.\nDiscovery Allows enabling/disabling various sections of the discovery document, e.g. endpoints, scopes, claims, grant types etc.\nvar builder = services.AddIdentityServer(options =\u0026gt; { options.Discovery.ShowApiScopes = false; options.Discovery.ShowClaims = false; // etc } The CustomEntries dictionary allows adding custom elements to the discovery document.\nvar builder = services.AddIdentityServer(options =\u0026gt; { options.Discovery.CustomEntries.Add(\u0026#34;my_setting\u0026#34;, \u0026#34;foo\u0026#34;); options.Discovery.CustomEntries.Add(\u0026#34;my_complex_setting\u0026#34;, new { foo = \u0026#34;foo\u0026#34;, bar = \u0026#34;bar\u0026#34; }); }); When you add a custom value that starts with ~/ it will be expanded to an absolute path below the IdentityServer base address, e.g.:\noptions.Discovery.CustomEntries.Add(\u0026#34;my_custom_endpoint\u0026#34;, \u0026#34;~/custom\u0026#34;); If you want to take full control over the rendering of the discovery (and jwks) document, you can implement the IDiscoveryResponseGenerator interface (or derive from our default implementation).\nAuthentication Login/logout related settings.\nCookieAuthenticationScheme\nSets the cookie authentication scheme configured by the host used for interactive users. If not set, the scheme will be inferred from the host\u0026rsquo;s default authentication scheme. This setting is typically used when AddPolicyScheme is used in the host as the default scheme.\nCookieLifetime\nThe authentication cookie lifetime (only effective if the IdentityServer-provided cookie handler is used).\nCookieSlidingExpiration\nSpecifies if the cookie should be sliding or not (only effective if the IdentityServer-provided cookie handler is used).\nCookieSameSiteMode\nSpecifies the SameSite mode for the internal cookies.\nRequireAuthenticatedUserForSignOutMessage\nIndicates if user must be authenticated to accept parameters to end session endpoint. Defaults to false.\nCheckSessionCookieName\nThe name of the cookie used for the check session endpoint.\nCheckSessionCookieDomain\nThe domain of the cookie used for the check session endpoint.\nCheckSessionCookieSameSiteMode\nThe SameSite mode of the cookie used for the check session endpoint.\nRequireCspFrameSrcForSignout\nIf set, will require frame-src CSP headers being emitting on the end session callback endpoint which renders iframes to clients for front-channel signout notification. Defaults to true.\nEvents Allows configuring if and which events should be submitted to a registered event sink. See :ref:here \u0026lt;refEvents\u0026gt; TODO for more information on events.\nvar builder = services.AddIdentityServer(options =\u0026gt; { options.Events.RaiseSuccessEvents = true; options.Events.RaiseFailureEvents = true; options.Events.RaiseErrorEvents = true; options.Events.RaiseInformationEvents = true; }) Logging Options related to logging.\nAuthorizeRequestSensitiveValuesFilter\nCollection of parameter names passed to the authorize endpoint that are considered sensitive and will be excluded from logging.\nTokenRequestSensitiveValuesFilter\nCollection of parameter names passed to the token endpoint that are considered sensitive and will be excluded from logging.\nInputLengthRestrictions Allows setting length restrictions on various protocol parameters like client id, scope, redirect URI etc.\nvar builder = services.AddIdentityServer(options =\u0026gt; { // allow scope parameter up to 1000 characters options.InputLengthRestrictions.Scope = 1000; }) UserInteraction Setting regarding the IdentityServer / user workflow.\nLoginUrl, LogoutUrl, ConsentUrl, ErrorUrl, DeviceVerificationUrl\nSets the URLs for the login, logout, consent, error and device verification pages.\nLoginReturnUrlParameter\nSets the name of the return URL parameter passed to the login page. Defaults to returnUrl.\nLogoutIdParameter\nSets the name of the logout message id parameter passed to the logout page. Defaults to logoutId.\nConsentReturnUrlParameter\nSets the name of the return URL parameter passed to the consent page. Defaults to returnUrl.\nErrorIdParameter\nSets the name of the error message id parameter passed to the error page. Defaults to errorId.\nCustomRedirectReturnUrlParameter\nSets the name of the return URL parameter passed to a custom redirect from the authorization endpoint. Defaults to returnUrl.\nDeviceVerificationUserCodeParameter\nSets the name of the user code parameter passed to the device verification page. Defaults to userCode.\nCookieMessageThreshold\nCertain interactions between IdentityServer and some UI pages require a cookie to pass state and context (any of the pages above that have a configurable \u0026ldquo;message id\u0026rdquo; parameter). Since browsers have limits on the number of cookies and their size, this setting is used to prevent too many cookies being created. The value sets the maximum number of message cookies of any type that will be created. The oldest message cookies will be purged once the limit has been reached. This effectively indicates how many tabs can be opened by a user when using IdentityServer.\nAllowOriginInReturnUrl\nFlag that allows return URL validation to accept full URL that includes the IdentityServer origin. Defaults to false.\nCaching These settings only apply if the respective caching has been enabled in the services configuration in startup.\nClientStoreExpiration\nCache duration of client configuration loaded from the client store.\nResourceStoreExpiration\nCache duration of identity and API resource configuration loaded from the resource store.\nCorsExpiration\nCache duration of CORS configuration loaded from the CORS policy service.\nIdentityProviderCacheDuration\nCache duration of identity provider configuration loaded from the identity provider store.\nCORS IdentityServer supports CORS for some of its endpoints. The underlying CORS implementation is provided from ASP.NET Core, and as such it is automatically registered in the dependency injection system.\nCorsPolicyName\nName of the CORS policy that will be evaluated for CORS requests into IdentityServer (defaults to IdentityServer). The policy provider that handles this is implemented in terms of the ICorsPolicyService registered in the dependency injection system. If you wish to customize the set of CORS origins allowed to connect, then it is recommended that you provide a custom implementation of ICorsPolicyService.\nCorsPaths\nThe endpoints within IdentityServer where CORS is supported. Defaults to the discovery, user info, token, and revocation endpoints.\nPreflightCacheDuration\nIndicates the value to be used in the preflight Access-Control-Max-Age response header. Defaults to null indicating no caching header is set on the response.\nCSP (Content Security Policy) IdentityServer emits CSP headers for some responses, where appropriate.\nLevel\nThe level of CSP to use. CSP Level 2 is used by default, but if older browsers must be supported then this be changed to CspLevel.One to accommodate them.\nAddDeprecatedHeader\nIndicates if the older X-Content-Security-Policy CSP header should also be emitted (in addition to the standards-based header value). Defaults to true.\nDevice Flow OAuth device flow related settings.\nDefaultUserCodeType\nThe user code type to use, unless set at the client level. Defaults to Numeric, a 9-digit code.\nInterval\nDefines the minimum allowed polling interval on the token endpoint. Defaults to 5.\nMutual TLS Mutual TLS enabled settings. See MTLS section for more information. TODO\nvar builder = services.AddIdentityServer(options =\u0026gt; { options.MutualTls.Enabled = true; // use mtls sub-domain options.MutualTls.DomainName = \u0026#34;mtls\u0026#34;; options.MutualTls.AlwaysEmitConfirmationClaim = true; }) Enabled\nSpecifies if MTLS support should be enabled. Defaults to false.\nClientCertificateAuthenticationScheme\nSpecifies the name of the authentication handler for X.509 client certificates. Defaults to Certificate.\nDomainName\nSpecifies either the name of the sub-domain or full domain for running the MTLS endpoints (will use path-based endpoints if not set). Use a simple string (e.g. \u0026ldquo;mtls\u0026rdquo;) to set a sub-domain, use a full domain name (e.g. \u0026ldquo;identityserver-mtls.io\u0026rdquo;) to set a full domain name. When a full domain name is used, you also need to set the IssuerName to a fixed value.\nAlwaysEmitConfirmationClaim\nSpecifies whether a cnf claim gets emitted for access tokens if a client certificate was present. Normally the cnf claims only gets emitted if the client used the client certificate for authentication, setting this to true, will set the claim regardless of the authentication method. (defaults to false).\nDynamic Providers Shared settings for the dynamic providers feature.\nPathPrefix\nPrefix in the pipeline for callbacks from external providers. Defaults to \u0026ldquo;/federation\u0026rdquo;.\nSignInScheme\nScheme used for signin. Defaults to the constant IdentityServerConstants.ExternalCookieAuthenticationScheme.\nSignOutScheme\nScheme for signout. Defaults to the constant IdentityServerConstants.DefaultCookieAuthenticationScheme.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/diagnostics/logging/",
    "title": "Logging",
    "tags": [],
    "description": "",
    "content": "Duende IdentityServer uses the standard logging facilities provided by ASP.NET Core. You don\u0026rsquo;t need to do any extra configuration.\nThe Microsoft documentation has a good intro and a description of the built-in logging providers.\nWe are roughly following the Microsoft guidelines for usage of log levels:\nTrace\nFor information that is valuable only to a developer troubleshooting an issue. These messages may contain sensitive application data like tokens and should not be enabled in a production environment.\nDebug\nFor following the internal flow and understanding why certain decisions are made. Has short-term usefulness during development and debugging.\nInformation\nFor tracking the general flow of the application. These logs typically have some long-term value.\nWarning\nFor abnormal or unexpected events in the application flow. These may include errors or other conditions that do not cause the application to stop, but which may need to be investigated.\nError\nFor errors and exceptions that cannot be handled. Examples: failed validation of a protocol request.\nCritical\nFor failures that require immediate attention. Examples: missing store implementation, invalid key material\u0026hellip;\nIn production, logging might produce too much data. It is recommended you either turn it off, or default to the Warning level. Have a look at events for more high-level production instrumentation.\nSetup for Serilog We personally like Serilog and the Serilog.AspNetCore package a lot. Give it a try:\npublic class Program { public static int Main(string[] args) { Activity.DefaultIdFormat = ActivityIdFormat.W3C; Log.Logger = new LoggerConfiguration() .MinimumLevel.Debug() .MinimumLevel.Override(\u0026#34;Microsoft\u0026#34;, LogEventLevel.Warning) .MinimumLevel.Override(\u0026#34;Microsoft.Hosting.Lifetime\u0026#34;, LogEventLevel.Information) .MinimumLevel.Override(\u0026#34;System\u0026#34;, LogEventLevel.Warning) .MinimumLevel.Override(\u0026#34;Microsoft.AspNetCore.Authentication\u0026#34;, LogEventLevel.Information) .Enrich.FromLogContext() .WriteTo.Console(outputTemplate: \u0026#34;[{Timestamp:HH:mm:ss} {Level}] {SourceContext}{NewLine}{Message:lj}{NewLine}{Exception}{NewLine}\u0026#34;, theme: AnsiConsoleTheme.Code) .CreateLogger(); try { Log.Information(\u0026#34;Starting host...\u0026#34;); CreateHostBuilder(args).Build().Run(); return 0; } catch (Exception ex) { Log.Fatal(ex, \u0026#34;Host terminated unexpectedly.\u0026#34;); return 1; } finally { Log.CloseAndFlush(); } } public static IHostBuilder CreateHostBuilder(string[] args) =\u0026gt; Microsoft.Extensions.Hosting.Host.CreateDefaultBuilder(args) .UseSerilog() .ConfigureWebHostDefaults(webBuilder =\u0026gt; { webBuilder.UseStartup\u0026lt;Startup\u0026gt;(); }); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/bff/extensibility/management/",
    "title": "Management Endpoints",
    "tags": [],
    "description": "",
    "content": "When you add Duende.BFF to DI - a default implementation for every management endpoint gets registered:\n// management endpoints services.AddTransient\u0026lt;ILoginService, DefaultLoginService\u0026gt;(); services.AddTransient\u0026lt;ILogoutService, DefaultLogoutService\u0026gt;(); services.AddTransient\u0026lt;IUserService, DefaultUserService\u0026gt;(); services.AddTransient\u0026lt;IBackchannelLogoutService, DefaultBackchannelLogoutService\u0026gt;(); You can add your own implementation, by overriding our default after calling AddBff().\nThe interface of the management endpoints is pretty generic, and allows for inserting any custom logic:\npublic interface IBffEndpointService { Task ProcessRequestAsync(HttpContext context); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/deployment/proxies/",
    "title": "Proxy Servers and Load Balancers",
    "tags": [],
    "description": "",
    "content": "In most situations, your IdentityServer is hosted using the IIS/ASP.NET Core Module, Nginx, or Apache. Proxy servers, load balancers, and other network appliances often obscure information about the request before it reaches the host, e.g.:\nwhen HTTPS requests are proxied over HTTP, the original scheme (HTTPS) is lost and must be forwarded in a header. because an app receives a request from the proxy and not its true source on the Internet or corporate network, the originating client IP address must also be forwarded in a header. Common effects of such infrastructures is that the HTTPS gets turned into HTTP, or that host names are incorrect in the discovery document or on redirect. In almost all cases, these problems can be solved by adding the ForwardedHeaders middleware to you pipeline. This takes care of translating the information received from reverse proxies or load balancers back into a format ASP.NET Core can understand it.\nPlease consult the Microsoft documentation for more details.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/tokens/requesting/",
    "title": "Requesting a Token",
    "tags": [],
    "description": "",
    "content": "A typical architecture is composed of two application (aka client) types - machine to machine calls and interactive applications.\nMachine to Machine communication In this scenario a headless application with no interactive user (e.g. a server daemon, batch job etc.) wants to call an API.\nPrerequisites are:\ndefine a client for the client credentials grant type define an API scope (and optionally a resource) grant the client access to the scope via the AllowedScopes property According to the OAuth specification, you request a token by posting to the token endpoint:\nPOST /connect/token CONTENT-TYPE application/x-www-form-urlencoded client_id=client1\u0026amp; client_secret=secret\u0026amp; grant_type=client_credentials\u0026amp; scope=scope1 In the success case, this will return a JSON response containing the access token:\nHTTP/1.1 200 OK Content-Type: application/json;charset=UTF-8 Cache-Control: no-store Pragma: no-cache { \u0026#34;access_token\u0026#34;: \u0026#34;2YotnFZFEjr1zCsicMWpAA\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;bearer\u0026#34;, \u0026#34;expires_in\u0026#34;: 3600, } .NET client library On .NET you can leverage the IdentityModel client library to request tokens.\nThe above token request would look like this in C#:\nusing IdentityModel.Client; var client = new HttpClient(); var response = await client.RequestClientCredentialsTokenAsync(new ClientCredentialsTokenRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/token\u0026#34;, ClientId = \u0026#34;m2m\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Scope = \u0026#34;api\u0026#34; }); Automating token requests in ASP.NET Core and Worker applications The IdentityModel.AspNetCore library can automate client credential request and token lifetime management for you.\nUsing this library, you only need to register the token client in DI:\npublic void ConfigureServices(IServiceCollection services) { services.AddAccessTokenManagement(options =\u0026gt; { options.Client.Clients.Add(\u0026#34;client\u0026#34;, new ClientCredentialsTokenRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/token\u0026#34;, ClientId = \u0026#34;m2m\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Scope = \u0026#34;api\u0026#34; }); }); } You can then add token management to an HTTP-factory provided client:\nservices.AddClientAccessTokenClient(\u0026#34;client\u0026#34;, configureClient: client =\u0026gt; { client.BaseAddress = new Uri(\u0026#34;https://demo.duendesoftware.com/api/\u0026#34;); }); \u0026hellip;and finally use the client with automatic token management in your application code:\npublic class DataController : Controller { IHttpClientFactory _factory; public DataController(IHttpClientFactory factory) { _factory = factory; } public IActionResult Index() { var client = _factory.CreateClient(\u0026#34;client\u0026#34;); // rest omitted } } Interactive applications In this scenario, an interactive application like a web application or mobile/desktop app wants to call an API in the context of an authenticated user (see spec here).\nYou will receive three tokens - an identity token containing details about the end-user authentication, the access token to call the API, and a refresh token for access token lifetime management. The access token will also contain some information about the end-user (e.g. the user ID), so that the API can do authorization based on the user\u0026rsquo;s identity.\nIn this scenario you typically use the authorization code flow which first involves a call to the authorize endpoint for all human interactions (e.g. login and/or consent). This returns a code, which you then redeem at the token endpoint to retrieve identity and access tokens.\nPrerequisites are:\ndefine a client for the authorization code grant type define an identity resource, e.g. openid define an API scope (and optionally a resource) grant the client access to both scopes via the AllowedScopes property Front-channel The call to the authorize endpoint is one using a redirect in the browser:\nGET /connect/authorize? client_id=client1\u0026amp; scope=openid api1\u0026amp; response_type=code\u0026amp; redirect_uri=https://myapp/callback\u0026amp; On success, the browser will ultimately redirect to the callback endpoint transmitting the authorization code (and other parameters like the granted scopes):\nGET /callback? code=abc\u0026amp; scope=openid api1 Back-channel The client then opens a back-channel communication to the token service to retrieve the tokens:\nPOST /connect/token CONTENT-TYPE application/x-www-form-urlencoded client_id=client1\u0026amp; client_secret=secret\u0026amp; grant_type=authorization_code\u0026amp; code=abc\u0026amp; redirect_uri=https://myapp/callback In this scenario, the token response will contain three tokens:\nHTTP/1.1 200 OK Content-Type: application/json;charset=UTF-8 Cache-Control: no-store Pragma: no-cache { \u0026#34;id_token\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;access_token\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;refresh_token\u0026#34;: \u0026#34;...\u0026#34; \u0026#34;token_type\u0026#34;: \u0026#34;bearer\u0026#34;, \u0026#34;expires_in\u0026#34;: 3600, } See the refresh token section for more information on how to deal with refresh tokens. TODO link\n.NET client library The most common client library for .NET is the OpenID Connect authentication handler for ASP.NET Core. This library handles the complete front- and back-channel interaction and coordination.\nYou only need to configure it in your startup code:\npublic void ConfigureServices(IServiceCollection services) { services.AddAuthentication(options =\u0026gt; { options.DefaultScheme = \u0026#34;cookie\u0026#34;; options.DefaultChallengeScheme = \u0026#34;duende\u0026#34;; }) .AddCookie(\u0026#34;cookie\u0026#34;) .AddOpenIdConnect(\u0026#34;duende\u0026#34;, \u0026#34;IdentityServer\u0026#34;, options =\u0026gt; { options.Authority = \u0026#34;https://demo.duendesoftware.com\u0026#34;; options.ClientId = \u0026#34;interactive.confidential\u0026#34;; options.ResponseType = \u0026#34;code\u0026#34;; options.ResponseMode = \u0026#34;query\u0026#34;; options.SaveTokens = true; options.Scope.Clear(); options.Scope.Add(\u0026#34;openid\u0026#34;); options.Scope.Add(\u0026#34;api\u0026#34;); options.Scope.Add(\u0026#34;offline_access\u0026#34;); options.TokenValidationParameters = new TokenValidationParameters { NameClaimType = \u0026#34;name\u0026#34;, RoleClaimType = \u0026#34;role\u0026#34; }; }); } Automating token management in ASP.NET Core The IdentityModel.AspNetCore library can also be used to automate token lifetime management in ASP.NET Core applications for you.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/tokens/authentication/shared_secret/",
    "title": "Shared Secrets",
    "tags": [],
    "description": "",
    "content": "Shared secrets is by far the most common technique for authenticating clients.\nFrom a security point of view they have some shortcomings\nthe shared secrets must be transmitted over the network during authentication they should not be persisted in clear text to reduce leaking them they should have high entropy to avoid brute-forcing attacks The following snippet creates a shared secret.\nvar secret = new Secret(\u0026#34;good_high_entropy_secret\u0026#34;.Sha256()); By default it is assumed that every shared secret is hashed either using SHA256 or SHA512. If you load from a data store, your IdentityServer would store the hashed version only, whereas the client needs access to the plain text version.\nAuthentication using a shared secret You can either send the client id/secret combination as part of the POST body::\nPOST /connect/token Content-type: application/x-www-form-urlencoded client_id=client\u0026amp; client_secret=secret\u0026amp; grant_type=authorization_code\u0026amp; code=hdh922\u0026amp; redirect_uri=https://myapp.com/callback ..or as a basic authentication header::\nPOST /connect/token Content-type: application/x-www-form-urlencoded Authorization: Basic xxxxx client_id=client1\u0026amp; client_secret=secret\u0026amp; grant_type=authorization_code\u0026amp; code=hdh922\u0026amp; redirect_uri=https://myapp.com/callback .NET client library You can use the IdentityModel client library to programmatically interact with the protocol endpoint from .NET code.\nusing IdentityModel.Client; var client = new HttpClient(); var response = await client.RequestAuthorizationCodeTokenAsync(new AuthorizationCodeTokenRequest { Address = TokenEndpoint, ClientId = \u0026#34;client\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Code = \u0026#34;...\u0026#34;, CodeVerifier = \u0026#34;...\u0026#34;, RedirectUri = \u0026#34;https://app.com/callback\u0026#34; }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/overview/terminology/",
    "title": "Terminology",
    "tags": [],
    "description": "",
    "content": "The specs, documentation and object model use a certain terminology that you should be aware of.\nDuende IdentityServer Duende IdentityServer is an OpenID Connect \u0026amp; OAuth engine - it implements the OpenID Connect and OAuth 2.0 family of protocols.\nDifferent literature uses different terms for the same role - you probably also find the terms security token service, identity provider, authorization server, IP-STS and more.\nBut they are in a nutshell all the same: a piece of software that issues security tokens to clients.\nA typical implementation of Duende IdentityServer has a number of jobs and features - including:\nmanage access to resources authenticate users using a local account store or via an external identity provider provide session management and single sign-on manage and authenticate clients issue identity and access tokens to clients User A user is a human that is using a registered client to access resources.\nClient A client is a piece of software that requests tokens from your IdentityServer - either for authenticating a user (requesting an identity token) or for accessing a resource (requesting an access token). A client must be first registered with your IdentityServer before it can request tokens.\nWhile there are many different client types, e.g. web applications, native mobile or desktop applications, SPAs, server processes etc., they can all be put into two high-level categories.\nMachine to Machine Communication In this scenario two machines talk to each other (e.g. background processes, batch jobs, server daemons), and there is no interactive user present. To authorize this communication, your IdentityServer issues a token to the caller.\nIn protocol terms, this scenario is called Client Credentials Flow and you can learn more about it in the issuing tokens section as well as in our Quickstart.\nInteractive Applications This is the most common type of client scenario: web applications, SPAs or native/mobile apps with interactive users. This scenario typically involves a browser for user interaction (e.g. for authentication or consent).\nIn protocol terms, this scenario is called Authorization Code Flow and you can learn more about it in the issuing tokens section as well as in our Quickstart.\nA client application can potentially have many instances - e.g. your web application might be physically deployed on multiple servers for load-balancing purposes, or your mobile application might be deployed to thousands of different phones. Logically these instances are still a single client.\nResources Resources are something you want to protect with your IdentityServer - either identity data of your users, or APIs.\nEvery resource has a unique name - and clients use this name to specify to which resources they want to get access to.\nIdentity data Identity information (aka claims) about a user, e.g. name or email address.\nAPIs APIs resources represent functionality a client wants to invoke - typically modelled as Web APIs, but not necessarily.\nIdentity Token An identity token represents the outcome of an authentication process. It contains at a bare minimum an identifier for the user (called the sub aka subject claim) and information about how and when the user authenticated. It can contain additional identity data.\nAccess Token An access token allows access to an API resource. Clients request access tokens and forward them to the API. Access tokens contain information about the client and the user (if present). APIs use that information to authorize access to their data and functionality.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/tokens/extension_grants/token_exchange/",
    "title": "Token Exchange",
    "tags": [],
    "description": "",
    "content": "The OAuth Token Exchange specification (RFC 8693) describes a general purpose mechanism for translating between token types. Common use cases are creating tokens for impersonation and delegation purposes - but it is not limited to that.\nYou can leverage the extension grant feature to implement your preferred token exchange logic.\nSome of the logic is boilerplate:\nread and validate incoming protocol parameters validate incoming token using the built-in token validator if the token was issued by the same token service using a token type specific library if the token is coming from a trusted (but different) token service read contents of token to apply custom logic/authorization if needed create response Here\u0026rsquo;s a simple implementation of the above steps:\npublic class TokenExchangeGrantValidator : IExtensionGrantValidator { private readonly ITokenValidator _validator; public TokenExchangeGrantValidator(ITokenValidator validator) { _validator = validator; } // register for urn:ietf:params:oauth:grant-type:token-exchange public string GrantType =\u0026gt; OidcConstants.GrantTypes.TokenExchange; public async Task ValidateAsync(ExtensionGrantValidationContext context) { // default response is error context.Result = new GrantValidationResult(TokenRequestErrors.InvalidRequest); // the spec allows for various token types, most commonly you return an access token var customResponse = new Dictionary\u0026lt;string, object\u0026gt; { { OidcConstants.TokenResponse.IssuedTokenType, OidcConstants.TokenTypeIdentifiers.AccessToken } }; // read the incoming token var subjectToken = context.Request.Raw.Get(OidcConstants.TokenRequest.SubjectToken); // and the token type var subjectTokenType = context.Request.Raw.Get(OidcConstants.TokenRequest.SubjectTokenType); // mandatory parameters if (string.IsNullOrWhiteSpace(subjectToken)) { return; } // for our impersonation/delegation scenario we require an access token if (!string.Equals(subjectTokenType, OidcConstants.TokenTypeIdentifiers.AccessToken)) { return; } // validate the incoming access token with the built-in token validator var validationResult = await _validator.ValidateAccessTokenAsync(subjectToken); if (validationResult.IsError) { return; } // these are two values you typically care about var sub = validationResult.Claims.First(c =\u0026gt; c.Type == JwtClaimTypes.Subject).Value; var clientId = validationResult.Claims.First(c =\u0026gt; c.Type == JwtClaimTypes.ClientId).Value; // add any custom logic here (if needed) // create response } } You then register your grant validator with DI:\nbuilder.AddExtensionGrantValidator\u0026lt;TokenExchangeGrantValidator\u0026gt;(); And configure your client to be able to use it:\nclient.AllowedGrantTypes = { OidcConstants.GrantTypes.TokenExchange }; Values sent to the token endpoint are logged, except well-known sensitive values that IdentityServer processes by default. Any sensitive values you use as input to your extension grant validator that you do not want included in the logs should be filtered. This can be done by adding those parameter names on the Logging.TokenRequestSensitiveValuesFilter collection on the IdentityServerOptions.\nToken Exchange for impersonation and delegation One of the primary use cases of the token exchange specification is creating tokens for identity delegation and impersonation scenarios. In these scenarios you want to forward certain token and identity information over multiple hops in a call chain.\nImpersonation In the impersonation use case, API 1 doing the token exchange becomes \u0026ldquo;invisible\u0026rdquo;. For API 2 it looks like as if the front end is doing a direct call. The token would look like this (simplified):\n{ \u0026#34;client_id\u0026#34;: \u0026#34;front_end\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;scope\u0026#34;: [ \u0026#34;api2\u0026#34; ] } Add the following code to the above validator to create an impersonation response:\n// set token client_id to original id context.Request.ClientId = clientId; // create impersonation response context.Result = new GrantValidationResult( subject: sub, authenticationMethod: GrantType, customResponse: customResponse); Delegation In the delegation use case, the call chain is preserved using the act claim, e.g.:\n{ \u0026#34;client_id\u0026#34;: \u0026#34;front-end\u0026#34;, \u0026#34;act\u0026#34;: { \u0026#34;client_id\u0026#34;: \u0026#34;api1\u0026#34; }, \u0026#34;sub\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;scope\u0026#34;: [ \u0026#34;api2\u0026#34; ] } For API 2 it still looks like that the front-end is making the call, but by inspecting the act claim, the API can learn about the traversed call chain.\nThe following code adds the act claim to the response:\n// set token client_id to original id context.Request.ClientId = clientId; // create actor data structure var actor = new { client_id = context.Request.Client.ClientId }; // create act claim var actClaim = new Claim(JwtClaimTypes.Actor, JsonSerializer.Serialize(actor), IdentityServerConstants.ClaimValueTypes.Json); context.Result = new GrantValidationResult( subject: sub, authenticationMethod: GrantType, claims: new[] { actClaim }, customResponse: customResponse); To emit the act claim into outgoing tokens, your profile service must know about it. The following simple profile service emits the act claim if the token request is in the context of a token exchange operation:\npublic class ProfileService : IProfileService { public override async Task GetProfileDataAsync(ProfileDataRequestContext context) { // add actor claim if needed if (context.Subject.GetAuthenticationMethod() == OidcConstants.GrantTypes.TokenExchange) { var act = context.Subject.FindFirst(JwtClaimTypes.Actor); if (act != null) { context.IssuedClaims.Add(act); } } // rest omitted } // rest omitted } See here for the full source code.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/apis/aspnetcore/jwt/",
    "title": "Using JWTs",
    "tags": [],
    "description": "",
    "content": "On ASP.NET Core, you typically use the JWT authentication handler for validating JWT bearer tokens.\nValidating a JWT token First you need add a reference to the authentication handler to your API project:\n\u0026lt;PackageReference Include=\u0026#34;Microsoft.AspNetCore.Authentication.JwtBearer\u0026#34; /\u0026gt; If all you care about, is making sure that an access token comes from your trusted IdentityServer, the following snippet shows the typical JWT validation configuration for ASP.NET Core:\npublic class Startup { public void ConfigureServices(IServiceCollection services) { services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) .AddJwtBearer(options =\u0026gt; { // base-address of your identityserver options.Authority = \u0026#34;https://demo.duendesoftware.com\u0026#34;; // audience is optional, make sure you read the following paragraphs // to understand your options options.TokenValidationParameters.ValidateAudience = false; // it\u0026#39;s recommended to check the type header to avoid \u0026#34;JWT confusion\u0026#34; attacks options.TokenValidationParameters.ValidTypes = new[] { \u0026#34;at+jwt\u0026#34; }; }); } } On .NET Core 3.1 you need to manually reference the System.IdentityModel.Tokens.Jwt NuGet package version 5.6 to be able to check the type header.\nAdding audience validation Simply making sure that the token is coming from a trusted issuer is not good enough for most cases. In more complex systems, you will have multiple resources and multiple clients. Not every client might be authorized to access every resource.\nIn OAuth there are two complementary mechanisms to embed more information about the \u0026ldquo;functionality\u0026rdquo; that the token is for - audience and scope (see defining resources for more information).\nIf you designed your APIs around the concept of API resources, your IdentityServer will emit the aud claim by default (api1 in this example):\n{ \u0026#34;typ\u0026#34;: \u0026#34;at+jwt\u0026#34;, \u0026#34;kid\u0026#34;: \u0026#34;123\u0026#34; }. { \u0026#34;aud\u0026#34;: \u0026#34;api1\u0026#34;, \u0026#34;client_id\u0026#34;: \u0026#34;mobile_app\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;read write delete\u0026#34; } If you want to express in your API, that only access tokens for the api1 audience (aka API resource name) are accepted, change the above code snippet to:\npublic class Startup { public void ConfigureServices(IServiceCollection services) { services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) .AddJwtBearer(options =\u0026gt; { options.Authority = \u0026#34;https://demo.duendesoftware.com\u0026#34;; options.Audience = \u0026#34;api1\u0026#34;; options.TokenValidationParameters.ValidTypes = new[] { \u0026#34;at+jwt\u0026#34; }; }); } } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/apis/aspnetcore/",
    "title": "Protecting APIs using ASP.NET Core",
    "tags": [],
    "description": "",
    "content": "Protecting APIs using ASP.NET Core Using JWTs Using Reference Tokens Authorization based on Scopes and other Claims Validating Proof-of-Possession "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/response_handling/authorize_interaction_response_generator/",
    "title": "Authorize Interaction Response Generator",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.ResponseHandling.IAuthorizeInteractionResponseGenerator The IAuthorizeInteractionResponseGenerator interface models the logic for determining if user must login or consent when making requests to the authorization endpoint.\nIf a custom implementation of IAuthorizeInteractionResponseGenerator is desired, the it\u0026rsquo;s recommended to derive from the built-in AuthorizeInteractionResponseGenerator to inherit all the default logic pertaining to login and consent semantics.\nIAuthorizeInteractionResponseGenerator APIs ProcessInteractionAsync\nReturns the InteractionResponse based on the ValidatedAuthorizeRequest an and optional ConsentResponse if the user was shown a consent page.\nInteractionResponse IsLogin\nSpecifies if the user must login.\nIsConsent\nSpecifies if the user must consent.\nIsError\nSpecifies if the user must be shown an error page.\nError\nThe error to display on the error page.\nErrorDescription\nThe description of the error to display on the error page.\nIsRedirect\nSpecifies if the user must be redirected to a custom page for custom processing.\nRedirectUrl\nThe URL for the redirect to the page for custom processing.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/data/configuration/",
    "title": "Configuration Data",
    "tags": [],
    "description": "",
    "content": "Configuration data models the information for Clients and Resources.\nStores Store interfaces are designed to abstract accessing the configuration data. The stores used in Duende IdentityServer are:\nClient store for Client data. CORS policy service for CORS support. Given that this is so closely tied to the Client configuration data, the CORS policy service is considered one of the configuration stores. Resource store for IdentityResource, ApiResource, and ApiScope data. Identity Provider store for IdentityProvider data. Registering Custom Stores Custom implementations of the stores must be registered in the DI system. There are convenience methods for registering these. For example:\npublic void ConfigureServices(IServiceCollection services) { services.AddIdentityServer() .AddClientStore\u0026lt;YourCustomClientStore\u0026gt;() .AddCorsPolicyService\u0026lt;YourCustomCorsPolicyService\u0026gt;() .AddResourceStore\u0026lt;YourCustomResourceStore\u0026gt;() .AddIdentityProviderStore\u0026lt;YourCustomAddIdentityProviderStore\u0026gt;(); } Caching Configuration Data Configuration data is used frequently during request processing. If this data is loaded from a database or other external store, then it might be expensive to frequently re-load the same data.\nDuende IdentityServer provides convenience methods to enable caching data from the various stores. The caching implementation relies upon an ICache\u0026lt;T\u0026gt; service and must also be added to DI. For example:\npublic void ConfigureServices(IServiceCollection services) { services.AddIdentityServer() .AddClientStore\u0026lt;YourCustomClientStore\u0026gt;() .AddCorsPolicyService\u0026lt;YourCustomCorsPolicyService\u0026gt;() .AddResourceStore\u0026lt;YourCustomResourceStore\u0026gt;() .AddInMemoryCaching() .AddClientStoreCache\u0026lt;YourCustomClientStore\u0026gt;() .AddCorsPolicyCache\u0026lt;YourCustomCorsPolicyService\u0026gt;() .AddResourceStoreCache\u0026lt;YourCustomResourceStore\u0026gt;() .AddIdentityProviderStoreCache\u0026lt;YourCustomAddIdentityProviderStore\u0026gt;(); } The duration of the data in the default cache is configurable on the IdentityServerOptions. For example:\npublic void ConfigureServices(IServiceCollection services) { services.AddIdentityServer(options =\u0026gt; { options.Caching.ClientStoreExpiration = TimeSpan.FromMinutes(5); options.Caching.ResourceStoreExpiration = TimeSpan.FromMinutes(5); }) .AddClientStore\u0026lt;YourCustomClientStore\u0026gt;() .AddCorsPolicyService\u0026lt;YourCustomCorsPolicyService\u0026gt;() .AddResourceStore\u0026lt;YourCustomResourceStore\u0026gt;() .AddInMemoryCaching() .AddClientStoreCache\u0026lt;YourCustomClientStore\u0026gt;() .AddCorsPolicyCache\u0026lt;YourCustomCorsPolicyService\u0026gt;() .AddResourceStoreCache\u0026lt;YourCustomResourceStore\u0026gt;(); } Further customization of the cache is possible:\nIf you wish to customize the caching behavior for the specific configuration objects, you can replace the ICache\u0026lt;T\u0026gt; service implementation in the dependency injection system. The default implementation of the ICache\u0026lt;T\u0026gt; itself relies upon the IMemoryCache interface (and MemoryCache implementation) provided by .NET. If you wish to customize the in-memory caching behavior, you can replace the IMemoryCache implementation in the dependency injection system. In-Memory Stores The various in-memory configuration APIs allow for configuring IdentityServer from an in-memory list of the various configuration objects. These in-memory collections can be hard-coded in the hosting application, or could be loaded dynamically from a configuration file or a database. By design, though, these collections are only created when the hosting application is starting up.\nUse of these configuration APIs are designed for use when prototyping, developing, and/or testing where it is not necessary to dynamically consult database at runtime for the configuration data. This style of configuration might also be appropriate for production scenarios if the configuration rarely changes, or it is not inconvenient to require restarting the application if the value must be changed.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/fundamentals/hosting/",
    "title": "Hosting",
    "tags": [],
    "description": "",
    "content": "You add the Duende IdentityServer engine to any ASP.NET Core application by adding the relevant services to the dependency injection (DI) system and adding the middleware to the processing pipeline.\nWhile technically you could share the ASP.NET Core host between Duende IdentityServer, clients or APIs. We recommend putting your IdentityServer into a separate application.\nDI system You add the necessary services to the DI system by calling AddIdentityServer in your startup class:\npublic void ConfigureServices(IServiceCollection services) { var builder = services.AddIdentityServer(options =\u0026gt; { ... }); } Many of the fundamental configuration settings can be set on the options. See the IdentityServerOptions reference for more details.\nThe builder object has a number of extension methods to add additional services to DI. You can see the full list in the reference section, but very commonly you start by adding the configuration stores for clients and resources, e.g.:\nvar builder = services.AddIdentityServer() .AddInMemoryClients(Config.Clients) .AddInMemoryIdentityResources(Config.IdentityResources) .AddInMemoryApiScopes(Config.ApiScopes) The above is using the in-memory stores, but we also support EntityFramework-based implementations and custom stores. See here for more information.\nPipeline You need to add the Duende IdentityServer middleware to the pipeline by calling UseIdentityServer.\nSince ordering is important in the pipeline, you typically want to put the IdentityServer middleware after the static files, but before the UI framework like MVC.\nThis would be a very typical minimal pipeline:\npublic void Configure(IApplicationBuilder app) { app.UseStaticFiles(); app.UseRouting(); app.UseIdentityServer(); app.UseAuthorization(); app.UseEndpoints(endpoints =\u0026gt; { endpoints.MapDefaultControllerRoute(); }); } UseIdentityServer includes a call to UseAuthentication, so it’s not necessary to have both.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/bff/apis/local/",
    "title": "Local APIs",
    "tags": [],
    "description": "",
    "content": "A local API can be any invocable functionality that is located inside the BFF host, for example an MVC controller or just a simple endpoint.\nThese endpoints need to be secured to make sure that only the frontend can call them. We recommend doing this using two layers of protection:\nSameSite cookies\nSameSite cookies are a built-in feature of modern browsers to make sure that a cookie only gets sent from a page that originates from the same site where the cookie was originally issued on.\nThis is a good first layer of defense, but makes the assumption that you can trust all sub-domains of your top-level site, for example *.mycompany.com.\nAnti-forgery header\nIn addition to the cookie protection, we recommend requiring an additional custom header, for example:\nGET /endpoint x-csrf: 1 The fact that the header value is static is really not important. Its presence in combination with the cookie requirement will trigger CORS preflight request for cross-origin calls. This effectively sandboxes the caller to the same origin as the backend which is a very strong security guarantee.\nIn addition, API endpoints also need some special treatment in situations where the session has expired, or authorization fails. In these cases you want to avoid trigger an authentication redirect to the upstream IdP, but instead return Ajax-friendly status codes\nSetup Duende.BFF can automate above pre/post-processing of API endpoints. For that you need to add the BFF middleware to the pipeline:\npublic void Configure(IApplicationBuilder app) { // rest omitted app.UseAuthentication(); app.UseRouting(); app.UseBff(); app.UseAuthorization(); app.UseEndpoints(endpoints =\u0026gt; { ... } } The BFF middleware must be placed before the authorization middleware, but after routing.\nIn addition, the endpoints that want the extra security features described above must be decorated, e.g.:\napp.UseEndpoints(endpoints =\u0026gt; { // MVC controllers endpoints.MapControllers() .RequireAuthorization() // no anonymous access .AsBffApiEndpoint(); // BFF pre/post processing // simple endpoint endpoints.MapPost(\u0026#34;/foo\u0026#34;, context =\u0026gt; { ... }) .RequireAuthorization() .AsBffApiEndpoint(); }); Or if using MVC, an attribute can be applied directly to the controller or action:\n[Route(\u0026#34;myApi\u0026#34;)] [BffApi] public class MyApiController : ControllerBase { ... } You can disable the anti-forgery protection requirement by setting the requireAntiForgeryCheck parameter to false on the endpoint, controller or action. This is not recommended though.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/ui/login/",
    "title": "Login",
    "tags": [],
    "description": "",
    "content": "Login Page The login page is responsible for establishing the user\u0026rsquo;s authentication session. This requires a user to present credentials and typically involves these steps:\nProvide the user with a page to allow them to enter credentials locally, use an external login provider, or use some other means of authenticating. Start the session by creating the authentication session cookie in your IdentityServer. If the login is client initiated, redirect the user back to the client. "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/ui/logout/",
    "title": "Logout",
    "tags": [],
    "description": "",
    "content": "Logout Page The logout page is responsible for terminating the user\u0026rsquo;s authentication session. This is a potentially complicated process and involves these steps:\nEnding the session by removing the authentication session cookie in your IdentityServer. Possibly triggering sign-out in an external provider if an external login was used. Notify all client applications that the user has signed out. If the logout is client initiated, redirect the user back to the client. "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/ui/logout/logout_context/",
    "title": "Logout Context",
    "tags": [],
    "description": "",
    "content": "To correctly perform all the steps for logout, your logout page needs contextual information about the user\u0026rsquo;s session and the client that initiated logout request. This information is provided by the LogoutRequest class and will provide your logout page data needed for the logout workflow.\nAccessing the LogoutRequest and the logoutId The logout page can be triggered in different ways:\nClient Initiated Logout (protocol) External Provider Logout Notification (protocol) Direct User Access (non-protocol) If the logout page is being triggered by a protocol workflow, then this means Duende IdentityServer has redirected the user\u0026rsquo;s browser to the logout page. In these scenarios, a logoutId parameter will be passed that represents the logout context. The logoutId value can be exchanged with the GetLogoutContextAsync API on the interaction service obtain a LogoutRequest object.\nIf the page is directly accessed by the user then there will be no logoutId parameter, but the context can still be accessed by calling GetLogoutContextAsync just without passing any parameters.\nIn either case, the LogoutRequest contains the data to perform client notification, and redirect the user back to the client after logout.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/apis/add_apis/",
    "title": "Adding API Endpoints to your IdentityServer",
    "tags": [],
    "description": "",
    "content": "It\u0026rsquo;s a common scenario to add additional API endpoints to the application hosting IdentityServer. These endpoints are typically protected by IdentityServer itself.\nFor simple scenarios, we give you some helpers. See the advanced section to understand more of the internal plumbing.\nYou could achieve the same by using either Microsoft\u0026rsquo;s JwtBearer handler. But this requires more configuration and creates dependencies on external libraries that might lead to conflicts in future updates.\nStart by registering your API as an ApiScope, (or resource) e.g.:\nvar scopes = new List\u0026lt;ApiScope\u0026gt; { // local API new ApiScope(IdentityServerConstants.LocalApi.ScopeName), }; ..and give your clients access to this API, e.g.:\nnew Client { // rest omitted AllowedScopes = { IdentityServerConstants.LocalApi.ScopeName }, } The value of IdentityServerConstants.LocalApi.ScopeName is IdentityServerApi.\nTo enable token validation for local APIs, add the following to your IdentityServer startup:\nservices.AddLocalApiAuthentication(); To protect an API controller, decorate it with an Authorize attribute using the LocalApi.PolicyName policy:\n[Route(\u0026#34;localApi\u0026#34;)] [Authorize(LocalApi.PolicyName)] public class LocalApiController : ControllerBase { public IActionResult Get() { // omitted } } Authorized clients can then request a token for the IdentityServerApi scope and use it to call the API.\nDiscovery You can also add your endpoints to the discovery document if you want, e.g like this::\nservices.AddIdentityServer(options =\u0026gt; { options.Discovery.CustomEntries.Add(\u0026#34;local_api\u0026#34;, \u0026#34;~/localapi\u0026#34;); }) Advanced Under the covers, the AddLocalApiAuthentication helper does a couple of things:\nadds an authentication handler that validates incoming tokens using IdentityServer\u0026rsquo;s built-in token validation engine (the name of this handler is IdentityServerAccessToken or IdentityServerConstants.LocalApi.AuthenticationScheme configures the authentication handler to require a scope claim inside the access token of value IdentityServerApi sets up an authorization policy that checks for a scope claim of value IdentityServerApi This covers the most common scenarios. You can customize this behavior in the following ways:\nAdd the authentication handler yourself by calling services.AddAuthentication().AddLocalApi(\u0026hellip;) this way you can specify the required scope name yourself, or (by specifying no scope at all) accept any token from the current IdentityServer instance Do your own scope validation/authorization in your controllers using custom policies or code, e.g.: services.AddAuthorization(options =\u0026gt; { options.AddPolicy(IdentityServerConstants.LocalApi.PolicyName, policy =\u0026gt; { policy.AddAuthenticationSchemes(IdentityServerConstants.LocalApi.AuthenticationScheme); policy.RequireAuthenticatedUser(); // custom requirements }); }); Claims Transformation You can provide a callback to transform the claims of the incoming token after validation. Either use the helper method, e.g.:\nservices.AddLocalApiAuthentication(principal =\u0026gt; { principal.Identities.First().AddClaim(new Claim(\u0026#34;additional_claim\u0026#34;, \u0026#34;additional_value\u0026#34;)); return Task.FromResult(principal); }); \u0026hellip;or implement the event on the options if you add the authentication handler manually.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/fundamentals/resources/api_scopes/",
    "title": "API Scopes",
    "tags": [],
    "description": "",
    "content": "Designing your API surface can be a complicated task. Duende IdentityServer provides a couple of primitives to help you with that.\nThe original OAuth 2.0 specification has the concept of scopes, which is just defined as the scope of access that the client requests. Technically speaking, the scope parameter is a list of space delimited values - you need to provide the structure and semantics of it.\nIn more complex systems, often the notion of a resource is introduced. This might be e.g. a physical or logical API. In turn each API can potentially have scopes as well. Some scopes might be exclusive to that resource, and some scopes might be shared.\nLet\u0026rsquo;s start with simple scopes first, and then we\u0026rsquo;ll have a look how resources can help structure scopes.\nScopes Let\u0026rsquo;s model something very simple - a system that has three logical operations read, write, and delete.\nYou can define them using the ApiScope class:\npublic static IEnumerable\u0026lt;ApiScope\u0026gt; GetApiScopes() { return new List\u0026lt;ApiScope\u0026gt; { new ApiScope(name: \u0026#34;read\u0026#34;, displayName: \u0026#34;Read your data.\u0026#34;), new ApiScope(name: \u0026#34;write\u0026#34;, displayName: \u0026#34;Write your data.\u0026#34;), new ApiScope(name: \u0026#34;delete\u0026#34;, displayName: \u0026#34;Delete your data.\u0026#34;) }; } You can then assign the scopes to various clients, e.g.:\nvar webViewer = new Client { ClientId = \u0026#34;web_viewer\u0026#34;, AllowedScopes = { \u0026#34;openid\u0026#34;, \u0026#34;profile\u0026#34;, \u0026#34;read\u0026#34; } }; var mobileApp = new Client { ClientId = \u0026#34;mobile_app\u0026#34;, AllowedScopes = { \u0026#34;openid\u0026#34;, \u0026#34;profile\u0026#34;, \u0026#34;read\u0026#34;, \u0026#34;write\u0026#34;, \u0026#34;delete\u0026#34; } } Authorization based on Scopes When a client asks for a scope (and that scope is allowed via configuration and not denied via consent), the value of that scope will be included in the resulting access token as a claim of type scope (for both JWTs and introspection), e.g.:\n{ \u0026#34;typ\u0026#34;: \u0026#34;at+jwt\u0026#34; }. { \u0026#34;client_id\u0026#34;: \u0026#34;mobile_app\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;read write delete\u0026#34; } The format of the scope parameter can be controlled by the EmitScopesAsSpaceDelimitedStringInJwt setting on the options. Historically IdentityServer emitted scopes as an array, but you can switch to a space delimited string instead.\nThe consumer of the access token can use that data to make sure that the client is actually allowed to invoke the corresponding functionality. See the APIs section for more information on protecting APIs with access tokens.\nBe aware, that scopes are purely for authorizing clients, not users. In other words, the write scope allows the client to invoke the functionality associated with the scope and is unrelated to the user\u0026rsquo;s permission to do so. This additional user centric authorization is application logic and not covered by OAuth, yet still possibly important to implement in your API.\nYou can add more identity information about the user to the access token. The additional claims added are based on the scope requested. The following scope definition tells the configuration system that when a write scope gets granted the user_level claim should be added to the access token:\nvar writeScope = new ApiScope( name: \u0026quot;write\u0026quot;, displayName: \u0026quot;Write your data.\u0026quot;, userClaims: new[] { \u0026quot;user_level\u0026quot; }); This will pass the user_level claim as a requested claim type to the profile service, so that the consumer of the access token can use this data as input for authorization decisions or business logic.\nWhen using the scope-only model, no aud (audience) claim will be added to the token since this concept does not apply. If you need an aud claim, you can enable the EmitStaticAudienceClaim setting on the options. This will emit an aud claim in the issuer_name/resources format. If you need more control of the aud claim, use API resources.\nParameterized Scopes Sometimes scopes have a certain structure, e.g. a scope name with an additional parameter: transaction:id or read_patient:patientid.\nIn this case you would create a scope without the parameter part and assign that name to a client, but in addition provide some logic to parse the structure of the scope at runtime using the IScopeParser interface or by deriving from our default implementation, e.g.:\npublic class ParameterizedScopeParser : DefaultScopeParser { public ParameterizedScopeParser(ILogger\u0026lt;DefaultScopeParser\u0026gt; logger) : base(logger) { } public override void ParseScopeValue(ParseScopeContext scopeContext) { const string transactionScopeName = \u0026#34;transaction\u0026#34;; const string separator = \u0026#34;:\u0026#34;; const string transactionScopePrefix = transactionScopeName + separator; var scopeValue = scopeContext.RawValue; if (scopeValue.StartsWith(transactionScopePrefix)) { // we get in here with a scope like \u0026#34;transaction:something\u0026#34; var parts = scopeValue.Split(separator, StringSplitOptions.RemoveEmptyEntries); if (parts.Length == 2) { scopeContext.SetParsedValues(transactionScopeName, parts[1]); } else { scopeContext.SetError(\u0026#34;transaction scope missing transaction parameter value\u0026#34;); } } else if (scopeValue != transactionScopeName) { // we get in here with a scope not like \u0026#34;transaction\u0026#34; base.ParseScopeValue(scopeContext); } else { // we get in here with a scope exactly \u0026#34;transaction\u0026#34;, which is to say we\u0026#39;re ignoring it // and not including it in the results scopeContext.SetIgnore(); } } } You then have access to the parsed value throughout the pipeline, e.g. in the profile service:\npublic class HostProfileService : IProfileService { public override async Task GetProfileDataAsync(ProfileDataRequestContext context) { var transaction = context.RequestedResources.ParsedScopes.FirstOrDefault(x =\u0026gt; x.ParsedName == \u0026#34;transaction\u0026#34;); if (transaction?.ParsedParameter != null) { context.IssuedClaims.Add(new Claim(\u0026#34;transaction_id\u0026#34;, transaction.ParsedParameter)); } } } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/deployment/data_protection/",
    "title": "ASP.NET Core Data Protection",
    "tags": [],
    "description": "",
    "content": "Duende IdentityServer relies on the built-in data protection feature of ASP.NET for\nprotecting keys at rest (if automatic key management is used and enabled) protecting persisted grants at rest (if enabled) session management (because ASP.NET Core cookies require it) It is crucial that you setup ASP.NET Core data protection correctly before you start using your IdentityServer in production. Please consult the Microsoft documentation for more details.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/di/",
    "title": "DI Extension Methods",
    "tags": [],
    "description": "",
    "content": "AddIdentityServer return a builder object that provides many extension methods to add IdentityServer specific services to DI. Here\u0026rsquo;s a list grouped by feature areas.\npublic void ConfigureServices(IServiceCollection services) { var builder = services.AddIdentityServer(); } Many of the fundamental configuration settings can be set on the options. See the IdentityServerOptions reference for more details.\nConfiguration Stores Several convenience methods are provided for registering custom stores:\nAddClientStore\u0026lt;T\u0026gt;\nRegisters a custom IClientStore implementation.\nAddCorsPolicyService\u0026lt;T\u0026gt;\nRegisters a custom ICorsPolicyService implementation.\nAddResourceStore\u0026lt;T\u0026gt;\nRegisters a custom IResourceStore implementation.\nAddIdentityProviderStore\u0026lt;T\u0026gt;\nRegisters a custom IIdentityProviderStore implementation.\nThe in-memory configuration stores can be registered in DI with the following extension methods.\nAddInMemoryClients\nRegisters IClientStore and ICorsPolicyService implementations based on the in-memory collection of Client configuration objects.\nAddInMemoryIdentityResources\nRegisters IResourceStore implementation based on the in-memory collection of IdentityResource configuration objects.\nAddInMemoryApiScopes\nRegisters IResourceStore implementation based on the in-memory collection of ApiScope configuration objects.\nAddInMemoryApiResources\nRegisters IResourceStore implementation based on the in-memory collection of ApiResource configuration objects.\nCaching Configuration Data Extension methods to enable caching for configuration data:\nAddInMemoryCaching\u0026lt;T\u0026gt;\nTo use any of the caches described below, an implementation of ICache\u0026lt;T\u0026gt; must be registered in DI. This API registers a default in-memory implementation of ICache\u0026lt;T\u0026gt; that\u0026rsquo;s based on ASP.NET Core\u0026rsquo;s MemoryCache.\nAddClientStoreCache\u0026lt;T\u0026gt; Registers a IClientStore decorator implementation which will maintain an in-memory cache of Client configuration objects. The cache duration is configurable on the Caching configuration options on the IdentityServerOptions.\nAddResourceStoreCache\u0026lt;T\u0026gt;\nRegisters a IResourceStore decorator implementation which will maintain an in-memory cache of IdentityResource and ApiResource configuration objects. The cache duration is configurable on the Caching configuration options on the IdentityServerOptions.\nAddCorsPolicyCache\u0026lt;T\u0026gt;\nRegisters a ICorsPolicyService decorator implementation which will maintain an in-memory cache of the results of the CORS policy service evaluation. The cache duration is configurable on the Caching configuration options on the IdentityServerOptions.\nAddIdentityProviderStoreCache\u0026lt;T\u0026gt;\nRegisters a IIdentityProviderStore decorator implementation which will maintain an in-memory cache of IdentityProvider configuration objects. The cache duration is configurable on the Caching configuration options on the IdentityServerOptions.\nTest Stores The TestUser class models a user, their credentials, and claims in IdentityServer.\nUse of TestUser is similar to the use of the \u0026ldquo;in-memory\u0026rdquo; stores in that it is intended for when prototyping, developing, and/or testing. The use of TestUser is not recommended in production.\nAddTestUsers\nRegisters TestUserStore based on a collection of TestUser objects. TestUserStore is e.g. used by the default quickstart UI. Also registers implementations of IProfileService and IResourceOwnerPasswordValidator that uses the test users as a backing store.\nSigning keys Duende IdentityServer needs some signing key material to sign tokens. This key material either comes from the built-in automatic key management feature (todo link) or can be configured statically.\nIt is recommended to use the automatic key management, this section covers the extensions methods for the static configuration.\nDuende IdentityServer supports X.509 certificates (both raw files and a reference to the certificate store), RSA keys and EC keys for token signatures and validation. Each key can be configured with a (compatible) signing algorithm, e.g. RS256, RS384, RS512, PS256, PS384, PS512, ES256, ES384 or ES512.\nYou can configure the key material with the following methods:\nAddSigningCredential\nAdds a signing key that provides the specified key material to the various token creation/validation services.\nAddDeveloperSigningCredential\nCreates temporary key material at startup time. This is for dev scenarios. The generated key will be persisted in the local directory by default (or just kept in memory).\nAddValidationKey\nAdds a key for validating tokens. They will be used by the internal token validator and will show up in the discovery document.\nAdditional services The following are convenient to add additional features to your IdentityServer.\nAddExtensionGrantValidator\nAdds an IExtensionGrantValidator implementation for use with extension grants.\nAddSecretParser\nAdds an ISecretParser implementation for parsing client or API resource credentials.\nAddSecretValidator\nAdds an ISecretValidator implementation for validating client or API resource credentials against a credential store.\nAddResourceOwnerValidator\nAdds an IResourceOwnerPasswordValidator implementation for validating user credentials for the resource owner password credentials grant type.\nAddProfileService\nAdds an IProfileService implementation. The default implementation (found in DefaultProfileService) relies upon the authentication cookie as the only source of claims for issuing in tokens.\nAddAuthorizeInteractionResponseGenerator\nAdds an IAuthorizeInteractionResponseGenerator implementation to customize logic at authorization endpoint for when a user must be shown a UI for error, login, consent, or any other custom page. The default implementation can be found in the AuthorizeInteractionResponseGenerator class, so consider deriving from this existing class if you need to augment the existing behavior.\nAddCustomAuthorizeRequestValidator\nAdds an ICustomAuthorizeRequestValidator implementation to customize request parameter validation at the authorization endpoint.\nAddCustomTokenRequestValidator\nAdds an ICustomTokenRequestValidator implementation to customize request parameter validation at the token endpoint.\nAddRedirectUriValidator\nAdds an IRedirectUriValidator implementation to customize redirect URI validation.\nAddAppAuthRedirectUriValidator\nAdds an \u0026ldquo;AppAuth\u0026rdquo; (OAuth 2.0 for Native Apps) compliant redirect URI validator (does strict validation but also allows http://127.0.0.1 with random port).\nAddJwtBearerClientAuthentication\nAdds support for client authentication using JWT bearer assertions.\nAddMutualTlsSecretValidators\nAdds the X509 secret validators for mutual TLS.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/diagnostics/events/",
    "title": "Events",
    "tags": [],
    "description": "",
    "content": "While logging is more low level \u0026ldquo;printf\u0026rdquo; style - events represent higher level information about certain operations in IdentityServer. Events are structured data and include event IDs, success/failure information, categories and details. This makes it easy to query and analyze them and extract useful information that can be used for further processing.\nEvents work great with structured logging stores like ELK, Seq or Splunk.\nEmitting events Events are not turned on by default - but can be globally configured in the ConfigureServices method, e.g.:\nservices.AddIdentityServer(options =\u0026gt; { options.Events.RaiseSuccessEvents = true; options.Events.RaiseFailureEvents = true; options.Events.RaiseErrorEvents = true; }); To emit an event use the IEventService from the DI container and call the RaiseAsync method, e.g.:\npublic async Task\u0026lt;IActionResult\u0026gt; Login(LoginInputModel model) { if (_users.ValidateCredentials(model.Username, model.Password)) { // issue authentication cookie with subject ID and username var user = _users.FindByUsername(model.Username); await _events.RaiseAsync(new UserLoginSuccessEvent(user.Username, user.SubjectId, user.Username)); } else { await _events.RaiseAsync(new UserLoginFailureEvent(model.Username, \u0026#34;invalid credentials\u0026#34;)); } } Custom sinks Our default event sink will simply serialize the event class to JSON and forward it to the ASP.NET Core logging system. If you want to connect to a custom event store, implement the IEventSink interface and register it with DI.\nThe following example uses Seq to emit events:\npublic class SeqEventSink : IEventSink { private readonly Logger _log; public SeqEventSink() { _log = new LoggerConfiguration() .WriteTo.Seq(\u0026#34;http://localhost:5341\u0026#34;) .CreateLogger(); } public Task PersistAsync(Event evt) { if (evt.EventType == EventTypes.Success || evt.EventType == EventTypes.Information) { _log.Information(\u0026#34;{Name} ({Id}), Details: {@details}\u0026#34;, evt.Name, evt.Id, evt); } else { _log.Error(\u0026#34;{Name} ({Id}), Details: {@details}\u0026#34;, evt.Name, evt.Id, evt); } return Task.CompletedTask; } } Add the Serilog.Sinks.Seq package to your host to make the above code work.\nBuilt-in events The following events are defined in IdentityServer:\nApiAuthenticationFailureEvent \u0026amp; ApiAuthenticationSuccessEvent\nGets raised for successful/failed API authentication at the introspection endpoint.\nClientAuthenticationSuccessEvent \u0026amp; ClientAuthenticationFailureEvent\nGets raised for successful/failed client authentication at the token endpoint.\nTokenIssuedSuccessEvent \u0026amp; TokenIssuedFailureEvent\nGets raised for successful/failed attempts to request identity tokens, access tokens, refresh tokens and authorization codes.\nTokenIntrospectionSuccessEvent \u0026amp; TokenIntrospectionFailureEvent\nGets raised for successful token introspection requests.\nTokenRevokedSuccessEvent\nGets raised for successful token revocation requests.\nUserLoginSuccessEvent \u0026amp; UserLoginFailureEvent\nGets raised by the quickstart UI for successful/failed user logins.\nUserLogoutSuccessEvent\nGets raised for successful logout requests.\nConsentGrantedEvent \u0026amp; ConsentDeniedEvent\nGets raised in the consent UI.\nUnhandledExceptionEvent\nGets raised for unhandled exceptions.\nDeviceAuthorizationFailureEvent \u0026amp; DeviceAuthorizationSuccessEvent\nGets raised for successful/failed device authorization requests.\nCustom events You can create your own events and emit them via our infrastructure.\nYou need to derive from our base Event class which injects contextual information like activity ID, timestamp, etc. Your derived class can then add arbitrary data fields specific to the event context::\npublic class UserLoginFailureEvent : Event { public UserLoginFailureEvent(string username, string error) : base(EventCategories.Authentication, \u0026#34;User Login Failure\u0026#34;, EventTypes.Failure, EventIds.UserLoginFailure, error) { Username = username; } public string Username { get; set; } } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/fundamentals/",
    "title": "Fundamentals",
    "tags": [],
    "description": "",
    "content": "Fundamentals Hosting Resources Clients Users and Logging In Claims Key Management License Key "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/models/identity_resource/",
    "title": "Identity Resource",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Models.IdentityResource This class models an identity resource.\npublic static readonly IEnumerable\u0026lt;IdentityResource\u0026gt; IdentityResources = new[] { // some standard scopes from the OIDC spec new IdentityResources.OpenId(), new IdentityResources.Profile(), new IdentityResources.Email(), // custom identity resource with some associated claims new IdentityResource(\u0026#34;custom.profile\u0026#34;, userClaims: new[] { JwtClaimTypes.Name, JwtClaimTypes.Email, \u0026#34;location\u0026#34;, JwtClaimTypes.Address }) }; Enabled\nIndicates if this resource is enabled and can be requested. Defaults to true.\nName\nThe unique name of the identity resource. This is the value a client will use for the scope parameter in the authorize request.\nDisplayName\nThis value will be used e.g. on the consent screen.\nDescription\nThis value will be used e.g. on the consent screen.\nRequired\nSpecifies whether the user can de-select the scope on the consent screen (if the consent screen wants to implement such a feature). Defaults to false.\nEmphasize\nSpecifies whether the consent screen will emphasize this scope (if the consent screen wants to implement such a feature). Use this setting for sensitive or important scopes. Defaults to false.\nShowInDiscoveryDocument\nSpecifies whether this scope is shown in the discovery document. Defaults to true.\nUserClaims\nList of associated user claim types that should be included in the identity token.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/tokens/authentication/jwt/",
    "title": "Private Key JWTs",
    "tags": [],
    "description": "",
    "content": "The OpenID Connect specification recommends a client authentication method based on asymmetric keys. With this approach, instead of transmitting the shared secret over the network, the client creates a JWT and signs it with its private key. Your IdentityServer only needs to store the corresponding key to be able to validate the signature.\nThe technique is described here and is based on the OAuth JWT assertion specification (RFC 7523).\nSetting up a private key JWT secret The default default private key JWT secret validator expects either a base64 encoded X.509 certificate or a JSON Web Key formatted RSA, EC or symmetric key on the secret definition:\nvar client = new Client { ClientId = \u0026quot;client.jwt\u0026quot;, ClientSecrets = { new Secret { // base64 encoded X.509 certificate Type = IdentityServerConstants.SecretTypes.X509CertificateBase64, Value = \u0026quot;MIID...xBXQ=\u0026quot; } new Secret { // JWK formatted RSA key Type = IdentityServerConstants.SecretTypes.JsonWebKey, Value = \u0026quot;{'e':'AQAB','kid':'Zz...GEA','kty':'RSA','n':'wWw...etgKw'}\u0026quot; } }, AllowedGrantTypes = GrantTypes.ClientCredentials, AllowedScopes = { \u0026quot;api1\u0026quot;, \u0026quot;api2\u0026quot; } }; You can share the same key for client authentication and signed authorize requests.\nAuthentication using a private key JWT On the client side the, the caller must first generate the JWT, and then send it on the assertion body field:\nPOST /connect/token Content-type: application/x-www-form-urlencoded client_assertion=\u0026lt;jwt\u0026gt;\u0026amp; client_assertion_type=urn:ietf:params:oauth:grant-type:jwt-bearer\u0026amp; grant_type=authorization_code\u0026amp; code=hdh922\u0026amp; redirect_uri=https://myapp.com/callback .NET client library You can use the Microsoft JWT library to create JSON Web Tokens.\nprivate static string CreateClientToken(SigningCredentials credential, string clientId, string tokenEndpoint) { var now = DateTime.UtcNow; var token = new JwtSecurityToken( clientId, tokenEndpoint, new List\u0026lt;Claim\u0026gt;() { new Claim(JwtClaimTypes.JwtId, Guid.NewGuid().ToString()), new Claim(JwtClaimTypes.Subject, clientId), new Claim(JwtClaimTypes.IssuedAt, now.ToEpochTime().ToString(), ClaimValueTypes.Integer64) }, now, now.AddMinutes(1), credential ); var tokenHandler = new JwtSecurityTokenHandler(); return tokenHandler.WriteToken(token); } ..and the IdentityModel client library to programmatically interact with the protocol endpoint from .NET code.\nusing IdentityModel.Client; static async Task\u0026lt;TokenResponse\u0026gt; RequestTokenAsync(SigningCredentials credential) { var client = new HttpClient(); var disco = await client.GetDiscoveryDocumentAsync(\u0026#34;https://demo.duendesoftware.com\u0026#34;); if (disco.IsError) throw new Exception(disco.Error); var clientToken = CreateClientToken(credential, \u0026#34;private.key.jwt\u0026#34;, disco.TokenEndpoint); var response = await client.RequestClientCredentialsTokenAsync(new ClientCredentialsTokenRequest { Address = disco.TokenEndpoint, Scope = \u0026#34;api1.scope1\u0026#34;, ClientAssertion = { Type = OidcConstants.ClientAssertionTypes.JwtBearer, Value = clientToken } }); if (response.IsError) throw new Exception(response.Error); return response; } See here for a sample for using JWT-based authentication.\nUsing ASP.NET Core The OpenID Connect authentication handler in ASP.NET Core allows for replacing a static client secret with a dynamically created client assertion.\nThis is accomplished by handling the various events on the handler. We recommend to encapsulate the event handler in a separate type. This makes it easier to consume services from DI:\npublic void ConfigureServices(IServiceCollection services) { // some details omitted services.AddTransient\u0026lt;OidcEvents\u0026gt;(); services.AddAuthentication(options =\u0026gt; .AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { options.Authority = Constants.Authority; // no static client secret options.ClientId = \u0026#34;mvc.jar.jwt\u0026#34;; // specifies type that handles events options.EventsType = typeof(OidcEvents); })); } In your event handler you can inject code before the handler redeems the code:\npublic class OidcEvents : OpenIdConnectEvents { private readonly AssertionService _assertionService; public OidcEvents(AssertionService assertionService) { _assertionService = assertionService; } public override Task AuthorizationCodeReceived(AuthorizationCodeReceivedContext context) { context.TokenEndpointRequest.ClientAssertionType = OidcConstants.ClientAssertionTypes.JwtBearer; context.TokenEndpointRequest.ClientAssertion = _assertionService.CreateClientToken(); return Task.CompletedTask; } } The assertion service would be a helper to create the JWT as shown above in the CreateClientToken method. See here for a sample for using JWT-based authentication (and signed authorize requests) in ASP.NET Core.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/tokens/refresh/",
    "title": "Refreshing a Token",
    "tags": [],
    "description": "",
    "content": "Access tokens have finite lifetimes. If a client needs long-lived access to a resource, refresh tokens can be used to request a new access token. This can be done with an API call and does not require any user interaction or interruption.\nSince this is a privileged operation, the clients needs to be explicitly authorized to be able to use refresh tokens by setting the AllowOfflineAccess property to true. See the client reference section for additional refresh token related settings.\nRefresh tokens are supported for the following flows: authorization code, hybrid and resource owner password credential flow.\nRequesting a refresh token You can request a refresh token by adding a scope called offline_access to the scope parameter list of the authorize request.\nRequesting an access token using a refresh token To get a new access token, you send the refresh token to the token endpoint. This will result in a new token response containing a new access token and its expiration and potentially also a new refresh token depending on the client configuration (see above).\nPOST /connect/token client_id=client\u0026amp; client_secret=secret\u0026amp; grant_type=refresh_token\u0026amp; refresh_token=hdh922 .NET client library On .NET you can leverage the IdentityModel client library to request refresh tokens, e.g.:\nusing IdentityModel.Client; var client = new HttpClient(); var response = await client.RequestRefreshTokenAsync(new RefreshTokenRequest { Address = TokenEndpoint, ClientId = \u0026#34;client\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, RefreshToken = \u0026#34;...\u0026#34; }); The IdentityModel.AspNetCore library can be used to automate refresh \u0026amp; access token lifetime management in ASP.NET Core.\nRefresh token security considerations Refresh tokens are a high-value target for attackers, because they typically have a much higher lifetime than access tokens.\nIt is recommended that a refresh token is either bound to the client via a client secret (for confidential/credentialed clients), or rotated for public clients.\nThe following techniques can be used to reduce the attack surface of refresh tokens.\nConsent It’s a good idea to ask for consent when a client requests a refresh token. This way you at least try to make the user aware of what’s happening, and maybe you also give them a chance to opt-out of it.\nDuende IdentityServer will always ask for consent (if enabled) if the client asks for the offline_access scope which goes in-line with the recommendations in the OpenID Connect specification.\nSliding expiration Refresh tokens usually have a much longer lifetime than access tokens. You can reduce their exposure by adding a sliding lifetime on top of the absolute lifetime. This allows for scenarios where a refresh token can be silently used if the user is regularly using the client, but needs a fresh authorize request if the client has not been used for a certain time. In other words, they auto-expire much quicker without potentially interfering with the typical usage pattern.\nYou can use the AbsoluteRefreshTokenLifetime and SlidingRefreshTokenLifetime client settings to fine tune this behavior.\nOne-time Refresh Tokens Another option is rotating the refresh tokens on every usage. This also reduces the exposure, and has a higher chance to make older refresh tokens (e.g. ex-filtrated from some storage mechanism or a network trace/log file) unusable.\nThe downside of this approach is that you might have more scenarios where a legitimate refresh token becomes unusable – e.g. due to network problems while refreshing them.\nRotation can be configured via the RefreshTokenUsage client settings and is enabled by default.\nReplay detection On top of one-time only semantics, you could also layer replay detection. This means that if you ever see the same refresh token used more than once, you could revoke all access to the client/user combination. Again – same caveat applies – while increasing the security, this might result in false positives.\nSee the reference section for more customization of the refresh token service.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/bff/extensibility/sessions/",
    "title": "Session Management",
    "tags": [],
    "description": "",
    "content": " custom session store - will be updated soon "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/bff/session/management/",
    "title": "Session Management Endpoints",
    "tags": [],
    "description": "",
    "content": "Duende.BFF adds endpoints for managing typical session-related operations like triggering login and logout and getting information about the currently logged-on user. These endpoint are meant to be called by the frontend.\nIn addition we add an implementation of the OpenID Connect back-channel notification endpoint to overcome the restrictions of third party cookies in front-channel notification in modern browsers.\nYou enable the endpoints by adding the relevant services into the DI container:\npublic void ConfigureServices(IServiceCollection services) { // Add BFF services to DI - also add server-side session management services.AddBff(options =\u0026gt; { // default value options.ManagementBasePath = \u0026#34;/bff\u0026#34;; }); // rest omitted } Endpoint routing is used to map the management endpoints:\npublic void Configure(IApplicationBuilder app) { // rest omitted app.UseEndpoints(endpoints =\u0026gt; { endpoints.MapBffManagementEndpoints(); }); MapBffManagementEndpoints adds all BFF management endpoints. You can also map every endpoint individually by calling the various MapBffManagementXxxEndpoint APIs, for example endpoints.MapBffManagementLoginEndpoint().\nThe following describes the default behavior of those endpoints. See the extensibility section for more information how to provide custom implementations.\nLogin The login endpoint triggers authentication with the scheme configured for challenge (typically the OpenID Connect handler).\nGET /bff/login By default the login endpoint will redirect back to the root of the application after authentication is done. Alternatively you can use a different local URL instead:\nGET /bff/login?returnUrl=/page2 User The user endpoint returns data about the currently logged-on user and the session.\nTo protect against cross-site request forgery, you need to add a static header to the GET request. Both header name and value can be configured on the options.\nGET bff/user x-csrf: 1 If there is no current session, the user endpoint will return a 401 status code. This endpoint can also be used to periodically query if the session is still valid.\nIf your backend uses sliding cookies, you typically want to avoid that querying the session will extend the session lifetime. Adding the slide=false query string parameter to the URL will prohibit that.\nThis features requires either usage of server-side sessions, or .NET 6 or higher (or both).\nGET bff/user?slide=false x-csrf: 1 If there is a valid session, the user endpoint returns a JSON array containing the contents of the ASP.NET Core authentication session and BFF specific management data, e.g.:\n[ { \u0026#34;type\u0026#34;: \u0026#34;sid\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;173E788068FFB728806501F4F46C52D6\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;sub\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;88421113\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;idp\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;local\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Bob Smith\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;bff:logout_url\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;/bff/logout?sid=173E788068FFB728806501F4F46C52D6\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;bff:session_expires_in\u0026#34;, \u0026#34;value\u0026#34;: 28799 }, { \u0026#34;type\u0026#34;: \u0026#34;bff:session_state\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;q-Hl1V9a7FCZE5o-vH9qpmyVKOaeVfMQBUJLrq-lDJU.013E58C33C7409C6011011B8291EF78A\u0026#34; } ] You can customize the contents of the ASP.NET Core session via the OpenID Connect handler\u0026rsquo;s ClaimAction infrastructure, or using claim transformation.\nDuende.BFF adds three additional elements to the list:\nbff:session_expires_in\nThis is the number of seconds the current session will be valid for\nbff:session_state\nThis is the session state value of the upstream OIDC provider that can be use for the JavaScript check_session mechanism (if provided).\nbff:logout_url\nThis is the URL to trigger logout. If the upstream provider includes an sid claim, the BFF logout endpoint requires this value as a query string parameter for CSRF protection. This behavior can be configured on the options.\nLogout This endpoint triggers local and upstream logout. If the upstream IdP sent a session ID, this must be appended to the URL:\nGET /bff/logout?sid=xyz By default the logout endpoint will redirect back to the root of the application after logout is done. Alternatively you can use a local URL instead:\nGET /bff/logout?sid=xyz\u0026amp;returnUrl=/loggedout The logout endpoint will trigger revocation of the user\u0026rsquo;s refresh token (if present). This can be configured on the options.\nBack-channel logout notifications The /bff/backchannel endpoint is an implementation of the OpenID Connect Back-Channel Logout specification.\nThe endpoint will call the registered session revocation service to revoke the user session when it receives a valid logout token. You need to enable server-side session for this feature to work.\nBy default, only the specific session of the user will be revoked. Alternatively, you can configure the endpoint to revoke every session that belongs to the given subject ID.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/apis/aspnetcore/reference/",
    "title": "Using Reference Tokens",
    "tags": [],
    "description": "",
    "content": "If you are using reference tokens, you need an authentication handler that implements the back-channel validation via the OAuth 2.0 token introspection protocol, e.g. this one:.\nservices.AddAuthentication(\u0026#34;token\u0026#34;) .AddOAuth2Introspection(\u0026#34;token\u0026#34;, options =\u0026gt; { options.Authority = Constants.Authority; // this maps to the API resource name and secret options.ClientId = \u0026#34;resource1\u0026#34;; options.ClientSecret = \u0026#34;secret\u0026#34;; }); Supporting both JWTs and reference tokens It is not uncommon to use the same API with both JWTs and reference tokens. In this case you setup to authentication handlers, make one the default handler and provide some forwarding logic, e.g.:\nservices.AddAuthentication(\u0026#34;token\u0026#34;) // JWT tokens .AddJwtBearer(\u0026#34;token\u0026#34;, options =\u0026gt; { options.Authority = Constants.Authority; options.Audience = \u0026#34;resource1\u0026#34;; options.TokenValidationParameters.ValidTypes = new[] { \u0026#34;at+jwt\u0026#34; }; // if token does not contain a dot, it is a reference token options.ForwardDefaultSelector = Selector.ForwardReferenceToken(\u0026#34;introspection\u0026#34;); }) // reference tokens .AddOAuth2Introspection(\u0026#34;introspection\u0026#34;, options =\u0026gt; { options.Authority = Constants.Authority; options.ClientId = \u0026#34;resource1\u0026#34;; options.ClientSecret = \u0026#34;secret\u0026#34;; }); The logic of the forward selector looks like this:\n/// \u0026lt;summary\u0026gt; /// Provides a forwarding func for JWT vs reference tokens (based on existence of dot in token) /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;introspectionScheme\u0026#34;\u0026gt;Scheme name of the introspection handler\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static Func\u0026lt;HttpContext, string\u0026gt; ForwardReferenceToken(string introspectionScheme = \u0026#34;introspection\u0026#34;) { string Select(HttpContext context) { var (scheme, credential) = GetSchemeAndCredential(context); if (scheme.Equals(\u0026#34;Bearer\u0026#34;, StringComparison.OrdinalIgnoreCase) \u0026amp;\u0026amp; !credential.Contains(\u0026#34;.\u0026#34;)) { return introspectionScheme; } return null; } return Select; } /// \u0026lt;summary\u0026gt; /// Extracts scheme and credential from Authorization header (if present) /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;context\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static (string, string) GetSchemeAndCredential(HttpContext context) { var header = context.Request.Headers[\u0026#34;Authorization\u0026#34;].FirstOrDefault(); if (string.IsNullOrEmpty(header)) { return (\u0026#34;\u0026#34;, \u0026#34;\u0026#34;); } var parts = header.Split(\u0026#39; \u0026#39;, StringSplitOptions.RemoveEmptyEntries); if (parts.Length != 2) { return (\u0026#34;\u0026#34;, \u0026#34;\u0026#34;); } return (parts[0], parts[1]); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/bff/session/",
    "title": "Authentication &amp; Session Management",
    "tags": [],
    "description": "",
    "content": "Authentication \u0026amp; Session Management This section deals with setting up the following components\nthe ASP.NET Core authentication system the OpenID Connect handler the cookie handler the BFF session management endpoints server-side sessions back-channel logout support "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/fundamentals/resources/",
    "title": "Resources",
    "tags": [],
    "description": "",
    "content": "Resources The ultimate job of Duende IdentityServer is to control access to resources.\nIdentity Resources API Scopes API Resources Resource Isolation "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/ui/login/session/",
    "title": "Authentication Session",
    "tags": [],
    "description": "",
    "content": "Authentication Session Regardless of how the user proves their identity on the login page, an authentication session must be established. This authentication session is based on ASP.NET Core’s authentication system, and is tracked with a cookie managed by the cookie authentication handler.\nTo establish the session, ASP.NET Core provides a SignInAsync extension method on the HttpContext. This API accepts a ClaimsPrincipal which contains claims that describe the user. IdentityServer requires a special claim called sub whose value uniquely identifies the user. On your login page, this would be the code to establish the authentication session and issue the cookie:\nvar claims = new Claim[] { new Claim(\u0026#34;sub\u0026#34;, \u0026#34;unique_id_for_your_user\u0026#34;) }; var identity = new ClaimsIdentity(claims, \u0026#34;pwd\u0026#34;); var user = new ClaimsPrincipal(identity); await HttpContext.SignInAsync(user); The sub claim is the subject identifier and is the most important claim your IdentityServer will issue. It will uniquely identify the user and must never change and must never be reassigned to a different user. A GUID data type is a very common choice for the sub.\nAdditional claims can be added to the cookie if desired or needed at other UI pages. For example, it\u0026rsquo;s common to also issue a name claim which represents the user\u0026rsquo;s display name.\nThe claims issued in the cookie are passed as the Subject on the ProfileDataRequestContext in the profile service.\nWell Known Claims Issued From the Login Page There are some claims beyond sub that can be issued by your login page to capture additional information about the user\u0026rsquo;s authentication session. Internally Duende IdentityServer will set some of these values if you do not specify them when calling SignInAsync. The claims are:\nname: The display name of the user. amr: Name of the authentication method used for user authentication (defaults to pwd). auth_time: Time in epoch format the user entered their credentials (defaults to the current time). idp: Authentication scheme name of the external identity provider used for login. When not specified then the value defaults to local indicating that it was a local login. This is used to determine if a user must re-authenticate when clients make authorization requests using the acr_values with an idp value, or the client has IdentityProviderRestrictions. If the user’s idp does not match the request, then they should re-authenticate. tenant: Tenant identifier the user is associated with (if needed). This is used to determine if a user must re-authenticate when clients make authorization requests using the acr_values with a tenant value. If the user\u0026rsquo;s tenant does not match the request, then they should re-authenticate. While you can create the ClaimsPrincipal yourself, you can alternatively use IdentityServer extension methods and the IdentityServerUser class to make this easier:\nvar user = new IdentityServerUser(\u0026#34;unique_id_for_your_user\u0026#34;) { DisplayName = user.Username }; await HttpContext.SignInAsync(user); Cookie Handler Configuration Duende IdentityServer registers a cookie authentication handler by default for the authentication session. The scheme that the handler in the authentication system is identified by is from the constant IdentityServerConstants.DefaultCookieAuthenticationScheme.\nWhen configuring IdentityServer, the AuthenticationOptions expose some settings to control the cookie (e.g. expiration and sliding). For example:\npublic void ConfigureServices(IServiceCollection services) { services.AddIdentityServer(options =\u0026gt; { options.Authentication.CookieLifetime = TimeSpan.FromHours(1); options.Authentication.CookieSlidingExpiration = false; }); } In addition to the authentication cookie, IdentityServer will issue an additional cookie which defaults to the name idsrv.session. This cookie is derived from the main authentication cookie, and it used for the check session endpoint for browser-based JavaScript clients at signout time. It is kept in sync with the authentication cookie, and is removed when the user signs out.\nIf you require more control over the cookie authentication handler you can register your own cookie handler. You can then configure IdentityServer to use your cookie handler by setting the CookieAuthenticationScheme on the AuthenticationOptions. For example:\npublic void ConfigureServices(IServiceCollection services) { services.AddAuthentication() .AddCookie(\u0026#34;your_cookie\u0026#34;, options =\u0026gt; { // ... }); services.AddIdentityServer(options =\u0026gt; { options.Authentication.CookieAuthenticationScheme = \u0026#34;your_cookie\u0026#34;; }); } If the CookieAuthenticationScheme is not set, the DefaultAuthenticationScheme configured for ASP.NET Core will be used instead. Note that the AddAuthentication call that sets the default can come after the AddIdentityServer call. For example:\npublic void ConfigureServices(IServiceCollection services) { // No cookie authentication scheme is set here. // Identity Server will use the default scheme from ASP.NET Core, // even though it is not yet defined. services.AddIdentityServer(); // Default scheme is registered. IdentityServer will use this scheme. services.AddAuthentication(defaultScheme: \u0026#34;your_cookie\u0026#34;) .AddCookie(\u0026#34;your_cookie\u0026#34;, options =\u0026gt; { // ... }); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/ui/logout/session_cleanup/",
    "title": "Ending the Session",
    "tags": [],
    "description": "",
    "content": "Removing the Authentication Cookie To remove the authentication cookie, simply use the ASP.NET Core SignOutAsync extension method on the HttpContext. You will need to pass the scheme used (which is provided by IdentityServerConstants.DefaultCookieAuthenticationScheme unless you have changed it):\nawait HttpContext.SignOutAsync(IdentityServerConstants.DefaultCookieAuthenticationScheme); Or you can use the overload that will simply sign-out of the default authentication scheme:\nawait HttpContext.SignOutAsync(); Prompting the User to Logout Typically you should prompt the user to logout which requires a POST to remove the cookie. Otherwise an attacker could hotlink to your logout page causing the user to be automatically logged out. This means you will need a page to prompt the user to logout.\nIf a logoutId is passed to the logout page and the returned LogoutRequest\u0026rsquo;s ShowSignoutPrompt is false then it is safe to skip the prompt. This would occur when the logout page is requested due to a validated client initiated logout via the end session endpoint. Your logout page process can continue as if the user submitted the post back to logout, in essence calling SignOutAsync.\nExternal Logins If your user has signed in with an external login, then it\u0026rsquo;s likely that they should perform an external logout of the external provider as well.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/data/operational/",
    "title": "Operational Data",
    "tags": [],
    "description": "",
    "content": "Operational Data For certain operations, IdentityServer needs a persistence store to keep dynamically created state. This data is collectively called operational data, and includes:\nGrants for authorization and device codes, reference and refresh tokens, and remembered user consent Keys managing dynamically created signing keys "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/bff/apis/remote/",
    "title": "Remote APIs",
    "tags": [],
    "description": "",
    "content": "For invoking APIs that are deployed on different servers, you have a couple of options:\ncreate local API endpoints that call those remote APIs use our built-in simplified HTTP forwarder use a fully fledged reverse proxy to transparently forward the local API calls to the remote APIs Manual API endpoints If you want to expose a frontend specific subset of your remote APIs or want to aggregate multiple remote APIs, it is a common practice to create local API endpoints that in turn call the remote APIs and present the data in a frontend specific way.\nYou can use a MVC controller for this, and leverage services like the HTTP client factory and the Duende.BFF token management to make the outgoing calls. The following is a very simplified version of that:\n[Route(\u0026#34;myApi\u0026#34;)] public class MyApiController : ControllerBase { private readonly IHttpClientFactory _httpClientFactory; public MyApiController(IHttpClientFactory httpClientFactory) { _httpClientFactory = httpClientFactory; } public async Task\u0026lt;IActionResult\u0026gt; Get(string id) { // create HTTP client var client = _httpClientFactory.CreateClient(); // get current user access token and set it on HttpClient var token = await HttpContext.GetUserAccessTokenAsync(); client.SetBearerToken(token); // call remote API var response = await client.GetAsync($\u0026#34;https://remoteServer/remoteApi?id={id}\u0026#34;); // maybe process response and return to frontend return new JsonResult(await response.Content.ReadAsStringAsync()); } } Use our built-in simple HTTP forwarder Our HTTP forwarder is useful when you realize that you are re-creating large parts of an already existing API surface in your BFF for forwarding. In this case you might decide to automate the process.\nDuende.BFF uses Microsoft YARP internally to give you a developer centric and simplified way to forward certain routes in your BFF to remote APIs. These routes have the same anti-forgery protection as local API endpoints, and also integrate with the automatic token management.\nTo enable that feature, you need add a reference to the Duende.BFF.Yarp Nuget package and add the service to DI:\nservices.AddBff() .AddRemoteApis(); The following snippet routes a local /api/customers endpoint to a remote API, and forwards the user\u0026rsquo;s access token in the outgoing call:\napp.UseEndpoints(endpoints =\u0026gt; { endpoints.MapRemoteBffApiEndpoint( \u0026#34;/api/customers\u0026#34;, \u0026#34;https://remoteHost/customers\u0026#34;) .RequireAccessToken(TokenType.User); }); Be aware that above example is opening up the complete /customers API namespace to the frontend and thus to the outside world. Try to be as specific as possible when designing the forwarding paths.\nThere are several ways to influence security parameters of such an endpoint:\nRequire authorization\nThe endpoint integrates with the ASP.NET Core authorization system and you can attach a RequireAuthorization extension to specify an authorization policy that must be fulfilled before being able to invoke the endpoint.\nAccess token requirements\nYou can specify access token requirements via the RequireAccessToken extension. The TokenType parameter has three options:\nUser\nA valid user access token is required and will be forwarded\nClient\nA valid client access token is required and will be forwarded\nUserOrClient\nEither a valid user access token or a valid client access token (as fallback) is required and will be forwarded\nYou can also use the WithOptionalUserAccessToken extension to specify that the API should be called with a user access token (if present), otherwise anonymously.\nThese settings only specify the logic that is applied before the API call gets proxied. The remote APIs you are calling should always specify their own authorization and token requirements.\nUse a fully fledged Reverse Proxy Instead of using simplified forwarder, you can also use a more feature complete reverse proxy - e.g. Microsoft YARP.\nYARP has built-in features that you might need, e.g. load balancing, service discovery, session affinity etc. So instead of us wrapping YARP internally, you can also use YARP directly and add our services like anti-forgery protection and token management on top.\nAdding YARP To enable our YARP integration, add a reference to the Duende.BFF.Yarp Nuget package and add the YARP and our service to DI:\nservices.AddBff(); var builder = services.AddReverseProxy() .AddTransforms\u0026lt;AccessTokenTransformProvider\u0026gt;(); Configuring YARP You can use many ways to configure YARP - most commonly via a config file or code. The following shows a simple code snippet using the in-memory configuration provider:\nbuilder.LoadFromMemory( new[] { new RouteConfig() { RouteId = \u0026#34;todos\u0026#34;, ClusterId = \u0026#34;cluster1\u0026#34;, Match = new RouteMatch { Path = \u0026#34;/todos/{**catch-all}\u0026#34; } }.WithAccessToken(TokenType.User), }, new[] { new ClusterConfig { ClusterId = \u0026#34;cluster1\u0026#34;, Destinations = new Dictionary\u0026lt;string, DestinationConfig\u0026gt;(StringComparer.OrdinalIgnoreCase) { { \u0026#34;destination1\u0026#34;, new DestinationConfig() { Address = \u0026#34;https://api.mycompany.com/todos\u0026#34; } }, } } }); The WithAccessToken extension method adds an entry to YARP\u0026rsquo;s metadata dictionary that instructs our plumbing to forward the current user access token for the route.\nYou can achieve the same in configuration with the following:\n\u0026#34;ReverseProxy\u0026#34;: { \u0026#34;Routes\u0026#34;: { \u0026#34;todos\u0026#34;: { \u0026#34;ClusterId\u0026#34;: \u0026#34;cluster1\u0026#34;, \u0026#34;Match\u0026#34;: { \u0026#34;Path\u0026#34;: \u0026#34;/todos/{**catch-all}\u0026#34;, }, \u0026#34;Metadata\u0026#34;: { \u0026#34;Duende.Bff.Yarp.TokenType\u0026#34;: \u0026#34;User\u0026#34; } } }, \u0026#34;Clusters\u0026#34;: { \u0026#34;cluster1\u0026#34;: { \u0026#34;Destinations\u0026#34;: { \u0026#34;destination1\u0026#34;: { \u0026#34;Address\u0026#34;: \u0026#34;https://api.mycompany.com/todos\u0026#34; } } } } } The allowed values for the token type are User, Client, UserOrClient\nAdding the YARP endpoint Last but not least, you need to add the YARP endpoint to the routing table:\nendpoints.MapBffReverseProxy(); // which is equivalent to //endpoints.MapReverseProxy() // .AsBffApiEndpoint(); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/samples/ui/",
    "title": "User Interaction",
    "tags": [],
    "description": "",
    "content": "These samples illustrate customization of the interactive pages used in your IdentityServer.\nSPA-style login page This sample shows an example of building the interactive pages (login, consent, logout, and error) as client-rendered (typical of SPAs), rather than server-rendered. Since there are many different SPA frameworks, the actual pages are coded using vanilla JavaScript.\nKey takeaways:\nhow to handle the necessary request parameters how to contact the backend of IdentityServer to implement the various workflows (login, logout, etc.) how to implement a backend to support the frontend pages link to source code\nAdding other protocol types to dynamic providers The dynamic providers feature allows for loading OpenID Connect identity provider configuration dynamically from a store. This sample shows how to extend the dynamic providers feature to support additional protocol types, and specifically WS-Federation.\nKey takeaways:\nhow to define a custom identity provider model how to map from the custom identity provider model to the protocol options how to register the custom protocol type with IdentityServer how to register the custom protocol type with IdentityServer how to use the existing provider store to persist custom provider model data link to source code\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/samples/aspid/",
    "title": "ASP.NET Identity Integration",
    "tags": [],
    "description": "",
    "content": "link to source code\nThis sample shows using ASP.NET Identity with Duende IdentityServer. The intent was to show the least amount of code needed to get a working sample that used Microsoft\u0026rsquo;s ASP.NET Identity user management library.\nThe first step in creating the sample was to create a new project that used the ASP.NET Identity templates from Visual Studio (\u0026ldquo;Individual Accounts\u0026rdquo; for the authentication type). This provides all of the \u0026ldquo;out of the box\u0026rdquo; features from ASP.NET Identity for user management with only minor modifications, which are described below.\nThen Duende IdentityServer was added to add OIDC/OAuth2 capabilities to the application. Only the minimal configuration was done to get Duende IdentityServer functional for this sample.\nFinally another project was added which acts as a OIDC client application to exercise the OIDC login (and logout) capabilities.\nThe changes to the template in the ASP.NET Identity project (i.e. \u0026ldquo;IdentityServerAspNetIdentity\u0026rdquo;):\nSqlite support was added, replacing the default of SqlServer. Duende IdentityServer was configured in Startup.cs with the necessary information about the client application, and the OIDC scopes it would be requesting. Debug level logging was enabled for the \u0026ldquo;Duende\u0026rdquo; prefix to allow viewing the logging emitted during request processing. In the middleware pipeline, UseIdentityServer replaced UseAuthentication. The logout page was scaffolded to allow modification (located in Areas/Identity/Pages/Account/Logout.cshtml). The default logout page from the template is unaware of OIDC single signout, so this feature was added. In the client application:\nA simple ASP.NET Core Razor Web Application was used as the starting point. In Startup.cs the standard cookie and OIDC authentication configuration was added. A secure page (Secure.cshtml) that required an authenticated user will render the logged in user\u0026rsquo;s claim in the page. The index page (Index.cshtml) was modified to allow a POST to trigger OIDC logout. A logout button was added to trigger the POST. "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/samples/windowsauth/",
    "title": "Windows Authentication",
    "tags": [],
    "description": "",
    "content": "This solution contains samples when using Windows Authentication.\nIIS Hosting This sample shows how to use Windows Authentication when hosting your IdentityServer behind IIS (or IIS Express). The salient piece to understand is a new LoginWithWindows action method in the AccountController from the quickstarts. Windows authentication is triggered, and once the result is determined the main authentication session cookie is created based on the WindowsIdentity results. Also, note there is some configuration in Startup with a call to Configure\u0026lt;IISOptions\u0026gt; (mainly to set AutomaticAuthentication to false).\nlink to source code\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/models/api_scope/",
    "title": "API Scope",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Models.ApiScope This class models an OAuth scope.\nEnabled\nIndicates if this resource is enabled and can be requested. Defaults to true.\nName\nThe unique name of the API. This value is used for authentication with introspection and will be added to the audience of the outgoing access token.\nDisplayName\nThis value can be used e.g. on the consent screen.\nDescription\nThis value can be used e.g. on the consent screen.\nUserClaims\nList of associated user claim types that should be included in the access token.\nDefining API scope in appsettings.json The AddInMemoryApiResource extension method also supports adding clients from the ASP.NET Core configuration file::\n\u0026#34;IdentityServer\u0026#34;: { \u0026#34;IssuerUri\u0026#34;: \u0026#34;urn:sso.company.com\u0026#34;, \u0026#34;ApiScopes\u0026#34;: [ { \u0026#34;Name\u0026#34;: \u0026#34;IdentityServerApi\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;resource1.scope1\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;resource2.scope1\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;scope3\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;shared.scope\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;transaction\u0026#34;, \u0026#34;DisplayName\u0026#34;: \u0026#34;Transaction\u0026#34;, \u0026#34;Description\u0026#34;: \u0026#34;A transaction\u0026#34; } ] } Then pass the configuration section to the AddInMemoryApiScopes method:\nbuilder.AddInMemoryApiScopes(configuration.GetSection(\u0026#34;IdentityServer:ApiScopes\u0026#34;)) "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/models/api_resource/",
    "title": "API Resource",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Models.ApiResource This class models an API.\nEnabled\nIndicates if this resource is enabled and can be requested. Defaults to true.\nName\nThe unique name of the API. This value is used for authentication with introspection and will be added to the audience of the outgoing access token.\nDisplayName\nThis value can be used e.g. on the consent screen.\nDescription\nThis value can be used e.g. on the consent screen.\nRequireResourceIndicator\nIndicates if this API resource requires the resource indicator to request it, and expects access tokens issued to it will only ever contain this API resource as the audience.\nApiSecrets\nThe API secret is used for the introspection endpoint. The API can authenticate with introspection using the API name and secret.\nAllowedAccessTokenSigningAlgorithms\nList of allowed signing algorithms for access token. If empty, will use the server default signing algorithm.\nUserClaims\nList of associated user claim types that should be included in the access token.\nScopes\nList of API scope names. You need to create those using ApiScope.\nDefining API resources in appsettings.json The AddInMemoryApiResource extensions method also supports adding API resources from the ASP.NET Core configuration file::\n\u0026quot;IdentityServer\u0026quot;: { \u0026quot;IssuerUri\u0026quot;: \u0026quot;urn:sso.company.com\u0026quot;, \u0026quot;ApiResources\u0026quot;: [ { \u0026quot;Name\u0026quot;: \u0026quot;resource1\u0026quot;, \u0026quot;DisplayName\u0026quot;: \u0026quot;Resource #1\u0026quot;, \u0026quot;Scopes\u0026quot;: [ \u0026quot;resource1.scope1\u0026quot;, \u0026quot;shared.scope\u0026quot; ] }, { \u0026quot;Name\u0026quot;: \u0026quot;resource2\u0026quot;, \u0026quot;DisplayName\u0026quot;: \u0026quot;Resource #2\u0026quot;, \u0026quot;UserClaims\u0026quot;: [ \u0026quot;name\u0026quot;, \u0026quot;email\u0026quot; ], \u0026quot;Scopes\u0026quot;: [ \u0026quot;resource2.scope1\u0026quot;, \u0026quot;shared.scope\u0026quot; ] } ] } Then pass the configuration section to the AddInMemoryApiResource method:\nbuilder.AddInMemoryApiResources(configuration.GetSection(\u0026#34;IdentityServer:ApiResources\u0026#34;)) "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/fundamentals/resources/api_resources/",
    "title": "API Resources",
    "tags": [],
    "description": "",
    "content": "When the API/resource surface gets larger, a flat list of scopes might become hard to manage.\nIn Duende IdentityServer, the ApiResource class allows for some additional organization as well as grouping and isolation of scopes as well as providing some common settings.\nLet\u0026rsquo;s use the following scope definition as an example:\npublic static IEnumerable\u0026lt;ApiScope\u0026gt; GetApiScopes() { return new List\u0026lt;ApiScope\u0026gt; { // invoice API specific scopes new ApiScope(name: \u0026#34;invoice.read\u0026#34;, displayName: \u0026#34;Reads your invoices.\u0026#34;), new ApiScope(name: \u0026#34;invoice.pay\u0026#34;, displayName: \u0026#34;Pays your invoices.\u0026#34;), // customer API specific scopes new ApiScope(name: \u0026#34;customer.read\u0026#34;, displayName: \u0026#34;Reads you customers information.\u0026#34;), new ApiScope(name: \u0026#34;customer.contact\u0026#34;, displayName: \u0026#34;Allows contacting one of your customers.\u0026#34;), // shared scopes new ApiScope(name: \u0026#34;manage\u0026#34;, displayName: \u0026#34;Provides administrative access.\u0026#34;) new ApiScope(name: \u0026#34;enumerate\u0026#34;, displayName: \u0026#34;Allows enumerating data.\u0026#34;) }; } With ApiResource you can now create two logical APIs and their corresponding scopes:\npublic static readonly IEnumerable\u0026lt;ApiResource\u0026gt; GetApiResources() { return new List\u0026lt;ApiResource\u0026gt; { new ApiResource(\u0026#34;invoice\u0026#34;, \u0026#34;Invoice API\u0026#34;) { Scopes = { \u0026#34;invoice.read\u0026#34;, \u0026#34;invoice.pay\u0026#34;, \u0026#34;manage\u0026#34;, \u0026#34;enumerate\u0026#34; } }, new ApiResource(\u0026#34;customer\u0026#34;, \u0026#34;Customer API\u0026#34;) { Scopes = { \u0026#34;customer.read\u0026#34;, \u0026#34;customer.contact\u0026#34;, \u0026#34;manage\u0026#34;, \u0026#34;enumerate\u0026#34; } } }; } Using the API resource grouping gives you the following additional features\nsupport for the JWT aud claim. The value(s) of the audience claim will be the name of the API resource(s) support for adding common user claims across all contained scopes support for introspection by assigning a API secret to the resource support for configuring the access token signing algorithm for the resource Let\u0026rsquo;s have a look at some example access tokens for the above resource configuration.\nClient requests: invoice.read and invoice.pay:\n{ \u0026#34;typ\u0026#34;: \u0026#34;at+jwt\u0026#34; }. { \u0026#34;client_id\u0026#34;: \u0026#34;client\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;aud\u0026#34;: \u0026#34;invoice\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;invoice.read invoice.pay\u0026#34; } Client requests: invoice.read and customer.read:\n{ \u0026#34;typ\u0026#34;: \u0026#34;at+jwt\u0026#34; }. { \u0026#34;client_id\u0026#34;: \u0026#34;client\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;aud\u0026#34;: [ \u0026#34;invoice\u0026#34;, \u0026#34;customer\u0026#34; ], \u0026#34;scope\u0026#34;: \u0026#34;invoice.read customer.read\u0026#34; } Client requests: manage:\n{ \u0026#34;typ\u0026#34;: \u0026#34;at+jwt\u0026#34; }. { \u0026#34;client_id\u0026#34;: \u0026#34;client\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;aud\u0026#34;: [ \u0026#34;invoice\u0026#34;, \u0026#34;customer\u0026#34; ], \u0026#34;scope\u0026#34;: \u0026#34;manage\u0026#34; } Adding user claims You can specify that an access token for an API resource (regardless which scope is requested) should contain additional user claims,\nvar customerResource = new ApiResource(\u0026#34;customer\u0026#34;, \u0026#34;Customer API\u0026#34;) { Scopes = { \u0026#34;customer.read\u0026#34;, \u0026#34;customer.contact\u0026#34;, \u0026#34;manage\u0026#34;, \u0026#34;enumerate\u0026#34; }, // additional claims to put into access token UserClaims = { \u0026#34;department_id\u0026#34;, \u0026#34;sales_region\u0026#34; } } If a client would now request a scope belonging to the customer resource, the access token would contain the additional claims (if provided by your profile service).\n{ \u0026#34;typ\u0026#34;: \u0026#34;at+jwt\u0026#34; }. { \u0026#34;client_id\u0026#34;: \u0026#34;client\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;aud\u0026#34;: [ \u0026#34;invoice\u0026#34;, \u0026#34;customer\u0026#34; ], \u0026#34;scope\u0026#34;: \u0026#34;invoice.read customer.read\u0026#34;, \u0026#34;department_id\u0026#34;: 5, \u0026#34;sales_region\u0026#34;: \u0026#34;south\u0026#34; } Setting a signing algorithm Your APIs might have certain requirements for the cryptographic algorithm used to sign the access tokens for that resource. An example could be regulatory requirements, or that you are starting to migration your system to higher security algorithms.\nThe following sample sets PS256 as the required signing algorithm for the invoices API:\nvar invoiceApi = new ApiResource(\u0026#34;invoice\u0026#34;, \u0026#34;Invoice API\u0026#34;) { Scopes = { \u0026#34;invoice.read\u0026#34;, \u0026#34;invoice.pay\u0026#34;, \u0026#34;manage\u0026#34;, \u0026#34;enumerate\u0026#34; }, AllowedAccessTokenSigningAlgorithms = { SecurityAlgorithms.RsaSsaPssSha256 } } Make sure that you have configured your IdentityServer for the required signing algorithm. See here for more details.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/apis/aspnetcore/authorization/",
    "title": "Authorization based on Scopes and other Claims",
    "tags": [],
    "description": "",
    "content": "The access token will include additional claims that can be used for authorization, e.g. the scope claim will reflect the scope the client requested (and was granted) during the token request.\nIn ASP.NET core, the contents of the JWT payload get transformed into claims and packaged up in a ClaimsPrincipal. So you can always write custom validation or authorization logic in C#:\npublic IActionResult Get() { var isAllowed = User.HasClaim(\u0026#34;scope\u0026#34;, \u0026#34;read\u0026#34;); // rest omitted } For better encapsulation and re-use, consider using the ASP.NET Core authorization policy feature.\nWith this approach, you would first turn the claim requirement(s) into a named policy:\npublic void ConfigureServices(IServiceCollection services) { services.AddAuthorization(options =\u0026gt; { options.AddPolicy(\u0026#34;read_access\u0026#34;, policy =\u0026gt; policy.RequireClaim(\u0026#34;scope\u0026#34;, \u0026#34;read\u0026#34;)); }); } ..and then enforce it, e.g. using the routing table:\napp.UseEndpoints(endpoints =\u0026gt; { endpoints.MapControllers().RequireAuthorization(\u0026#34;read_access\u0026#34;); }); \u0026hellip;or imperatively inside the controller:\npublic class DataController : ControllerBase { IAuthorizationService _authz; public DataController(IAuthorizationService authz) { _authz = authz; } public async Task\u0026lt;IActionResult\u0026gt; Get() { var allowed = _authz.CheckAccess(User, \u0026#34;read_access\u0026#34;); // rest omitted } } \u0026hellip; or declaratively:\npublic class DataController : ControllerBase { [Authorize(\u0026#34;read_access\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Get() { var allowed = authz.CheckAccess(User, \u0026#34;read_access\u0026#34;); // rest omitted } } Scope claim format Historically, Duende IdentityServer emitted the scope claims as an array in the JWT. This works very well with the .NET deserialization logic, which turns every array item into a separate claim of type scope.\nThe newer JWT Profile for OAuth spec mandates that the scope claim is a single space delimited string. You can switch the format by setting the EmitScopesAsSpaceDelimitedStringInJwt on the options. But this means that the code consuming access tokens might need to be adjusted. The following code can do a conversion to the multiple claims format that .NET prefers:\nnamespace IdentityModel.AspNetCore.AccessTokenValidation { /// \u0026lt;summary\u0026gt; /// Logic for normalizing scope claims to separate claim types /// \u0026lt;/summary\u0026gt; public static class ScopeConverter { /// \u0026lt;summary\u0026gt; /// Logic for normalizing scope claims to separate claim types /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;principal\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static ClaimsPrincipal NormalizeScopeClaims(this ClaimsPrincipal principal) { var identities = new List\u0026lt;ClaimsIdentity\u0026gt;(); foreach (var id in principal.Identities) { var identity = new ClaimsIdentity(id.AuthenticationType, id.NameClaimType, id.RoleClaimType); foreach (var claim in id.Claims) { if (claim.Type == \u0026#34;scope\u0026#34;) { if (claim.Value.Contains(\u0026#39; \u0026#39;)) { var scopes = claim.Value.Split(\u0026#39; \u0026#39;, StringSplitOptions.RemoveEmptyEntries); foreach (var scope in scopes) { identity.AddClaim(new Claim(\u0026#34;scope\u0026#34;, scope, claim.ValueType, claim.Issuer)); } } else { identity.AddClaim(claim); } } else { identity.AddClaim(claim); } } identities.Add(identity); } return new ClaimsPrincipal(identities); } } } The above code could then be called as an extension method or as part of claims transformation.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/fundamentals/clients/",
    "title": "Clients",
    "tags": [],
    "description": "",
    "content": "Clients represent applications that can request tokens from your IdentityServer.\nThe details vary, but you typically define the following common settings for a client:\na unique client ID a secret if needed the allowed interactions with the token service (called a grant type) a network location where identity and/or access token gets sent to (called a redirect URI) a list of scopes (aka resources) the client is allowed to access Defining a client for server to server communication In this scenario no interactive user is present - a service (i.e. the client) wants to communicate with an API (i.e. the resource that supports the scope):\npublic class Clients { public static IEnumerable\u0026lt;Client\u0026gt; Get() { return new List\u0026lt;Client\u0026gt; { new Client { ClientId = \u0026#34;service.client\u0026#34;, ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, AllowedGrantTypes = GrantTypes.ClientCredentials, AllowedScopes = { \u0026#34;api1\u0026#34;, \u0026#34;api2.read_only\u0026#34; } } }; } } Defining an interactive application for use authentication and delegated API access Interactive applications (e.g. web applications or native desktop/mobile) applications use the authorization code flow. This flow gives you the best security because the access tokens are transmitted via back-channel calls only (and gives you access to refresh tokens):\nvar interactiveClient = new Client { ClientId = \u0026#34;interactive\u0026#34;, AllowedGrantTypes = GrantTypes.Code, AllowOfflineAccess = true, ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, RedirectUris = { \u0026#34;http://localhost:21402/signin-oidc\u0026#34; }, PostLogoutRedirectUris = { \u0026#34;http://localhost:21402/\u0026#34; }, FrontChannelLogoutUri = \u0026#34;http://localhost:21402/signout-oidc\u0026#34;, AllowedScopes = { IdentityServerConstants.StandardScopes.OpenId, IdentityServerConstants.StandardScopes.Profile, IdentityServerConstants.StandardScopes.Email, \u0026#34;api1\u0026#34;, \u0026#34;api2.read_only\u0026#34; }, }; Defining clients in appsettings.json The AddInMemoryClients extensions method also supports adding clients from the ASP.NET Core configuration file. This allows you to define static clients directly from the appsettings.json file:\n\u0026#34;IdentityServer\u0026#34;: { \u0026#34;IssuerUri\u0026#34;: \u0026#34;urn:sso.company.com\u0026#34;, \u0026#34;Clients\u0026#34;: [ { \u0026#34;Enabled\u0026#34;: true, \u0026#34;ClientId\u0026#34;: \u0026#34;local-dev\u0026#34;, \u0026#34;ClientName\u0026#34;: \u0026#34;Local Development\u0026#34;, \u0026#34;ClientSecrets\u0026#34;: [ { \u0026#34;Value\u0026#34;: \u0026#34;\u0026lt;Insert Sha256 hash of the secret encoded as Base64 string\u0026gt;\u0026#34; } ], \u0026#34;AllowedGrantTypes\u0026#34;: [ \u0026#34;client_credentials\u0026#34; ], \u0026#34;AllowedScopes\u0026#34;: [ \u0026#34;api1\u0026#34; ], } ] } Then pass the configuration section to the AddInMemoryClients method:\nAddInMemoryClients(configuration.GetSection(\u0026#34;IdentityServer:Clients\u0026#34;)) "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/endpoints/",
    "title": "Endpoints",
    "tags": [],
    "description": "",
    "content": "Endpoints Discovery Endpoint Authorize Endpoint Token Endpoint UserInfo Endpoint Introspection Endpoint Revocation Endpoint End Session Endpoint Device Authorization Endpoint "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/ui/error/",
    "title": "Error",
    "tags": [],
    "description": "",
    "content": "The error page is used to display to the end user than an error has ocurred during requests to the authorize endpoint.\nCommonly errors are due to misconfiguration, and there\u0026rsquo;s not much an end user can do about that. But this allows the user to understand that something went wrong and that they are not in the middle of a successful workflow.\nError Context Details of the error are provided to the error page via an errorId parameter.\nThe interaction service provides a GetErrorContextAsync API that will extract that information from the errorId. The returned ErrorMessage object contains these details.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/deployment/data_stores/",
    "title": "IdentityServer Data Stores",
    "tags": [],
    "description": "",
    "content": "IdentityServer itself is stateless and does not require server affinity - but there is data that needs to be shared between in multi-instance deployments.\nConfiguration data This typically includes:\nresources clients startup configuration, e.g. key material, external provider settings etc… The way you store that data depends on your environment. In situations where configuration data rarely changes we recommend using the in-memory stores and code or configuration files. In highly dynamic environments (e.g. Saas) we recommend using a database or configuration service to load configuration dynamically.\nOperational data For certain operations, IdentityServer needs a persistence store to keep state, this includes:\nissuing authorization codes issuing reference and refresh tokens storing consent automatic management for signing keys You can either use a traditional database for storing operational data, or use a cache with persistence features like Redis.\nDuende IdentityServer includes storage implementations for above data using EntityFramework, and you can build your own. See the data stores section for more information.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/tokens/password_grant/",
    "title": "Issuing Tokens based on User Passwords",
    "tags": [],
    "description": "",
    "content": "The password grant type is an OAuth 2.0 protocol flow for authenticating end-users at the token endpoint. It is designed for legacy applications, and it is generally recommended to use a browser-based flow instead - but in certain situation it is not feasible to change existing applications.\nThe password grant type is deprecated per OAuth 2.1.\nRequesting a token using Password grant First you need to add the GrantType.Password to the AllowedGrantTypes list of the client you want to use.\nThen your client application would provide some means for the end-user to enter their credentials and post them to the token endpoint:\nPOST /token HTTP/1.1 Host: demo.duendesoftware.com Content-Type: application/x-www-form-urlencoded client_id=client\u0026amp; client_secret=secret grant_type=password\u0026amp; username=bob\u0026amp; password=password .NET client library On .NET you can use the IdentityModel client library to request tokens using the password grant type, e.g.:\nusing IdentityModel.Client; var client = new HttpClient(); var response = await client.RequestPasswordTokenAsync(new PasswordTokenRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/token\u0026#34;, ClientId = \u0026#34;client\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Scope = \u0026#34;api1\u0026#34;, UserName = \u0026#34;bob\u0026#34;, Password = \u0026#34;password\u0026#34; }); Validating the token request Since this flow is not generally recommended, no standard implementation for validating the token request and user credentials is included. To add support for it you need to to implement and register an implementation of the IResourceOwnerPasswordValidator interface::\npublic interface IResourceOwnerPasswordValidator { /// \u0026lt;summary\u0026gt; /// Validates the resource owner password credential /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;context\u0026#34;\u0026gt;The context.\u0026lt;/param\u0026gt; Task ValidateAsync(ResourceOwnerPasswordValidationContext context); } The context contains parsed protocol parameters like UserName and Password as well as the raw request.\nIt is the job of the validator to implement the password validation and set the Result property on the context accordingly (see the Grant Validation Result reference).\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/overview/specs/",
    "title": "Supported Specifications",
    "tags": [],
    "description": "",
    "content": "Duende IdentityServer implements the following specifications:\nOpenID Connect OpenID Connect Core 1.0 (spec) OpenID Connect Discovery 1.0 (spec) OpenID Connect RP-Initiated Logout 1.0 - draft 01 (spec) OpenID Connect Session Management 1.0 - draft 30 (spec) OpenID Connect Front-Channel Logout 1.0 - draft 04 (spec) OpenID Connect Back-Channel Logout 1.0 - draft 06 (spec) Multiple Response Types (spec) Form Post Response Mode (spec) OAuth 2.x OAuth 2.0 (RFC 6749) OAuth 2.0 Bearer Token Usage (RFC 6750) JSON Web Token (RFC 7519) OAuth 2.0 Token Revocation (RFC 7009) OAuth 2.0 Token Introspection (RFC 7662) Proof Key for Code Exchange (RFC 7636) JSON Web Tokens for Client Authentication (RFC 7523) OAuth 2.0 Device Authorization Grant (RFC 8628) Proof-of-Possession Key Semantics for JSON Web Tokens (RFC 7800) OAuth 2.0 Mutual TLS Client Authentication and Certificate-Bound Access Tokens (RFC 8705) OAuth 2.0 Token Exchange (RFC 8693) Resource Indicators for OAuth 2.0 (RFC 8707) JWT Secured Authorization Request (draft) JWT Profile for OAuth 2.0 Access Tokens (RFC 9068) OAuth 2.0 Authorization Server Issuer Identifier in Authorization Response (RFC 9207) "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/tokens/authentication/mtls/",
    "title": "TLS Client Certificates",
    "tags": [],
    "description": "",
    "content": "Clients can use an X.509 client certificate as an authentication mechanism to endpoints in your IdentityServer.\nFor this you need to associate a client certificate with a client in your IdentityServer and enable MTLS support on the options.\nvar builder = service.AddIdentityServer(options =\u0026gt; { options.MutualTls.Enabled = true; }) Use the DI extensions methods to add the services to DI which contain a default implementation to do that either thumbprint or common-name based:\nbuilder.AddMutualTlsSecretValidators(); Then add client secret of type SecretTypes.X509CertificateName (for PKI-based scenarios) or SecretTypes.X509CertificateThumbprint (for self-issued certificates) to the client you want to authenticate.\nFor example::\nnew Client { ClientId = \u0026#34;mtls.client\u0026#34;, AllowedGrantTypes = GrantTypes.ClientCredentials, AllowedScopes = { \u0026#34;api1\u0026#34; }, ClientSecrets = { // name based new Secret(@\u0026#34;CN=client, OU=production, O=company\u0026#34;, \u0026#34;client.dn\u0026#34;) { Type = SecretTypes.X509CertificateName }, // or thumbprint based new Secret(\u0026#34;bca0d040847f843c5ee0fa6eb494837470155868\u0026#34;, \u0026#34;mtls.tb\u0026#34;) { Type = SecretTypes.X509CertificateThumbprint }, } } .NET client library When writing a client to connect to IdentityServer, the SocketsHttpHandler (or HttpClientHandler depending on you .NET version) class provides a convenient mechanism to add a client certificate to outgoing requests.\nUse such a handler with HttpClient to perform the client certificate authentication handshake at the TLS channel. The following snippet is using IdentityModel to read the discovery document and request a token:\nstatic async Task\u0026lt;TokenResponse\u0026gt; RequestTokenAsync() { var handler = new SocketsHttpHandler(); var cert = new X509Certificate2(\u0026#34;client.p12\u0026#34;, \u0026#34;password\u0026#34;); handler.SslOptions.ClientCertificates = new X509CertificateCollection { cert }; var client = new HttpClient(handler); var disco = await client.GetDiscoveryDocumentAsync(Constants.Authority); if (disco.IsError) throw new Exception(disco.Error); var response = await client.RequestClientCredentialsTokenAsync(new ClientCredentialsTokenRequest { Address = disco.MtlEndpointAliases.TokenEndpoint ClientId = \u0026#34;mtls.client\u0026#34;, Scope = \u0026#34;api1\u0026#34; }); if (response.IsError) throw new Exception(response.Error); return response; } TODO: add ASP.NET Core client sample\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/bff/extensibility/tokens/",
    "title": "Token Management",
    "tags": [],
    "description": "",
    "content": "The token management library does essentially two things:\nstores access and refresh tokens in the current session refreshes access tokens automatically at the token service when needed Both aspects can be customized.\nToken service communication The token management library uses a named HTTP client from the HTTP client factory for all token service communication. You can provide a customized HTTP client yourself using the well-known name after calling AddBff:\nservices.AddHttpClient(AccessTokenManagementDefaults.BackChannelHttpClientName, configureClient =\u0026gt; { ... }); You can also supply client assertions to the token management library. See this sample for JWT-based client authentication.\nCustom token storage We recommend to use the default storage mechanism, as this will automatically be compatible with the Duende.BFF server-side sessions.\nIf you do not use server-side sessions, then the access and refresh token will be stored in the protected session cookie. If you want to change this, you can take over token storage completely.\nThis would involve two steps\nturn off the SaveTokens flag on the OpenID Connect handler and handle the relevant events manually to store the tokens in your custom store implement and register the IdentityModel.AspNetCore.AccessTokenManagement.IUserAccessTokenStore interface The interface is responsible to storing, retrieving and clearing tokens for the automatic token management:\npublic interface IUserAccessTokenStore { /// \u0026lt;summary\u0026gt; /// Stores tokens /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;user\u0026#34;\u0026gt;User the tokens belong to\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;accessToken\u0026#34;\u0026gt;The access token\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;expiration\u0026#34;\u0026gt;The access token expiration\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;refreshToken\u0026#34;\u0026gt;The refresh token (optional)\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;parameters\u0026#34;\u0026gt;Extra optional parameters\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task StoreTokenAsync(ClaimsPrincipal user, string accessToken, DateTimeOffset expiration, string refreshToken = null, UserAccessTokenParameters parameters = null); /// \u0026lt;summary\u0026gt; /// Retrieves tokens from store /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;user\u0026#34;\u0026gt;User the tokens belong to\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;parameters\u0026#34;\u0026gt;Extra optional parameters\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;access and refresh token and access token expiration\u0026lt;/returns\u0026gt; Task\u0026lt;UserAccessToken\u0026gt; GetTokenAsync(ClaimsPrincipal user, UserAccessTokenParameters parameters = null); /// \u0026lt;summary\u0026gt; /// Clears the stored tokens for a given user /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;user\u0026#34;\u0026gt;User the tokens belong to\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;parameters\u0026#34;\u0026gt;Extra optional parameters\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task ClearTokenAsync(ClaimsPrincipal user, UserAccessTokenParameters parameters = null); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/quickstarts/",
    "title": "Quickstarts",
    "tags": [],
    "description": "",
    "content": "Quickstarts The following hands-on tutorials guide you through a couple of common scenarios.\nOverview Protecting an API using Client Credentials Interactive Applications with ASP.NET Core ASP.NET Core and API access Using EntityFramework Core for configuration and operational data Building JavaScript client applications Using ASP.NET Core Identity "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/samples/bff/",
    "title": "Backend for Frontend Pattern",
    "tags": [],
    "description": "",
    "content": "This solution contains a collection of clients using our BFF security framework.\nJavaScript Frontend This sample shows how to use the BFF framework with a JavaScript-based frontend (e.g. SPA).\nlink to source code\nBlazor Server This sample shows how to use the BFF framework with Blazor Server.\nlink to source code\nBlazor WASM This sample shows how to use the BFF framework with Blazor WASM.\nlink to source code\nYARP Integration This sample shows how to use the BFF extensions for Microsoft YARP\nlink to source code\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/data/operational/grants/",
    "title": "Grants",
    "tags": [],
    "description": "",
    "content": "Many protocol flows produce state that represents a grant of one type or another. These include authorization and device codes, reference and refresh tokens, and remembered user consent.\nStores The persistence for grants is abstracted behind two interfaces:\nThe persisted grant store is a common store for most grants. The device flow store is a specialized store for device grants. Registering Custom Stores Custom implementations of IPersistedGrantStore, and/or IDeviceFlowStore must be registered in the DI system. For example:\npublic void ConfigureServices(IServiceCollection services) { services.AddIdentityServer(); services.AddTransient\u0026lt;IPersistedGrantStore, YourCustomPersistedGrantStore\u0026gt;(); services.AddTransient\u0026lt;IDeviceFlowStore, YourCustomDeviceFlowStore\u0026gt;(); } Grant Expiration and Consumption The presence of the record in the store without a ConsumedTime and while still within the Expiration represents the validity of the grant. Setting either of these two values, or removing the record from the store effectively revokes the grant.\nSome grant types are one-time use only (either by definition or configuration). Once they are \u0026ldquo;used\u0026rdquo;, rather than deleting the record, the ConsumedTime value is set in the database marking them as having been used. This \u0026ldquo;soft delete\u0026rdquo; allows for custom implementations to either have flexibility in allowing a grant to be re-used (typically within a short window of time), or to be used in risk assessment and threat mitigation scenarios (where suspicious activity is detected) to revoke access. For refresh tokens, this sort of custom logic would be performed in the IRefreshTokenService.\nPersisted Grant Service Working with the grants store directly might be too low level. As such, a higher level service called the IPersistedGrantService is provided. It abstracts and aggregates the different grant types into one concept, and allows querying and revoking the persisted grants for a user.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/ui/login/redirect/",
    "title": "Redirecting back to the client",
    "tags": [],
    "description": "",
    "content": "The Return URL and the Login Workflow Once the user has been logged in, they must complete the protocol workflow so they can ultimately be logged into the client. To facilitate this, the login page is passed a returnUrl query parameter which refers to the URL the prior request came from. This URL is, in essence, the same authorization endpoint to which the client made the original authorize request.\nIn the request to your login page where it logs the user in with a call to SignInAsync, it would then simply use the returnUrl to redirect the response back. This will cause the browser to re-issue the original authorize request from the client allowing your IdentityServer to complete the protocol work. An example of this redirect can be seen in the local login topic.\nBeware open-redirect attacks via the returnUrl parameter. You should validate that the returnUrl refers to a well-known location. Either use the Url.IsLocalUrl helper from ASP.NET Core, or use the interaction service from Duende IdentityServer for APIs to validate the returnUrl parameter.\nKeep in mind that this returnUrl is state that needs to be maintained during the user\u0026rsquo;s login workflow. If your workflow involves page post-backs, redirecting the user to an external login provider, or just sending the user through a custom workflow, then this value must be preserved across all of those page transitions.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/stores/resource_store/",
    "title": "Resource Store",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Stores.IResourceStore Used to dynamically load resource configuration.\n/// \u0026lt;summary\u0026gt; /// Resource retrieval /// \u0026lt;/summary\u0026gt; public interface IResourceStore { /// \u0026lt;summary\u0026gt; /// Gets identity resources by scope name. /// \u0026lt;/summary\u0026gt; Task\u0026lt;IEnumerable\u0026lt;IdentityResource\u0026gt;\u0026gt; FindIdentityResourcesByScopeNameAsync(IEnumerable\u0026lt;string\u0026gt; scopeNames); /// \u0026lt;summary\u0026gt; /// Gets API scopes by scope name. /// \u0026lt;/summary\u0026gt; Task\u0026lt;IEnumerable\u0026lt;ApiScope\u0026gt;\u0026gt; FindApiScopesByNameAsync(IEnumerable\u0026lt;string\u0026gt; scopeNames); /// \u0026lt;summary\u0026gt; /// Gets API resources by scope name. /// \u0026lt;/summary\u0026gt; Task\u0026lt;IEnumerable\u0026lt;ApiResource\u0026gt;\u0026gt; FindApiResourcesByScopeNameAsync(IEnumerable\u0026lt;string\u0026gt; scopeNames); /// \u0026lt;summary\u0026gt; /// Gets API resources by API resource name. /// \u0026lt;/summary\u0026gt; Task\u0026lt;IEnumerable\u0026lt;ApiResource\u0026gt;\u0026gt; FindApiResourcesByNameAsync(IEnumerable\u0026lt;string\u0026gt; apiResourceNames); /// \u0026lt;summary\u0026gt; /// Gets all resources. /// \u0026lt;/summary\u0026gt; Task\u0026lt;Resources\u0026gt; GetAllResourcesAsync(); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/models/client/",
    "title": "Client",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Models.Client The Client class models an OpenID Connect or OAuth 2.0 client - e.g. a native application, a web application or a JS-based application.\npublic static IEnumerable\u0026lt;Client\u0026gt; Get() { return new List\u0026lt;Client\u0026gt; { /////////////////////////////////////////// // machine to machine client ////////////////////////////////////////// new Client { ClientId = \u0026#34;machine\u0026#34;, ClientSecrets = { Configuration[\u0026#34;machine.secret\u0026#34;] }, AllowedGrantTypes = GrantTypes.ClientCredentials, AllowedScopes = machineScopes }, /////////////////////////////////////////// // web client ////////////////////////////////////////// new Client { ClientId = \u0026#34;web\u0026#34;, ClientSecrets = { new Secret(Configuration[\u0026#34;web.secret\u0026#34;]) }, AllowedGrantTypes = GrantTypes.Code, RedirectUris = { \u0026#34;https://myapp.com:/signin-oidc\u0026#34; }, PostLogoutRedirectUris = { \u0026#34;https://myapp.com/signout-callback-oidc\u0026#34; }, BackChannelLogoutUri = \u0026#34;https://myapp.com/backchannel-logout\u0026#34;, AllowOfflineAccess = true, AllowedScopes = webScopes } } } Basics Enabled\nSpecifies if client is enabled. Defaults to true.\nClientId\nUnique ID of the client\nClientSecrets\nList of client secrets - credentials to access the token endpoint.\nRequireClientSecret\nSpecifies whether this client needs a secret to request tokens from the token endpoint (defaults to true)\nRequireRequestObject\nSpecifies whether this client needs to wrap the authorize request parameters in a JWT (defaults to false)\nAllowedGrantTypes\nSpecifies the grant types the client is allowed to use. Use the GrantTypes class for common combinations.\nRequirePkce\nSpecifies whether clients using an authorization code based grant type must send a proof key (defaults to true).\nAllowPlainTextPkce\nSpecifies whether clients using PKCE can use a plain text code challenge (not recommended - and default to false)\nRedirectUris\nSpecifies the allowed URIs to return tokens or authorization codes to\nAllowedScopes\nBy default a client has no access to any resources - specify the allowed resources by adding the corresponding scopes names\nAllowOfflineAccess\nSpecifies whether this client can request refresh tokens (be requesting the offline_access scope)\nAllowAccessTokensViaBrowser\nSpecifies whether this client is allowed to receive access tokens via the browser. This is useful to harden flows that allow multiple response types (e.g. by disallowing a hybrid flow client that is supposed to use code id_token to add the token response type and thus leaking the token to the browser.\nProperties\nDictionary to hold any custom client-specific values as needed.\nAuthentication / Session Management PostLogoutRedirectUris\nSpecifies allowed URIs to redirect to after logout.\nFrontChannelLogoutUri\nSpecifies logout URI at client for HTTP based front-channel logout.\nFrontChannelLogoutSessionRequired\nSpecifies if the user\u0026rsquo;s session id should be sent to the FrontChannelLogoutUri. Defaults to true.\nBackChannelLogoutUri\nSpecifies logout URI at client for HTTP based back-channel logout.\nBackChannelLogoutSessionRequired\nSpecifies if the user\u0026rsquo;s session id should be sent in the request to the BackChannelLogoutUri. Defaults to true.\nEnableLocalLogin\nSpecifies if this client can use local accounts, or external IdPs only. Defaults to true.\nIdentityProviderRestrictions\nSpecifies which external IdPs can be used with this client (if list is empty all IdPs are allowed). Defaults to empty.\nUserSsoLifetime\nThe maximum duration (in seconds) since the last time the user authenticated. Defaults to null. You can adjust the lifetime of a session token to control when and how often a user is required to reenter credentials instead of being silently authenticated, when using a web application.\nAllowedCorsOrigins\nIf specified, will be used by the default CORS policy service implementations (In-Memory and EF) to build a CORS policy for JavaScript clients.\nToken IdentityTokenLifetime\nLifetime to identity token in seconds (defaults to 300 seconds / 5 minutes)\nAllowedIdentityTokenSigningAlgorithms\nList of allowed signing algorithms for identity token. If empty, will use the server default signing algorithm.\nAccessTokenLifetime\nLifetime of access token in seconds (defaults to 3600 seconds / 1 hour)\nAuthorizationCodeLifetime\nLifetime of authorization code in seconds (defaults to 300 seconds / 5 minutes)\nAccessTokenType\nSpecifies whether the access token is a reference token or a self contained JWT token (defaults to Jwt).\nIncludeJwtId\nSpecifies whether JWT access tokens should have an embedded unique ID (via the jti claim). Defaults to true.\nClaims\nAllows settings claims for the client (will be included in the access token).\nAlwaysSendClientClaims\nIf set, the client claims will be sent for every flow. If not, only for client credentials flow (default is false)\nAlwaysIncludeUserClaimsInIdToken\nWhen requesting both an id token and access token, should the user claims always be added to the id token instead of requiring the client to use the userinfo endpoint. Default is false.\nClientClaimsPrefix\nIf set, the prefix client claim types will be prefixed with. Defaults to client_. The intent is to make sure they don\u0026rsquo;t accidentally collide with user claims.\nPairWiseSubjectSalt Salt value used in pair-wise subjectId generation for users of this client. Currently not implemented.\nRefresh Token AbsoluteRefreshTokenLifetime\nMaximum lifetime of a refresh token in seconds. Defaults to 2592000 seconds / 30 days\nSlidingRefreshTokenLifetime\nSliding lifetime of a refresh token in seconds. Defaults to 1296000 seconds / 15 days\nRefreshTokenUsage\nReUse\nthe refresh token handle will stay the same when refreshing tokens\nOneTime\nthe refresh token handle will be updated when refreshing tokens. This is the default.\nRefreshTokenExpiration\nAbsolute\nthe refresh token will expire on a fixed point in time (specified by the AbsoluteRefreshTokenLifetime). This is the default.\nSliding\nwhen refreshing the token, the lifetime of the refresh token will be renewed (by the amount specified in SlidingRefreshTokenLifetime). The lifetime will not exceed AbsoluteRefreshTokenLifetime.\nUpdateAccessTokenClaimsOnRefresh\nGets or sets a value indicating whether the access token (and its claims) should be updated on a refresh token request.\nConsent Screen Consent screen specific settings.\nRequireConsent\nSpecifies whether a consent screen is required. Defaults to false.\nAllowRememberConsent\nSpecifies whether user can choose to store consent decisions. Defaults to true.\nConsentLifetime\nLifetime of a user consent in seconds. Defaults to null (no expiration).\nClientName\nClient display name (used for logging and consent screen).\nClientUri\nURI to further information about client.\nLogoUri\nURI to client logo.\nDevice flow Device flow specific settings.\nUserCodeType\nSpecifies the type of user code to use for the client. Otherwise falls back to default.\nDeviceCodeLifetime\nLifetime to device code in seconds (defaults to 300 seconds / 5 minutes)\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/models/idp/",
    "title": "Identity Provider",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Models.OidcProvider The OidcProvider models an external OpenID Connect provider for use in the dynamic providers feature. Its properties map to the Open ID Connect options class from ASP.NET Core, and those properties include:\nEnabled\nSpecifies if provider is enabled. Defaults to true.\nScheme\nScheme name for the provider.\nDisplayName\nDisplay name for the provider.\nType\nProtocol type of the provider. Defaults to \u0026ldquo;oidc\u0026rdquo; for the OidcProvider.\nAuthority\nThe base address of the OIDC provider.\nResponseType\nThe response type. Defaults to \u0026ldquo;id_token\u0026rdquo;.\nClientId\nThe client id.\nClientSecret\nThe client secret. By default this is the plaintext client secret and great consideration should be taken if this value is to be stored as plaintext in the store. It is possible to store this in a protected way and then unprotect when loading from the store either by implementing a custom IIdentityProviderStore or registering a custom IConfigureNamedOptions\u0026lt;OpenIdConnectOptions\u0026gt;.\nScope\nSpace separated list of scope values.\nDuende.IdentityServer.Models.IdentityProviderName The IdentityProviderName models the display name of an identity provider.\nEnabled\nSpecifies if provider is enabled. Defaults to true.\nScheme\nScheme name for the provider.\nDisplayName\nDisplay name for the provider.\nDuende.IdentityServer.Models.IdentityProvider The IdentityProvider is a base class to model arbitrary identity providers, which OidcProvider derives from. This leaves open the possibility for extensions to the dynamic provider feature to support other protocol types (as distinguished by the Type property).\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/stores/client_store/",
    "title": "Client Store",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Stores.IClientStore Used to dynamically load client configuration.\n/// \u0026lt;summary\u0026gt; /// Retrieval of client configuration /// \u0026lt;/summary\u0026gt; public interface IClientStore { /// \u0026lt;summary\u0026gt; /// Finds a client by id /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;clientId\u0026#34;\u0026gt;The client id\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;The client\u0026lt;/returns\u0026gt; Task\u0026lt;Client\u0026gt; FindClientByIdAsync(string clientId); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/stores/cors_policy_service/",
    "title": "CORS Policy Service",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Stores.ICorsPolicyService Used to determine if CORS requests are allowed to certain protocol endpoints.\n/// \u0026lt;summary\u0026gt; /// Service that determines if CORS is allowed. /// \u0026lt;/summary\u0026gt; public interface ICorsPolicyService { /// \u0026lt;summary\u0026gt; /// Determines whether origin is allowed. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;origin\u0026#34;\u0026gt;The origin.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task\u0026lt;bool\u0026gt; IsOriginAllowedAsync(string origin); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/stores/idp_store/",
    "title": "Identity Provider Store",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Stores.IIdentityProviderStore Used to dynamically load identity provider configuration.\n/// \u0026lt;summary\u0026gt; /// Interface to model storage of identity providers. /// \u0026lt;/summary\u0026gt; public interface IIdentityProviderStore { /// \u0026lt;summary\u0026gt; /// Gets all identity providers name. /// \u0026lt;/summary\u0026gt; Task\u0026lt;IEnumerable\u0026lt;IdentityProviderName\u0026gt;\u0026gt; GetAllSchemeNamesAsync(); /// \u0026lt;summary\u0026gt; /// Gets the identity provider by scheme name. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;scheme\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task\u0026lt;IdentityProvider\u0026gt; GetBySchemeAsync(string scheme); } The IdentityProvider is intended to be a base class to model arbitrary identity providers. The default implementation included in Duende IdentityServer will return a derived class for OpenID Connect providers, via the OidcProvider class.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/ui/consent/",
    "title": "Consent",
    "tags": [],
    "description": "",
    "content": "During an authorization request, if user consent is required the browser will be redirected to the consent page.\nYou can configure the consent requirement per client. By default no consent is required, but this setting can be changed via the RequireConsent setting.\nConsent is used to allow an end user to grant a client access to resources.\nConsent Page In order for the user to grant consent, a consent page must be provided by the hosting application. The quickstart UI has a basic implementation of a consent page.\nA consent page normally renders the display name of the current user, the display name of the client requesting access, the logo of the client, a link for more information about the client, and the list of resources the client is requesting access to. It\u0026rsquo;s also common to allow the user to indicate that their consent should be \u0026ldquo;remembered\u0026rdquo; so they are not prompted again in the future for the same client.\nOnce the user has provided consent, the consent page must inform your IdentityServer of the consent, and then the browser must be redirected back to the authorization endpoint.\nAuthorization Context Your IdentityServer will pass a returnUrl parameter to the consent page which contains the parameters of the authorization request. These parameters provide the context for the consent page, and can be read with help from the interaction service.\nThe GetAuthorizationContextAsync API will return an instance of AuthorizationRequest. Additional details about the client or resources can be obtained using the IClientStore and IResourceStore interfaces.\nInforming IdentityServer of the consent result The GrantConsentAsync API on the interaction service allows the consent page to inform your IdentityServer of the outcome of consent (which might also be to deny the client access).\nYour IdentityServer will temporarily persist the outcome of the consent. This persistence uses a cookie by default, as it only needs to last long enough to convey the outcome back to the authorization endpoint. This temporary persistence is different than the persistence used for the \u0026ldquo;remember my consent\u0026rdquo; feature (and it is the authorization endpoint which persists the \u0026ldquo;remember my consent\u0026rdquo; for the user). If you wish to use some other persistence between the consent page and the authorization redirect, then you can implement IMessageStore and register the implementation in DI.\nReturning the user to the authorization endpoint Once the consent page has informed IdentityServer of the outcome, the user can be redirected back to the returnUrl. Your consent page should protect against open redirects by verifying that the returnUrl is valid. This can be done by calling IsValidReturnUrl on the interaction service.\nAlso, if GetAuthorizationContextAsync returns a non-null result, then you can also trust that the returnUrl is valid.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/deployment/caching/",
    "title": "Distributed Caching",
    "tags": [],
    "description": "",
    "content": "Some optional features rely on ASP.NET Core distributed caching:\nState data formatter for OpenID Connect Replay cache (e.g. for JWT client credentials) Device flow throttling service Authorization parameter store In order to work in a multi server environment, this needs to be set up correctly. Please consult the Microsoft documentation for more details.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/models/",
    "title": "Models",
    "tags": [],
    "description": "",
    "content": "Models Identity Resource API Scope API Resource Client Identity Provider Grant Validation Result Secrets "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/overview/packaging/",
    "title": "Packaging and Builds",
    "tags": [],
    "description": "",
    "content": "Product You can find the Duende IdentityServer source code on GitHub.\nThis repo is the source for the following main product Nuget packages:\nDuende IdentityServer Duende IdentityServer EntityFramework Integration Duende IdentityServer ASP.NET Identity Integration UI Duende IdentityServer does not contain any UI, because this is always custom to the project. We still provide you a starting point for your modifications.\nstandard UI UI with ASP.NET Identity integration Templates Contains templates for the dotnet CLI.\nNuGet package source code You can install the templates using the following command:\ndotnet new -i Duende.IdentityServer.Templates "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/services/profile_service/",
    "title": "Profile Service",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Services.IProfileService Encapsulates retrieval of user claims from a data source of your choice.\n/// \u0026lt;summary\u0026gt; /// This interface allows IdentityServer to connect to your user and profile store. /// \u0026lt;/summary\u0026gt; public interface IProfileService { /// \u0026lt;summary\u0026gt; /// This method is called whenever claims about the user are requested (e.g. during token creation or via the userinfo endpoint) /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;context\u0026#34;\u0026gt;The context.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task GetProfileDataAsync(ProfileDataRequestContext context); /// \u0026lt;summary\u0026gt; /// This method gets called whenever identity server needs to determine if the user is valid or active (e.g. if the user\u0026#39;s account has been deactivated since they logged in). /// (e.g. during token issuance or validation). /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;context\u0026#34;\u0026gt;The context.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task IsActiveAsync(IsActiveContext context); } GetProfileDataAsync\nThe API that is expected to load claims for a user. It is passed an instance of ProfileDataRequestContext.\nIsActiveAsync\nThe API that is expected to indicate if a user is currently allowed to obtain tokens. It is passed an instance of IsActiveContext.\nDuende.IdentityServer.Models.ProfileDataRequestContext Models the request for user claims and is the vehicle to return those claims. It contains these properties:\nSubject\nThe ClaimsPrincipal modeling the user.\nClient\nThe Client for which the claims are being requested.\nRequestedClaimTypes\nThe collection of claim types being requested. This data is source from the requested scopes and their associated claim types.\nCaller\nAn identifier for the context in which the claims are being requested (e.g. an identity token, an access token, or the user info endpoint. The constant IdentityServerConstants.ProfileDataCallers contains the different constant values.\nIssuedClaims\nThe list of claims that will be returned. This is expected to be populated by the custom IProfileService implementation.\nAddRequestedClaims\nExtension method on the ProfileDataRequestContext to populate the IssuedClaims, but first filters the claims based on RequestedClaimTypes.\nDuende.IdentityServer.Models.IsActiveContext Models the request to determine if the user is currently allowed to obtain tokens. It contains these properties:\nSubject\nThe ClaimsPrincipal modeling the user.\nClient\nThe Client for which the claims are being requested.\nCaller\nAn identifier for the context in which the claims are being requested (e.g. an identity token, an access token, or the user info endpoint. The constant IdentityServerConstants.ProfileDataCallers contains the different constant values.\nIsActive\nThe flag indicating if the user is allowed to obtain tokens. This is expected to be assigned by the custom IProfileService implementation.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/fundamentals/resources/isolation/",
    "title": "Resource Isolation",
    "tags": [],
    "description": "",
    "content": " This is an Enterprise Edition feature.\nOAuth itself only knows about scopes - the (API) resource concept does not exist from a pure protocol point of view. This means that all the requested scope and audience combination get merged into a single access token. This has a couple of downsides, e.g.\ntokens can become very powerful (and big) if such a token leaks, it allows access to multiple resources resources within that single token might have conflicting settings, e.g. user claims of all resources share the same token resource specific processing like signing or encryption algorithms conflict without sender-constraints, a resource could potentially re-use (or abuse) a token to call another contained resource directly To solve this problem RFC 8707 adds an additional request parameter for the authorize and token endpoint called resource. This allows requesting a token for a specific resource (in other words - making sure the audience claim has a single value only, and all scopes belong to that single resource).\nUsing the resource parameter Let\u0026rsquo;s assume you have the following resource design and that the client is allowed access to all scopes:\nvar resources = new[] { new ApiResource(\u0026#34;urn:invoices\u0026#34;) { Scopes = { \u0026#34;read\u0026#34;, \u0026#34;write\u0026#34; } }, new ApiResource(\u0026#34;urn:products\u0026#34;) { Scopes = { \u0026#34;read\u0026#34;, \u0026#34;write\u0026#34; } } }; If the client would simply request a token for the read scope, the resulting access token would contain the audience of both the invoice and the products API and thus be accepted at both APIs.\nMachine to machine scenarios If the client in addition passes the resource parameter specifying the name of the resource where it wants to use the access token, the token engine can down-scope the resulting access token to the single resource, e.g.:\nPOST /token grant_type=client_credentials\u0026amp; client_id=client\u0026amp; client_secret=...\u0026amp; scope=read\u0026amp; resource=urn:invoices Thus resulting in an access token like this (some details omitted):\n{ \u0026#34;aud\u0026#34;: [ \u0026#34;urn:invoice\u0026#34; ], \u0026#34;scope\u0026#34;: \u0026#34;read\u0026#34;, \u0026#34;client_id\u0026#34;: \u0026#34;client\u0026#34; } Interactive applications The authorize endpoint supports the resource parameter as well, e.g.:\nGET /authorize?client_id=client\u0026amp;response_type=code\u0026amp;scope=read\u0026amp;resource=urn:invoices Once the front-channel operations are done, the resulting code can be redeemed by passing the resource name on the token endpoint:\nPOST /token grant_type=authorization_code\u0026amp; client_id=client\u0026amp; client_secret=...\u0026amp; authorization_code=...\u0026amp; redirect_uri=...\u0026amp; resource=urn:invoices Requesting access to multiple resources It is also possible to request access to multiple resources. This will result in multiple access tokens - one for each request resource.\nGET /authorize?client_id=client\u0026amp;response_type=code\u0026amp;scope=read offline_access\u0026amp;resource=urn:invoices\u0026amp;resource=urn:products When you redeem the code, you need to specify for which resource you want to have an access token, e.g.:\nPOST /token grant_type=authorization_code\u0026amp; client_id=client\u0026amp; client_secret=...\u0026amp; authorization_code=...\u0026amp; redirect_uri=...\u0026amp; resource=urn:invoices Which will return an access token for the invoices API and a refresh token. If you want to also retrieve the access token for the products API, you use the refresh token and make another roundtrip to the token endpoint.\nPOST /token grant_type=refresh_token\u0026amp; client_id=client\u0026amp; client_secret=...\u0026amp; refresh_token=...\u0026amp; resource=urn:products The end-result will be that the client has two access tokens - one for each resource and can manage their lifetime via the refresh token.\nEnforcing resource isolation All examples so far used the resource parameter optionally. If you have API resources, where you want to make sure they are not sharing access tokens with other resources, you can enforce the resource indicator, e.g.:\nvar resources = new[] { new ApiResource(\u0026#34;urn:invoices\u0026#34;) { Scopes = { \u0026#34;read\u0026#34;, \u0026#34;write\u0026#34; }, RequireResourceIndicator = true }, new ApiResource(\u0026#34;urn:products\u0026#34;) { Scopes = { \u0026#34;read\u0026#34;, \u0026#34;write\u0026#34; } } }; "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/bff/extensibility/proxy/",
    "title": "Reverse Proxy",
    "tags": [],
    "description": "",
    "content": "You can customize the proxy behavior in two ways\nprovide a customized HTTP client for outgoing calls provide custom request/response transformation Custom HTTP clients By default, Duende.BFF will create and cache an HTTP client per configured route or local path.\nThis invoker is setup like this:\nvar client = new HttpMessageInvoker(new SocketsHttpHandler { UseProxy = false, AllowAutoRedirect = false, AutomaticDecompression = DecompressionMethods.None, UseCookies = false }); If you want to customize the HTTP client for specific paths, you can either implement the IHttpMessageInvokerFactory interface or derive from the DefaultHttpMessageInvokerFactory, e.g.:\npublic class MyInvokerFactory : DefaultHttpMessageInvokerFactory { public override HttpMessageInvoker CreateClient(string localPath) { if (localPath == \u0026#34;/foo\u0026#34;) { return Clients.GetOrAdd(localPath, (key) =\u0026gt; { return new HttpMessageInvoker(new SocketsHttpHandler { // this API needs a proxy UseProxy = true, Proxy = new WebProxy(\u0026#34;https://myproxy\u0026#34;), AllowAutoRedirect = false, AutomaticDecompression = DecompressionMethods.None, UseCookies = false }); }); } return base.CreateClient(localPath); } } ..and override our registration:\nservices.AddSingleton\u0026lt;IHttpMessageInvokerFactory, MyInvokerFactory\u0026gt;(); Custom transformations In the standard configuration, BFF uses the YARP default behavior for forwarding HTTP requests. In addition we\nremove the sensitive session cookie add the current access token If you want to modify this behavior you can either implement IHttpTransformerFactory from scratch:\npublic interface IHttpTransformerFactory { /// \u0026lt;summary\u0026gt; /// Creates a HTTP transformer based on the local path /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;localPath\u0026#34;\u0026gt;Local path the remote API is mapped to\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;accessToken\u0026#34;\u0026gt;The access token to attach to the request (if present)\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; HttpTransformer CreateTransformer(string localPath, string accessToken = null); } \u0026hellip;or derive from the DefaultHttpTransformerFactory.\nThe transformations are based on YARP\u0026rsquo;s transform library and are extensible. See here for a full list of built-in transforms.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/ui/",
    "title": "User Interaction",
    "tags": [],
    "description": "",
    "content": "User Interaction and Pages As browser requests are made to the protocol endpoints in your IdentityServer, they will be redirected to the interactive pages for the user to see. Depending on the features required, the pages expected in your IdentityServer are:\nLogin: allows the user to login. This could be achieved with a local credential, or could utilize an external login provider (e.g. social or enterprise federation system). Logout: allows the user to logout (including providing single sign-out). Error: display error information to the end user, typically when there are workflow errors. Consent: allows the user to grant resource access to clients (typically only used if the client is third-party). Additional custom pages that you might want are then also possible (e.g. password reset, registration), and those are typically available to the user as links from one of the above pages.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/fundamentals/users/",
    "title": "Users and Logging In",
    "tags": [],
    "description": "",
    "content": "Users and User Interface The design of Duende IdentityServer allows you to use any user database and build any user interface (UI) workflow needed to satisfy your requirements. This means you have the ability to customize any UI page (registration, login, password reset, etc.), support any credential type (password, MFA, etc.), use any user database (greenfield or legacy), and/or use federated logins from any provider (social or enterprise). You have the ability to control the entire user experience while Duende IdentityServer provides the implementation of the security protocol (OpenID Connect and OAuth).\nWhile you can use any custom user database or identity management library for your users, we provide integration support for ASP.NET Identity.\nAuthorization Endpoint and Login Page Workflow The standard mechanism to allow users to login is for the client application to use a web browser. This is obvious if the client application is a web application, but it\u0026rsquo;s also the recommended practice for native and mobile applications.\nWhen a user must login, the client application will redirect the user to the protocol endpoint called the authorization endpoint in your IdentityServer server to request authentication. As part of the authorize request, your IdentityServer will typically display a login page for the user to enter their credentials. Once the user has authenticated, your IdentityServer will redirect the user back to the application with the protocol response.\nRecall the diagram showing the relationship of your custom UI pages and the IdentityServer middleware in your IdentityServer host application:\nWhen your IdentityServer receives an authorize request, it will inspect it for a current authentication session for a user. This authentication session is based on ASP.NET Core\u0026rsquo;s authentication system and is ultimately determined by a cookie issued from your login page.\nIf the user has never logged in there will be no cookie, and then the request to the authorize endpoint will result in a redirect to your login page. This is the entry point into your custom workflow that can take over to get the user logged in.\nOnce the login page has finished logging in the user with the ASP.NET Core authentication system, it will redirect the user back to the authorize endpoint. This time the request to the authorize endpoint will have an authenticated session for the user, and it can then create the protocol response and redirect to the client application.\nAdditional Pages In addition to the login page, there are other pages that Duende IdentityServer expects (e.g. logout, error, consent), and you could implement custom pages as well (e.g. register, forgot password, etc.). Details about building these pages, and coverage of additional topics are in the User Interaction section of this documentation.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/apis/aspnetcore/confirmation/",
    "title": "Validating Proof-of-Possession",
    "tags": [],
    "description": "",
    "content": "If your IdentityServer added a cnf claim to the access token, you should validate that early in the pipeline. Ideally directly after the standard token validation is done, e.g. using a middleware:\npublic void Configure(IApplicationBuilder app) { // rest omitted // normal token validation happens here app.UseAuthentication(); // middleware to validate cnf claim app.UseConfirmationValidation(); app.UseAuthorization(); // rest omitted } Validating MTLS Proof-of-Possession If you are using a TLS client certificate for proof-of-possession, the following sample middleware can be used to validate the cnf claim:\n// this middleware validate the cnf claim (if present) against the thumbprint of the X.509 client certificate for the current client public class ConfirmationValidationMiddleware { private readonly RequestDelegate _next; private readonly ILogger _logger; private readonly ConfirmationValidationMiddlewareOptions _options; public ConfirmationValidationMiddleware( RequestDelegate next, ILogger\u0026lt;ConfirmationValidationMiddlewareOptions\u0026gt; logger, ConfirmationValidationMiddlewareOptions options = null) { _next = next; _logger = logger; _options ??= new ConfirmationValidationMiddlewareOptions(); } public async Task Invoke(HttpContext ctx) { if (ctx.User.Identity.IsAuthenticated) { // read the cnf claim from the validated token var cnfJson = ctx.User.FindFirst(\u0026#34;cnf\u0026#34;)?.Value; if (!String.IsNullOrWhiteSpace(cnfJson)) { // if present, make sure a valid certificate was presented as well var certResult = await ctx.AuthenticateAsync(_options.CertificateSchemeName); if (!certResult.Succeeded) { await ctx.ChallengeAsync(_options.CertificateSchemeName); return; } // get access to certificate from transport var certificate = await ctx.Connection.GetClientCertificateAsync(); var thumbprint = Base64UrlTextEncoder.Encode(certificate.GetCertHash(HashAlgorithmName.SHA256)); // retrieve value of the thumbprint from cnf claim var cnf = JObject.Parse(cnfJson); var sha256 = cnf.Value\u0026lt;string\u0026gt;(\u0026#34;x5t#S256\u0026#34;); // compare thumbprint claim with thumbprint of current TLS client certificate if (String.IsNullOrWhiteSpace(sha256) || !thumbprint.Equals(sha256, StringComparison.OrdinalIgnoreCase)) { _logger.LogError(\u0026#34;certificate thumbprint does not match cnf claim.\u0026#34;); await ctx.ChallengeAsync(_options.JwtBearerSchemeName); return; } _logger.LogDebug(\u0026#34;certificate thumbprint matches cnf claim.\u0026#34;); } } await _next(ctx); } } public class ConfirmationValidationMiddlewareOptions { public string CertificateSchemeName { get; set; } = CertificateAuthenticationDefaults.AuthenticationScheme; public string JwtBearerSchemeName { get; set; } = JwtBearerDefaults.AuthenticationScheme; } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/tokens/extension_grants/",
    "title": "Extension Grants",
    "tags": [],
    "description": "",
    "content": "Extension Grants OAuth defines an extensibility point called extension grants.\nExtension grants allow adding support for non-standard token issuance scenarios, e.g.\ntoken transformation SAML to JWT, or Windows to JWT delegation or impersonation federation encapsulating custom input parameters You can add support for additional grant types by implementing the IExtensionGrantValidator interface.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/bff/apis/",
    "title": "API Endpoints",
    "tags": [],
    "description": "",
    "content": "Securing and Accessing API Endpoints A typical frontend application will call two types of APIs:\nfrontend exclusive APIs (aka local APIs)\nThese APIs only exist to support the specific frontend; they are not shared with other frontends. They are typically located in the BFF host and can be called directly by the frontend.\nshared APIs (aka remote APIs)\nThese APIs are deployed on a different host than the BFF, typically because they need to be shared between multiple frontends or (more generally speaking) multiple clients. These APIs can only be called via the BFF host acting as a proxy.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/data/operational/keys/",
    "title": "Keys",
    "tags": [],
    "description": "",
    "content": "The automatic key management feature in Duende IdentityServer requires a store to persist keys that are dynamically created.\nSigning Key Store By default, the file system is used, but the storage of these keys is abstracted behind a extensible store interface. The ISigningKeyStore is that storage interface.\nRegistering a custom signing key store To register a custom signing key store in the DI container, there is a AddSigningKeyStore helper on the IIdentityServerBuilder. For example:\npublic void ConfigureServices(IServiceCollection services) { services.AddIdentityServer() .AddSigningKeyStore\u0026lt;YourCustomStore\u0026gt;(); } Key Lifecycle When keys are required, LoadKeysAsync will be called to load them all from the store. They are then cached automatically for some amount of time based on configuration. Periodically a new key will be created, and StoreKeyAsync will be used to persist the new key. Once a key is past its retirement, DeleteKeyAsync will be used to purge the key from the store.\nSerialized Key The SerializedKey is the model that contains the key data to persist.\nIt is expected that the Id is the unique identifier for the key in the store. The Data property is the main payload of the key and contains a copy of all the other values. Some of the properties affect how the Data is processed (e.g. DataProtected), and the other properties are considered read-only and thus can\u0026rsquo;t be changed to affect the behavior (e.g. changing the Created value will not affect the key lifetime, nor will changing Algorithm change which signing algorithm the key is used for).\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/ui/login/context/",
    "title": "Login Context",
    "tags": [],
    "description": "",
    "content": "The returnUrl query parameter passed to the login page refers to the URL the prior request came from. This URL typically refers to the IdentityServer authorization endpoint and contains the original request parameters sent from the client. These parameters might contain information your login page needs to customize its workflow. Some examples would be for branding, dynamic page customization (e.g. which external login providers to use), or controlling what credentials the client application expects (e.g. perhaps MFA is required).\nAuthorization Request Context In order to read the original authorize request parameter values, you can use the interaction service. It provides a GetAuthorizationContextAsync API that will extract that information from the returnUrl and return an AuthorizationRequest object which contains these values.\nIt is unnecessary (and discouraged) for your login page logic to parse the returnUrl itself.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/bff/session/server_side_sessions/",
    "title": "Server-side Sessions",
    "tags": [],
    "description": "",
    "content": "By default, ASP.NET Core\u0026rsquo;s cookie handler will store all user session data in a protected cookie. This works very well unless cookie size or revocation becomes an issue.\nDuende.BFF includes all the plumbing to store your sessions server-side. The cookie will then only be used to transmit the session ID between the browser and the BFF host. This has the following advantages\nthe cookie size will be very small and constant - regardless how much data (e.g. token or claims) is stored in the authentication session the session can be also revoked outside the context of a browser interaction, for example when receiving a back-channel logout notification from the upstream OpenID Connect provider Server-side session can be enabled in startup:\nservices.AddBff() .AddServerSideSessions(); The default implementation stores the session in-memory on the server. This is useful for testing, for production you typically want a more robust storage mechanism.\nWe provide an EntityFramework Core-based session store implementation (e.g. for SQL Server):\nvar cn = _configuration.GetConnectionString(\u0026#34;db\u0026#34;); services.AddBff() .AddEntityFrameworkServerSideSessions(options=\u0026gt; { options.UseSqlServer(cn); }); You can also use a custom store, see extensibility for more information.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/stores/persisted_grant_store/",
    "title": "Persisted Grant Store",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Stores.IPersistedGrantStore Models storage of persisted grants.\n/// \u0026lt;summary\u0026gt; /// Interface for persisting any type of grant. /// \u0026lt;/summary\u0026gt; public interface IPersistedGrantStore { /// \u0026lt;summary\u0026gt; /// Stores the grant. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;grant\u0026#34;\u0026gt;The grant.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task StoreAsync(PersistedGrant grant); /// \u0026lt;summary\u0026gt; /// Gets the grant. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;The key.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task\u0026lt;PersistedGrant\u0026gt; GetAsync(string key); /// \u0026lt;summary\u0026gt; /// Gets all grants based on the filter. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;filter\u0026#34;\u0026gt;The filter.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task\u0026lt;IEnumerable\u0026lt;PersistedGrant\u0026gt;\u0026gt; GetAllAsync(PersistedGrantFilter filter); /// \u0026lt;summary\u0026gt; /// Removes the grant by key. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;The key.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task RemoveAsync(string key); /// \u0026lt;summary\u0026gt; /// Removes all grants based on the filter. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;filter\u0026#34;\u0026gt;The filter.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task RemoveAllAsync(PersistedGrantFilter filter); } PersistedGrant Models persistence of authorization codes, reference and refresh tokens, and user consents.\n/// \u0026lt;summary\u0026gt; /// A model for a persisted grant /// \u0026lt;/summary\u0026gt; public class PersistedGrant { /// \u0026lt;summary\u0026gt; /// Gets or sets the key. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The key. /// \u0026lt;/value\u0026gt; public string Key { get; set; } /// \u0026lt;summary\u0026gt; /// Gets the type. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The type. /// \u0026lt;/value\u0026gt; public string Type { get; set; } /// \u0026lt;summary\u0026gt; /// Gets the subject identifier. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The subject identifier. /// \u0026lt;/value\u0026gt; public string SubjectId { get; set; } /// \u0026lt;summary\u0026gt; /// Gets the session identifier. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The session identifier. /// \u0026lt;/value\u0026gt; public string SessionId { get; set; } /// \u0026lt;summary\u0026gt; /// Gets the client identifier. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The client identifier. /// \u0026lt;/value\u0026gt; public string ClientId { get; set; } /// \u0026lt;summary\u0026gt; /// Gets the description the user assigned to the device being authorized. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The description. /// \u0026lt;/value\u0026gt; public string Description { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the creation time. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The creation time. /// \u0026lt;/value\u0026gt; public DateTime CreationTime { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the expiration. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The expiration. /// \u0026lt;/value\u0026gt; public DateTime? Expiration { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the consumed time. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The consumed time. /// \u0026lt;/value\u0026gt; public DateTime? ConsumedTime { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the data. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The data. /// \u0026lt;/value\u0026gt; public string Data { get; set; } } The Data property contains a copy of all of the values (and more) and is considered authoritative by IdentityServer, thus most of the other property values are considered informational and read-only.\nPersistedGrantFilter /// \u0026lt;summary\u0026gt; /// Represents a filter used when accessing the persisted grants store. /// Setting multiple properties is interpreted as a logical \u0026#39;AND\u0026#39; to further filter the query. /// At least one value must be supplied. /// \u0026lt;/summary\u0026gt; public class PersistedGrantFilter { /// \u0026lt;summary\u0026gt; /// Subject id of the user. /// \u0026lt;/summary\u0026gt; public string SubjectId { get; set; } /// \u0026lt;summary\u0026gt; /// Session id used for the grant. /// \u0026lt;/summary\u0026gt; public string SessionId { get; set; } /// \u0026lt;summary\u0026gt; /// Client id the grant was issued to. /// \u0026lt;/summary\u0026gt; public string ClientId { get; set; } /// \u0026lt;summary\u0026gt; /// The type of grant. /// \u0026lt;/summary\u0026gt; public string Type { get; set; } } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/stores/device_flow_store/",
    "title": "Device Flow Store",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Stores.IDeviceFlowStore Models storage of grants for the device flow.\n/// \u0026lt;summary\u0026gt; /// Interface for the device flow store /// \u0026lt;/summary\u0026gt; public interface IDeviceFlowStore { /// \u0026lt;summary\u0026gt; /// Stores the device authorization request. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;deviceCode\u0026#34;\u0026gt;The device code.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;userCode\u0026#34;\u0026gt;The user code.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;The data.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task StoreDeviceAuthorizationAsync(string deviceCode, string userCode, DeviceCode data); /// \u0026lt;summary\u0026gt; /// Finds device authorization by user code. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;userCode\u0026#34;\u0026gt;The user code.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task\u0026lt;DeviceCode\u0026gt; FindByUserCodeAsync(string userCode); /// \u0026lt;summary\u0026gt; /// Finds device authorization by device code. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;deviceCode\u0026#34;\u0026gt;The device code.\u0026lt;/param\u0026gt; Task\u0026lt;DeviceCode\u0026gt; FindByDeviceCodeAsync(string deviceCode); /// \u0026lt;summary\u0026gt; /// Updates device authorization, searching by user code. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;userCode\u0026#34;\u0026gt;The user code.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;The data.\u0026lt;/param\u0026gt; Task UpdateByUserCodeAsync(string userCode, DeviceCode data); /// \u0026lt;summary\u0026gt; /// Removes the device authorization, searching by device code. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;deviceCode\u0026#34;\u0026gt;The device code.\u0026lt;/param\u0026gt; Task RemoveByDeviceCodeAsync(string deviceCode); } DeviceCode /// \u0026lt;summary\u0026gt; /// Represents data needed for device flow. /// \u0026lt;/summary\u0026gt; public class DeviceCode { /// \u0026lt;summary\u0026gt; /// Gets or sets the creation time. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The creation time. /// \u0026lt;/value\u0026gt; public DateTime CreationTime { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the lifetime. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The lifetime. /// \u0026lt;/value\u0026gt; public int Lifetime { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the client identifier. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The client identifier. /// \u0026lt;/value\u0026gt; public string ClientId { get; set; } /// \u0026lt;summary\u0026gt; /// Gets the description the user assigned to the device being authorized. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The description. /// \u0026lt;/value\u0026gt; public string Description { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets a value indicating whether this instance is open identifier. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt; if this instance is open identifier; otherwise, \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;. /// \u0026lt;/value\u0026gt; public bool IsOpenId { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets a value indicating whether this instance is authorized. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt; if this instance is authorized; otherwise, \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;. /// \u0026lt;/value\u0026gt; public bool IsAuthorized { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the requested scopes. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The authorized scopes. /// \u0026lt;/value\u0026gt; public IEnumerable\u0026lt;string\u0026gt; RequestedScopes { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the authorized scopes. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The authorized scopes. /// \u0026lt;/value\u0026gt; public IEnumerable\u0026lt;string\u0026gt; AuthorizedScopes { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the subject. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The subject. /// \u0026lt;/value\u0026gt; public ClaimsPrincipal Subject { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the session identifier. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The session identifier. /// \u0026lt;/value\u0026gt; public string SessionId { get; set; } } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/services/persisted_grant_service/",
    "title": "Persisted Grant Service",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Services.IPersistedGrantService Provides access to a user\u0026rsquo;s grants.\n/// \u0026lt;summary\u0026gt; /// Implements persisted grant logic /// \u0026lt;/summary\u0026gt; public interface IPersistedGrantService { /// \u0026lt;summary\u0026gt; /// Gets all grants for a given subject ID. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;subjectId\u0026#34;\u0026gt;The subject identifier.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task\u0026lt;IEnumerable\u0026lt;Grant\u0026gt;\u0026gt; GetAllGrantsAsync(string subjectId); /// \u0026lt;summary\u0026gt; /// Removes all grants for a given subject id, and optionally client id and session id combination. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;subjectId\u0026#34;\u0026gt;The subject identifier.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;clientId\u0026#34;\u0026gt;The client identifier (optional).\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;sessionId\u0026#34;\u0026gt;The session id (optional).\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task RemoveAllGrantsAsync(string subjectId, string clientId = null, string sessionId = null); } Grant /// \u0026lt;summary\u0026gt; /// Models a grant the user has given. /// \u0026lt;/summary\u0026gt; public class Grant { /// \u0026lt;summary\u0026gt; /// Gets or sets the subject identifier. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The subject identifier. /// \u0026lt;/value\u0026gt; public string SubjectId { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the client identifier. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The client identifier. /// \u0026lt;/value\u0026gt; public string ClientId { get; set; } /// \u0026lt;summary\u0026gt; /// Gets the description the user assigned to the device being authorized. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The description. /// \u0026lt;/value\u0026gt; public string Description { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the scopes. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The scopes. /// \u0026lt;/value\u0026gt; public IEnumerable\u0026lt;string\u0026gt; Scopes { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the creation time. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The creation time. /// \u0026lt;/value\u0026gt; public DateTime CreationTime { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the expiration. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The expiration. /// \u0026lt;/value\u0026gt; public DateTime? Expiration { get; set; } } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/fundamentals/claims/",
    "title": "Claims",
    "tags": [],
    "description": "",
    "content": "IdentityServer emits claims about users and clients into tokens. You are in full control of which claims you want to emit, in which situations you want to emit those claims, and where to retrieve those claims from.\nUser claims User claims can be put in both identity and access tokens. The central extensibility point to implement for emitting claims is called the profile service.\nWhenever IdentityServer creates tokens for a user, it invokes the registered profile service with a context that presents detailed information about the current token request, including\nthe identity of the client who is requesting the token the identity of the user what type of token is requested the requested claim types according to the definition of the requested resources You can use different strategies to determine which claims you want to emit based on that information\nalways emit certain claims (because they are an integral part of the user identity and needed in scenarios) emit claims based on user or client identity emit claims based on the requested resources Generally speaking, we recommend using the resource definitions to associate user claims with resources. In that case your profile service receives an aggregated list of requested claim types based on the requested resources. The implementation is then as simple as returning the corresponding claim values back to the runtime.\nHere\u0026rsquo;s a sample implementation of a profile service:\npublic class SampleProfileService : IProfileService { // this method adds claims that should go into the token to context.IssuedClaims public virtual Task GetProfileDataAsync(ProfileDataRequestContext context) { var requestedClaimTypes = context.RequestedClaimTypes; var user = context.Subject; // your implementation to retrieve the requested information var claims = GetRequestedClaims(user, requestedClaimsTypes); context.IssuedClaims.AddRange(claims); return Task.CompletedTask; } // this method allows to check if the user is still \u0026#34;enabled\u0026#34; per token request public virtual Task IsActiveAsync(IsActiveContext context) { context.IsActive = true; return Task.CompletedTask; } } The Subject property on the ProfileDataRequestContext contains the principal that was issued during user sign-in. Typically, the profile service will source some claims from the Subject and others from databases or other data sources.\nThe profile service also gets called for requests to the userinfo endpoint. In that case, the Subject property will not contain the principal issued during user sign-in, since userinfo calls don\u0026rsquo;t happen as part of a session. Instead, the Subject property will contain a claims principal populated with the claims in the access token used to authorize the userinfo call. You can check the caller of the profile service by querying the Caller property on the context.\nClient claims Client claims are typically statically defined claims that get emitted into access tokens. The following shows an example of a client that is associated with a certain customer in your system:\nvar client = new Client { ClientId = \u0026#34;client\u0026#34;, // rest omitted Claims = { new ClientClaim(\u0026#34;customer_id\u0026#34;, \u0026#34;123\u0026#34;) } }; All client claims will be by default prefixed with client to avoid accidental collision with user claims, e.g. the above claim would show up as client_customer_id in access tokens. You can change (or remove) that prefix by setting the ClientClaimsPrefix on the client definition.\nBy default, client claims are only sent in the client credentials flow. If you want to enable them for other flows, you need to set the AlwaysSendClientClaims property on the client definition.\nSetting client claims dynamically If you want to set client claims dynamically, you could either do that at client load time (via a client store implementation), or using a custom token request validator.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/models/grant_validation_result/",
    "title": "Grant Validation Result",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Validation.GrantValidationResult The GrantValidationResult class models the outcome of grant validation for extensions grants and resource owner password grants.\nIt models either a successful validation result with claims (e.g. subject ID) or an invalid result with an error code and message, e.g.:\npublic class ExtensionGrantValidator : IExtensionGrantValidator { public Task ValidateAsync(ExtensionGrantValidationContext context) { // some validation steps if (success) { context.Result = new GrantValidationResult( subject: \u0026#34;818727\u0026#34;, authenticationMethod: \u0026#34;custom\u0026#34;, claims: extraClaims); } else { // custom error message context.Result = new GrantValidationResult( TokenRequestErrors.InvalidGrant, \u0026#34;invalid custom credential\u0026#34;); } return Task.CompletedTask; } } It also allows passing additional custom values that will be included in the token response, e.g.:\ncontext.Result = new GrantValidationResult( subject: \u0026#34;818727\u0026#34;, authenticationMethod: \u0026#34;custom\u0026#34;, customResponse: new Dictionary\u0026lt;string, object\u0026gt; { { \u0026#34;some_data\u0026#34;, \u0026#34;some_value\u0026#34; } }); This will result in the following token response:\n{ \u0026#34;access_token\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;Bearer\u0026#34;, \u0026#34;expires_in\u0026#34;: 360, \u0026#34;some_data\u0026#34;: \u0026#34;some_value\u0026#34; } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/validators/extension_grant_validator/",
    "title": "Extension Grant Validator",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Validation.IExtensionGrantValidator Use an implementation of this interface to handle extension grants.\npublic interface IExtensionGrantValidator { /// \u0026lt;summary\u0026gt; /// Handles the custom grant request. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;request\u0026#34;\u0026gt;The validation context.\u0026lt;/param\u0026gt; Task ValidateAsync(ExtensionGrantValidationContext context); /// \u0026lt;summary\u0026gt; /// Returns the grant type this validator can deal with /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The type of the grant. /// \u0026lt;/value\u0026gt; string GrantType { get; } } GrantType\nSpecifies the name of the extension grant that the implementation wants to register for.\nValidateAsync\nThis methods gets called at runtime, when a request comes in that is using the registered extension grant. The job of this method is to validate the request and to populate ExtensionGrantValidationContext.Result with a grant validation result\nThe instance of the extension grant validator gets registered with:\nbuilder.AddExtensionGrantValidator\u0026lt;MyValidator\u0026gt;(); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/validators/custom_token_request_validator/",
    "title": "Custom Token Request Validator",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Validation.ICustomTokenRequestValidator Allows running custom code as part of the token issuance pipeline at the token endpoint.\n/// \u0026lt;summary\u0026gt; /// Allows inserting custom validation logic into token requests /// \u0026lt;/summary\u0026gt; public interface ICustomTokenRequestValidator { /// \u0026lt;summary\u0026gt; /// Custom validation logic for a token request. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;context\u0026#34;\u0026gt;The context.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt; /// The validation result /// \u0026lt;/returns\u0026gt; Task ValidateAsync(CustomTokenRequestValidationContext context); } ValidateAsync\nThis method gets called during token request processing. The context gives you access to request and response parameters.\nYou can also change certain parameters on the validated request object, e.g. the token lifetime, toke type, confirmation method and client claims.\nThe CustomResponse dictionary allows emitting additional response fields.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/tokens/dynamic_validation/",
    "title": "Dynamic Request Validation and Customization",
    "tags": [],
    "description": "",
    "content": "You can hook into the token request pipeline by implementing the ICustomTokenRequestValidator interface.\nThis allows you to\nadd additional token request validation logic do custom per-client processing add custom response parameters return custom errors and error descriptions modify parameters on-the-fly access token lifetime and type client claims confirmation method The following example emits additional claims and changes the token lifetime on-the-fly based on a granted scope.\npublic class TransactionScopeTokenRequestValidator : ICustomTokenRequestValidator { public Task ValidateAsync(CustomTokenRequestValidationContext context) { var transaction = context .Result .ValidatedRequest .ValidatedResources .ParsedScopes.FirstOrDefault(x =\u0026gt; x.ParsedName == \u0026#34;transaction\u0026#34;); // transaction scope has been requested if (transaction?.ParsedParameter != null) { // emit transaction id as a claim context.Result.ValidatedRequest.ClientClaims.Add( new Claim(transaction.ParsedName, transaction.ParsedParameter)); // also shorten token lifetime context.Result.ValidatedRequest.AccessTokenLifetime = 10; } return Task.CompletedTask; } } You can register your implementation like this:\nbuilder.AddCustomTokenRequestValidator\u0026lt;TransactionScopeTokenRequestValidator\u0026gt;(); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/samples/extension_grants/",
    "title": "Extension Grants and Token Exchange",
    "tags": [],
    "description": "",
    "content": "link to source code\nThis sample shows an implementation of the Token Exchange specification RFC 8693 via the Duende IdentityServer extension grant mechanism.\nSee here for more information on extension grants.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/fundamentals/keys/",
    "title": "Key Management",
    "tags": [],
    "description": "",
    "content": "You need key material to sign issued tokens, e.g. identity tokens, JWT access tokens, logout tokens, etc.\nDuende IdentityServer supports signing tokens using the RS, PS and ES family of cryptographic signing algorithms. You can configure the keys either statically by loading them from a secured location manually, or using the automatic key management feature (recommended).\nAutomatic key management The automatic key management feature follows best practices for handling signing key material:\nautomatic key rotation secure storage of keys at rest announcement upcoming new keys in discovery maintenance of retired keys in discovery Automatic key management is on by default, and creates RSA keys for RS256 usage in the ~/keys folder on the filesystem. The keys are automatically rotated every 90 days, announced 14 days in advance, and retained for 14 days after it expires.\nYou can configure the key management parameters on the IdentityServerOptions, e.g.:\nvar builder = services.AddIdentityServer(options =\u0026gt; { // set path where to store keys options.KeyManagement.KeyPath = \u0026#34;/home/shared/keys\u0026#34;; // new key every 30 days options.KeyManagement.RotationInterval = TimeSpan.FromDays(30); // announce new key 2 days in advance in discovery options.KeyManagement.PropagationTime = TimeSpan.FromDays(2); // keep old key for 7 days in discovery for validation of tokens options.KeyManagement.RetentionDuration = TimeSpan.FromDays(7); }); Manage multiple keys If no specific signing algorithms are configured, key management will auto-maintain an RSA key for the RS256 signing algorithm. You can specify multiple keys, algorithms, and if those keys should additionally get wrapped in an X.509 certificate.\noptions.KeyManagement.SigningAlgorithms = new[] { // RS256 for older clients (with additional X.509 wrapping) new SigningAlgorithmOptions(SecurityAlgorithms.RsaSha256) { UseX509Certificate = true }, // PS256 new SigningAlgorithmOptions(SecurityAlgorithms.RsaSsaPssSha256), // ES256 new SigningAlgorithmOptions(SecurityAlgorithms.EcdsaSha256) }; When you register multiple keys, the first key in the list will be the default key. Client and API resource definitions both have an AllowedTokenSigningAlgorithm property to override the default on a per resource and client basis.\nKey storage and protection By default the keys will be protected at rest using the ASP.NET Core Data Protection mechanism. See the deployment section to learn more about setting up data protection.\nKey storage defaults to the file system, but is extensible. We also provide EntityFramework integration.\nStatic key configuration You can also statically configure your key material. A common scenario is to load keys from a key vault or other secured location at startup. With static configuration you are responsible for secure storage, loading and rotation of keys.\nFor this purpose you disable the automatic key management, and load the keys manually with the AddSigningCredential DI extension method:\nvar builder = services.AddIdentityServer(options =\u0026gt; { options.KeyManagement.Enabled = false; }); var key = LoadKeyFromVault(); builder.AddSigningCredential(key, SecurityAlgorithms.RsaSha256); You can call AddSigningCredential multiple times if you want to register more than one signing key. Another extension method called AddValidationKey can be called to register public keys that should be accepted for token validation.\nA signing key registered with AddSigningCredential will take precedence over any keys created by the automatic key management feature.\nDisabling automatic key management The automatic key management feature can be disabled by setting the Enabled flag to false on the the IdentityServerOptions, e.g.:\nvar builder = services.AddIdentityServer(options =\u0026gt; { options.KeyManagement.Enabled = false; }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/samples/pat/",
    "title": "Personal Access Tokens (PAT)",
    "tags": [],
    "description": "",
    "content": "link to source code\nThis sample shows how to provide a self-service UI to create access tokens. This is a common approach to enable integrations with APIs without having to create full-blown OAuth clients.\nWhen combining PATs with the reference token feature, you also get automatic validation and revocation support. This is very similar to API keys, but does not require custom infrastructure. The sample also contains an API that accepts both JWT and reference tokens.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/services/",
    "title": "Services",
    "tags": [],
    "description": "",
    "content": "Services Profile Service Persisted Grant Service Refresh Token Service IdentityServer Interaction Service Device Flow Interaction Service "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/overview/support/",
    "title": "Support and Issues",
    "tags": [],
    "description": "",
    "content": "Source Code You can find all source code for IdentityServer and its supporting repos in our organization.\nIssue Tracker The IdentityServer issue tracker and pull requests allow you to follow the current work and submit bug reports.\nPlanned features and their milestones can be tracked using this label.\nDeveloper Support Standard developer support and feature requests are handled via our public developer community.\nPriority developer support is part of our Enterprise Edition. It provides access to a helpdesk system with a response time guarantee. Please contact us for more information.\nSee here for our support policy.\nReporting a security vulnerability Security issues and bugs should be reported privately here. You should receive a response within 24 hours.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/bff/tokens/",
    "title": "Token Management",
    "tags": [],
    "description": "",
    "content": "Duende.BFF includes an automatic token management feature. This uses the access and refresh token stored in the authentication session to always provide a current access token for outgoing API calls.\nFor most scenarios, there is no additional configuration necessary. The token management will infer the configuration and token endpoint URL from the metadata of the OpenID Connect provider.\nThe easiest way to retrieve the current access token is to use an extension method on HttpContext:\nvar token = await HttpContext.GetUserAccessTokenAsync(); You can then use the token to set it on an HttpClient instance:\nvar client = new HttpClient(); client.SetBearerToken(token); We recommend to leverage the HttpClientFactory to fabricate HTTP clients that are already aware of the token management plumbing. For this you would register a named client in your startup e.g. like this:\n// registers HTTP client that uses the managed user access token services.AddUserAccessTokenHttpClient(\u0026#34;apiClient\u0026#34;, configureClient: client =\u0026gt; { client.BaseAddress = new Uri(\u0026#34;https://remoteServer/\u0026#34;); }); And then retrieve a client instance like this:\n[Route(\u0026#34;myApi\u0026#34;)] public class MyApiController : ControllerBase { private readonly IHttpClientFactory _httpClientFactory; public MyController(IHttpClientFactory httpClientFactory) { _httpClientFactory = httpClientFactory; } public async Task\u0026lt;IActionResult\u0026gt; Get(string id) { // create HTTP client with automatic token management var client = _httpClientFactory.CreateClient(\u0026#34;apiClient\u0026#34;); // call remote API var response = await client.GetAsync(\u0026#34;remoteApi\u0026#34;); // rest omitted } } If you prefer to use typed clients, you can do that as well:\n// registers a typed HTTP client with token management support services.AddHttpClient\u0026lt;MyTypedApiClient\u0026gt;(client =\u0026gt; { client.BaseAddress = new Uri(\u0026#34;https://remoteServer/\u0026#34;); }) .AddUserAccessTokenHandler(); And then use that client, for example like this on a controller\u0026rsquo;s action method:\npublic async Task\u0026lt;IActionResult\u0026gt; CallApiAsUserTyped( [FromServices] MyTypedClient client) { var response = await client.GetData(); // rest omitted } The client will internally always try to use a current and valid access token. If for any reason this is not possible, the 401 status code will be returned to the caller.\nManually revoking refresh tokens Duende.BFF revokes refresh tokens automatically at logout time (this behavior can be controlled via the options).\nIf you want to manually revoke the current refresh token, you can use the following code:\nawait HttpContext.RevokeUserRefreshTokenAsync(); This will invalidate the refresh token at the token service.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/tokens/",
    "title": "Requesting Tokens",
    "tags": [],
    "description": "",
    "content": "Requesting Tokens At its very heart, Duende IdentityServer is a so-called Security Token Service (STS).\nOverview Requesting a Token Refreshing a Token Issuing Tokens based on User Passwords Extension Grants Dynamic Request Validation and Customization Issuing internal Tokens Proof-of-Possession Access Tokens Reference Tokens Client Authentication Signed Authorize Requests Calling Endpoints from JavaScript "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/ui/login/local/",
    "title": "Accepting Local Credentials",
    "tags": [],
    "description": "",
    "content": "The steps for implementing a local login page are:\nValidate the user\u0026rsquo;s credentials Issue the authentication cookie Redirect the user to the return URL The below code shows a sample Razor Page that could act as a login page. This sample hard codes the logic for the credentials, so this is where your implementation would use your custom user database or identity management library.\nThis is the cshtml for the login Razor Page:\n@page @model Sample.Pages.Account.LoginModel @addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers \u0026lt;div asp-validation-summary=\u0026#34;All\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;form method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; asp-for=\u0026#34;ReturnUrl\u0026#34; /\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label asp-for=\u0026#34;Username\u0026#34;\u0026gt;Username\u0026lt;/label\u0026gt; \u0026lt;input asp-for=\u0026#34;Username\u0026#34; autofocus\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label asp-for=\u0026#34;Password\u0026#34;\u0026gt;Password\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; asp-for=\u0026#34;Password\u0026#34; autocomplete=\u0026#34;off\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Login\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; And this is the code behind for the login Razor Page:\nnamespace Sample.Pages.Account { public class LoginModel : PageModel { [BindProperty(SupportsGet = true)] public string ReturnUrl { get; set; } [BindProperty] public string Username { get; set; } [BindProperty] public string Password { get; set; } public async Task\u0026lt;IActionResult\u0026gt; OnPost() { if (Username == \u0026#34;alice\u0026#34; \u0026amp;\u0026amp; Password == \u0026#34;password\u0026#34;) { var claims = new Claim[] { new Claim(\u0026#34;sub\u0026#34;, \u0026#34;unique_id_for_alice\u0026#34;) }; var identity = new ClaimsIdentity(claims, \u0026#34;pwd\u0026#34;); var user = new ClaimsPrincipal(identity); await HttpContext.SignInAsync(user); if (Url.IsLocalUrl(ReturnUrl)) { return Redirect(ReturnUrl); } } ModelState.AddModelError(\u0026#34;\u0026#34;, \u0026#34;Invalid username or password\u0026#34;); return Page(); } } } The above Razor page is expected to be located in the project at the path: ~/Pages/Account/Login.cshtml, which allows it to be loaded from the browser at the \u0026ldquo;/Account/Login\u0026rdquo; path.\nWhile you can use any custom user database or identity management library for your users, we provide first class integration support for ASP.NET Identity.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/ui/logout/notification/",
    "title": "Client Notifications",
    "tags": [],
    "description": "",
    "content": "Notifying clients that the user has signed-out As part of the logout process you will want to ensure client applications are informed that the user has signed out.\nThis is done by sending a notification to and endpoint provided by the each client application. Depending on your architecture, there are three supported techniques to call these endpoints:\nfront-channel notifications via the browser back-channel notifications via server-side call a PostMessage-based notification for JavaScript clients Regardless which technique you are using, Duende IdentityServer keeps track of the client applications involved with the current user session and provides helpers and automated ways of invoking the notification mechanisms.\nBoth the front-channel and JS-based notifications make use of cookies in iframes. If your architecture spans multiple sites, this will not work reliable. We recommend using back-channel notifications in this case. See the supported specifications page for links to the relevant documents.\nFront-channel server-side clients To signout the user from the server-side client applications via the front-channel spec, the \u0026ldquo;logged out\u0026rdquo; page in IdentityServer must render an \u0026lt;iframe\u0026gt; for each client that points to the corresponding notification endpoint at the client.\nClients that wish to be notified must have the FrontChannelLogoutUri configuration value set. IdentityServer tracks which clients the user has signed into, and provides an API called GetLogoutContextAsync on the IIdentityServerInteractionService. This API returns a LogoutRequest object with a SignOutIFrameUrl property that your logged out page must render into an \u0026lt;iframe\u0026gt;.\nSee the Quickstart UI account controller and signout view for an example.\nBack-channel server-side clients To signout the user from the server-side client applications via the back-channel the IBackChannelLogoutService service can be used. IdentityServer will automatically use this service when your logout page removes the user\u0026rsquo;s authentication cookie via a call to HttpContext.SignOutAsync.\nClients that wish to be notified must have the BackChannelLogoutUri configuration value set.\nBrowser-based JavaScript clients There is nothing special you need to do to notify these clients that the user has signed out.\nThe clients, though, must perform monitoring on the check_session_iframe, and this is implemented by spec compliant client libraries, e.g. the oidc-client JavaScript library.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/ui/custom/",
    "title": "Custom Pages",
    "tags": [],
    "description": "",
    "content": "In addition to the pages your IdentityServer is expected to provide, you can add any other pages you wish. These could be pages needed during login (e.g. registration, password reset), self-service pages to allow the user to manage their profile (e.g. change password, change email), or even more specialized pages for various user workflows (e.g. password expired, or EULA).\nThese custom pages can be made available to the end user as links from the standard pages in your IdentityServer (i.e. login, consent), they can be rendered to the user during login page workflows, or they could be displayed as a result of requests into the authorize endpoint.\nAuthorize Endpoint Requests and Custom Pages As requests are made into the authorize endpoint, if a user already has an established authentication session then they will not be presented with a login page at your IdentityServer (as that is the normal expectation for single sign-on).\nDuende IdentityServer provides the authorize interaction response generator extensibility point to allow overriding or controlling the response from the authorize endpoint.\nBuilt-in AuthorizeInteractionResponseGenerator To provide custom logic for the authorize endpoint, the recommondation is to derive from the built-in AuthorizeInteractionResponseGenerator to inherit all the default logic pertaining to login and consent semantics. To augment the built-in logic, override ProcessLoginAsync and/or ProcessConsentAsync (depending on the nature of the custom logic). The pattern would be to invoke the base implementation and if the result did not cause a login, consent or error, then the custom logic could be tested to determine if it is desired to prevent SSO and instead force the user to interact in some way (e.g. re-login, trigger MFA, accept a EULA, etc). The sample below illustrates:\npublic class CustomAuthorizeInteractionResponseGenerator : AuthorizeInteractionResponseGenerator { public CustomAuthorizeInteractionResponseGenerator(IdentityServerOptions options, ISystemClock clock, ILogger\u0026lt;AuthorizeInteractionResponseGenerator\u0026gt; logger, IConsentService consent, IProfileService profile) : base(options, clock, logger, consent, profile) { } protected internal override async Task\u0026lt;InteractionResponse\u0026gt; ProcessLoginAsync(ValidatedAuthorizeRequest request) { var result = await base.ProcessLoginAsync(request); if (!result.IsLogin \u0026amp;\u0026amp; !result.IsError) { // check EULA database var mustShowEulaPage = HasUserAcceptedEula(request.Subject); if (!mustShowEulaPage) { result = new InteractionResponse { RedirectUrl = \u0026#34;/eula/accept\u0026#34; }; } } return result; } } Custom Redirects When using custom redirect pages by setting the RedirectUrl on the InteractionResponse, IdentityServer will provide a returnUrl query parameter with the request (much like on the login page). Once the custom logic is complete on the page, then the URL in the returnUrl query parameter should be used to return the user back into the IdentityServer authorize request workflow.\nBeware open-redirect attacks via the returnUrl parameter. You should validate that the returnUrl refers to a well-known location. Either use the Url.IsLocalUrl helper from ASP.NET Core, or use the interaction service from Duende IdentityServer for APIs to validate the returnUrl parameter.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/data/ef/",
    "title": "Entity Framework Integration",
    "tags": [],
    "description": "",
    "content": "An EntityFramework-based implementation is provided for the configuration and operational data extensibility points in IdentityServer. The use of EntityFramework allows any EF-supported database to be used with this library.\nThe features provided by this library are broken down into two main areas: configuration store and operational store support. These two different areas can be used independently or together, based upon the needs of the hosting application.\nTo use this library, ensure that you have the NuGet package for the ASP.NET Identity integration. It is called Duende.IdentityServer.EntityFramework. You can install it with:\ndotnet add package Duende.IdentityServer.EntityFramework Configuration Store Support For storing configuration data, then the configuration store can be used. This support provides implementations of the IClientStore, IResourceStore, IIdentityProviderStore, and the ICorsPolicyService extensibility points. These implementations use a DbContext-derived class called ConfigurationDbContext to model the tables in the database.\nTo use the configuration store support, use the AddConfigurationStore extension method after the call to AddIdentityServer:\npublic IServiceProvider ConfigureServices(IServiceCollection services) { const string connectionString = @\u0026#34;Data Source=(LocalDb)\\MSSQLLocalDB;database=YourIdentityServerDatabase;trusted_connection=yes;\u0026#34;; var migrationsAssembly = typeof(Startup).GetTypeInfo().Assembly.GetName().Name; services.AddIdentityServer() // this adds the config data from DB (clients, resources, CORS) .AddConfigurationStore(options =\u0026gt; { options.ConfigureDbContext = builder =\u0026gt; builder.UseSqlServer(connectionString, sql =\u0026gt; sql.MigrationsAssembly(migrationsAssembly)); }); } To configure the configuration store, use the ConfigurationStoreOptions options object passed to the configuration callback.\nConfigurationStoreOptions This options class contains properties to control the configuration store and ConfigurationDbContext.\nConfigureDbContext Delegate of type Action used as a callback to configure the underlying ConfigurationDbContext. The delegate can configure the ConfigurationDbContext in the same way if EF were being used directly with AddDbContext, which allows any EF-supported database to be used.\nDefaultSchema Allows setting the default database schema name for all the tables in the ConfigurationDbContext\noptions.DefaultSchema = \u0026#34;myConfigurationSchema\u0026#34;; If you need to change the schema for the Migration History Table, you can chain another action to the UseSqlServer:\noptions.ConfigureDbContext = b =\u0026gt; b.UseSqlServer(connectionString, sql =\u0026gt; sql.MigrationsAssembly(migrationsAssembly).MigrationsHistoryTable(\u0026#34;MyConfigurationMigrationTable\u0026#34;, \u0026#34;myConfigurationSchema\u0026#34;)); Operational Store For storing operational data then the operational store can be used. This support provides implementations of the IPersistedGrantStore, IDeviceFlowStore, and ISigningKeyStore extensibility points. The implementation uses a DbContext-derived class called PersistedGrantDbContext to model the table in the database.\nTo use the operational store support, use the AddOperationalStore extension method after the call to AddIdentityServer:\npublic IServiceProvider ConfigureServices(IServiceCollection services) { const string connectionString = @\u0026#34;Data Source=(LocalDb)\\MSSQLLocalDB;database=YourIdentityServerDatabase;trusted_connection=yes;\u0026#34;; var migrationsAssembly = typeof(Startup).GetTypeInfo().Assembly.GetName().Name; services.AddIdentityServer() // this adds the operational data from DB (codes, tokens, consents) .AddOperationalStore(options =\u0026gt; { options.ConfigureDbContext = builder =\u0026gt; builder.UseSqlServer(connectionString, sql =\u0026gt; sql.MigrationsAssembly(migrationsAssembly)); // this enables automatic token cleanup. this is optional. options.EnableTokenCleanup = true; options.TokenCleanupInterval = 3600; // interval in seconds (default is 3600) }); } To configure the operational store, use the OperationalStoreOptions options object passed to the configuration callback.\nOperationalStoreOptions This options class contains properties to control the operational store and PersistedGrantDbContext.\nConfigureDbContext Delegate of type Action used as a callback to configure the underlying PersistedGrantDbContext. The delegate can configure the PersistedGrantDbContext in the same way if EF were being used directly with AddDbContext, which allows any EF-supported database to be used.\nDefaultSchema Allows setting the default database schema name for all the tables in the PersistedGrantDbContext.\nEnableTokenCleanup Indicates whether expired grants will be automatically cleaned up from the database. The default is false.\nRemoveConsumedTokens [added in 5.1] Indicates whether consumed grants will be automatically cleaned up from the database. The default is false.\nTokenCleanupInterval The token cleanup interval (in seconds). The default is 3600 (1 hour).\nThe token cleanup feature does not remove persisted grants that are consumed (see persisted grants). It only removes persisted grants that are beyond their Expiration.\nDatabase creation and schema changes across different versions of IdentityServer It is very likely that across different versions of IdentityServer (and the EF support) that the database schema will change to accommodate new and changing features.\nWe do not provide any support for creating your database or migrating your data from one version to another. You are expected to manage the database creation, schema changes, and data migration in any way your organization sees fit.\nUsing EF migrations is one possible approach to this. If you do wish to use migrations, then see the EF quickstart for samples on how to get started, or consult the Microsoft documentation on EF migrations.\nWe also publish sample SQL scripts for the current version of the database schema.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/services/refresh_token_service/",
    "title": "Refresh Token Service",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Services.IRefreshTokenService All refresh token handling is implemented in the DefaultRefreshTokenService (which is the default implementation of the IRefreshTokenService interface):\npublic interface IRefreshTokenService { /// \u0026lt;summary\u0026gt; /// Validates a refresh token. /// \u0026lt;/summary\u0026gt; Task\u0026lt;TokenValidationResult\u0026gt; ValidateRefreshTokenAsync(string token, Client client); /// \u0026lt;summary\u0026gt; /// Creates the refresh token. /// \u0026lt;/summary\u0026gt; Task\u0026lt;string\u0026gt; CreateRefreshTokenAsync(ClaimsPrincipal subject, Token accessToken, Client client); /// \u0026lt;summary\u0026gt; /// Updates the refresh token. /// \u0026lt;/summary\u0026gt; Task\u0026lt;string\u0026gt; UpdateRefreshTokenAsync(string handle, RefreshToken refreshToken, Client client); } The logic around refresh token handling is pretty involved, and we don\u0026rsquo;t recommend implementing the interface from scratch, unless you exactly know what you are doing. If you want to customize certain behavior, it is more recommended to derive from the default implementation and call the base checks first.\nThe most common customization that you probably want to do is how to deal with refresh token replays. This is for situations where the token usage has been set to one-time only, but the same token gets sent more than once. This could either point to a replay attack of the refresh token, or to faulty client code like logic bugs or race conditions.\nIt is important to note, that a refresh token is never deleted in the database. Once it has been used, the ConsumedTime property will be set. If a token is received that has already been consumed, the default service will call a virtual method called AcceptConsumedTokenAsync.\nThe default implementation will reject the request, but here you can implement custom logic like grace periods, or revoking additional refresh or access tokens.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/response_handling/",
    "title": "Response Generators",
    "tags": [],
    "description": "",
    "content": "Response Generators Authorize Interaction Response Generator "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/overview/demo_server/",
    "title": "Demo Server",
    "tags": [],
    "description": "",
    "content": "You can try Duende IdentityServer with your favourite client library. We have a test instance at demo.duendesoftware.\nOn the main page you can find instructions on how to configure your client and how to call an API.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/services/interaction_service/",
    "title": "IdentityServer Interaction Service",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Services.IIdentityServerInteractionService The IIdentityServerInteractionService interface is intended to provide services to be used by the user interface to communicate with IdentityServer, mainly pertaining to user interaction. It is available from the dependency injection system and would normally be injected as a constructor parameter into your MVC controllers for the user interface of IdentityServer.\nIIdentityServerInteractionService APIs GetAuthorizationContextAsync\nReturns the AuthorizationRequest based on the returnUrl passed to the login or consent pages.\nIsValidReturnUrl\nIndicates if the returnUrl is a valid URL for redirect after login or consent.\nGetErrorContextAsync\nReturns the ErrorMessage based on the errorId passed to the error page.\nGetLogoutContextAsync\nReturns the LogoutRequest based on the logoutId passed to the logout page.\nCreateLogoutContextAsync\nUsed to create a logoutId if there is not one presently. This creates a cookie capturing all the current state needed for signout and the logoutId identifies that cookie. This is typically used when there is no current logoutId and the logout page must capture the current user\u0026rsquo;s state needed for sign-out prior to redirecting to an external identity provider for signout. The newly created logoutId would need to be roundtripped to the external identity provider at signout time, and then used on the signout callback page in the same way it would be on the normal logout page.\nGrantConsentAsync\nAccepts a ConsentResponse to inform IdentityServer of the user\u0026rsquo;s consent to a particular AuthorizationRequest.\nDenyAuthorizationAsync\nAccepts a AuthorizationError to inform IdentityServer of the error to return to the client for a particular AuthorizationRequest.\nGetAllUserGrantsAsync\nReturns a collection of Grant for the user. These represent a user\u0026rsquo;s consent or a clients access to a user\u0026rsquo;s resource.\nRevokeUserConsentAsync\nRevokes all of a user\u0026rsquo;s consents and grants for a client.\nRevokeTokensForCurrentSessionAsync\nRevokes all of a user\u0026rsquo;s consents and grants for clients the user has signed into during their current session.\nReturned models The above methods return various models.\nAuthorizationRequest Client\nThe client that initiated the request.\nRedirectUri\nThe URI to redirect the user to after successful authorization.\nDisplayMode\nThe display mode passed from the authorization request.\nUiLocales\nThe UI locales passed from the authorization request.\nIdP The external identity provider requested. This is used to bypass home realm discovery (HRD). This is provided via the \u0026ldquo;idp:\u0026rdquo; prefix to the acr_values parameter on the authorize request.\nTenant\nThe tenant requested. This is provided via the \u0026ldquo;tenant:\u0026rdquo; prefix to the acr_values parameter on the authorize request.\nLoginHint\nThe expected username the user will use to login. This is requested from the client via the login_hint parameter on the authorize request.\nPromptMode\nThe prompt mode requested from the authorization request.\nAcrValues\nThe acr values passed from the authorization request.\nValidatedResources\nThe ResourceValidationResult which represents the validated resources from the authorization request.\nParameters\nThe entire parameter collection passed to the authorization request.\nRequestObjectValues\nThe validated contents of the request object (if present).\nResourceValidationResult Resources\nThe resources of the result.\nParsedScopes\nThe parsed scopes represented by the result.\nRawScopeValues\nThe original (raw) scope values represented by the validated result.\nErrorMessage Error\nThe error code.\nErrorDescription\nThe error description.\nDisplayMode\nThe display mode passed from the authorization request.\nUiLocales\nThe UI locales passed from the authorization request.\nRequestId\nThe per-request identifier. This can be used to display to the end user and can be used in diagnostics.\nClientId\nThe client id making the request (if available).\nRedirectUri\nThe redirect URI back to the client (id available).\nLogoutRequest ClientId\nThe client identifier that initiated the request.\nPostLogoutRedirectUri\nThe URL to redirect the user to after they have logged out.\nSessionId\nThe user\u0026rsquo;s current session id.\nSignOutIFrameUrl\nThe URL to render in an on the logged out page to enable single sign-out.\nParameters\nThe entire parameter collection passed to the end session endpoint.\nShowSignoutPrompt\nIndicates if the user should be prompted for signout based upon the parameters passed to the end session endpoint.\nConsentResponse ScopesValuesConsented\nThe collection of scopes the user consented to.\nRememberConsent\nFlag indicating if the user\u0026rsquo;s consent is to be persisted.\nDescription\nOptional description the user can set for the grant (e.g. the name of the device being used when consent is given). This can be presented back to the user from the persisted grant service.\nError\nError, if any, for the consent response. This will be returned to the client in the authorization response.\nErrorDescription\nError description. This will be returned to the client in the authorization response.\nGrant SubjectId\nThe subject id that allowed the grant.\nClientId\nThe client identifier for the grant.\nDescription\nThe description the user assigned to the client or device being authorized.\nScopes\nThe collection of scopes granted.\nCreationTime\nThe date and time when the grant was granted.\nExpiration\nThe date and time when the grant will expire.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/tokens/internal/",
    "title": "Issuing internal Tokens",
    "tags": [],
    "description": "",
    "content": "Sometimes, extensibility code running on your IdentityServer needs access tokens to call other APIs. In this case it is not necessary to use the protocol endpoints. The tokens can be issued internally.\nThe IdentityServerTools class is a collection of useful internal tools that you might need when writing extensibility code for IdentityServer. To use it, inject it into your code, e.g. a controller::\npublic MyController(IdentityServerTools tools) { _tools = tools; } The IssueJwtAsync method allows creating JWT tokens using the IdentityServer token creation engine. The IssueClientJwtAsync is an easier version of that for creating tokens for server-to-server communication (e.g. when you have to call an IdentityServer protected API from your code):\npublic async Task\u0026lt;IActionResult\u0026gt; MyAction() { var token = await _tools.IssueClientJwtAsync( clientId: \u0026#34;client_id\u0026#34;, lifetime: 3600, audiences: new[] { \u0026#34;backend.api\u0026#34; }); // more code } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/apis/",
    "title": "Protecting APIs",
    "tags": [],
    "description": "",
    "content": "Protecting APIs Duende IdentityServer issues tokens for accessing resources.\nThese resources are very often HTTP-based APIs, but could be also other \u0026ldquo;invokable\u0026rdquo; functionality like messaging endpoints, gRPC services or even good old XML Web Services. See the issuing tokens section on more information on access tokens and how to request them.\nProtecting APIs using ASP.NET Core Adding API Endpoints to your IdentityServer "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/ui/login/external/",
    "title": "Integrating with External Providers",
    "tags": [],
    "description": "",
    "content": "External Identity Providers One option for allowing your users to login is by using an external identity provider. These external providers can be a social login for your users (e.g. Google), a corporate login system (e.g. Azure AD for employees), or some other login system your users use.\nThe workflow using an external provider is much like the workflow from one of your client applications using your IdentityServer. Your login page must redirect the user to the identity provider for login, and the identity provider will redirect the user to a callback endpoint in your IdentityServer to process the results. This means the external provider should implement a standard protocol (e.g. Open ID Connect, SAML2-P, or WS-Federation) to allow such an integration.\nIt is possible to use a custom protocol to allow logins from an external provider, but you are taking on risk using something that is not as widely validated and scrutinized as one of the standard authentication protocols (e.g. Open ID Connect, SAML2-P, or WS-Federation).\nTo ease integration with external providers, it is recommended to use an authentication handler for ASP.NET Core that implements the corresponding protocol used by the provider. Many are available as part of ASP.NET Core, but you might need to find others (both commercial and free) for things like SAML2-P and other social login systems not provided by ASP.NET Core.\nRegistering Authentication Handlers for External Providers Supporting an external provider is achieved by simply registering the handler in your IdentityServer\u0026rsquo;s startup. For example, to use employee logins from Azure AD (AAD):\npublic void ConfigureServices(IServiceCollection services) { services.AddIdentityServer(); services.AddAuthentication() .AddOpenIdConnect(\u0026#34;AAD\u0026#34;, \u0026#34;Employee Login\u0026#34;, options =\u0026gt; { // options omitted }); } The above snippet registers a scheme called AAD in the ASP.NET Core authentication system, and uses a human-friendly display name of \u0026ldquo;Employee Login\u0026rdquo;. The options necessary will be different based on the protocol and identity provider used, and are beyond the scope of this documentation.\nTriggering the Authentication Handler To allow the user to be redirected to the external provider, there must be some code in your login page that triggers the handler. This can be done because you have provided the user with a button to click, or it could be due to inspecting some property of the authorization context, or it could be based on any other aspect of the request (e.g. such as the user entering their email).\nThe process of determining which identity provider to use is called Home Realm Discovery, or HRD for short.\nTo invoke an external authentication handler use the ChallengeAsync extension method on the HttpContext (or using the MVC ChallengeResult). When triggering challenge, it\u0026rsquo;s common to pass some properties to indicate the callback URL where you intend to process the external login results and any other state you need to maintain across the workflow (e.g. such as the return URL passed to the login page):\nvar callbackUrl = Url.Action(\u0026#34;MyCallback\u0026#34;); var props = new AuthenticationProperties { RedirectUri = callbackUrl, Items = { { \u0026#34;scheme\u0026#34;, \u0026#34;AAD\u0026#34; }, { \u0026#34;returnUrl\u0026#34;, returnUrl } } }; return Challenge(\u0026#34;AAD\u0026#34;, props); The Role of Cookies in External Logins ASP.NET Core needs a way to manage the state produced from the result of the external login. This state is managed (by default) with another cookie using ASP.NET Core\u0026rsquo;s cookie authentication handler.\nThis extra cookie is necessary since there are typically several redirects involved until you are done with the external authentication process.\nIf you are using ASP.NET Identity, many of these technical details are hidden from you. It is recommended that you also read the Microsoft docs and do the ASP.NET Identity quickstart.\nOne option on an external authentication handlers is called SignInScheme. This specifies the cookie handler to manage the state:\nservices.AddAuthentication() .AddOpenIdConnect(\u0026#34;AAD\u0026#34;, \u0026#34;Employee Login\u0026#34;, options =\u0026gt; { options.SignInScheme = \u0026#34;scheme of cookie handler to use\u0026#34;; // other options omitted }); Given that this is such a common practice, IdentityServer registers a cookie handler specifically for this external provider workflow. The scheme is represented via the IdentityServerConstants.ExternalCookieAuthenticationScheme constant. If you were to use our external cookie handler, then for the SignInScheme above you\u0026rsquo;d assign the value to be the IdentityServerConstants.ExternalCookieAuthenticationScheme constant:\nservices.AddAuthentication() .AddOpenIdConnect(\u0026#34;AAD\u0026#34;, \u0026#34;Employee Login\u0026#34;, options =\u0026gt; { options.SignInScheme = IdentityServerConstants.ExternalCookieAuthenticationScheme; // other options omitted }); Alternatively, you can also register your own custom cookie handler instead. For example:\nservices.AddAuthentication() .AddCookie(\u0026#34;MyTempHandler\u0026#34;) .AddOpenIdConnect(\u0026#34;AAD\u0026#34;, \u0026#34;Employee Login\u0026#34;, options =\u0026gt; { options.SignInScheme = \u0026#34;MyTempHandler\u0026#34;; // other options omitted }); For specialized scenarios, you can also short-circuit the external cookie mechanism and forward the external user directly to the main cookie handler. This typically involves handling events on the external handler to make sure you do the correct claims transformation from the external identity source.\nHandling the Callback On the callback page your typical tasks are:\nInspect the identity returned by the external provider. Make a decision how you want to deal with that user. This might be different based on the fact if this is a new user or a returning user. New users might need additional steps and UI before they are allowed in. Typically this involves creating a new internal user account that is linked to the user from the external provider. Store the external claims that you want to keep. Delete the temporary cookie. Establish the user\u0026rsquo;s authentication session. Complete the login workflow. Inspecting the External Identity To access the result of the external login, invoke the AuthenticateAsync method. This will read the external cookie to retrieve the claims issued by the external provider and any other state you previously stored when calling ChallengeAsync:\n// read external identity from the temporary cookie var result = await HttpContext.AuthenticateAsync(IdentityServerConstants.ExternalCookieAuthenticationScheme); if (result?.Succeeded != true) { throw new Exception(\u0026#34;External authentication error\u0026#34;); } // retrieve claims of the external user var externalUser = result.Principal; if (externalUser == null) { throw new Exception(\u0026#34;External authentication error\u0026#34;); } // retrieve claims of the external user var userId = externalUser.FindFirst(\u0026#34;sub\u0026#34;).Value; var scheme = result.Properties.Items[\u0026#34;scheme\u0026#34;]; // retrieve returnUrl var returnUrl = result.Properties.Items[\u0026#34;returnUrl\u0026#34;] ?? \u0026#34;~/\u0026#34;; // use the user information to find your user in your database, or provision a new user The sub claim from the external cookie is the external provider\u0026rsquo;s unique id for the user. This value should be used to locate your local user record for the user.\nEstablish Session, Clean Up, and Resume Workflow Once your callback page logic has identified the user based on the external identity provider, it will log the user in and complete the original login workflow:\nvar user = FindUserFromExternalProvider(scheme, userId); // issue authentication cookie for user await HttpContext.SignInAsync(new IdentityServerUser(user.SubjectId) { DisplayName = user.DisplayName, IdentityProvider = scheme }); // delete temporary cookie used during external authentication await HttpContext.SignOutAsync(IdentityServerConstants.ExternalCookieAuthenticationScheme); // return back to protocol processing return Redirect(returnUrl); Typically, the sub value used to login the user would be the user\u0026rsquo;s unique id from your local user database.\nState, URL length, and ISecureDataFormat When redirecting to an external provider for sign-in, frequently state from the client application must be roundtripped. This means that state is captured prior to leaving the client and preserved until the user has returned to the client application. Many protocols, including OpenID Connect, allow passing some sort of state as a parameter as part of the request, and the identity provider will return that state on the response. The OpenID Connect authentication handler provided by ASP.NET Core utilizes this feature of the protocol, and that is how it implements the returnUrl feature mentioned above.\nThe problem with storing state in a request parameter is that the request URL can get too large (over the common limit of 2000 characters). The OpenID Connect authentication handler does provide an extensibility point to store the state in your server, rather than in the request URL. You can implement this yourself by implementing ISecureDataFormat and configuring it on the OpenIdConnectOptions.\nFortunately, IdentityServer provides an implementation of this for you, backed by the IDistributedCache implementation registered in the DI container (e.g. the standard MemoryDistributedCache). To use the IdentityServer provided secure data format implementation, simply call the AddOidcStateDataFormatterCache extension method on the IServiceCollection when configuring DI.\nIf no parameters are passed, then all OpenID Connect handlers configured will use the IdentityServer provided secure data format implementation:\npublic void ConfigureServices(IServiceCollection services) { // configures the OpenIdConnect handlers to persist the state parameter into the server-side IDistributedCache. services.AddOidcStateDataFormatterCache(); services.AddAuthentication() .AddOpenIdConnect(\u0026#34;demoidsrv\u0026#34;, \u0026#34;IdentityServer\u0026#34;, options =\u0026gt; { // ... }) .AddOpenIdConnect(\u0026#34;aad\u0026#34;, \u0026#34;Azure AD\u0026#34;, options =\u0026gt; { // ... }) .AddOpenIdConnect(\u0026#34;adfs\u0026#34;, \u0026#34;ADFS\u0026#34;, options =\u0026gt; { // ... }); } If only particular schemes are to be configured, then pass those schemes as parameters:\npublic void ConfigureServices(IServiceCollection services) { // configures the OpenIdConnect handlers to persist the state parameter into the server-side IDistributedCache. services.AddOidcStateDataFormatterCache(\u0026#34;aad\u0026#34;, \u0026#34;demoidsrv\u0026#34;); // rest omitted } See this quickstart for step-by-step instructions for adding external authentication and configuring it.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/fundamentals/license_key/",
    "title": "License Key",
    "tags": [],
    "description": "",
    "content": "When deploying your IdentityServer to production, you will need to configure your license key. This can be configured in one of two ways:\nVia a well-known file on the file system Programmatically in your startup code File System Duende IdentityServer will look for a file called Duende_IdentityServer_License.key in the same directory as your hosting application. If present, the contents of the file will be loaded as the license key.\nStartup If you prefer to load the license key dynamically, you can in your startup code. When calling AddIdentityServer from ConfigureServices, you can pass a lambda expression to configure various options in your IdentityServer. The LicenseKey is one such setting. For example:\npublic void ConfigureServices(IServiceCollection services) { services.AddIdentityServer(options =\u0026gt; { options.LicenseKey = \u0026#34;your_license_key\u0026#34;; }); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/ui/logout/client_redirect/",
    "title": "Returning to the Client",
    "tags": [],
    "description": "",
    "content": "If sign-out was initiated by a client application, then the client first redirected the user to the end session endpoint. This can be determined if a logoutId is passed to the login page and the returned LogoutRequest\u0026rsquo;s PostLogoutRedirectUri is set.\nHow to Redirect If there is a PostLogoutRedirectUri value, then it\u0026rsquo;s important how this URL is used to redirect the user. The logout page typically should not directly redirect the user to this URL. Doing so would skip the necessary front-channel notifications to clients.\nInstead, the typical approach is to render the PostLogoutRedirectUri as a link on the \u0026ldquo;logged out\u0026rdquo; page. This will allow the page to render, the front-channel iframes will load and perform their duty. It\u0026rsquo;s possible to add JavaScript to the page could enhance this experience even more.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/stores/",
    "title": "Stores",
    "tags": [],
    "description": "",
    "content": "Stores Resource Store Client Store CORS Policy Service Identity Provider Store Persisted Grant Store Device Flow Store Signing Key Store "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/services/device_flow_interaction_service/",
    "title": "Device Flow Interaction Service",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Services.IDeviceFlowInteractionService The IDeviceFlowInteractionService interface is intended to provide services to be used by the user interface to communicate with Duende IdentityServer during device flow authorization. It is available from the dependency injection system and would normally be injected as a constructor parameter into your MVC controllers for the user interface of IdentityServer.\nIDeviceFlowInteractionService APIs GetAuthorizationContextAsync\nReturns the DeviceFlowAuthorizationRequest based on the userCode passed to the login or consent pages.\nHandleRequestAsync\nCompletes device authorization for the given userCode.\nDeviceFlowAuthorizationRequest ClientId\nThe client identifier that initiated the request.\nScopesRequested\nThe scopes requested from the authorization request.\nDeviceFlowInteractionResult IsError\nSpecifies if the authorization request errored.\nErrorDescription\nError description upon failure.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/ui/login/dynamicproviders/",
    "title": "Dynamic Providers",
    "tags": [],
    "description": "",
    "content": "Dynamic Identity Providers Normally authentication handlers for external providers are added into your IdentityServer using AddAuthentication() and AddOpenIdConnect(). This is fine for a handful of schemes, but the authentication handler architecture in ASP.NET Core was not designed for dozens or more statically registered in the DI system. At some point you will incur a performance penalty for having too many. Also, as you need to add or change this configuration you will need to re-compile and re-run your startup code for those changes to take effect.\nDuende IdentityServer provides support for dynamic configuration of OpenID Connect providers loaded from a store. This is designed to address the performance concern as well as allowing changes to the configuration to a running server.\nListing and displaying the dynamic providers on the login page The identity provider store can be used to query the database containing the dynamic providers.\n/// \u0026lt;summary\u0026gt; /// Interface to model storage of identity providers. /// \u0026lt;/summary\u0026gt; public interface IIdentityProviderStore { /// \u0026lt;summary\u0026gt; /// Gets all identity providers name. /// \u0026lt;/summary\u0026gt; Task\u0026lt;IEnumerable\u0026lt;IdentityProviderName\u0026gt;\u0026gt; GetAllSchemeNamesAsync(); // other APIs omitted } These results can then be used to populate the list of options presented to the user on the login page.\nThis API is deliberatly separate to the IAuthenticationSchemeProvider provided by ASP.NET Core, which returns the list of statically configured providers (from Startup.cs). This allows the developer to have more control over the customization on the login page (e.g. there might be hundreds or thousands of dynamic providers, and therefore you would not want them displayed on the login page, but you might have a few social providers statically configured that you would want to display).\nHere is an example of how the IdentityServer Quickstart UI uses both interfaces to then present a merged and unified list to the end user:\nvar schemes = await _schemeProvider.GetAllSchemesAsync(); var providers = schemes .Where(x =\u0026gt; x.DisplayName != null) .Select(x =\u0026gt; new ExternalProvider { DisplayName = x.DisplayName ?? x.Name, AuthenticationScheme = x.Name }).ToList(); var dynamicSchemes = (await _identityProviderStore.GetAllSchemeNamesAsync()) .Where(x =\u0026gt; x.Enabled) .Select(x =\u0026gt; new ExternalProvider { AuthenticationScheme = x.Scheme, DisplayName = x.DisplayName }); providers.AddRange(dynamicSchemes); Store and Configuration Data To use the dynamic providers feature an identity provider store must be provided that will load model data for the OIDC identity provider to be used. If you\u0026rsquo;re using the Entity Framework Integration then this is implemented for you.\nThe configuration data for the OIDC provider is used to assign the configuration on the ASP.NET Core OpenID Connect Options class, much like you would if you were to statically configure the options when using AddOpenIdConnect(). The identity provider model documentation provides details for the model properties and how they are mapped to the options.\nCustomizing OpenIdConnectOptions If it is needed to further customize the OpenIdConnectOptions, you can register in the DI system an instance of IConfigureNamedOptions\u0026lt;OpenIdConnectOptions\u0026gt;. For example:\npublic class CustomConfig : IConfigureNamedOptions\u0026lt;OpenIdConnectOptions\u0026gt; { public void Configure(string name, OpenIdConnectOptions options) { if (name == \u0026#34;MyScheme\u0026#34;) { options.ClaimActions.MapAll(); } } public void Configure(OpenIdConnectOptions options) { } } And to register this in the DI system:\npublic void ConfigureServices(IServiceCollection services) { services.ConfigureOptions\u0026lt;CustomConfig\u0026gt;(); } Accessing OidcProvider data in IConfigureNamedOptions If your customization of the OpenIdConnectOptions requires per-provider data that you are storing on the OidcProvider, then we provide an abstraction for the IConfigureNamedOptions\u0026lt;OpenIdConnectOptions\u0026gt;. This abstraction requires your code to derive from ConfigureAuthenticationOptions\u0026lt;OpenIdConnectOptions, OidcProvider\u0026gt; (rather than IConfigureNamedOptions\u0026lt;OpenIdConnectOptions\u0026gt;). For exmaple:\nclass CustomOidcConfigureOptions : ConfigureAuthenticationOptions\u0026lt;OpenIdConnectOptions, OidcProvider\u0026gt; { public CustomOidcConfigureOptions(IHttpContextAccessor httpContextAccessor) : base(httpContextAccessor) { } protected override void Configure(ConfigureAuthenticationContext\u0026lt;OpenIdConnectOptions, OidcProvider\u0026gt; context) { var oidcProvider = context.IdentityProvider; var oidcOptions = context.AuthenticationOptions; // TODO: configure oidcOptions with values from oidcProvider } } The above class would need to be configured in DI (as before):\npublic void Configure(IServiceCollection services) { services.ConfigureOptions\u0026lt;CustomOidcConfigureOptions\u0026gt;(); } Callback Paths As part of the architecture of the dynamic providers feature, the various callback paths are required and are automatically set to follow a convention. The convention of these paths follows the form of ~/federation/{scheme}/{suffix}.\nThese are three paths that are set on the OpenIdConnectOptions:\nCallbackPath. This is the OIDC redirect URI protocol value. The suffix \u0026ldquo;/signin\u0026rdquo; is used for this path. SignedOutCallbackPath. This is the OIDC post logout redirect URI protocol value. The suffix \u0026ldquo;/signout-callback\u0026rdquo; is used for this path. RemoteSignOutPath. This is the OIDC front channel logout URI protocol value. The suffix \u0026ldquo;/signout\u0026rdquo; is used for this path. This means for your IdentityServer running at \u0026ldquo;https://sample.duendesoftware.com\u0026rdquo; and an OIDC identity provider whose scheme is \u0026ldquo;idp1\u0026rdquo;, your client configuration with the external OIDC identity provider would be:\nThe redirect URI would be \u0026ldquo;https://sample.duendesoftware.com/federation/idp1/signin\u0026quot; The post logout redirect URI would be \u0026ldquo;https://sample.duendesoftware.com/federation/idp1/signout-callback\u0026quot; The front channel logout URI would be \u0026ldquo;https://sample.duendesoftware.com/federation/idp1/signout\u0026quot; DynamicProviderOptions The DynamicProviderOptions is a new options class in the IdentityServer options object model. It provides shared settings for the dynamic identity providers feature.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/models/secrets/",
    "title": "Secrets",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Validation.ISecretParser Parses a secret from the raw HTTP request.\npublic interface ISecretParser { /// \u0026lt;summary\u0026gt; /// Tries to find a secret on the context that can be used for authentication /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;context\u0026#34;\u0026gt;The HTTP context.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;A parsed secret\u0026lt;/returns\u0026gt; Task\u0026lt;ParsedSecret\u0026gt; ParseAsync(HttpContext context); /// \u0026lt;summary\u0026gt; /// Returns the authentication method name that this parser implements /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;The authentication method.\u0026lt;/value\u0026gt; string AuthenticationMethod { get; } } AuthenticationMethod\nThe name of the authentication method that this parser registers for. This value must be unique and will be displayed in the discovery document.\nParseAsync\nThe job of this method is to extract the secret from the HTTP request and parse it into a ParsedSecret\nDuende.IdentityServer.Model.ParsedSecret Represents a parsed secret.\n/// \u0026lt;summary\u0026gt; /// Represents a secret extracted from the HttpContext /// \u0026lt;/summary\u0026gt; public class ParsedSecret { /// \u0026lt;summary\u0026gt; /// Gets or sets the identifier associated with this secret /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The identifier. /// \u0026lt;/value\u0026gt; public string Id { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the credential to verify the secret /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The credential. /// \u0026lt;/value\u0026gt; public object Credential { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the type of the secret /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The type. /// \u0026lt;/value\u0026gt; public string Type { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets additional properties. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The properties. /// \u0026lt;/value\u0026gt; public Dictionary\u0026lt;string, string\u0026gt; Properties { get; set; } = new Dictionary\u0026lt;string, string\u0026gt;(); } The parsed secret is forwarded to the registered secret validator. The validator will typically inspect the Type property to determine if this secret is something that can be validated by that validator instance. If yes, it will know how to cast the Credential object into a format that is understood.\nDuende.IdentityServer.Validation.ISecretParser Validates a parsed secret.\npublic interface ISecretValidator { /// \u0026lt;summary\u0026gt;Validates a secret\u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;secrets\u0026#34;\u0026gt;The stored secrets.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;parsedSecret\u0026#34;\u0026gt;The received secret.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;A validation result\u0026lt;/returns\u0026gt; Task\u0026lt;SecretValidationResult\u0026gt; ValidateAsync( IEnumerable\u0026lt;Secret\u0026gt; secrets, ParsedSecret parsedSecret); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/validators/",
    "title": "Validators",
    "tags": [],
    "description": "",
    "content": "Validators Extension Grant Validator Custom Token Request Validator "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/ui/logout/external/",
    "title": "External Logout",
    "tags": [],
    "description": "",
    "content": "When a user is logging out, and they have used an external identity provider to sign-in then it is likely that they should be redirected to also sign-out of the external provider. Not all external providers support sign-out, as it depends on the protocol and features they support.\nDon\u0026rsquo;t forget that your logout page still needs to complete all the other steps to properly sign the user out. This is complicated if the logout page must redirect to an external provider to sign out. To achieve both, it is necessary to have the external provider to redirect the user back to your IdentityServer after signing out of the external provider. Across this redirect exchange, there will be state that must be maintained so the complete sign out workflow can complete successfully.\nDetermining the Identity Provider To detect that a user must be redirected to an external identity provider for sign-out is typically done by using an idp claim issued into the cookie at IdentityServer. The value is either local for a local sign-in or the scheme of the corresponding authentication handler used for an external provider. At sign-out time this claim should be consulted to determine if an external sign-out is required.\nThe constant IdentityServerConstants.LocalIdentityProvider can be used instead of hard coding the value local for the local login provider identifier.\nRedirecting to the External Provider To trigger logout at an external provider, use the SignOutAsync extension method on the HttpContext (or the SignOutResult action result in MVC or Razor Pages). You must pass the scheme of the provider as configured in your startup (which should also match the idp claim mentioned above).\npublic IActionResult Logout(string logoutId) { // other code elided var idp = User.FindFirst(\u0026#34;idp\u0026#34;).Value; if (idp != IdentityServerConstants.LocalIdentityProvider) { return SignOut(idp); } // other code elided } Redirecting back from the External Provider and State Management To redirect back to your IdentityServer after the external provider sign-out, the RedirectUri should be used on the AuthenticationProperties when using ASP.NET Core\u0026rsquo;s SignOutAsync API.\nRecall that after we return, we must perform the other steps to complete the logout workflow. These steps require the context passed as the logoutId parameter, so this state needs to be roundtripped to the external provider. We can do so by incorporating the logoutId value into the RedirectUri.\nIf there is no logoutId parameter on the original logout page request, we still might have context that needs to be round tripped. We can obtain a logoutId to use by calling CreateLogoutContextAsync API on the interaction service.\nFor example:\npublic async Task\u0026lt;IActionResult\u0026gt; Logout(string logoutId) { // other code elided var idp = User.FindFirst(\u0026#34;idp\u0026#34;).Value; if (idp != IdentityServerConstants.LocalIdentityProvider) { logoutId = logoutId ?? await _interaction.CreateLogoutContextAsync(); string url = Url.Action(\u0026#34;Logout\u0026#34;, new { logoutId = logoutId }); return SignOut(new AuthenticationProperties { RedirectUri = url }, idp); } // other code elided } Once the user is signed-out of the external provider and then redirected back, the normal sign-out processing at your IdentityServer should execute which involves processing the logoutId and doing all necessary cleanup.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/ui/login/windows/",
    "title": "Windows Authentication",
    "tags": [],
    "description": "",
    "content": "There are several ways how you can enable Windows authentication in ASP.NET Core (and thus in your IdentityServer).\nOn Windows using IIS hosting (both in- and out-of process) On Windows using HTTP.SYS hosting On any platform using the Negotiate authentication handler (added in ASP.NET Core 3.0) See the Microsoft documentation for additional information.\nOn Windows using IIS hosting The typical ASP.NET Core CreateDefaultBuilder host setup enables support for IIS-based Windows authentication when hosting in IIS. Make sure that Windows authentication is enabled in launchSettings.json or your IIS configuration.\nThe IIS integration layer will configure a Windows authentication handler into DI that can be invoked via the authentication service. Typically in your IdentityServer it is advisable to disable the automatic behavior.\nThis is done in ConfigureServices (details vary depending on in-proc vs out-of-proc hosting)::\n// configures IIS out-of-proc settings (see https://github.com/aspnet/AspNetCore/issues/14882) services.Configure\u0026lt;IISOptions\u0026gt;(iis =\u0026gt; { iis.AuthenticationDisplayName = \u0026#34;Windows\u0026#34;; iis.AutomaticAuthentication = false; }); // ..or configures IIS in-proc settings services.Configure\u0026lt;IISServerOptions\u0026gt;(iis =\u0026gt; { iis.AuthenticationDisplayName = \u0026#34;Windows\u0026#34;; iis.AutomaticAuthentication = false; }); You trigger Windows authentication by calling ChallengeAsync using the Windows scheme (or if you want to use a constant: Microsoft.AspNetCore.Server.IISIntegration.IISDefaults.AuthenticationScheme).\nThis will send the Www-Authenticate header back to the browser which will then re-load the current URL including the Windows identity. You can tell that Windows authentication was successful, when you call AuthenticateAsync on the Windows scheme and the principal returned is of type WindowsPrincipal.\nThe principal will have information like user and group SID and the Windows account name. The following snippet shows how to trigger authentication, and if successful convert the information into a standard ClaimsPrincipal for the temp-Cookie approach::\nprivate async Task\u0026lt;IActionResult\u0026gt; ChallengeWindowsAsync(string returnUrl) { // see if windows auth has already been requested and succeeded var result = await HttpContext.AuthenticateAsync(\u0026#34;Windows\u0026#34;); if (result?.Principal is WindowsPrincipal wp) { // we will issue the external cookie and then redirect the // user back to the external callback, in essence, treating windows // auth the same as any other external authentication mechanism var props = new AuthenticationProperties() { RedirectUri = Url.Action(\u0026#34;Callback\u0026#34;), Items = { { \u0026#34;returnUrl\u0026#34;, returnUrl }, { \u0026#34;scheme\u0026#34;, \u0026#34;Windows\u0026#34; }, } }; var id = new ClaimsIdentity(\u0026#34;Windows\u0026#34;); // the sid is a good sub value id.AddClaim(new Claim(JwtClaimTypes.Subject, wp.FindFirst(ClaimTypes.PrimarySid).Value)); // the account name is the closest we have to a display name id.AddClaim(new Claim(JwtClaimTypes.Name, wp.Identity.Name)); // add the groups as claims -- be careful if the number of groups is too large var wi = wp.Identity as WindowsIdentity; // translate group SIDs to display names var groups = wi.Groups.Translate(typeof(NTAccount)); var roles = groups.Select(x =\u0026gt; new Claim(JwtClaimTypes.Role, x.Value)); id.AddClaims(roles); await HttpContext.SignInAsync( IdentityServerConstants.ExternalCookieAuthenticationScheme, new ClaimsPrincipal(id), props); return Redirect(props.RedirectUri); } else { // trigger windows auth // since windows auth don\u0026#39;t support the redirect uri, // this URL is re-triggered when we call challenge return Challenge(\u0026#34;Windows\u0026#34;); } } A sample is provided here.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/data/",
    "title": "Data Stores and Persistence",
    "tags": [],
    "description": "",
    "content": "Data Stores and Persistence Duende IdentityServer is backed by two kinds of data:\nConfiguration Data Operational Data Data access is abstracted by store interfaces that are registered in the DI system. These store interfaces allow IdentityServer to access the data it needs at runtime when processing requests. You can implement these interfaces yourself and thus can use any database you wish. If you prefer a relational database for this data, then we provide EntityFramework Core implementations.\nGiven that data stores abstract the details of the data stored, strictly speaking, IdentityServer does not know or understand where the data is actually being stored. As such, there is no built-in administrative tool to populate or manage this data. There are third-party options (both commercial and FOSS) that provide an administrative UI for managing the data when using the EntityFramework Core implementations.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/upgrades/v5.1_to_v5.2/",
    "title": "Duende IdentityServer v5.1 to v5.2",
    "tags": [],
    "description": "",
    "content": "This upgrade guide covers upgrading from Duende IdentityServer v5.1 to v5.2 (release notes).\nStep 1: Update NuGet package In your IdentityServer host project, update the version of the NuGet. For example in your project file:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;5.1.0\u0026#34; /\u0026gt; would change to:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;5.2.0\u0026#34; /\u0026gt; Step 2: Update Database Schema (if needed) If you are using a database for your configuration data, then there is a database schema update for the new Dynamic Providers feature (more details). This includes:\nA new table called IdentityProviders for storing the OIDC provider details. Its TSQL schema would look like this: CREATE TABLE [IdentityProviders] ( [Id] int NOT NULL IDENTITY, [Scheme] nvarchar(200) NOT NULL, [DisplayName] nvarchar(200) NULL, [Enabled] bit NOT NULL, [Type] nvarchar(20) NOT NULL, [Properties] nvarchar(max) NULL, CONSTRAINT [PK_IdentityProviders] PRIMARY KEY ([Id]) ); If you are using the Duende.IdentityServer.EntityFramework package as the implementation for the database and you\u0026rsquo;re using EntityFramework Core migrations as the mechanism for managing those schema changes over time, the commands below will update those migrations with the new changes. Note that you might need to adjust based on your specific organization of the migration files.\ndotnet ef migrations add Update_DuendeIdentityServer_v5_2 -c ConfigurationDbContext -o Data/Migrations/IdentityServer/ConfigurationDb Then to apply those changes to your database:\ndotnet ef database update -c ConfigurationDbContext Step 4: Update custom AuthorizeInteractionResponseGenerator (if needed) If you have created a custom, derived implementation of the AuthorizeInteractionResponseGenerator, then the constructor must accept an additional parameter of type IdentityServerOptions. This is needed for the new tenant validation in authorize endpoint requests.\nStep 5: Done! That\u0026rsquo;s it. Of course, at this point you can and should test that your IdentityServer is updated and working properly.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/ui/logout/external_notification/",
    "title": "External Logout Notification",
    "tags": [],
    "description": "",
    "content": "Federated sign-out is the situation where a user has used an external identity provider to log into IdentityServer, and then the user logs out of that external identity provider via a workflow unknown to IdentityServer. When the user signs out, it will be useful for IdentityServer to be notified so that it can sign the user out of IdentityServer and all of the applications that use IdentityServer.\nNot all external identity providers support federated sign-out, but those that do will provide a mechanism to notify clients that the user has signed out. This notification usually comes in the form of a request in an from the external identity provider\u0026rsquo;s \u0026ldquo;logged out\u0026rdquo; page. IdentityServer must then notify all of its clients (as discussed here), also typically in the form of a request in an from within the external identity provider\u0026rsquo;s .\nWhat makes federated sign-out a special case (when compared to a normal logout) is that the federated sign-out request is not to the normal sign-out endpoint in IdentityServer. In fact, each external IdentityProvider will have a different endpoint into your IdentityServer host. This is due to that fact that each external identity provider might use a different protocol, and each middleware listens on different endpoints.\nThe net effect of all of these factors is that there is no \u0026ldquo;logged out\u0026rdquo; page being rendered as we would on the normal sign-out workflow, which means we are missing the sign-out notifications to IdentityServer\u0026rsquo;s clients. We must add code for each of these federated sign-out endpoints to render the necessary notifications to achieve federated sign-out.\nFortunately IdentityServer already contains this code. When requests come into IdentityServer and invoke the handlers for external authentication providers, IdentityServer detects if these are federated signout requests and if they are it will automatically render the same as described here for logout.\nIn short, federated signout is automatically supported.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/stores/signing_key_store/",
    "title": "Signing Key Store",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Stores.ISigningKeyStore Used to dynamically load client configuration.\n/// \u0026lt;summary\u0026gt; /// Interface to model storage of serialized keys. /// \u0026lt;/summary\u0026gt; public interface ISigningKeyStore { /// \u0026lt;summary\u0026gt; /// Returns all the keys in storage. /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task\u0026lt;IEnumerable\u0026lt;SerializedKey\u0026gt;\u0026gt; LoadKeysAsync(); /// \u0026lt;summary\u0026gt; /// Persists new key in storage. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task StoreKeyAsync(SerializedKey key); /// \u0026lt;summary\u0026gt; /// Deletes key from storage. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;id\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task DeleteKeyAsync(string id); } SerializedKey /// \u0026lt;summary\u0026gt; /// Serialized key. /// \u0026lt;/summary\u0026gt; public class SerializedKey { /// \u0026lt;summary\u0026gt; /// Version number of serialized key. /// \u0026lt;/summary\u0026gt; public int Version { get; set; } /// \u0026lt;summary\u0026gt; /// Key identifier. /// \u0026lt;/summary\u0026gt; public string Id { get; set; } /// \u0026lt;summary\u0026gt; /// Date key was created. /// \u0026lt;/summary\u0026gt; public DateTime Created { get; set; } /// \u0026lt;summary\u0026gt; /// The algorithm. /// \u0026lt;/summary\u0026gt; public string Algorithm { get; set; } /// \u0026lt;summary\u0026gt; /// Contains X509 certificate. /// \u0026lt;/summary\u0026gt; public bool IsX509Certificate { get; set; } /// \u0026lt;summary\u0026gt; /// Serialized data for key. /// \u0026lt;/summary\u0026gt; public string Data { get; set; } /// \u0026lt;summary\u0026gt; /// Indicates if data is protected. /// \u0026lt;/summary\u0026gt; public bool DataProtected { get; set; } } The Data property contains a copy of all of the values (and more) and is considered authoritative by IdentityServer, thus most of the other property values are considered informational and read-only.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/bff/options/",
    "title": "Configuration Options",
    "tags": [],
    "description": "",
    "content": "The Duende.BFF.BffOptions allows to configure several aspects of the BFF framework.\nYou set the options at startup time in your ConfigureServices method:\nservices.AddBff(options =\u0026gt; { // configure options here.. }) General EnforceBffMiddleware\nThis injects exra checks to make sure the BFF middleware has been added to the pipeline. Since this middleware does important security checks, this protects from accidental configuration errors. You can disable this check if it interferes with some custom logic you might have.\nLicenseKey\nThis sets the license key for Duende.BFF. This license key is required for production deployments.\nSession Management ManagementBasePath\nBase path for management endpoints. Defaults to /bff.\nRequireLogoutSessionId\nFlag that specifies if the sid claim needs to be present in the logout request as query string parameter. Used to prevent cross site request forgery. Defaults to true.\nRevokeRefreshTokenOnLogout\nSpecifies if the user\u0026rsquo;s refresh token is automatically revoked at logout time. Defaults to true.\nRequireLogoutSessionId\nFlag that specifies if the sid claim needs to be present in the logout request as query string parameter. Used to prevent cross site request forgery. Defaults to true.\nBackchannelLogoutAllUserSessions\nSpecifies if during backchannel logout all matching user sessions are logged out. If true, all sessions for the subject will be revoked. If false, just the specific session will be revoked. Defaults to false.\nAPIs AntiForgeryHeaderName\nSpecifies the name of the header used for anti-forgery header protection. Defaults to X-CSRF.\nAntiForgeryHeaderValue\nSpecifies the expected value of Anti-forgery header. Defaults to 1.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/diagnostics/",
    "title": "Diagnostics",
    "tags": [],
    "description": "",
    "content": "Diagnostics Logging Events "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/aspnet_identity/",
    "title": "ASP.NET Identity Integration",
    "tags": [],
    "description": "",
    "content": "ASP.NET Identity Integration An ASP.NET Identity-based implementation is provided for managing the identity database for users of IdentityServer. This implementation implements the extensibility points in IdentityServer needed to load identity data for your users to emit claims into tokens.\nTo use this library, ensure that you have the NuGet package for the ASP.NET Identity integration. It is called Duende.IdentityServer.AspNetIdentity. You can install it with:\ndotnet add package Duende.IdentityServer.AspNetIdentity Next, configure ASP.NET Identity normally in your IdentityServer host with the standard calls to AddIdentity and any other related configuration.\nThen in your Startup.cs, use the AddAspNetIdentity extension method after the call to AddIdentityServer:\npublic void ConfigureServices(IServiceCollection services) { services.AddIdentity\u0026lt;ApplicationUser, IdentityRole\u0026gt;() .AddEntityFrameworkStores\u0026lt;ApplicationDbContext\u0026gt;() .AddDefaultTokenProviders(); services.AddIdentityServer() .AddAspNetIdentity\u0026lt;ApplicationUser\u0026gt;(); } AddAspNetIdentity requires as a generic parameter the class that models your user for ASP.NET Identity (and the same one passed to AddIdentity to configure ASP.NET Identity). This configures IdentityServer to use the ASP.NET Identity implementations of IUserClaimsPrincipalFactory to convert the user data into claims, IResourceOwnerPasswordValidator to support the password grant type, and IProfileService which uses the IUserClaimsPrincipalFactory to add claims to tokens. It also configures some of ASP.NET Identity\u0026rsquo;s options for use with IdentityServer (such as claim types to use and authentication cookie settings).\nIf you need to use your own implementation of IUserClaimsPrincipalFactory, then that is supported. Our implementation of the IUserClaimsPrincipalFactory will use the decorator pattern to encapsulate yours. For this to work properly, ensure that your implementation is registered in the DI system prior to calling the IdentityServer AddAspNetIdentity extension method.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/upgrades/v5.0_to_v5.1/",
    "title": "Duende IdentityServer v5.0 to v5.1",
    "tags": [],
    "description": "",
    "content": "This upgrade guide covers upgrading from Duende IdentityServer v5.0 to v5.1 (release notes). Fortunately there\u0026rsquo;s not much to do :)\nStep 1: Update NuGet package In your IdentityServer host project, update the version of the NuGet. For example in your project file:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;5.0.0\u0026#34; /\u0026gt; would change to:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;5.1.0\u0026#34; /\u0026gt; Step 2: Update Database Schema (if needed) If you are using a database for your operational data, then there is a small database schema update. This includes:\nA new index on the ConsumedTime column in the PersistedGrants table (more details). If you are using the Duende.IdentityServer.EntityFramework package as the implementation for the database and you\u0026rsquo;re using EntityFramework Core migrations as the mechanism for managing those schema changes over time, the commands below will update those migrations with the new changes. Note that you might need to adjust based on your specific organization of the migration files.\ndotnet ef migrations add Update_DuendeIdentityServer_v5_1 -c PersistedGrantDbContext -o Data/Migrations/IdentityServer/PersistedGrantDb Then to apply those changes to your database:\ndotnet ef database update -c PersistedGrantDbContext Step 3: Done! That\u0026rsquo;s it. Of course, at this point you can and should test that your IdentityServer is updated and working properly.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/bff/",
    "title": "BFF Security Framework",
    "tags": [],
    "description": "",
    "content": "BFF Security Framework The Duende.BFF (Backend for Frontend) security framework packages up guidance and the necessary components to secure browser-based frontends (e.g. SPAs or Blazor WASM applications) with ASP.NET Core backends.\nDuende.BFF is part of the IdentityServer Business Edition or higher. The same license and special offers apply.\nThe source code for the BFF framework can be found here. NuGet here. Samples here.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/bff/extensibility/",
    "title": "Extensibility",
    "tags": [],
    "description": "",
    "content": "Extensibility Duende.BFF can be extended in the following areas\ncustom logic at the session management endpoints custom logic and configuration for HTTP forwarding custom data storage for server-side sessions and access/refresh tokens "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/ui/federation/",
    "title": "Federation Gateway",
    "tags": [],
    "description": "",
    "content": "Federation means that your IdentityServer offers authentication methods that use external authentication providers.\nIf you offer a number of these external authentication methods, often the term Federation Gateway is used to describe this architectural approach.\nGenerally, this architecture allows shielding your client applications from the complexities of your authentication workflows and business requirements that go along with them.\nYour clients only need to trust the gateway, and the gateway coordinates all the communication and trust relationships with the external providers. This might involve switching between different protocols, token types, claim types etc. Also the gateway can make sure that all claims and identities that ultimately arrive at the client applications are trustworthy and in a format that the client expects.\nThere are a number of scenarios where this approach is commonly used.\nMultiple authentication methods for users Maybe your users should have multiple options how they can sign-in/up, e.g.\nusername/password or a commercial provider like Google or Microsoft Account username/password or a commercial provider for customers, and Active Directory or Azure AD for employees Integration of on-premise products with customer identity systems If you are building on-premise products, you have to integrate with a multitude of customer authentication systems. Maintaining variations of your business software for each product you have to integrate with, makes your software hard to maintain.\nWith a federation gateway, you only need to adapt to these external systems at the gateway level, all of your business applications are shielded from the technical details.\nSoftware-as-a-Service It\u0026rsquo;s very common to offer federation with your customers\u0026rsquo; authentication systems in SaaS scenarios. This way your customers get single-sign-on to your applications without having to explicitly create accounts in your identity system.\nSupport for external authentication methods IdentityServer leverages the ASP.NET Core authentication infrastructure for communicating with external providers. This means that every authentication system that is supported by ASP.NET Core, can also be used in the context of IdentityServer. This includes support for commercial providers like Google, GitHub or LinkedIn (and many more) as well as any OpenID Connect, SAML2p or WS-Federation based systems.\nSee the Integrating with External Providers section for more details.\nHome Realm Discovery The process of selecting the \u0026ldquo;best\u0026rdquo; authentication workflow for a user (especially when you have multiple authentication methods) is called Home Realm Discovery (or HRD for short).\nSince users are typically anonymous when they arrive at the gateway, you need some sort of hint to optimize the login workflow, e.g.\nyou present a list of available authentication methods to the user. This might work for simpler scenarios, but probably not if you have a lot of choices or if this would reveal your customers\u0026rsquo; authentication systems you ask the user for an identifier (e.g. email address) and have a way to infer the right external authentication method from that id. This is a common technique for SaaS systems. the client application can give a hint to the gateway via a custom protocol parameter of IdentityServer\u0026rsquo;s built-in support for the idp parameter on acr_values. In some case the client already knows the right authentication method, e.g. when your customers access your software via a customer-specific URL (see here). you restrict the available authentication methods per client in the client configuration using the IdentityProviderRestrictions property (see here) Every system is slightly different. Always start with the desired user experience, and then choose from the above options (or combinations) to implement the required flow.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/tokens/pop/",
    "title": "Proof-of-Possession Access Tokens",
    "tags": [],
    "description": "",
    "content": "By default, OAuth access tokens are so called bearer tokens. This means they are not bound to a client and anybody who possesses the token can use it. The security concern here is that a leaked token could be used by a (malicious) third-party to impersonate the client and/or user.\nOn the other hand, Proof-of-Possession (PoP) tokens are bound to the client that requested the token. This is also often called sender constraining. This is done by using cryptography to prove that the sender of the token knows an additional secret only known to the client.\nThis proof is called the confirmation method and is expressed via the standard cnf claim,e.g.:\n{ \u0026#34;iss\u0026#34;: \u0026#34;https://localhost:5001\u0026#34;, \u0026#34;iat\u0026#34;: 1609932801, \u0026#34;exp\u0026#34;: 1609936401, \u0026#34;aud\u0026#34;: \u0026#34;urn:resource1\u0026#34;, \u0026#34;client_id\u0026#34;: \u0026#34;web_app\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;88421113\u0026#34;, \u0026#34;cnf\u0026#34;: \u0026#34;confirmation_method\u0026#34; } When using reference tokens, the cnf claim will be returned from the introspection endpoint.\nProof-of-possession using Mutual TLS RFC 8705 specifies how to bind a TLS client certificate to an access token. With this method your IdentityServer will embed the SHA-256 thumbprint of the X.509 certificate into the access token via the cnf claims, e.g.:\n{ // rest omitted \u0026#34;cnf\u0026#34;: { \u0026#34;x5t#S256\u0026#34;: \u0026#34;bwcK0esc3ACC3DB2Y5_lESsXE8o9ltc05O89jdN-dg2\u0026#34; } } This is done automatically if you authenticate the client using a TLS client certificate.\nThe client must then use the same client certificate to call the APIs, and your APIs can validate the cnf claim by comparing it to the thumbprint of the client certificate on the TLS channel.\nIf the access token would leak, it cannot be replayed without having access to the additional private key of the X.509 client certificate.\nCombine TLS proof-of-possession with other authentication methods It is not mandatory to authenticate your clients with a client certificate to get the benefit of proof-of-possession. You can combine this feature with an arbitrary client authentication method - or even no client authentication at all (e.g. for public mobile/native clients).\nIn this scenario, the client would create an X.509 certificate on the fly, and use that to establish the TLS channel to your IdentityServer. As long as the certificate is accepted by your web server, your IdentityServer can embed the cnf claim, and your APIs can validate it.\n.NET Client In .NET it is straight-forward to create an X.509 certificate on the fly and use it to open a TLS connection.\nstatic X509Certificate2 CreateClientCertificate(string name) { X500DistinguishedName distinguishedName = new X500DistinguishedName($\u0026#34;CN={name}\u0026#34;); using (RSA rsa = RSA.Create(2048)) { var request = new CertificateRequest(distinguishedName, rsa, HashAlgorithmName.SHA256,RSASignaturePadding.Pkcs1); request.CertificateExtensions.Add( new X509KeyUsageExtension( X509KeyUsageFlags.DataEncipherment | X509KeyUsageFlags.KeyEncipherment | X509KeyUsageFlags.DigitalSignature , false)); request.CertificateExtensions.Add( new X509EnhancedKeyUsageExtension( new OidCollection { new Oid(\u0026#34;1.3.6.1.5.5.7.3.2\u0026#34;) }, false)); return request.CreateSelfSigned( new DateTimeOffset(DateTime.UtcNow.AddDays(-1)), new DateTimeOffset(DateTime.UtcNow.AddDays(10))); } } Then use this client certificate on the TLS channel to request the token:\nstatic async Task\u0026lt;TokenResponse\u0026gt; RequestTokenAsync() { var client = new HttpClient(GetHandler(ClientCertificate)); var disco = await client.GetDiscoveryDocumentAsync(\u0026#34;https://demo.duendesoftware.com\u0026#34;); if (disco.IsError) throw new Exception(disco.Error); var response = await client.RequestClientCredentialsTokenAsync(new ClientCredentialsTokenRequest { Address = disco.MtlsEndpointAliases.TokenEndpoint, ClientId = \u0026#34;client\u0026#34;, Scope = \u0026#34;api1\u0026#34; }); if (response.IsError) throw new Exception(response.Error); return response; } static SocketsHttpHandler GetHandler(X509Certificate2 certificate) { var handler = new SocketsHttpHandler(); handler.SslOptions.ClientCertificates = new X509CertificateCollection { certificate }; return handler; } Enabling support in your IdentityServer The last step is to enable that feature in the options:\nvar builder = services.AddIdentityServer(options =\u0026gt; { // other settings options.MutualTls.AlwaysEmitConfirmationClaim = true; }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/tokens/reference/",
    "title": "Reference Tokens",
    "tags": [],
    "description": "",
    "content": "When using reference tokens, Duende IdentityServer stores the contents of the token in the persisted grant store and issues a unique identifier for this token back to the client.\nThe consumer of the token must use the introspection endpoint to validate the token.\nYou can set the token type of a client using the following client setting:\nclient.AccessTokenType = AccessTokenType.Reference; Enabling an API to consume reference tokens The introspection endpoint requires authentication - since the client of an introspection endpoint is typically an API, you configure the secret on the ApiResource:\nvar api = new ApiResource(\u0026#34;api1\u0026#34;) { ApiSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) } Scopes = { \u0026#34;read\u0026#34;, \u0026#34;write\u0026#34; } } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/tokens/authentication/",
    "title": "Client Authentication",
    "tags": [],
    "description": "",
    "content": "Client Authentication Overview Shared Secrets Private Key JWTs TLS Client Certificates "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/deployment/",
    "title": "Deployment",
    "tags": [],
    "description": "",
    "content": "Deployment Duende IdentityServer is just middleware that you host in ASP.NET Core. All rules and advice around deploying ASP.NET Core applications to various hosting environments apply here too. This section focuses on IdentityServer-specific concerns.\nProxy Servers and Load Balancers ASP.NET Core Data Protection IdentityServer Data Stores Distributed Caching "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/upgrades/is4_v4_to_dis_v5/",
    "title": "IdentityServer4 v4.1 to Duende IdentityServer v5",
    "tags": [],
    "description": "",
    "content": "This upgrade guide covers upgrading from IdentityServer4 v4.1.x to Duende IdentityServer v5.\nStep 1: Update NuGet package In your IdentityServer host project, update the IdentityServer NuGet being used from IdentityServer4 to Duende IdentityServer. For example in your project file:\n\u0026lt;PackageReference Include=\u0026#34;IdentityServer4\u0026#34; Version=\u0026#34;4.1.1\u0026#34; /\u0026gt; would change to the latest version of Duende IdentityServer:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;5.2.0\u0026#34; /\u0026gt; If you\u0026rsquo;re using any of the other IdentityServer4 packages, such as IdentityServer4.EntityFramework or IdentityServer4.AspNetIdentity, then there are Duende equivalents such as Duende.IdentityServer.EntityFramework and Duende.IdentityServer.AspNetIdentity, respectively.\nStep 2: Update Namespaces Anywhere IdentityServer4 was used as a namespace, replace it with Duende.IdentityServer. For example:\nusing IdentityServer4; using IdentityServer4.Models; would change to:\nusing Duende.IdentityServer; using Duende.IdentityServer.Models; Step 3: Remove AddDeveloperSigningCredential If in ConfigureServices in your Startup.cs you were previously using AddDeveloperSigningCredential, that can be removed. Automatic key management is now a built-in feature.\nStep 4: Update Database Schema (if needed) If you are using a database for your configuration and operational data, then there is a small database schema update. This includes:\nA new Keys table for the automatic key management feature in the operational database. A new RequireResourceIndicator boolean column on the ApiResources table in the configuration database. If you are using the Duende.IdentityServer.EntityFramework package as the implementation for the database and you\u0026rsquo;re using EntityFramework Core migrations as the mechanism for managing those schema changes over time, the commands below will update those migrations with the new changes. Note that you might need to adjust based on your specific organization of the migration files.\ndotnet ef migrations add UpdateToDuende_v5 -c PersistedGrantDbContext -o Data/Migrations/IdentityServer/PersistedGrantDb dotnet ef migrations add UpdateToDuende_v5 -c ConfigurationDbContext -o Data/Migrations/IdentityServer/ConfigurationDb Then to apply those changes to your database:\ndotnet ef database update -c PersistedGrantDbContext dotnet ef database update -c ConfigurationDbContext Step 5: Migrating signing keys (optional) In IdentityServer4, the common way to configure a signing key in Startup was to use AddSigningCredential() and provide key material (such as an X509Certificate2). In Duende IdentityServer the automatic key management feature can manage those keys for you.\nSince client apps and APIs commonly cache the key material published from the discovery document then when upgrading you need to consider how those applications will handle an upgraded token server with a new and different signing key.\nIf while upgrading you can simply restart all of the client apps and APIs that depend on those signing keys, then you can remove the old signing key and start to use the new automatic key management. When they are restarted they will reload the discovery document and thus be aware of the new signing key.\nBut if you can\u0026rsquo;t restart all the client apps and APIs then you will need to maintain the prior signing key while still publishing the new keys produced from the automatic key management feature. This can be achieved by still using AddSigningCredential(). A signing key registered with AddSigningCredential() will take precedence over any keys created by the automatic key management feature. Once the client apps and APIs have updated their caches (typically after 24 hours) then you can remove the prior signing key by removing the call to AddSigningCredential() and redeploy your IdentityServer.\nStep 6: Done! That\u0026rsquo;s it. Of course, at this point you can and should test that your IdentityServer is updated and working properly.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/upgrades/",
    "title": "Upgrading",
    "tags": [],
    "description": "",
    "content": "Upgrading Here is a list of upgrade guides.\nDuende IdentityServer v5.1 to v5.2 Duende IdentityServer v5.0 to v5.1 IdentityServer4 v4.1 to Duende IdentityServer v5 IdentityServer4 v3.1 to Duende IdentityServer v5 "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/samples/",
    "title": "Samples",
    "tags": [],
    "description": "",
    "content": "Samples Our samples repository contains various samples for IdentityServer, BFF and typical application scenarios.\nFeel free to open a new feature request if you are looking for a particular sample, and can\u0026rsquo;t find it here.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/upgrades/is4_v3_to_dis_v5/",
    "title": "IdentityServer4 v3.1 to Duende IdentityServer v5",
    "tags": [],
    "description": "",
    "content": "This upgrade guide covers upgrading from IdentityServer4 v3.1.x to Duende IdentityServer v5. This upgrade is a complex one because the configuration object model had some non-trivial changes from IdentityServer4 v3 to IdentityServer4 v4.\nIn short, in IdentityServer4 v3 there was a parent-child relationship between the ApiResources and the ApiScopes. Then in IdentityServer4 v4 the ApiScopes was promoted to be its own top-level configuration. This meant that the child collection under the ApiResources was renamed to ApiResourcesScopes and it contained a reference to the new top-level ApiScopes.\nIf you were using a database for this configuration, then this means that configuration changed from a parent-child, to two top-level tables with a join table between them (to put it loosely). The new ApiResourcesScopes table was created to act as that join table.\nAlso, all the prior tables that were associated with the ApiResources were prefixed with \u0026ldquo;Api\u0026rdquo; and that prefix became \u0026ldquo;ApiResource\u0026rdquo; to better indicate the association. Then any new tables associated with the new top-level ApiScopes have the \u0026ldquo;ApiScope\u0026rdquo; prefix to indicate that association.\nIn order to properly update the database, the easiest approach is to first update to the latest of IdentityServer4 v4. Once that\u0026rsquo;s complete, then it\u0026rsquo;s very simple to move to Duende IdentityServer v5.\nThere is a sample project for this migration exercise. It is located here.\nStep 1: Update NuGet package to IdentityServer4 v4.x In your IdentityServer host project, update the IdentityServer NuGet being used from IdentityServer4 v3 to IdentityServer4 v4. For example in your project file:\n\u0026lt;PackageReference Include=\u0026#34;IdentityServer4\u0026#34; Version=\u0026#34;3.1.4\u0026#34; /\u0026gt; would change to the latest version of IdentityServer4:\n\u0026lt;PackageReference Include=\u0026#34;IdentityServer4\u0026#34; Version=\u0026#34;4.1.2\u0026#34; /\u0026gt; If you\u0026rsquo;re using any of the other IdentityServer4 packages, such as IdentityServer4.EntityFramework or IdentityServer4.AspNetIdentity, then update those as well.\nStep 2: Update Database Schema with EF Core Migrations If you are using a database for your configuration and operational data, then there is a bit of work. The reason is that for this type of schema restructuring EntityFramework Core\u0026rsquo;s migrations can lose existing data. To handle this, the conversation from the old schema to the new will be performed by custom SQL. This is only needed for the configuration database, not the operational one so normal migrations will suffice for the operational database.\nFirst for the operational database, we can simply apply EF Core migrations. Note that you might need to adjust based on your specific organization of the migration files.\ndotnet ef migrations add Grants_v4 -c PersistedGrantDbContext -o Migrations/PersistedGrantDb Then to apply those changes to your database:\ndotnet ef database update -c PersistedGrantDbContext Next for the configuration database, we\u0026rsquo;ll also add an EF Migration with:\ndotnet ef migrations add Config_v4 -c ConfigurationDbContext -o Migrations/ConfigurationDb When you run this, you should see the warnings from EF Core about this migration possibly losing data:\nBuild started... Build succeeded. info: Microsoft.EntityFrameworkCore.Infrastructure[10403] Entity Framework Core 3.1.15 initialized \u0026#39;ConfigurationDbContext\u0026#39; using provider \u0026#39;Microsoft.EntityFrameworkCore.SqlServer\u0026#39; with options: MigrationsAssembly=IdentityServerMigrationSample, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null An operation was scaffolded that may result in the loss of data. Please review the migration for accuracy. Done. To undo this action, use \u0026#39;ef migrations remove\u0026#39; To ensure we don\u0026rsquo;t lose data, we will add a custom SQL script to run instead of the generated migration. To ensure the script is available to the migration we will include the script into the project as an embedded resource. You could devise other approaches (like simply loading the SQL script from the filesystem) based on your preferences.\nThe SQL script to include is located here. Copy it into your project folder and then configure it as an embedded resource in the csproj file:\n\u0026lt;ItemGroup\u0026gt; \u0026lt;EmbeddedResource Include=\u0026#34;ConfigurationDb_v4_delta.sql\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; Then modify the migration that was just created. Remove all of the code in the Up and Down methods are replace the Up with this code, which will execute the custom SQL script:\nusing System.IO; using Microsoft.EntityFrameworkCore.Migrations; namespace IdentityServerMigrationSample.Migrations.ConfigurationDb { public partial class Config_v4 : Migration { protected override void Up(MigrationBuilder migrationBuilder) { var assembly = typeof(Program).Assembly; using (var s = assembly.GetManifestResourceStream(\u0026#34;IdentityServerMigrationSample.ConfigurationDb_v4_delta.sql\u0026#34;)) { using (StreamReader sr = new StreamReader(s)) { var sql = sr.ReadToEnd(); migrationBuilder.Sql(sql); } } } protected override void Down(MigrationBuilder migrationBuilder) { } } } Note that given that there is no Down implementation, this is a one-way update.\nAnd now run the migration:\ndotnet ef database update -c ConfigurationDbContext And your database should now be updated.\nStep 3: Verify your configuration database data At this point, you should be able to query your migrated database and see your data in tact. This script allows you to query the new restructured tables.\nStep 4: Move onto the upgrade guide for Duende IdentityServer v5 Once your project has been updated to IdentityServer4 v4, then you can work through the guide to update from IdentityServer4 v4 to Duende IdentityServer v5 (which should be far easier). Here is the link to the next upgrade guide.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/tokens/jar/",
    "title": "Signed Authorize Requests",
    "tags": [],
    "description": "",
    "content": "Instead of providing the parameters for an authorize request as individual query string key/value pairs, you can package them up in signed JWTs. This makes the parameters tamper proof and you can authenticate the client already on the front-channel.\nSee here for a sample for using signed authorize requests (and JWT-based authentication) in ASP.NET Core.\nYou can either transmit them by value or by reference to the authorize endpoint - see the spec for more details.\nDuende IdentityServer requires the request JWTs to be signed. We support X509 certificates and JSON web keys, e.g.:\nvar client = new Client { ClientId = \u0026#34;foo\u0026#34;, // set this to true to accept signed requests only RequireRequestObject = true, ClientSecrets = { new Secret { // X509 cert base64-encoded Type = IdentityServerConstants.SecretTypes.X509CertificateBase64, Value = Convert.ToBase64String(cert.Export(X509ContentType.Cert)) }, new Secret { // RSA key as JWK Type = IdentityServerConstants.SecretTypes.JsonWebKey, Value = \u0026#34;{\u0026#39;e\u0026#39;:\u0026#39;AQAB\u0026#39;,\u0026#39;kid\u0026#39;:\u0026#39;...\u0026#39;,\u0026#39;kty\u0026#39;:\u0026#39;RSA\u0026#39;,\u0026#39;n\u0026#39;:\u0026#39;...\u0026#39;}\u0026#34; } } } Passing request JWTs by reference If the request_uri parameter is used, IdentityServer will make an outgoing HTTP call to fetch the JWT from the specified URL.\nYou can customize the HTTP client used for this outgoing connection, e.g. to add caching or retry logic (e.g. via the Polly library):\nbuilder.AddJwtRequestUriHttpClient(client =\u0026gt; { client.Timeout = TimeSpan.FromSeconds(30); }) .AddTransientHttpErrorPolicy(policy =\u0026gt; policy.WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(3) })); Request URI processing is disabled by default. Enable on the Endpoints on the IdentityServerOptions. Also see the security considerations from the JAR specification.\nAccessing the request object data You can access the validated data from the request object in two ways:\nWherever you have access to the ValidatedAuthorizeRequest, the RequestObjectValues dictionary holds the values. In the UI code you can call IIdentityServerInteractionService.GetAuthorizationContextAsync, the resulting AuthorizationRequest object contains the RequestObjectValues dictionary as well. "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/tokens/cors/",
    "title": "Calling Endpoints from JavaScript",
    "tags": [],
    "description": "",
    "content": "In JavaScript-based clients, some endpoints like the token endpoint (but also discovery) will be accessed via Ajax calls.\nGiven that your IdentityServer will most likely be hosted on a different origin than these clients, this implies that Cross-Origin Resource Sharing (CORS) will need to be configured.\nClient-based CORS Configuration One approach to configuring CORS is to use the AllowedCorsOrigins collection on the client configuration. Simply add the origin of the client to the collection and the default configuration in IdentityServer will consult these values to allow cross-origin calls from the origins.\nBe sure to use an origin (not a URL) when configuring CORS. For example: https://foo:123/ is a URL, whereas https://foo:123 is an origin.\nThis default CORS implementation will be in use if you are using either the \u0026ldquo;in-memory\u0026rdquo; or EF-based client configuration that we provide. If you define your own IClientStore, then you will need to implement your own custom CORS policy service (see below).\nCustom Cors Policy Service Duende IdentityServer allows the hosting application to implement the ICorsPolicyService to completely control the CORS policy.\nThe single method to implement is: Task IsOriginAllowedAsync(string origin). Return true if the origin is allowed, false otherwise.\nOnce implemented, simply register the implementation in DI and IdentityServer will then use your custom implementation.\nDefaultCorsPolicyService If you simply wish to hard-code a set of allowed origins, then there is a pre-built ICorsPolicyService implementation you can use called DefaultCorsPolicyService.\nThis would be configured as a singleton in DI, and hard-coded with its AllowedOrigins collection, or setting the flag AllowAll to true to allow all origins.\nFor example, in ConfigureServices:\nservices.AddSingleton\u0026lt;ICorsPolicyService\u0026gt;((container) =\u0026gt; { var logger = container.GetRequiredService\u0026lt;ILogger\u0026lt;DefaultCorsPolicyService\u0026gt;\u0026gt;(); return new DefaultCorsPolicyService(logger) { AllowedOrigins = { \u0026#34;https://foo\u0026#34;, \u0026#34;https://bar\u0026#34; } }; }); Use AllowAll with caution.\nMixing IdentityServer\u0026rsquo;s CORS policy with ASP.NET Core\u0026rsquo;s CORS policies IdentityServer uses the CORS middleware from ASP.NET Core to provide its CORS implementation. It is possible that your application that hosts IdentityServer might also require CORS for its own custom endpoints. In general, both should work together in the same application.\nYour code should use the documented CORS features from ASP.NET Core without regard to IdentityServer. This means you should define policies and register the middleware as normal. If your application defines policies in ConfigureServices, then those should continue to work in the same places you are using them (either where you configure the CORS middleware or where you use the MVC EnableCors attributes in your controller code). If instead you define an inline policy in the use of the CORS middleware (via the policy builder callback), then that too should continue to work normally.\nThe one scenario where there might be a conflict between your use of the ASP.NET Core CORS services and IdentityServer is if you decide to create a custom ICorsPolicyProvider. Given the design of the ASP.NET Core\u0026rsquo;s CORS services and middleware, IdentityServer implements its own custom ICorsPolicyProvider and registers it in the DI system. Fortunately, the IdentityServer implementation is designed to use the decorator pattern to wrap any existing ICorsPolicyProvider that is already registered in DI. What this means is that you can also implement the ICorsPolicyProvider, but it simply needs to be registered prior to IdentityServer in DI (e.g. in ConfigureServices).\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/reference/",
    "title": "Reference",
    "tags": [],
    "description": "",
    "content": "Reference IdentityServer Options DI Extension Methods Endpoints Models Services Response Generators Stores Validators "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v5/samples/misc/",
    "title": "Miscellaneous",
    "tags": [],
    "description": "",
    "content": "WebForms client This sample shows how to add OpenID Connect code flow with PKCE to a .NET 4.8 WebForms client.\nlink to source code\nSecuring Azure Functions This sample shows how to parse and validate a JWT token issued by IdentityServer inside an Azure Function.\nlink to source code\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/",
    "title": "IdentityServer (v6)",
    "tags": [],
    "description": "",
    "content": "Duende IdentityServer v6 Documentation The most flexible \u0026amp; standards-compliant OpenID Connect and OAuth 2.0 framework for ASP.NET Core.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/endpoints/discovery/",
    "title": "Discovery Endpoint",
    "tags": [],
    "description": "",
    "content": "The discovery endpoint can be used to retrieve metadata about your IdentityServer - it returns information like the issuer name, key material, supported scopes etc.\nThe discovery endpoint is available via /.well-known/openid-configuration relative to the base address, e.g.:\nhttps://demo.duendesoftware.com/.well-known/openid-configuration .NET client library You can use the IdentityModel client library to programmatically interact with the protocol endpoint from .NET code.\nvar client = new HttpClient(); var disco = await client.GetDiscoveryDocumentAsync(\u0026#34;https://demo.duendesoftware.com\u0026#34;); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/overview/",
    "title": "Overview",
    "tags": [],
    "description": "BFF",
    "content": "Duende.BFF is a library for building services that solve security and identity problems in browser based applications such as SPAs and Blazor WASM applications. It is used to create a backend host that is paired with a frontend application. This backend is called the Backend For Frontend (BFF) host, and is responsible for all of the OAuth and OIDC protocol interactions. Moving the protocol handling out of JavaScript provides important security benefits and works around changes in browser privacy rules that increasingly disrupt OAuth and OIDC protocol flows in browser based applications. The Duende.BFF library makes it easy to build and secure BFF hosts by providing session and token management, API endpoint protection, and logout notifications.\nThreats against browser based applications Browser based applications have a relatively large attack surface. Security risks come not only from the application\u0026rsquo;s own code, which must be protected against cross site scripting, cross site request forgery, and other vulnerabilities, but also from the frameworks, libraries, and other NPM packages it uses, as well as all of their transitive dependencies. Additionally, other applications running on the same site must also be secured. The recent Spectre attacks against browsers serve as a reminder that new threats are constantly emerging. Given all of these risks, we do not recommend storing high-value access tokens or refresh tokens in JavaScript-accessible locations.\nIn Duende.BFF, tokens are only accessible server-side and sessions are managed using encrypted and signed HTTP-only cookies. This greatly simplifies the threat model and reduces risk. While content injection attacks are still possible, the BFF limits the attacker\u0026rsquo;s ability to abuse APIs by constraining access through a well-defined interface to the backend which eliminates the possibility of arbitrary API calls.\nChanges in browser privacy rules Browsers are increasingly restricting the use of cookies across site boundaries to protect user privacy. This can be a problem for legitimate OAuth and OpenID Connect interactions, as some interactions in these protocols are indistinguishable from common tracking mechanisms from a browser\u0026rsquo;s perspective. When the identity provider and client application are hosted on 3rd party sites, this affects several flows, including:\nFront-channel logout notifications OpenID Connect Session Management The \u0026ldquo;silent renew\u0026rdquo; technique for session-bound token refreshing Using a BFF removes or mitigates all of these problems in the design. The backend component makes backchannel logout notifications possible, while still allowing the option of front-channel notifications for 1st party clients. Robust server-side session and token management with optional server-side sessions and refresh tokens take the place of OIDC Session Management and older token refresh mechanisms. As an ASP.NET Core server-side application, the BFF has access to a full featured and stable OpenID Connect client library that supports all the necessary protocol mechanisms and provides an excellent extensibility model for advanced features like Mutual TLS, DPoP, JWT secured authorization requests, and JWT-based client authentication.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/quickstarts/0_overview/",
    "title": "Overview",
    "tags": [],
    "description": "Quickstarts",
    "content": "The quickstarts provide step-by-step instructions for various common Duende IdentityServer scenarios. They start with the absolute basics and become more complex - it is recommended you do them in order.\nadding Duende IdentityServer to an ASP.NET Core application configuring Duende IdentityServer issuing tokens for various clients securing web applications and APIs adding support for EntityFramework based configuration adding support for ASP.NET Identity Every quickstart has a reference solution - you can find the code in the samples folder.\nPreparation The first thing you should do is install our templates:\ndotnet new --install Duende.IdentityServer.Templates They will be used as a starting point for the various tutorials.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/tokens/authentication/overview/",
    "title": "Overview",
    "tags": [],
    "description": "Client Authentication",
    "content": "Confidential and credentialed clients need to authenticate with your IdentityServer before they can request tokens.\nDuende IdentityServer has built-in support for various client credential types and authentication methods, and an extensible infrastructure to customize the authentication system.\nAll information in this section also applies to API secrets for introspection.\nWe recommend using asymmetric client credentials like the private key jwt or Mutual TLS authentication method over shared secrets.\nAssigning secrets A client secret is abstracted by the Secret class. It provides properties for setting the value and type as well as a description and expiration date.\nvar secret = new Secret { Value = \u0026#34;foo\u0026#34;, Type = \u0026#34;bar\u0026#34;, Description = \u0026#34;my custom secret\u0026#34;, Expiration = new DateTime(2021,12,31) } You can assign multiple secrets to a client to enable roll-over scenarios, e.g.:\nvar primary = new Secret(\u0026#34;foo\u0026#34;); var secondary = new Secret(\u0026#34;bar\u0026#34;); client.ClientSecrets = new[] { primary, secondary }; Secret parsing During request processing, the secret must be somehow extracted from the incoming request. The various specs describe a couple of options, e.g. as part of the authorization header or the body payload.\nIt is the job of implementations of the ISecretParser interface to accomplish this. You can add secret parsers by calling the AddSecretParser() DI extension method.\nThe following secret parsers are part of Duende IdentityServer:\nDuende.IdentityServer.Validation.BasicAuthenticationSecretParser\nparses an OAuth basic authentication formatted Authorization header. Enabled by default.\nDuende.IdentityServer.Validation.PostBodySecretParser\nParses from the client_id and client_secret body fields. Enabled by default.\nDuende.IdentityServer.Validation.JwtBearerClientAssertionSecretParser\nParses a JWT on the client_assertion body field. Can be enabled by calling the AddJwtBearerClientAuthentication DI extension method.\nDuende.IdentityServer.Validation.MutualTlsSecretParser\nParses the client_id body field and TLS client certificate. Can be enabled by calling the AddMutualTlsSecretValidators DI extension method.\nSecret validation It is the job of implementations of the ISecretValidator interface to validate the extracted credentials.\nYou can add secret parsers by calling the AddSecretValidator() DI extension method.\nThe following secret validators are part of Duende IdentityServer:\nDuende.IdentityServer.Validation.HashedSharedSecretValidator\nValidates shared secrets that are stored hashed. Enabled by default.\nDuende.IdentityServer.Validation.PlainTextSharedSecretValidator\nValidates shared secrets that are stored in plaintext.\nDuende.IdentityServer.Validation.PrivateKeyJwtSecretValidator\nValidates JWTs that are signed with either X.509 certificates or keys wrapped in a JWK. Can be enabled by calling the AddJwtBearerClientAuthentication DI extension method.\nDuende.IdentityServer.Validation.X509ThumbprintSecretValidator\nValidates X.509 client certificates based on a thumbprint. Can be enabled by calling the AddMutualTlsSecretValidators DI extension method.\nDuende.IdentityServer.Validation.X509NameSecretValidator\nValidates X.509 client certificates based on a common name. Can be enabled by calling the AddMutualTlsSecretValidators DI extension method.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/tokens/overview/",
    "title": "Overview",
    "tags": [],
    "description": "Tokens",
    "content": "Duende IdentityServer is a token service engine based on OAuth 2.x and OpenID Connect.\nHow to request tokens OIDC and OAuth contain two endpoints that can issue tokens - the authorize endpoint and the token endpoint.\nWhile the authorize endpoint can be used for some special cases, you typically use the token endpoint for issuing tokens.\nToken Types The following token types are supported.\nIdentity Token During user authentication, your IdentityServer collects data about the user, e.g. authentication method, authentication time, some protocol information and a unique identifier for the user that was authenticated, to communicate back to the client application “what happened at the token service”.\nThis data must be sent in a format that is both tamper proof and that allows the client to authenticate the issuer. In OIDC this format is JSON – and the way to add the above security properties to a JSON object is by wrapping it in a JWT (along with JWS, JWA and JWK) – hence the name identity token.\nThe data includes token lifetime information (exp, iat, nbf), the authentication method (amr) and time (auth_time), the authentication source (idp), the session ID (sid) and information about the user (sub and name).\n{ \u0026#34;iss\u0026#34;: \u0026#34;https://localhost:5001\u0026#34;, \u0026#34;nbf\u0026#34;: 1609932802, \u0026#34;iat\u0026#34;: 1609932802, \u0026#34;exp\u0026#34;: 1609933102, \u0026#34;aud\u0026#34;: \u0026#34;web_app\u0026#34;, \u0026#34;amr\u0026#34;: [ \u0026#34;pwd\u0026#34; ], \u0026#34;nonce\u0026#34;: \u0026#34;63745529591...I3ZTIyOTZmZTNj\u0026#34;, \u0026#34;sid\u0026#34;: \u0026#34;F6E6F2EDE86EB8731EF609A4FE40ED89\u0026#34;, \u0026#34;auth_time\u0026#34;: 1609932794, \u0026#34;idp\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;88421113\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Bob\u0026#34;, } This data is solely for the client application (the aud claim) that initiated the authentication request, and you never send it to an API to consume. The identity token also contains a nonce (a number used once) to make sure it is only consumed once at the client.\nSee the OpenID Connect specification for more information on identity tokens.\nAccess Token An access token is a data structure that allows a client to access a resource (e.g. an API - see the protecting APIs section for more details).\nThe data associated with an access token typically includes the client ID, the requested scopes, an expiration time, and user information in case of an interactive application. Access tokens come in two flavours: JSON Web Tokens (JWT) or reference tokens.\nIn the case of JWTs, all claims are embedded into the token itself, e.g.:\n{ \u0026#34;iss\u0026#34;: \u0026#34;https://localhost:5001\u0026#34;, \u0026#34;nbf\u0026#34;: 1609932801, \u0026#34;iat\u0026#34;: 1609932801, \u0026#34;exp\u0026#34;: 1609936401, \u0026#34;aud\u0026#34;: \u0026#34;urn:resource1\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;openid resource1.scope1 offline_access\u0026#34;, \u0026#34;amr\u0026#34;: [ \u0026#34;pwd\u0026#34; ], \u0026#34;client_id\u0026#34;: \u0026#34;web_app\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;88421113\u0026#34;, \u0026#34;auth_time\u0026#34;: 1609932794, \u0026#34;idp\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;sid\u0026#34;: \u0026#34;F6E6F2EDE86EB8731EF609A4FE40ED89\u0026#34;, \u0026#34;jti\u0026#34;: \u0026#34;2C56A356A306E64AFC7D2C6399E23A17\u0026#34; } A reference token does not contain any data, but is a pointer to the token data stored in the token service. Reference tokens allow for immediate revocation (by deleting the token data from your IdentityServer data store), whereas a JWT can only be invalidated via expiration.\nYou can control the access token format on a per-client basis using the AccessTokenType setting.\nSee the OAuth specification for more information on access tokens.\nRefresh Token Refresh tokens allow for token lifetime management of access tokens. Since an access token has a finite lifetime, the refresh token (usually with a significantly longer lifetime) can be used to request new access tokens. This mechanism serves three purposes\nit allows similar semantics as sliding expiration for cookies - just with access tokens lifetime management does not need to involve the end-user and thus provides a good UX refresh tokens can be revoked and thus provide a way to revoke long-lived API access (while allowing the above two features) See the OAuth specification for more information on refresh tokens.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/overview/big_picture/",
    "title": "The big Picture",
    "tags": [],
    "description": "",
    "content": "Most modern applications look more or less like this:\nThe most common interactions are:\nBrowsers communicate with web applications Web applications communicate with web APIs (sometimes on their own, sometimes on behalf of a user) Browser-based applications communicate with web APIs Native applications communicate with web APIs Server-based applications communicate with web APIs Web APIs communicate with web APIs (sometimes on their own, sometimes on behalf of a user) Typically each and every layer (front-end, middle-tier and back-end) has to protect resources and implement authentication and/or authorization – often against the same user store.\nOutsourcing these fundamental security functions to a security token service prevents duplicating that functionality across those applications and endpoints.\nRestructuring the application to support a security token service leads to the following architecture and protocols:\nSuch a design divides security concerns into two parts:\nAuthentication Authentication is needed when an application needs to know the identity of the current user. Typically these applications manage data on behalf of that user and need to make sure that this user can only access the data for which they are allowed. The most common example for that is (classic) web applications – but native and JS-based applications also have a need for authentication.\nThe most common authentication protocols are SAML2p, WS-Federation and OpenID Connect – SAML2p being the most popular and the most widely deployed.\nOpenID Connect is the newest of the three, but is considered to be the future because it has the most potential for modern applications. It was built for mobile application scenarios right from the start and is designed to be API friendly.\nAPI Access Applications have two fundamental ways with which they communicate with APIs – using the application identity, or delegating the user’s identity. Sometimes both methods need to be combined.\nOAuth2 is a protocol that allows applications to request access tokens from a security token service and use them to communicate with APIs. This delegation reduces complexity in both the client applications as well as the APIs since authentication and authorization can be centralized.\nOpenID Connect and OAuth 2.0 – better together OpenID Connect and OAuth 2.0 are very similar – in fact OpenID Connect is an extension on top of OAuth 2.0. The two fundamental security concerns, authentication and API access, are combined into a single protocol - often with a single round trip to the security token service.\nWe believe that the combination of OpenID Connect and OAuth 2.0 is the best approach to secure modern applications for the foreseeable future. Duende IdentityServer is an implementation of these two protocols and is highly optimized to solve the typical security problems of today’s mobile, native and web applications.\nHow Duende IdentityServer can help Duende IdentityServer is middleware that adds spec-compliant OpenID Connect and OAuth 2.0 endpoints to an arbitrary ASP.NET Core host.\nTypically, you build (or re-use) an application that contains login and logout pages (and optionally a consent page, depending on your needs) and add the IdentityServer middleware to that application. The middleware adds the necessary protocol heads to the application so that clients can talk to it using those standard protocols.\nThe hosting application can be as complex as you want, but we typically recommend to keep the attack surface as small as possible by including authentication/federation related UI only.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/overview/",
    "title": "Overview",
    "tags": [],
    "description": "IdentityServer",
    "content": "Overview The big Picture Terminology Supported Specifications Packaging and Builds Support and Issues Security best-practices Demo Server Glossary Resources "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/endpoints/authorize/",
    "title": "Authorize Endpoint",
    "tags": [],
    "description": "",
    "content": "The authorize endpoint can be used to request tokens or authorization codes via the browser. This process typically involves authentication of the end-user and optionally consent.\nIdentityServer supports a subset of the OpenID Connect and OAuth 2.0 authorize request parameters. For a full list, see here.\nRequired parameters client_id\nidentifier of the client\nscope\none or more registered scopes\nredirect_uri\nmust exactly match one of the allowed redirect URIs for that client\nresponse_type\nspecifies the response type\nid_token\ntoken\nid_token token\ncode\ncode id_token\ncode id_token token\nOptional parameters response_mode\nspecifies the response mode\nquery\nfragment\nform_post\nstate\nechos back the state value on the token response, this is for round tripping state between client and provider, correlating request and response and CSRF/replay protection. (recommended)\nnonce\nechos back the nonce value in the identity token (for replay protection)\nRequired when identity tokens is transmitted via the browser channel\nprompt\nnone\nno UI will be shown during the request. If this is not possible (e.g. because the user has to sign in or consent) an error is returned\nlogin\nthe login UI will be shown, even if the user is already signed-in and has a valid session\ncreate\nthe user registration UI will be shown, if the UserInteraction.CreateAccountUrl option is set (the option is null by default, which disables support for this prompt value)\ncode_challenge\nsends the code challenge for PKCE\ncode_challenge_method\nplain\nindicates that the challenge is using plain text (not recommended)\nS256\nindicates the challenge is hashed with SHA256\nlogin_hint\ncan be used to pre-fill the username field on the login page\nui_locales\ngives a hint about the desired display language of the login UI\nmax_age\nif the user\u0026rsquo;s logon session exceeds the max age (in seconds), the login UI will be shown\nacr_values\nallows passing in additional authentication related information - IdentityServer special cases the following proprietary acr_values:\nidp:name_of_idp\nbypasses the login/home realm screen and forwards the user directly to the selected identity provider (if allowed per client configuration)\ntenant:name_of_tenant\ncan be used to pass a tenant name to the login UI\nrequest\ninstead of providing all parameters as individual query string parameters, you can provide a subset or all of them as a JWT\nrequest_uri\nURL of a pre-packaged JWT containing request parameters\nGET /connect/authorize? client_id=client1\u0026amp; scope=openid email api1\u0026amp; response_type=id_token token\u0026amp; redirect_uri=https://myapp/callback\u0026amp; state=abc\u0026amp; nonce=xyz .NET client library You can use the IdentityModel client library to programmatically create authorize request URLs from .NET code.\nvar ru = new RequestUrl(\u0026#34;https://demo.duendesoftware.com/connect/authorize\u0026#34;); var url = ru.CreateAuthorizeUrl( clientId: \u0026#34;client\u0026#34;, responseType: \u0026#34;code\u0026#34;, redirectUri: \u0026#34;https://app.com/callback\u0026#34;, scope: \u0026#34;openid\u0026#34;); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/quickstarts/1_client_credentials/",
    "title": "Protecting an API using Client Credentials",
    "tags": [],
    "description": "",
    "content": "Welcome to the first quickstart for IdentityServer! To see the full list of quickstarts, please see Quickstarts Overview.\nThis first quickstart provides step-by-step instructions to set up IdentityServer in the most basic scenario: protecting APIs for server-to-server communication. You will create a solution containing three projects:\nAn Identity Server An API that requires authentication A client that accesses that API The client will request an access token from IdentityServer using its client ID and secret and then use the token to gain access to the API.\nSource Code Finished source code for each quickstart in this series is available in the Samples repository, and a reference implementation of this quickstart is available here.\nPreparation The IdentityServer templates for the dotnet CLI are a good starting point for the quickstarts. To install the templates open a console window and type the following command:\ndotnet new --install Duende.IdentityServer.Templates Create the Solution and IdentityServer Project In this section, you will create a directory for the solution and use the isempty (IdentityServer Empty) template to create an ASP.NET Core application that includes a basic IdentityServer setup.\nBack in the console, run the following commands to create the directory structure for the solution.\nmkdir quickstart cd quickstart mkdir src dotnet new sln -n Quickstart This will create a quickstart directory that will serve as the root of the solution, a src subdirectory to hold your source code, and a solution file to organize your projects. Throughout the rest of the quickstart series, paths will be written relative to to the quickstart directory.\nFrom the new quickstart directory, run the following commands to use the isempty template to create a new project. The template creates a web project named IdentityServer with the IdentityServer package installed and minimal configuration added for it.\ncd src dotnet new isempty -n IdentityServer This will create the following files within a new src/IdentityServer directory:\nIdentityServer.csproj - project file with the IdentityServer NuGet package added Properties/launchSettings.json file - launch profile appsettings.json - run time settings Program.cs - main application entry point HostingExtensions.cs - configuration for ASP.NET pipeline and services Notably, the IdentityServer services are configured here and the IdentityServer middleware is added to the pipeline here. Config.cs - definitions for resources and clients used by IdentityServer The src/IdentityServer/Properties/launchSettings.json file created by the isempty template sets the applicationUrl to https://localhost:5001. You can change the port that your IdentityServer host listens on by changing the port in this url. This url also sets the protocol (http or https) that the IdentityServer host will use. In production scenarios you should always use https.\nNext, add the IdentityServer project to the solution. Back in the console, navigate up to the quickstart directory and add the IdentityServer project to the solution.\ncd .. dotnet sln add ./src/IdentityServer/IdentityServer.csproj Defining an API Scope Scope is a core feature of OAuth that allows you to express the extent or scope of access. Clients request scopes when they initiate the protocol, declaring what scope of access they want. IdentityServer then has to decide which scopes to include in the token. Just because the client has asked for something doesn\u0026rsquo;t mean they should get it! There are built-in abstractions as well as extensibility points that you can use to make this decision. Ultimately, IdentityServer issues a token to the client, which then uses the token to access APIs. APIs can check the scopes that were included in the token to make authorization decisions.\nScopes don\u0026rsquo;t have structure imposed by the protocols - they are just space-separated strings. This allows for flexibility when designing the scopes used by a system. In this quickstart, you will create a scope that represents complete access to an API that will be created later in this quickstart.\nScope definitions can be loaded in many ways. This quickstart shows how to use a \u0026ldquo;code as configuration\u0026rdquo; approach. A minimal Config.cs was created by the template at src/IdentityServer/Config.cs. Open it and add an ApiScope to the ApiScopes property:\npublic static IEnumerable\u0026lt;ApiScope\u0026gt; ApiScopes =\u0026gt; new List\u0026lt;ApiScope\u0026gt; { new ApiScope(name: \u0026#34;api1\u0026#34;, displayName: \u0026#34;MyAPI\u0026#34;) }; See the full file here.\nIn production it is important to give your API a useful name and display name. Use these names to describe your API in simple terms to both developers and users. Developers will use the name to connect to your API, and end users will see the display name on consent screens, etc.\nDefining the client The next step is to configure a client application that you will use to access the API. You\u0026rsquo;ll create the client application project later in this quickstart. First, you\u0026rsquo;ll add configuration for it to your IdentityServer project.\nIn this quickstart, the client will not have an interactive user and will authenticate with IdentityServer using a client secret.\nAdd this client definition to Config.cs:\npublic static IEnumerable\u0026lt;Client\u0026gt; Clients =\u0026gt; new List\u0026lt;Client\u0026gt; { new Client { ClientId = \u0026#34;client\u0026#34;, // no interactive user, use the clientid/secret for authentication AllowedGrantTypes = GrantTypes.ClientCredentials, // secret for authentication ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, // scopes that client has access to AllowedScopes = { \u0026#34;api1\u0026#34; } } }; Again, see the full file here.\nClients can be configured with many options. Your minimal machine-to-machine client here contains\nA ClientId, which identifies the application to IdentityServer so that it knows which client is trying to connect to it. A Secret, which you can think of as the password for the client. The list of scopes that the client is allowed to ask for. Notice that the allowed scope here matches the name of the ApiScope above. Configuring IdentityServer The scope and client definitions are loaded in HostingExtensions.cs. The template created a ConfigureServices method there that is already loading the scopes and clients. You can take a look to see how it is done. Note that the template adds a few things that are not used in this quickstart. Here\u0026rsquo;s the minimal ConfigureServices method that is needed:\npublic static WebApplication ConfigureServices(this WebApplicationBuilder builder) { builder.Services.AddIdentityServer() .AddInMemoryApiScopes(Config.ApiScopes) .AddInMemoryClients(Config.Clients); return builder.Build(); } That\u0026rsquo;s it - your IdentityServer is now configured. If you run the project and then navigate to https://localhost:5001/.well-known/openid-configuration in your browser, you should see the discovery document. The discovery document is a standard endpoint in OpenID Connect and OAuth. It is used by your clients and APIs to retrieve configuration data needed to request and validate tokens, login and logout, etc.\nOn first startup, IdentityServer will use its automatic key management feature to create a signing key and store it in the src/IdentityServer/keys directory. To avoid accidentally disclosing cryptographic secrets, the entire keys directory should be excluded from source control. It will be recreated if it is not present.\nCreate an API Project Next, add an API project to your solution. This API will serve protected resources that will be secured by IdentityServer.\nYou can either use the ASP.NET Core Web API template from Visual Studio or use the .NET CLI to create the API project. To use the CLI, run the following command from the src directory:\ndotnet new webapi -n Api Then navigate back up to the root quickstart directory and add it to the solution by running the following commands:\ncd .. dotnet sln add ./src/Api/Api.csproj Add JWT Bearer Authentication Now you will add JWT Bearer Authentication to the API\u0026rsquo;s ASP.NET pipeline. The goal is to authorize calls to your API using tokens issued by the IdentityServer project. To that end, you will add authentication middleware to the pipeline from the Microsoft.AspNetCore.Authentication.JwtBearer NuGet package. This middleware will\nFind and parse a JWT sent with incoming requests as an Authorization: Bearer header. Validate the JWT\u0026rsquo;s signature to ensure that it was issued by IdentityServer. Validate that the JWT is not expired. Run this command in the src directory to install the middleware package in the Api:\ndotnet add ./Api/Api.csproj package Microsoft.AspNetCore.Authentication.JwtBearer Now add JWT Bearer authentication services to the Service Collection to allow for dependency injection (DI), and configure Bearer as the default Authentication Scheme.\nbuilder.Services.AddAuthentication(\u0026#34;Bearer\u0026#34;) .AddJwtBearer(\u0026#34;Bearer\u0026#34;, options =\u0026gt; { options.Authority = \u0026#34;https://localhost:5001\u0026#34;; options.TokenValidationParameters = new TokenValidationParameters { ValidateAudience = false }; }); Audience validation is disabled here because access to the api is modeled with ApiScopes only. By default, no audience will be emitted unless the api is modeled with ApiResources instead. See here for a more in-depth discussion.\nAdd authentication middleware to the pipeline immediately before authorization:\napp.UseAuthentication(); app.UseAuthorization(); UseAuthentication adds the authentication middleware to the pipeline so authentication will be performed automatically on every call into the host. UseAuthorization adds the authorization middleware to make sure your API endpoint cannot be accessed by anonymous clients.\nAdd a controller Add a new class called IdentityController in src/Api/Controllers:\n[Route(\u0026#34;identity\u0026#34;)] [Authorize] public class IdentityController : ControllerBase { [HttpGet] public IActionResult Get() { return new JsonResult(from c in User.Claims select new { c.Type, c.Value }); } } This controller will be used to test authorization and to display the claims identity through the eyes of the API. See the full file here.\nConfigure API to listen on Port 6001 Configure the API to run on https://localhost:6001 only. You can do this by editing the launchSettings.json file in the src/Api/Properties directory. Change the application URL setting to be:\n\u0026#34;applicationUrl\u0026#34;: \u0026#34;https://localhost:6001\u0026#34; Test the controller Run the API project and then navigate to the identity controller at https://localhost:6001/identity in a browser. This should return a 401 status code, which means your API requires a credential and is now protected by IdentityServer.\nCreate the client project The last step is to create a client that requests an access token and then uses that token to access the API. Your client will be a console project in your solution. From the quickstart/src directory, run the following command:\ndotnet new console -n Client Then as before, add it to your solution using:\ncd .. dotnet sln add ./src/Client/Client.csproj Add the IdentityModel NuGet package The token endpoint at IdentityServer implements the OAuth protocol, and you could use raw HTTP to access it. However, we have a client library called IdentityModel that encapsulates the protocol interaction in an easy to use API.\nAdd the IdentityModel NuGet package to your client. This can be done either via Visual Studio\u0026rsquo;s Nuget Package manager or dotnet CLI. From the quickstart directory, run the following command:\ndotnet add ./src/Client/Client.csproj package IdentityModel Retrieve the discovery document IdentityModel includes a client library to use with the discovery endpoint. This way you only need to know the base address of IdentityServer - the actual endpoint addresses can be read from the metadata. Add the following to the client\u0026rsquo;s Program.cs in the src/Client/Program.cs directory:\n// discover endpoints from metadata var client = new HttpClient(); var disco = await client.GetDiscoveryDocumentAsync(\u0026#34;https://localhost:5001\u0026#34;); if (disco.IsError) { Console.WriteLine(disco.Error); return; } If you get an error connecting it may be that you are running https and the development certificate for localhost is not trusted. You can run dotnet dev-certs https --trust in order to trust the development certificate. This only needs to be done once.\nRequest a token from IdentityServer Next you can use the information from the discovery document to request a token from IdentityServer to access api1:\n// request token var tokenResponse = await client.RequestClientCredentialsTokenAsync(new ClientCredentialsTokenRequest { Address = disco.TokenEndpoint, ClientId = \u0026#34;client\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Scope = \u0026#34;api1\u0026#34; }); if (tokenResponse.IsError) { Console.WriteLine(tokenResponse.Error); return; } Console.WriteLine(tokenResponse.AccessToken); Copy and paste the access token from the console to jwt.ms to inspect the raw token.\nCalling the API To send the access token to the API you typically use the HTTP Authorization header. This is done using the SetBearerToken extension method:\n// call api var apiClient = new HttpClient(); apiClient.SetBearerToken(tokenResponse.AccessToken); var response = await apiClient.GetAsync(\u0026#34;https://localhost:6001/identity\u0026#34;); if (!response.IsSuccessStatusCode) { Console.WriteLine(response.StatusCode); } else { var doc = JsonDocument.Parse(await response.Content.ReadAsStringAsync()).RootElement; Console.WriteLine(JsonSerializer.Serialize(doc, new JsonSerializerOptions { WriteIndented = true })); } The completed Program.cs file can be found here.\nTo test the flow, start the IdentityServer and API projects. Once they are running, run the Client project.\nThe output should look like this:\nIf you\u0026rsquo;re using Visual Studio, here\u0026rsquo;s how to start everything up:\nRight click the solution and select Set Startup Projects Choose Multiple Startup Projects and set the action for Api and IdentityServer to Start Run the solution and wait a moment for both the API and and IdentityServer to start Right click the Client project and select Debug\u0026hellip; Start New Instance. By default an access token will contain claims about the scope, lifetime (nbf and exp), the client ID (client_id) and the issuer name (iss).\nAuthorization at the API Right now, the API accepts any access token issued by your IdentityServer. In this section, you will add an Authorization Policy to the API that will check for the presence of the \u0026ldquo;api1\u0026rdquo; scope in the access token. The protocol ensures that this scope will only be in the token if the client requests it and IdentityServer allows the client to have that scope. You configured IdentityServer to allow this access by including it in the allowedScopes property. Add the following to the ConfigureServices method in the API\u0026rsquo;s Program.cs file:\nbuilder.Services.AddAuthorization(options =\u0026gt; { options.AddPolicy(\u0026#34;ApiScope\u0026#34;, policy =\u0026gt; { policy.RequireAuthenticatedUser(); policy.RequireClaim(\u0026#34;scope\u0026#34;, \u0026#34;api1\u0026#34;); }); }); You can now enforce this policy at various levels, e.g.:\nglobally for all API endpoints for specific controllers/actions Typically you set the policy for all controllers where they are mapped in src/Api/Program.cs:\napp.MapControllers().RequireAuthorization(\u0026#34;ApiScope\u0026#34;); Further experiments This quickstart focused on the success path:\nThe client was able to request a token. The client could use the token to access the API. You can now try to provoke errors to learn how the system behaves, e.g.:\nTry to connect to IdentityServer when it is not running (unavailable). Try to use an invalid client id or secret to request the token. Try to ask for an invalid scope during the token request. Try to call the API when it is not running (unavailable). Don\u0026rsquo;t send the token to the API. Configure the API to require a different scope than the one in the token. "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/quickstarts/2_interactive/",
    "title": "Interactive Applications with ASP.NET Core",
    "tags": [],
    "description": "",
    "content": "Welcome to Quickstart 2 for Duende IdentityServer!\nIn this quickstart, you will add support for interactive user authentication via the OpenID Connect protocol to the IdentityServer you built in Quickstart 1. Once that is in place, you will create an ASP.NET Razor Pages application that will use IdentityServer for authentication.\nWe recommend you do the quickstarts in order. If you\u0026rsquo;d like to start here, begin from a copy of the reference implementation of Quickstart 1. Throughout this quickstart, paths are written relative to the base quickstart directory created in part 1, which is the root directory of the reference implementation. You will also need to install the IdentityServer templates.\nEnable OIDC in IdentityServer To enable OIDC in IdentityServer you need:\nAn interactive UI Configuration for OIDC scopes Configuration for an OIDC client Users to log in with Add the UI Support for the OpenID Connect protocol is already built into IdentityServer. You need to provide the User Interface for login, logout, consent and error.\nWhile the look \u0026amp; feel and workflows will differ in each implementation, we provide a Razor Pages-based UI that you can use as a starting point. You can use the .NET CLI to add the quickstart UI to a project. Run the following command from the src/IdentityServer directory:\ndotnet new isui Enable the UI Once you have added the UI, you will need to register its services and enable it in the pipeline. In src/IdentityServer/HostingExtensions.cs you will find commented out code in the ConfigureServices and ConfigurePipeline methods that enable the UI. Note that there are three places to comment in - two in ConfigurePipeline and one in ConfigureServices.\nThere is also a template called isinmem which combines the basic IdentityServer from the isempty template with the quickstart UI from the isui template.\nComment in the service registration and pipeline configuration, run the IdentityServer project, and navigate to https://localhost:5001. You should now see a home page.\nSpend some time reading the pages and models, especially those in the src/IdentityServer/Pages/Account directory. These pages are the main UI entry points for login and logout. The better you understand them, the easier it will be to make future modifications.\nConfigure OIDC Scopes Similar to OAuth, OpenID Connect uses scopes to represent something you want to protect and that clients want to access. In contrast to OAuth, scopes in OIDC represent identity data like user id, name or email address rather than APIs.\nAdd support for the standard openid (subject id) and profile (first name, last name, etc) scopes by declaring them in src/IdentityServer/Config.cs:\npublic static IEnumerable\u0026lt;IdentityResource\u0026gt; IdentityResources =\u0026gt; new List\u0026lt;IdentityResource\u0026gt; { new IdentityResources.OpenId(), new IdentityResources.Profile(), }; Then register the identity resources in src/IdentityServer/HostingExtensions.cs:\nbuilder.Services.AddIdentityServer() .AddInMemoryIdentityResources(Config.IdentityResources) .AddInMemoryApiScopes(Config.ApiScopes) .AddInMemoryClients(Config.Clients); All standard scopes and their corresponding claims can be found in the OpenID Connect specification.\nAdd Test Users The sample UI also comes with an in-memory \u0026ldquo;user database\u0026rdquo;. You can enable this by calling AddTestUsers in src/IdentityServer/HostingExtensions.cs:\nbuilder.Services.AddIdentityServer() .AddInMemoryIdentityResources(Config.IdentityResources) .AddInMemoryApiScopes(Config.ApiScopes) .AddInMemoryClients(Config.Clients) .AddTestUsers(TestUsers.Users); In the TestUsers class, you can see that two users called alice and bob are defined with some identity claims. You can use those users to login. Note that the test users\u0026rsquo; passwords match their usernames.\nRegister an OIDC client The last step in the IdentityServer project is to add a new configuration entry for a client that will use OIDC to log in. You will create the application code for this client in the next section. For now, you will register its configuration.\nOpenID Connect-based clients are very similar to the OAuth clients we added in Quickstart 1. But since the flows in OIDC are always interactive, we need to add some redirect URLs to our configuration.\nThe Clients list in src/IdentityServer/Config.cs should look like this:\npublic static IEnumerable\u0026lt;Client\u0026gt; Clients =\u0026gt; new List\u0026lt;Client\u0026gt; { // machine to machine client (from quickstart 1) new Client { ClientId = \u0026#34;client\u0026#34;, ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, AllowedGrantTypes = GrantTypes.ClientCredentials, // scopes that client has access to AllowedScopes = { \u0026#34;api1\u0026#34; } }, // interactive ASP.NET Core Web App new Client { ClientId = \u0026#34;web\u0026#34;, ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, AllowedGrantTypes = GrantTypes.Code, // where to redirect to after login RedirectUris = { \u0026#34;https://localhost:5002/signin-oidc\u0026#34; }, // where to redirect to after logout PostLogoutRedirectUris = { \u0026#34;https://localhost:5002/signout-callback-oidc\u0026#34; }, AllowedScopes = new List\u0026lt;string\u0026gt; { IdentityServerConstants.StandardScopes.OpenId, IdentityServerConstants.StandardScopes.Profile } } }; Create the OIDC client Next you will create an ASP.NET web application that will allow interactive users to log in using OIDC. Use the webapp template to create the project. Run the following commands from the src directory:\ndotnet new webapp -n WebClient cd .. dotnet sln add ./src/WebClient/WebClient.csproj This version of the quickstarts uses Razor Pages for the web client. If you prefer MVC, the conversion is straightforward. See the quickstart for IdentityServer 5 that uses it.\nInstall the OIDC NuGet Package To add support for OpenID Connect authentication to the WebClient project, you need to add the NuGet package containing the OpenID Connect handler. From the src/WebClient directory, run the following command:\ndotnet add package Microsoft.AspNetCore.Authentication.OpenIdConnect Configure Authentication Services Then add the following to ConfigureServices in src/WebClient/Program.cs:\nusing System.IdentityModel.Tokens.Jwt; // ... JwtSecurityTokenHandler.DefaultMapInboundClaims = false; builder.Services.AddAuthentication(options =\u0026gt; { options.DefaultScheme = \u0026#34;Cookies\u0026#34;; options.DefaultChallengeScheme = \u0026#34;oidc\u0026#34;; }) .AddCookie(\u0026#34;Cookies\u0026#34;) .AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { options.Authority = \u0026#34;https://localhost:5001\u0026#34;; options.ClientId = \u0026#34;web\u0026#34;; options.ClientSecret = \u0026#34;secret\u0026#34;; options.ResponseType = \u0026#34;code\u0026#34;; options.Scope.Clear(); options.Scope.Add(\u0026#34;openid\u0026#34;); options.Scope.Add(\u0026#34;profile\u0026#34;); options.SaveTokens = true; }); If you are unfamiliar with the fundamentals of how the ASP.NET Core authentication system works, then we recommend this recording of an Introduction to ASP.NET Core Authentication and Authorization.\nAddAuthentication registers the authentication services. Notice that in its options, the DefaultChallengeScheme is set to \u0026ldquo;oidc\u0026rdquo;, and the DefaultScheme is set to \u0026ldquo;Cookies\u0026rdquo;. The DefaultChallengeScheme is used when an unauthenticated user must log in. This begins the OpenID Connect protocol, redirecting the user to IdentityServer. After the user has logged in and been redirected back to the client, the client creates its own local cookie. Subsequent requests to the client will include this cookie and be authenticated with the default Cookie scheme.\nAfter the call to AddAuthentication, AddCookie adds the handler that can process the local cookie.\nFinally, AddOpenIdConnect is used to configure the handler that performs the OpenID Connect protocol. The Authority indicates where the trusted token service is located. The ClientId and the ClientSecret identify this client. The Scope is the collection of scopes that the client will request. By default it includes the openid and profile scopes, but clear the collection and add them back for explicit clarity. SaveTokens is used to persist the tokens in the cookie (as they will be needed later).\nThis uses the authorization code flow with PKCE to connect to the OpenID Connect provider. See here for more information on protocol flows.\nConfigure the Pipeline Now add UseAuthentication to the ASP.NET pipeline in src/WebClient/Program.cs. Also chain a call to RequireAuthorization onto MapRazorPages to disable anonymous access for the entire application.\napp.UseRouting(); app.UseAuthentication(); app.UseAuthorization(); app.MapRazorPages().RequireAuthorization(); See the ASP.NET Core documentation on Razor Pages authorization conventions for more options that allow you to specify authorization on a per page or directory basis.\nDisplay the Auth Cookie Modify src/WebClient/Pages/Index.cshtml to display the claims of the user and the cookie properties:\n@page @model IndexModel @using Microsoft.AspNetCore.Authentication \u0026lt;h2\u0026gt;Claims\u0026lt;/h2\u0026gt; \u0026lt;dl\u0026gt; @foreach (var claim in User.Claims) { \u0026lt;dt\u0026gt;@claim.Type\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;@claim.Value\u0026lt;/dd\u0026gt; } \u0026lt;/dl\u0026gt; \u0026lt;h2\u0026gt;Properties\u0026lt;/h2\u0026gt; \u0026lt;dl\u0026gt; @foreach (var prop in (await HttpContext.AuthenticateAsync()).Properties.Items) { \u0026lt;dt\u0026gt;@prop.Key\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;@prop.Value\u0026lt;/dd\u0026gt; } \u0026lt;/dl\u0026gt; Configure WebClient\u0026rsquo;s Port Update the client\u0026rsquo;s applicationUrl in src/WebClient/Properties/launchSettings.json to use port 5002.\n{ \u0026#34;profiles\u0026#34;: { \u0026#34;WebClient\u0026#34;: { \u0026#34;commandName\u0026#34;: \u0026#34;Project\u0026#34;, \u0026#34;dotnetRunMessages\u0026#34;: true, \u0026#34;launchBrowser\u0026#34;: true, \u0026#34;applicationUrl\u0026#34;: \u0026#34;https://localhost:5002\u0026#34;, \u0026#34;environmentVariables\u0026#34;: { \u0026#34;ASPNETCORE_ENVIRONMENT\u0026#34;: \u0026#34;Development\u0026#34; } } } } Test the client Now everything should be in place to log in to WebClient using OIDC. Run IdentityServer and WebClient and then trigger the authentication handshake by navigating to the protected home page. You should see a redirect to the login page in IdentityServer.\nAfter you log in, IdentityServer will redirect back to WebClient, where the OpenID Connect authentication handler will process the response and sign-in the user locally by setting a cookie. Finally the WebClient\u0026rsquo;s page will show the contents of the cookie.\nAs you can see, the cookie has two parts: the claims of the user and some metadata in the properties. This metadata also contains the original access and id tokens issued by IdentityServer. Feel free to copy these tokens to jwt.ms to inspect their content.\nAdding sign-out Next you will add sign-out to WebClient.\nTo sign out, you need to\nClear local application cookies Make a roundtrip to IdentityServer using the OIDC protocol to clear its session The cookie auth handler will clear the local cookie when you sign out from its authentication scheme. The OpenId Connect handler will perform the protocol steps for the roundtrip to IdentityServer when you sign out of its scheme.\nCreate a page to trigger sign-out of both schemes by running the following command from the src/WebClient/Pages directory:\ndotnet new page -n Signout Update the new page\u0026rsquo;s model (src/WebClient/Pages/Signout.cshtml.cs) with the following code:\npublic class SignoutModel : PageModel { public IActionResult OnGet() { return SignOut(\u0026#34;Cookies\u0026#34;, \u0026#34;oidc\u0026#34;); } } This will clear the local cookie and then redirect to the IdentityServer. The IdentityServer will clear its cookies and then give the user a link to return back to the web application.\nCreate a link to the logout page in src/WebClient/Pages/Shared/_Layout.cshtml within the navbar-nav list:\n\u0026lt;!-- Existing navbar generated by template --\u0026gt; \u0026lt;ul class=\u0026#34;navbar-nav flex-grow-1\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link text-dark\u0026#34; asp-area=\u0026#34;\u0026#34; asp-page=\u0026#34;/Index\u0026#34;\u0026gt;Home\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link text-dark\u0026#34; asp-area=\u0026#34;\u0026#34; asp-page=\u0026#34;/Privacy\u0026#34;\u0026gt;Privacy\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;!-- Add this item to the list --\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link text-dark\u0026#34; asp-area=\u0026#34;\u0026#34; asp-page=\u0026#34;/Signout\u0026#34;\u0026gt;Signout\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; Getting claims from the UserInfo endpoint You might have noticed that even though you\u0026rsquo;ve configured the client to be allowed to retrieve the profile identity scope, the claims associated with that scope (such as name, family_name, website etc.) don\u0026rsquo;t appear in the returned token. You need to tell the client to retrieve those claims from the userinfo endpoint by specifying scopes that the client application needs to access and setting the GetClaimsFromUserInfoEndpoint option. Add the following to ConfigureServices in src/WebClient/Program.cs:\n.AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { // ... options.Scope.Clear(); options.Scope.Add(\u0026#34;openid\u0026#34;); options.Scope.Add(\u0026#34;profile\u0026#34;); options.GetClaimsFromUserInfoEndpoint = true; // ... }); After restarting the client app, logging out, and logging back in, you should see additional user claims associated with the profile identity scope displayed on the page.\nFurther Experiments This quickstart created a client with interactive login using OIDC. To experiment further you can\nAdd additional claims to the identity Add support for external authentication Add More Claims To add more claims to the identity:\nAdd a new identity resource to the list in src/IdentityServer/Config.cs. Name it and specify which claims should be returned when it is requested. The Name property of the resource is the scope value that clients can request to get the associated UserClaims. For example, you could add an IdentityResource named \u0026ldquo;verification\u0026rdquo; which would include the email and email_verified claims.\npublic static IEnumerable\u0026lt;IdentityResource\u0026gt; IdentityResources =\u0026gt; new List\u0026lt;IdentityResource\u0026gt; { new IdentityResources.OpenId(), new IdentityResources.Profile(), new IdentityResource() { Name = \u0026#34;verification\u0026#34;, UserClaims = new List\u0026lt;string\u0026gt; { JwtClaimTypes.Email, JwtClaimTypes.EmailVerified } } }; Give the client access to the resource via the AllowedScopes property on the client configuration in src/IdentityServer/Config.cs. The string value in AllowedScopes must match the Name property of the resource.\nnew Client { ClientId = \u0026#34;web\u0026#34;, //... AllowedScopes = new List\u0026lt;string\u0026gt; { IdentityServerConstants.StandardScopes.OpenId, IdentityServerConstants.StandardScopes.Profile, \u0026#34;verification\u0026#34; } } Request the resource by adding it to the Scopes collection on the OpenID Connect handler configuration in src/WebClient/Program.cs, and add a ClaimAction to map the new claim returned from the userinfo endpoint onto a user claim.\n.AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { // ... options.Scope.Add(\u0026#34;verification\u0026#34;); options.ClaimActions.MapJsonKey(\u0026#34;email_verified\u0026#34;, \u0026#34;email_verified\u0026#34;); // ... } IdentityServer uses the IProfileService to retrieve claims for tokens and the userinfo endpoint. You can provide your own implementation of IProfileService to customize this process with custom logic, data access, etc. Since you are using AddTestUsers, the TestUserProfileService is used automatically. It will automatically include requested claims from the test users added in src/IdentityServer/TestUsers.cs.\nAdd Support for External Authentication Adding support for external authentication to your IdentityServer can be done with very little code; all that is needed is an authentication handler.\nASP.NET Core ships with handlers for Google, Facebook, Twitter, Microsoft Account and OpenID Connect. In addition, you can find handlers for many other authentication providers here.\nAdd Google support To use Google for authentication, you need to:\nAdd the Microsoft.AspNetCore.Authentication.Google NuGet package to the IdentityServer project. Register with Google and set up a client. Store the client id and secret securely with dotnet user-secrets. Add the Google authentication handler to the middleware pipeline and configure it. See Microsoft\u0026rsquo;s guide for details on how to register with Google, create the client, and store the secrets in user-secrets. Stop before adding the authentication middleware and Google authentication handler to the pipeline. You will need an IdentityServer specific option.\nAdd the following to ConfigureServices in src/IdentityServer/HostingExtensions.cs:\nbuilder.Services.AddAuthentication() .AddGoogle(\u0026#34;Google\u0026#34;, options =\u0026gt; { options.SignInScheme = IdentityServerConstants.ExternalCookieAuthenticationScheme; options.ClientId = builder.Configuration[\u0026#34;Authentication:Google:ClientId\u0026#34;]; options.ClientSecret = builder.Configuration[\u0026#34;Authentication:Google:ClientSecret\u0026#34;]; }); When authenticating with Google, there are again two authentication schemes. AddGoogle adds the Google scheme, which handles the protocol flow back and forth with Google. After successful login, the application needs to sign in to an additional scheme that can authenticate future requests without needing a roundtrip to Google - typically by issuing a local cookie. The SignInScheme tells the Google handler to use the scheme named IdentityServerConstants.ExternalCookieAuthenticationScheme, which is a cookie authentication handler automatically created by IdentityServer that is intended for external logins.\nNow run IdentityServer and WebClient and try to authenticate (you may need to log out and log back in). You will see a Google button on the login page.\nClick on Google and authenticate with a Google account. You should land back on the WebClient home page, showing that the user is now coming from Google with claims sourced from Google\u0026rsquo;s data.\nThe Google button is rendered by the login page automatically when there are external providers registered as authentication schemes. See the BuildModelAsync method in src/IdentityServer/Pages/Login/Index.cshtml.cs and the corresponding Razor template for more details.\nAdding an additional OpenID Connect-based external provider A cloud-hosted demo version of Duende IdentityServer can be added as an additional external provider.\nRegister and configure the services for the OpenId Connect handler in src/IdentityServer/HostingExtensions.cs:\nbuilder.Services.AddAuthentication() .AddGoogle(\u0026#34;Google\u0026#34;, options =\u0026gt; { /* ... */ }) .AddOpenIdConnect(\u0026#34;oidc\u0026#34;, \u0026#34;Demo IdentityServer\u0026#34;, options =\u0026gt; { options.SignInScheme = IdentityServerConstants.ExternalCookieAuthenticationScheme; options.SignOutScheme = IdentityServerConstants.SignoutScheme; options.SaveTokens = true; options.Authority = \u0026#34;https://demo.duendesoftware.com\u0026#34;; options.ClientId = \u0026#34;interactive.confidential\u0026#34;; options.ClientSecret = \u0026#34;secret\u0026#34;; options.ResponseType = \u0026#34;code\u0026#34;; options.TokenValidationParameters = new TokenValidationParameters { NameClaimType = \u0026#34;name\u0026#34;, RoleClaimType = \u0026#34;role\u0026#34; }; }); Now if you try to authenticate, you should see an additional button to log in to the cloud-hosted Demo IdentityServer. If you click that button, you will be redirected to https://demo.duendesoftware.com/. Note that the demo site is using the same UI as your site, so there will not be very much that changes visually when you\u0026rsquo;re redirected. Check that the page\u0026rsquo;s location has changed and then log in using the alice or bob users (their passwords are their usernames, just as they are for the local test users). You should land back at WebClient, authenticated with a demo user.\nThe demo users are logically distinct entities from the local test users, even though they happen to have identical usernames. Inspect their claims in WebClient and note the differences between them, such as the distinct sub claims.\nThe quickstart UI auto-provisions external users. When an external user logs in for the first time, a new local user is created with a copy of all the external user\u0026rsquo;s claims. This auto-provisioning process occurs in the OnGet method of src/IdentityServer/Pages/ExternalLogin/Callback.cshtml.cs, and is completely customizable. For example, you could modify Callback so that it will require registration before provisioning the external user.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/endpoints/token/",
    "title": "Token Endpoint",
    "tags": [],
    "description": "",
    "content": "The token endpoint can be used to programmatically request tokens.\nDuende IdentityServer supports a subset of the OpenID Connect and OAuth 2.0 token request parameters. For a full list, see here.\nRequired parameters client_id\nclient identifier; not necessary in body if it is present in the authorization header\ngrant_type\nauthorization_code\nclient_credentials\npassword\nrefresh_token\nurn:ietf:params:oauth:grant-type:device_code\nextension grant\nOptional parameters client_secret\nclient secret for confidential/credentials clients - either in the post body, or as a basic authentication header.\nscope\none or more registered scopes. If not specified, a token for all explicitly allowed scopes will be issued.\nredirect_uri\nrequired for the authorization_code grant type\ncode\nthe authorization code (required for authorization_code grant type)\ncode_verifier\nPKCE proof key\nusername\nresource owner username (required for password grant type)\npassword\nresource owner password (required for password grant type)\nacr_values\nallows passing in additional authentication related information. Duende IdentityServer special cases the following proprietary acr_values\ntenant:name_of_tenant\ncan be used to pass a tenant name to the token endpoint\nrefresh_token\nthe refresh token (required for refresh_token grant type)\ndevice_code\nthe device code (required for urn:ietf:params:oauth:grant-type:device_code grant type)\nauth_req_id\nthe backchannel authentication request id (required for urn:openid:params:grant-type:ciba grant type)\nPOST /connect/token CONTENT-TYPE application/x-www-form-urlencoded client_id=client1\u0026amp; client_secret=secret\u0026amp; grant_type=authorization_code\u0026amp; code=hdh922\u0026amp; redirect_uri=https://myapp.com/callback .NET client library You can use the IdentityModel client library to programmatically interact with the protocol endpoint from .NET code.\nusing IdentityModel.Client; var client = new HttpClient(); var response = await client.RequestAuthorizationCodeTokenAsync(new AuthorizationCodeTokenRequest { Address = TokenEndpoint, ClientId = \u0026#34;client\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Code = \u0026#34;...\u0026#34;, CodeVerifier = \u0026#34;...\u0026#34;, RedirectUri = \u0026#34;https://app.com/callback\u0026#34; }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/quickstarts/3_api_access/",
    "title": "ASP.NET Core and API access",
    "tags": [],
    "description": "",
    "content": "Welcome to Quickstart 3 for Duende IdentityServer!\nThe previous quickstarts introduced API access and user authentication. This quickstart will bring the two together.\nOpenID Connect and OAuth combine elegantly; you can achieve both user authentication and api access in a single exchange with the token service.\nIn Quickstart 2, the token request in the login process asked for only identity resources, that is, only scopes such as profile and openid. In this quickstart, you will add scopes for API resources to that request. IdentityServer will respond with two tokens:\nthe identity token, containing information about the authentication process and session, and the access token, allowing access to APIs on behalf of the logged on user We recommend you do the quickstarts in order. If you\u0026rsquo;d like to start here, begin from a copy of the reference implementation of Quickstart 2. Throughout this quickstart, paths are written relative to the base quickstart directory created in part 1, which is the root directory of the reference implementation. You will also need to install the IdentityServer templates.\nModifying the client configuration The client configuration in IdentityServer requires two straightforward updates.\nAdd the api1 resource to the allowed scopes list so that the client will have permission to access it. Enable support for refresh tokens by setting the AllowOfflineAccess flag. Update the Client in src/IdentityServer/Config.cs as follows:\nnew Client { ClientId = \u0026#34;web\u0026#34;, ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, AllowedGrantTypes = GrantTypes.Code, // where to redirect to after login RedirectUris = { \u0026#34;https://localhost:5002/signin-oidc\u0026#34; }, // where to redirect to after logout PostLogoutRedirectUris = { \u0026#34;https://localhost:5002/signout-callback-oidc\u0026#34; }, AllowOfflineAccess = true, AllowedScopes = new List\u0026lt;string\u0026gt; { IdentityServerConstants.StandardScopes.OpenId, IdentityServerConstants.StandardScopes.Profile, \u0026#34;api1\u0026#34; } } Modifying the Web client Now configure the client to ask for access to api1 and for a refresh token by requesting the api1 and offline_access scopes. This is done in the OpenID Connect handler configuration in src/WebClient/Program.cs:\nbuilder.Services.AddAuthentication(options =\u0026gt; { options.DefaultScheme = \u0026#34;Cookies\u0026#34;; options.DefaultChallengeScheme = \u0026#34;oidc\u0026#34;; }) .AddCookie(\u0026#34;Cookies\u0026#34;) .AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { options.Authority = \u0026#34;https://localhost:5001\u0026#34;; options.ClientId = \u0026#34;web\u0026#34;; options.ClientSecret = \u0026#34;secret\u0026#34;; options.ResponseType = \u0026#34;code\u0026#34;; options.SaveTokens = true; options.Scope.Clear(); options.Scope.Add(\u0026#34;openid\u0026#34;); options.Scope.Add(\u0026#34;profile\u0026#34;); options.Scope.Add(\u0026#34;api1\u0026#34;); options.Scope.Add(\u0026#34;offline_access\u0026#34;); options.GetClaimsFromUserInfoEndpoint = true; }); Since SaveTokens is enabled, ASP.NET Core will automatically store the id, access, and refresh tokens in the properties of the authentication cookie. If you run the solution and authenticate, you will see the tokens on the page that displays the cookie claims and properties created in quickstart 2.\nUsing the access token Now you will use the access token to authorize requests from the WebClient to the Api.\nCreate a page that will\nRetrieve the access token from the session using the GetTokenAsync method from Microsoft.AspNetCore.Authentication Set the token in an Authentication: Bearer HTTP header Make an HTTP request to the API Display the results Create the Page by running the following command from the src/WebClient/Pages directory:\ndotnet new page -n CallApi Update src/WebClient/Pages/CallApi.cshtml.cs as follows:\npublic class CallApiModel : PageModel { public string Json = string.Empty; public async Task OnGet() { var accessToken = await HttpContext.GetTokenAsync(\u0026#34;access_token\u0026#34;); var client = new HttpClient(); client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\u0026#34;Bearer\u0026#34;, accessToken); var content = await client.GetStringAsync(\u0026#34;https://localhost:6001/identity\u0026#34;); var parsed = JsonDocument.Parse(content); var formatted = JsonSerializer.Serialize(parsed, new JsonSerializerOptions { WriteIndented = true }); Json = formatted; } } And update src/WebClient/Pages/CallApi.cshtml as follows:\n@page @model MyApp.Namespace.CallApiModel \u0026lt;pre\u0026gt;@Model.Json\u0026lt;/pre\u0026gt; Make sure the IdentityServer and Api projects are running, start the WebClient and request /CallApi after authentication.\nFurther Reading - Access token lifetime management By far the most complex task for a typical client is to manage the access token. You typically want to\nrequest the access and refresh token at login time cache those tokens use the access token to call APIs until it expires use the refresh token to get a new access token repeat the process of caching and refreshing with the new token ASP.NET Core has built-in facilities that can help you with some of those tasks (like caching or sessions), but there is still quite some work left to do. Consider using the IdentityModel library for help with access token lifetime management. It provides abstractions for storing tokens, automatic refresh of expired tokens, etc.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/endpoints/userinfo/",
    "title": "UserInfo Endpoint",
    "tags": [],
    "description": "",
    "content": "The UserInfo endpoint can be used to retrieve claims about a user (see spec).\nThe caller needs to send a valid access token. Depending on the granted scopes, the UserInfo endpoint will return the mapped claims (at least the openid scope is required).\nGET /connect/userinfo Authorization: Bearer \u0026lt;access_token\u0026gt; HTTP/1.1 200 OK Content-Type: application/json { \u0026#34;sub\u0026#34;: \u0026#34;248289761001\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Bob Smith\u0026#34;, \u0026#34;given_name\u0026#34;: \u0026#34;Bob\u0026#34;, \u0026#34;family_name\u0026#34;: \u0026#34;Smith\u0026#34; } .NET client library You can use the IdentityModel client library to programmatically interact with the protocol endpoint from .NET code.\nusing IdentityModel.Client; var client = new HttpClient(); var response = await client.GetUserInfoAsync(new UserInfoRequest { Address = disco.UserInfoEndpoint, Token = token }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/endpoints/introspection/",
    "title": "Introspection Endpoint",
    "tags": [],
    "description": "",
    "content": "The introspection endpoint is an implementation of RFC 7662.\nIt can be used to validate reference tokens (or JWTs if the consumer does not have support for appropriate JWT or cryptographic libraries). The introspection endpoint requires authentication - since the client of an introspection endpoint is an API, you configure the secret on the ApiResource.\nPOST /connect/introspect Authorization: Basic xxxyyy token=\u0026lt;token\u0026gt; A successful response will return a status code of 200 and either an active or inactive token::\n{ \u0026#34;active\u0026#34;: true, \u0026#34;sub\u0026#34;: \u0026#34;123\u0026#34; } Unknown or expired tokens will be marked as inactive::\n{ \u0026#34;active\u0026#34;: false, } An invalid request will return a 400, an unauthorized request 401.\n.NET client library You can use the IdentityModel client library to programmatically interact with the protocol endpoint from .NET code.\nusing IdentityModel.Client; var client = new HttpClient(); var response = await client.IntrospectTokenAsync(new TokenIntrospectionRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/introspect\u0026#34;, ClientId = \u0026#34;api1\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Token = accessToken }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/quickstarts/4_ef/",
    "title": "Using EntityFramework Core for configuration and operational data",
    "tags": [],
    "description": "",
    "content": "Welcome to Quickstart 4 for Duende IdentityServer! In this quickstart you will move configuration and other temporary data into a database using Entity Framework.\nWe recommend you do the quickstarts in order. If you\u0026rsquo;d like to start here, begin from a copy of the reference implementation of Quickstart 3. Throughout this quickstart, paths are written relative to the base quickstart directory created in part 1, which is the root directory of the reference implementation. You will also need to install the IdentityServer templates.\nIn the previous quickstarts, you configured clients and scopes with code. IdentityServer loaded this configuration data into memory on startup. Modifying the configuration required a restart. IdentityServer also generates temporary data, such as authorization codes, consent choices, and refresh tokens. Up to this point in the quickstarts, this data was also stored in memory.\nTo move this data into a database that is persistent between restarts and across multiple IdentityServer instances, you will use the Duende.IdentityServer.EntityFramework library.\nThis quickstart shows how to add Entity Framework support to IdentityServer manually. There is also a template that will create a new IdentityServer project with the EntityFramework integration already added: dotnet new isef.\nConfigure IdentityServer Install Duende.IdentityServer.EntityFramework IdentityServer\u0026rsquo;s Entity Framework integration is provided by the Duende.IdentityServer.EntityFramework NuGet package. Run the following commands from the src/IdentityServer directory to replace the Duende.IdentityServer package with it. Replacing packages prevents any dependency issues with version mismatches.\ndotnet remove package Duende.IdentityServer dotnet add package Duende.IdentityServer.EntityFramework Install Microsoft.EntityFrameworkCore.Sqlite Duende.IdentityServer.EntityFramework can be used with any Entity Framework database provider. In this quickstart, you will use Sqlite. To add Sqlite support to your IdentityServer project, install the Entity framework Sqlite NuGet package by running the following command from the src/IdentityServer directory:\ndotnet add package Microsoft.EntityFrameworkCore.Sqlite Configuring the Stores Duende.IdentityServer.EntityFramework stores configuration and operational data in separate stores, each with their own DbContext.\nConfigurationDbContext: used for configuration data such as clients, resources, and scopes PersistedGrantDbContext: used for dynamic operational data such as authorization codes and refresh tokens To use these stores, replace the existing calls to AddInMemoryClients, AddInMemoryIdentityResources, and AddInMemoryApiScopes in your ConfigureServices method in src/IdentityServer/HostingExtensions.cs with AddConfigurationStore and AddOperationalStore, like this:\npublic static WebApplication ConfigureServices(this WebApplicationBuilder builder) { var migrationsAssembly = typeof(Program).Assembly.GetName().Name; const string connectionString = @\u0026#34;Data Source=Duende.IdentityServer.Quickstart.EntityFramework.db\u0026#34;; builder.Services.AddIdentityServer() .AddConfigurationStore(options =\u0026gt; { options.ConfigureDbContext = b =\u0026gt; b.UseSqlite(connectionString, sql =\u0026gt; sql.MigrationsAssembly(migrationsAssembly)); }) .AddOperationalStore(options =\u0026gt; { options.ConfigureDbContext = b =\u0026gt; b.UseSqlite(connectionString, sql =\u0026gt; sql.MigrationsAssembly(migrationsAssembly)); }) .AddTestUsers(TestUsers.Users); //... } You will use Entity Framework migrations later on in this quickstart to manage the database schema. The call to MigrationsAssembly(\u0026hellip;) tells Entity Framework that the host project will contain the migrations. This is necessary since the host project is in a different assembly than the one that contains the DbContext classes.\nManaging the Database Schema The Duende.IdentityServer.EntityFramework.Storage NuGet package (installed as a dependency of Duende.IdentityServer.EntityFramework) contains entity classes that map onto IdentityServer\u0026rsquo;s models. These entities are maintained in sync with IdentityServer\u0026rsquo;s models - when the models are changed in a new release, corresponding changes are made to the entities. As you use IdentityServer and upgrade over time, you are responsible for your database schema and changes necessary to that schema.\nOne approach for managing those changes is to use EF migrations, which is what this quickstart will use. If migrations are not your preference, then you can manage the schema changes in any way you see fit.\nAdding Migrations To create migrations, you will need to install the Entity Framework Core CLI tool on your machine and the Microsoft.EntityFrameworkCore.Design NuGet package in IdentityServer. Run the following commands from the src/IdentityServer directory:\ndotnet tool install --global dotnet-ef dotnet add package Microsoft.EntityFrameworkCore.Design Handle Expected Exception The Entity Framework CLI internally starts up IdentityServer for a short time in order to read your database configuration. After it has read the configuration, it shuts IdentityServer down by throwing a StopTheHostException (in Entity Framework 6) or HostAbortedException (in Entity Framework 7) exception. We expect this exception to be unhandled and therefore stop IdentityServer. Since it is expected, you do not need to log it as a fatal error. Update the error logging code in src/IdentityServer/Program.cs as follows:\ncatch (Exception ex) when ( // https://github.com/dotnet/runtime/issues/60600 ex.GetType().Name is not \u0026#34;StopTheHostException\u0026#34; // HostAbortedException was added in .NET 7, but since we target .NET 6 we // need to do it this way until we target .NET 8 \u0026amp;\u0026amp; ex.GetType().Name is not \u0026#34;HostAbortedException\u0026#34;) { Log.Fatal(ex, \u0026#34;Unhandled exception\u0026#34;); } When using Microsoft.EntityFrameworkCore.Tools version 6.x, you must use the \u0026ldquo;StopTheHostException\u0026rdquo; string here rather than catching the StopTheHostException because it is a private type. If you use version 7.x of Microsoft.EntityFrameworkCore.Tools and reference version 7.x of the Microsoft.Extensions.Hosting package, you can catch the \u0026ldquo;HostAbortedException\u0026rdquo; as expected. See https://github.com/dotnet/runtime/issues/60600.\nNow run the following two commands from the src/IdentityServer directory to create the migrations:\ndotnet ef migrations add InitialIdentityServerPersistedGrantDbMigration -c PersistedGrantDbContext -o Data/Migrations/IdentityServer/PersistedGrantDb dotnet ef migrations add InitialIdentityServerConfigurationDbMigration -c ConfigurationDbContext -o Data/Migrations/IdentityServer/ConfigurationDb You should now see a src/IdentityServer/Data/Migrations/IdentityServer directory in your project containing the code for your newly created migrations.\nInitializing the Database Now that you have the migrations, you can write code to create the database from them and seed the database with the same configuration data used in the previous quickstarts.\nThe approach used in this quickstart is used to make it easy to get IdentityServer up and running. You should devise your own database creation and maintenance strategy that is appropriate for your architecture.\nIn src/IdentityServer/HostingExtensions.cs, add this method to initialize the database:\nprivate static void InitializeDatabase(IApplicationBuilder app) { using (var serviceScope = app.ApplicationServices.GetService\u0026lt;IServiceScopeFactory\u0026gt;().CreateScope()) { serviceScope.ServiceProvider.GetRequiredService\u0026lt;PersistedGrantDbContext\u0026gt;().Database.Migrate(); var context = serviceScope.ServiceProvider.GetRequiredService\u0026lt;ConfigurationDbContext\u0026gt;(); context.Database.Migrate(); if (!context.Clients.Any()) { foreach (var client in Config.Clients) { context.Clients.Add(client.ToEntity()); } context.SaveChanges(); } if (!context.IdentityResources.Any()) { foreach (var resource in Config.IdentityResources) { context.IdentityResources.Add(resource.ToEntity()); } context.SaveChanges(); } if (!context.ApiScopes.Any()) { foreach (var resource in Config.ApiScopes) { context.ApiScopes.Add(resource.ToEntity()); } context.SaveChanges(); } } } Call InitializeDatabase from the ConfigurePipeline method:\npublic static WebApplication ConfigurePipeline(this WebApplication app) { app.UseSerilogRequestLogging(); if (app.Environment.IsDevelopment()) { app.UseDeveloperExceptionPage(); } InitializeDatabase(app); //... } Now if you run the IdentityServer project, the database should be created and seeded with the quickstart configuration data. You should be able to use a tool like SQL Lite Studio to connect and inspect the data.\nThe InitializeDatabase method is convenient way to seed the database, but this approach is not ideal to leave in to execute each time the application runs. Once your database is populated, consider removing the call to the API.\nRun the client applications You should now be able to run any of the existing client applications and sign-in, get tokens, and call the API \u0026ndash; all based upon the database configuration.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/endpoints/revocation/",
    "title": "Revocation Endpoint",
    "tags": [],
    "description": "",
    "content": "This endpoint allows revoking access tokens (reference tokens only) and refresh token. It implements the token revocation specification (RFC 7009).\ntoken\nthe token to revoke (required)\ntoken_type_hint\neither access_token or refresh_token (optional)\nPOST /connect/revocation HTTP/1.1 Host: server.example.com Content-Type: application/x-www-form-urlencoded Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW token=...\u0026amp;token_type_hint=refresh_token .NET client library You can use the IdentityModel client library to programmatically interact with the protocol endpoint from .NET code.\nusing IdentityModel.Client; var client = new HttpClient(); var result = await client.RevokeTokenAsync(new TokenRevocationRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/revocation\u0026#34;, ClientId = \u0026#34;client\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Token = token }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/quickstarts/5_aspnetid/",
    "title": "Using ASP.NET Core Identity",
    "tags": [],
    "description": "",
    "content": "Welcome to Quickstart 5 for Duende IdentityServer! In this quickstart you will integrate IdentityServer with ASP.NET Core Identity.\nWe recommend you do the quickstarts in order. If you\u0026rsquo;d like to start here, begin from a copy of the reference implementation of Quickstart 4. Throughout this quickstart, paths are written relative to the base quickstart directory created in part 1, which is the root directory of the reference implementation. You will also need to install the IdentityServer templates.\nIdentityServer\u0026rsquo;s flexible design allows you to use any database you want to store users and their data, including password hashes, multifactor authentication details, roles, claims, profile data, etc. If you are starting with a new user database, then ASP.NET Core Identity is one option you could choose. This quickstart shows how to use ASP.NET Core Identity with IdentityServer.\nThe approach this quickstart takes to using ASP.NET Core Identity is to create a new project for the IdentityServer host. This new project will replace the IdentityServer project you built up in the previous quickstarts. You will create a new project because it is a convenient way to get the UI assets that are needed to login and logout with ASP.NET Core Identity. All the other projects in this solution (for the clients and the API) will remain the same.\nThis quickstart assumes you are familiar with how ASP.NET Core Identity works. If you are not, it is recommended that you first learn about it.\nNew Project for ASP.NET Core Identity The first step is to add a new project for ASP.NET Core Identity to your solution. We provide a template that contains the minimal UI assets needed to use ASP.NET Core Identity with IdentityServer. You will eventually delete the old project for IdentityServer, but there are some items that you will need to migrate over.\nStart by creating a new IdentityServer project that will use ASP.NET Core Identity. Run the following commands from the src directory:\ndotnet new isaspid -n IdentityServerAspNetIdentity cd .. dotnet sln add ./src/IdentityServerAspNetIdentity/IdentityServerAspNetIdentity.csproj When prompted to \u0026ldquo;seed\u0026rdquo; the user database, choose \u0026ldquo;Y\u0026rdquo; for \u0026ldquo;yes\u0026rdquo;. This populates the user database with our \u0026ldquo;alice\u0026rdquo; and \u0026ldquo;bob\u0026rdquo; users. Their passwords are \u0026ldquo;Pass123$\u0026rdquo;.\nThe template uses Sqlite as the database for the users, and EF migrations are pre-created in the template. If you wish to use a different database provider, you will need to change the provider used in the code and re-create the EF migrations.\nInspect the new project Open the new project in the editor of your choice, and inspect the generated code. Much of it is the same from the prior quickstarts and templates. The following sections will describe some key differences and guide you through migrating configuration from the old IdentityServer Project, including:\nThe project file (IdentityServerAspNetIdentity.csproj) Pipeline and service configuration (HostingExtensions.cs) Resource and client configuration (Config.cs) Entry point and seed data (Program.cs and SeedData.cs) Login and logout pages (Pages in Pages/Account) IdentityServerAspNetIdentity.csproj Notice the reference to Duende.IdentityServer.AspNetIdentity. This NuGet package contains the ASP.NET Core Identity integration components for IdentityServer.\nHostingExtensions.cs In ConfigureServices notice the necessary AddDbContext() and AddIdentity\u0026lt;ApplicationUser, IdentityRole\u0026gt;() calls are done to configure ASP.NET Core Identity.\nAlso notice that much of the same IdentityServer configuration you did in the previous quickstarts is already done. The template uses the in-memory style for clients and resources, which are defined in Config.cs.\nFinally, notice the addition of the new call to AddAspNetIdentity(). AddAspNetIdentity() adds the integration layer to allow IdentityServer to access the user data for the ASP.NET Core Identity user database. This is needed when IdentityServer must add claims for the users into tokens.\nNote that AddIdentity\u0026lt;ApplicationUser, IdentityRole\u0026gt;() must be invoked before AddIdentityServer().\nConfig.cs Config.cs contains the hard-coded in-memory clients and resource definitions. To keep the same clients and API working as the prior quickstarts, we need to copy over the configuration data from the old IdentityServer project into this one. Do that now, and afterwards Config.cs should look like this:\npublic static class Config { public static IEnumerable\u0026lt;IdentityResource\u0026gt; IdentityResources =\u0026gt; new List\u0026lt;IdentityResource\u0026gt; { new IdentityResources.OpenId(), new IdentityResources.Profile(), }; public static IEnumerable\u0026lt;ApiScope\u0026gt; ApiScopes =\u0026gt; new List\u0026lt;ApiScope\u0026gt; { new ApiScope(\u0026#34;api1\u0026#34;, \u0026#34;My API\u0026#34;) }; public static IEnumerable\u0026lt;Client\u0026gt; Clients =\u0026gt; new List\u0026lt;Client\u0026gt; { // machine to machine client new Client { ClientId = \u0026#34;client\u0026#34;, ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, AllowedGrantTypes = GrantTypes.ClientCredentials, // scopes that client has access to AllowedScopes = { \u0026#34;api1\u0026#34; } }, // interactive ASP.NET Core Web App new Client { ClientId = \u0026#34;web\u0026#34;, ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, AllowedGrantTypes = GrantTypes.Code, // where to redirect to after login RedirectUris = { \u0026#34;https://localhost:5002/signin-oidc\u0026#34; }, // where to redirect to after logout PostLogoutRedirectUris = { \u0026#34;https://localhost:5002/signout-callback-oidc\u0026#34; }, AllowOfflineAccess = true, AllowedScopes = new List\u0026lt;string\u0026gt; { IdentityServerConstants.StandardScopes.OpenId, IdentityServerConstants.StandardScopes.Profile, \u0026#34;api1\u0026#34; } } }; } At this point, you no longer need the old IdentityServer project and can remove it from the solution. From the quickstart directory, run the following commands:\ndotnet sln remove ./src/IdentityServer/IdentityServer.csproj rm -r ./src/IdentityServer Program.cs and SeedData.cs The application entry point in Program.cs is a little different than most ASP.NET Core projects. Notice that it looks for a command line argument called /seed which is used as a flag to seed the users in the ASP.NET Core Identity database. This seed process is invoked during template creation and already ran when you were prompted to seed the database.\nLook at the SeedData class\u0026rsquo; code to see how the database is created and the first users are created.\nAccount Pages Finally, take a look at the the pages in the src/IdentityServerAspNetIdentity/Pages/Account directory. These pages contain slightly different login and logout code than the prior quickstart and templates because the login and logout processes now rely on ASP.NET Core Identity. Notice the use of the SignInManager and UserManager types from ASP.NET Core Identity to validate credentials and manage the authentication session.\nMuch of the rest of the code is the same from the prior quickstarts and templates.\nLogging in with the Web client At this point, you should be able to run all of the existing clients and samples. Launch the Web client application, and you should be redirected to IdentityServer to log in. Login with one of the users created by the seed process (e.g., alice/Pass123$), and after that you will be redirected back to the Web client application where your user\u0026rsquo;s claims should be listed.\nYou should also be able to go to the call api page to invoke the API on behalf of the user:\nCongratulations, you\u0026rsquo;re using users from ASP.NET Core Identity in IdentityServer!\nAdding Custom Profile Data Next you will add a custom property to your user model and include it as a claim when the appropriate Identity Resource is requested.\nFirst, add a FavoriteColor property to the ApplicationUser class.\npublic class ApplicationUser : IdentityUser { public string FavoriteColor { get; set; } } Then, set the FavoriteColor of one of your test users in SeedData.cs\nalice = new ApplicationUser { UserName = \u0026#34;alice\u0026#34;, Email = \u0026#34;AliceSmith@email.com\u0026#34;, EmailConfirmed = true, FavoriteColor = \u0026#34;red\u0026#34;, }; In the same file, add code to recreate the database when you re-seed the data, by calling EnsureDeleted just before Migrate:\nvar context = scope.ServiceProvider.GetService\u0026lt;ApplicationDbContext\u0026gt;(); context.Database.EnsureDeleted(); context.Database.Migrate(); Caution: this will destroy your test users when you make changes to them. While that is convenient for this quickstart, it is not recommended in production!\nNext, create an ef migration for the CustomProfileData and reseed your user database. Run the following commands from the src/IdentityServerAspNetIdentity directory:\ndotnet ef migrations add CustomProfileData dotnet run /seed Now that you have more data in the database, you can use it to set claims. IdentityServer contains an extensibility point called the IProfileService that is responsible for retrieval of user claims. The ASP.NET Identity Integration includes an implementation of IProfileService that retrieves claims from ASP.NET Identity. You can extend that implementation to use the custom profile data as a source of claims data. See here for more details on the profile service.\nCreate a new class called CustomProfileService and add the following code to it:\nusing Duende.IdentityServer.AspNetIdentity; using Duende.IdentityServer.Models; using IdentityServerAspNetIdentity.Models; using Microsoft.AspNetCore.Identity; using System.Security.Claims; namespace IdentityServerAspNetIdentity { public class CustomProfileService : ProfileService\u0026lt;ApplicationUser\u0026gt; { public CustomProfileService(UserManager\u0026lt;ApplicationUser\u0026gt; userManager, IUserClaimsPrincipalFactory\u0026lt;ApplicationUser\u0026gt; claimsFactory) : base(userManager, claimsFactory) { } protected override async Task GetProfileDataAsync(ProfileDataRequestContext context, ApplicationUser user) { var principal = await GetUserClaimsAsync(user); var id = (ClaimsIdentity)principal.Identity; if (!string.IsNullOrEmpty(user.FavoriteColor)) { id.AddClaim(new Claim(\u0026#34;favorite_color\u0026#34;, user.FavoriteColor)); } context.AddRequestedClaims(principal.Claims); } } } Register the CustomProfileService in HostingExtensions.cs:\nbuilder.Services .AddIdentityServer(options =\u0026gt; { // ... }) .AddInMemoryIdentityResources(Config.IdentityResources) .AddInMemoryApiScopes(Config.ApiScopes) .AddInMemoryClients(Config.Clients) .AddAspNetIdentity\u0026lt;ApplicationUser\u0026gt;() .AddProfileService\u0026lt;CustomProfileService\u0026gt;(); Finally, you need to configure your application to make a request for the favorite_color, and include that claim in your client\u0026rsquo;s configuration.\nAdd a new IdentityResource in src/IdentityServerAspNetIdentity/Config.cs that will map the color scope onto the favorite_color claim type:\npublic static IEnumerable\u0026lt;IdentityResource\u0026gt; IdentityResources =\u0026gt; new IdentityResource[] { new IdentityResources.OpenId(), new IdentityResources.Profile(), new IdentityResource(\u0026#34;color\u0026#34;, new [] { \u0026#34;favorite_color\u0026#34; }) }; Allow the web client to request the color scope (also in Config.cs):\nnew Client { ClientId = \u0026#34;web\u0026#34;, // ... AllowedScopes = new List\u0026lt;string\u0026gt; { IdentityServerConstants.StandardScopes.OpenId, IdentityServerConstants.StandardScopes.Profile, \u0026#34;api1\u0026#34;, \u0026#34;color\u0026#34; } } Finally, update the WebClient project so that it will request the color scope. In its src/WebClient/Program.cs file, add the color scope to the requested scopes, and add a claim action to map the favorite_color into the principal:\n.AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { // ... options.Scope.Clear(); options.Scope.Add(\u0026#34;openid\u0026#34;); options.Scope.Add(\u0026#34;profile\u0026#34;); options.Scope.Add(\u0026#34;offline_access\u0026#34;); options.Scope.Add(\u0026#34;api1\u0026#34;); options.Scope.Add(\u0026#34;color\u0026#34;); options.GetClaimsFromUserInfoEndpoint = true; options.ClaimActions.MapUniqueJsonKey(\u0026#34;favorite_color\u0026#34;, \u0026#34;favorite_color\u0026#34;); }); Now restart the IdentityServerAspNetIdentity and WebClient projects, sign out and sign back in as alice, and you should see the favorite color claim.\nWhat\u0026rsquo;s Missing? The rest of the code in this template is similar to the other quickstarts and templates we provide. You will notice that this template does not include UI code for user registration, password reset, and other things you might expect from Microsoft\u0026rsquo;s templates that include ASP.NET Core Identity.\nGiven the variety of requirements and different approaches to using ASP.NET Core Identity, our template deliberately does not provide those features. The intent of this template is to be a starting point to which you can add the features you need from ASP.NET Core Identity, customized according to your requirements. Alternatively, you can create a new project based on the ASP.NET Core Identity template and add the IdentityServer features you have learned about in these quickstarts to that project. With that approach, you may need to configure IdentityServer so that it knows the paths to pages for user interactions. Set the LoginUrl, LogoutUrl, ConsentUrl, ErrorUrl, and DeviceVerificationUrl as needed in your IdentityServerOptions.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/endpoints/end_session/",
    "title": "End Session Endpoint",
    "tags": [],
    "description": "",
    "content": "The end session endpoint can be used to trigger single sign-out in the browser (see spec).\nTo use the end session endpoint a client application will redirect the user\u0026rsquo;s browser to the end session URL. All applications that the user has logged into via the browser during the user\u0026rsquo;s session can participate in the sign-out.\nThe URL for the end session endpoint is available via discovery.\nid_token_hint\nWhen the user is redirected to the endpoint, they will be prompted if they really want to sign-out. This prompt can be bypassed by a client sending the original id_token received from authentication. This is passed as a query string parameter called id_token_hint.\npost_logout_redirect_uri\nIf a valid id_token_hint is passed, then the client may also send a post_logout_redirect_uri parameter. This can be used to allow the user to redirect back to the client after sign-out. The value must match one of the client\u0026rsquo;s pre-configured PostLogoutRedirectUris.\nstate\nIf a valid post_logout_redirect_uri is passed, then the client may also send a state parameter. This will be returned back to the client as a query string parameter after the user redirects back to the client. This is typically used by clients to roundtrip state across the redirect.\nGET /connect/endsession?id_token_hint=...\u0026amp;post_logout_redirect_uri=http%3A%2F%2Flocalhost%3A7017%2Findex.html .NET client library You can use the IdentityModel client library to programmatically create end sessions request URLs from .NET code.\nvar ru = new RequestUrl(\u0026#34;https://demo.duendesoftware.com/connect/end_session\u0026#34;); var url = ru.CreateEndSessionUrl( idTokenHint: \u0026#34;...\u0026#34;, postLogoutRedirectUri: \u0026#34;...\u0026#34;); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/endpoints/device_authorization/",
    "title": "Device Authorization Endpoint",
    "tags": [],
    "description": "",
    "content": "The device authorization endpoint can be used to request device and user codes. This endpoint is used to start the device flow authorization process.\nclient_id\nclient identifier (required)\nclient_secret\nclient secret either in the post body, or as a basic authentication header. Optional.\nscope\none or more registered scopes. If not specified, a token for all explicitly allowed scopes will be issued\nPOST /connect/deviceauthorization client_id=client1\u0026amp; client_secret=secret\u0026amp; scope=openid api1 .NET client library You can use the IdentityModel client library to programmatically interact with the protocol endpoint from .NET code.\nusing IdentityModel.Client; var client = new HttpClient(); var response = await client.RequestDeviceAuthorizationAsync(new DeviceAuthorizationRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/device_authorize\u0026#34;, ClientId = \u0026#34;device\u0026#34; }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/endpoints/ciba/",
    "title": "Backchannel Authentication Endpoint",
    "tags": [],
    "description": "",
    "content": "The backchannel authentication endpoint is used by a client to initiate a CIBA request.\nClients must be configured with the \u0026ldquo;urn:openid:params:grant-type:ciba\u0026rdquo; grant type to use this endpoint. You can use the OidcConstants.GrantTypes.Ciba constant rather than hard coding the value for the CIBA grant type.\nRequired parameters scope\none or more registered scopes\nThe client id and a client credential is required to authenticate to the endpoint using any valid form of authentication that has been configured for it (much like the token endpoint).\nExactly one of these values is required login_hint\nhint for the end user to be authenticated. the value used is implementation specific.\nid_token_hint\na previously issued id_token for the end user to be authenticated\nlogin_hint_token\na token containing information for the end user to be authenticated. the details are implementation specific.\nTo validate these implementation specific values and use them to identity the user that is to be authenticated, you are required to implement the IBackchannelAuthenticationUserValidator interface.\nOptional parameters binding_message\nidentifier or message intended to be displayed on both the consumption device and the authentication device\nuser_code\na secret code, such as a password or pin, that is known only to the user but verifiable by the OP\nrequested_expiry\na positive integer allowing the client to request the expires_in value for the auth_req_id the server will return. if not present, then the optional CibaLifetime property on the Client is used, and if that is not present, then the DefaultLifetime on the CibaOptions will be used.\nacr_values\nallows passing in additional authentication related information - IdentityServer special cases the following proprietary acr_values:\nidp:name_of_idp\nbypasses the login/home realm screen and forwards the user directly to the selected identity provider (if allowed per client configuration)\ntenant:name_of_tenant\ncan be used to pass a tenant name to the login UI\nresource\nresource indicator identifying the ApiResource for which the access token should be restricted to\nrequest\ninstead of providing all parameters as individual parameters, you can provide all of them as a JWT\nPOST /connect/ciba client_id=client1\u0026amp; client_secret=secret\u0026amp; scope=openid api1\u0026amp; login_hint=alice And a successful response will look something like:\nHTTP/1.1 200 OK Content-Type: application/json Cache-Control: no-store { \u0026#34;auth_req_id\u0026#34;: \u0026#34;1C266114A1BE42528AD104986C5B9AC1\u0026#34;, \u0026#34;expires_in\u0026#34;: 600, \u0026#34;interval\u0026#34;: 5 } .NET client library You can use the IdentityModel client library to programmatically interact with the protocol endpoint from .NET code.\nusing IdentityModel.Client; var client = new HttpClient(); var cibaResponse = await client.RequestBackchannelAuthenticationAsync(new BackchannelAuthenticationRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/ciba\u0026#34;, ClientId = \u0026#34;client1\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Scope = \u0026#34;openid api1\u0026#34;, LoginHint = \u0026#34;alice\u0026#34;, }); And with a successful response, it can be used to poll the token endpoint:\nwhile (true) { var response = await client.RequestBackchannelAuthenticationTokenAsync(new BackchannelAuthenticationTokenRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/token\u0026#34;, ClientId = \u0026#34;client1\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, AuthenticationRequestId = cibaResponse.AuthenticationRequestId }); if (response.IsError) { if (response.Error == OidcConstants.TokenErrors.AuthorizationPending || response.Error == OidcConstants.TokenErrors.SlowDown) { await Task.Delay(cibaResponse.Interval.Value * 1000); } else { throw new Exception(response.Error); } } else { // success! use response.IdentityToken, response.AccessToken, and response.RefreshToken (if requested) } } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/extensibility/management/login/",
    "title": "BFF Login Endpoint Extensibility",
    "tags": [],
    "description": "",
    "content": "The BFF login endpoint has extensibility points in two interfaces. The ILoginService is the top level abstraction that processes requests to the endpoint. This service can be used to add custom request processing logic. The IReturnUrlValidator ensures that the returnUrl parameter passed to the login endpoint is safe to use.\nRequest Processing ProcessRequestAsync is the top level function called in the endpoint service and can be used to add arbitrary logic to the endpoint.\nFor example, you could take whatever actions you need before normal processing of the request like this:\npublic override Task ProcessRequestAsync(HttpContext context) { // Custom logic here return base.ProcessRequestAsync(context); } Return URL Validation To prevent open redirector attacks, the returnUrl parameter to the login endpoint must be validated. You can customize this validation by implementing the IReturnUrlValidator interface. The default implementation enforces that return urls are local.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/architecture/",
    "title": "Architecture",
    "tags": [],
    "description": "",
    "content": "A BFF host is an ASP.NET Core application with the following components:\nThese components handle OIDC and OAuth protocol requests and responses, manage user sessions and tokens, secure API endpoints for the front end, and optionally serve UI assets.\nDuende.BFF builds on widely used tools and frameworks, including ASP.NET Core\u0026rsquo;s OpenID Connect and cookie authentication handlers, YARP, and Duende.AccessTokenManagment. Duende.BFF combines these tools and adds additional security and application features that are useful with a BFF architecture so that you can focus on providing application logic instead of security logic:\nASP.NET OpenID Connect Handler Duende.BFF uses ASP.NET\u0026rsquo;s OpenID Connect handler for OIDC and OAuth protocol processing. As long-term users of and contributors to this library, we think it is a well implemented and flexible implementation of the protocols.\nASP.NET Cookie Handler Duende.BFF uses ASP.NET\u0026rsquo;s Cookie handler for session management. The Cookie handler provides a claims-based identity to the application persisted in a digitally signed and encrypted cookie that is protected with modern cookie security features, including the Secure, HttpOnly and SameSite attributes. The handler also provides absolute and sliding session support, and has a flexible extensibility model, which Duende.BFF uses to implement server-side session management and back-channel logout support.\nDuende.AccessTokenManagement Duende.BFF uses the Duende.AccessTokenManagement library for access token management and storage. This includes storage and retrieval of tokens, refreshing tokens as needed, and revoking tokens on logout. The library provides integration with the ASP.NET HTTP client to automatically attach tokens to outgoing HTTP requests, and its underlying management actions can also be programmatically invoked through an imperative API.\nAPI Endpoints In the BFF architecture, the frontend makes API calls to backend services via the BFF host exclusively. Typically the BFF acts as a reverse proxy to remote APIs, providing session and token management. Implementing local APIs within the BFF host is also possible. Regardless, requests to APIs are authenticated with the session cookie and need to be secured with an anti-forgery protection header.\nYARP Duende.BFF proxies requests to remote APIs using Microsoft\u0026rsquo;s YARP (Yet Another Reverse Proxy). You can set up YARP using a simplified developer-centric configuration API provided by Duende.BFF, or if you have more complex requirements, you can use the full YARP configuration system directly. If you are using YARP directly, Duende.BFF provides YARP integration to add BFF security and identity features.\nUI Assets The BFF host typically serves at least some of the UI assets of the frontend, which can be HTML/JS/CSS, WASM, and/or server-rendered content. Serving the UI assets, or at least the index page of the UI from the same origin as the backend simplifies requests from the frontend to the backend. Doing so makes the two components same-origin, so that browsers will allow requests with no need to use CORS and automatically include cookies (including the crucial authentication cookie). This also avoids issues where third-party cookie blocking or the SameSite cookie attribute prevents the frontend from sending the authentication cookie to the backend.\nIt is also possible to separate the BFF and UI and host them separately. See here for more discussion of UI hosting architecture.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/session/handlers/",
    "title": "ASP.NET Core Authentication System",
    "tags": [],
    "description": "",
    "content": "You typically use the following two ASP.NET Core authentication handlers to implement remote authentication:\nthe OpenID Connect authentication handler to interact with the remote OIDC / OAuth token service, e.g. Duende IdentityServer the cookie handler to do local session management Furthermore the BFF plumbing relies on the configuration of the ASP.NET Core default authentication schemes. This describes how the two handlers share the work.\nOpenID Connect for challenge and signout - cookies for all the other operations:\nservices.AddAuthentication(options =\u0026gt; { options.DefaultScheme = \u0026#34;cookie\u0026#34;; options.DefaultChallengeScheme = \u0026#34;oidc\u0026#34;; options.DefaultSignOutScheme = \u0026#34;oidc\u0026#34;; }) .AddCookie(\u0026#34;cookie\u0026#34;, options =\u0026gt; { ... }) .AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { ... }); The OpenID Connect Authentication Handler The OIDC handler connects the application to the authentication / access token system.\nThe exact settings depend on the OIDC provider and its configuration settings. We recommend:\nuse authorization code flow with PKCE use a response_mode of query since this plays nicer with SameSite cookies use a strong client secret. Since the BFF can be a confidential client, it is totally possible to use strong client authentication like JWT assertions, JAR or MTLS. Shared secrets work as well of course. turn off inbound claims mapping save the tokens into the authentication session so they can be automatically managed request a refresh token using the offline_access scope services.AddAuthentication().AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { options.Authority = \u0026#34;https://demo.duendesoftware.com\u0026#34;; // confidential client using code flow + PKCE options.ClientId = \u0026#34;spa\u0026#34;; options.ClientSecret = \u0026#34;secret\u0026#34;; options.ResponseType = \u0026#34;code\u0026#34;; // query response type is compatible with strict SameSite mode options.ResponseMode = \u0026#34;query\u0026#34;; // get claims without mappings options.MapInboundClaims = false; options.GetClaimsFromUserInfoEndpoint = true; // save tokens into authentication session // to enable automatic token management options.SaveTokens = true; // request scopes options.Scope.Clear(); options.Scope.Add(\u0026#34;openid\u0026#34;); options.Scope.Add(\u0026#34;profile\u0026#34;); options.Scope.Add(\u0026#34;api\u0026#34;); // and refresh token options.Scope.Add(\u0026#34;offline_access\u0026#34;); }); The OIDC handler will use the default sign-in handler (the cookie handler) to establish a session after successful validation of the OIDC response.\nThe Cookie Handler The cookie handler is responsible for establishing the session and manage authentication session related data.\nThings to consider:\ndetermine the session lifetime and if the session lifetime should be sliding or absolute it is recommended to use a cookie name prefix if compatible with your application use the highest available SameSite mode that is compatible with your application, e.g. strict, but at least lax services.AddAuthentication().AddCookie(\u0026#34;cookie\u0026#34;, options =\u0026gt; { // set session lifetime options.ExpireTimeSpan = TimeSpan.FromHours(8); // sliding or absolute options.SlidingExpiration = false; // host prefixed cookie name options.Cookie.Name = \u0026#34;__Host-spa\u0026#34;; // strict SameSite handling options.Cookie.SameSite = SameSiteMode.Strict; }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/samples/basics/",
    "title": "Basics",
    "tags": [],
    "description": "",
    "content": "This solution contains a collection of common scenarios.\nClient Credentials This sample shows how to use the client_credentials grant type. This is typically used for machine to machine communication.\nKey takeaways:\nhow to request a token using client credentials how to use a shared secret how to use access token link to source code\nJWT-based Client Authentication This sample shows how to use the client_credentials grant type with JWT-based client authentication. This authentication method is more recommended than shared secrets.\nKey takeaways:\ncreate a JWT for client authentication use a JWT as a client secret replacement configure IdentityServer to accept a JWT as a client secret link to source code\nIntrospection \u0026amp; Reference Tokens This sample shows how to use the reference tokens instead of JWTs.\nThings of interest:\nthe client registration uses AccessTokenType of value Reference the client requests scope2 - this scope is part of an API resource. API resources allow defining API secrets, which can then be used to access the introspection endpoint The API supports both JWT and reference tokens, this is achieved by forwarding the token to the right handler at runtime Key takeaways:\nconfiguring a client to receive reference tokens setup an API resource with an API secret configure an API to accept and validate reference tokens link to source code\nMVC Client Sample This sample shows how to use the authorization_code grant type. This is typically used for interactive applications like web applications.\nKey takeaways:\nconfigure an MVC client to use IdentityServer access tokens in ASP.NET Core\u0026rsquo;s authentication session call an API manually refresh tokens link to source code\nMVC Client with automatic Access Token Management This sample shows how to use IdentityModel.AspNetCore to automatically manage access tokens.\nThe sample uses a special client ID in the sample IdentityServer with a short token lifetime (75 seconds). When repeating the API call, make sure you inspect the returned iat and exp claims to observer how the token is slides.\nYou can also turn on debug tracing to get more insights in the token management library.\nKey takeaways:\nuse IdentityModel.AspNetCore to automate refreshing tokens link to source code\nMVC Client with JAR and JWT-based Authentication This sample shows how to use signed authorize requests, and JWT-based authentication for clients in MVC. It also show how to integrate that technique with automatic token management.\nKey takeaways:\nuse the ASP.NET Core extensibility points to add signed authorize requests and JWT-based authentication use JWT-based authentication for automatic token management configure a client in IdentityServer to share key material for both front- and back-channel link to source code\nMVC Client with Back-Channel Logout Notifications This sample shows how to use back-channel logout notifications.\nKey takeaways:\nhow to implement the back-channel notification endpoint how to leverage events on the cookie handler to invalidate the user session link to source code\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/extensibility/management/",
    "title": "BFF Management Endpoints Extensibility",
    "tags": [],
    "description": "",
    "content": "The behavior of each management endpoint is defined in a service. When you add Duende.BFF to DI, a default implementation for every management endpoint gets registered:\n// management endpoints services.AddTransient\u0026lt;ILoginService, DefaultLoginService\u0026gt;(); services.AddTransient\u0026lt;ISilentLoginService, DefaultSilentLoginService\u0026gt;(); services.AddTransient\u0026lt;ISilentLoginCallbackService, DefaultSilentLoginCallbackService\u0026gt;(); services.AddTransient\u0026lt;ILogoutService, DefaultLogoutService\u0026gt;(); services.AddTransient\u0026lt;IUserService, DefaultUserService\u0026gt;(); services.AddTransient\u0026lt;IBackchannelLogoutService, DefaultBackchannelLogoutService\u0026gt;(); services.AddTransient\u0026lt;IDiagnosticsService, DefaultDiagnosticsService\u0026gt;(); You can add your own implementation by overriding the default after calling AddBff().\nThe management endpoint services all inherit from the IBffEndpointService, which provides a general-purpose mechanism to add custom logic to the endpoints.\npublic interface IBffEndpointService { Task ProcessRequestAsync(HttpContext context); } None of the endpoint services contain additional members beyond ProcessRequestAsync.\nYou can customize the behavior of the endpoints either by implementing the appropriate interface or by extending the default implementation of that interface. In many cases, extending the default implementation is preferred, as this allows you to keep most of the default behavior by calling the base ProcessRequestAsync from your derived class. Several of the default endpoint service implementations also define virtual methods that can be overridden to customize their behavior with more granularity. See the following pages for details on those extension points.\nBFF Login Endpoint Extensibility BFF Silent Login Endpoint Extensibility BFF Silent Login Callback Extensibility BFF Logout Endpoint Extensibility BFF User Endpoint Extensibility BFF Back-Channel Logout Endpoint Extensibility BFF Diagnostics Endpoint Extensibility "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/fundamentals/resources/identity/",
    "title": "Identity Resources",
    "tags": [],
    "description": "",
    "content": "An identity resource is a named group of claims about a user that can be requested using the scope parameter.\nThe OpenID Connect specification suggests a couple of standard scope name to claim type mappings that might be useful to you for inspiration, but you can freely design them yourself.\nOne of them is actually mandatory, the openid scope, which tells the provider to return the sub (subject id) claim in the identity token.\nThis is how you could define the openid scope in code:\npublic static IEnumerable\u0026lt;IdentityResource\u0026gt; GetIdentityResources() { return new List\u0026lt;IdentityResource\u0026gt; { new IdentityResource( name: \u0026#34;openid\u0026#34;, userClaims: new[] { \u0026#34;sub\u0026#34; }, displayName: \u0026#34;Your user identifier\u0026#34;) }; } But since this is one of the standard scopes from the spec you can shorten that to:\npublic static IEnumerable\u0026lt;IdentityResource\u0026gt; GetIdentityResources() { return new List\u0026lt;IdentityResource\u0026gt; { new IdentityResources.OpenId() }; } See the reference section for more information on IdentityResource.\nThe following example shows a custom identity resource called profile that represents the display name, email address and website claim:\npublic static IEnumerable\u0026lt;IdentityResource\u0026gt; GetIdentityResources() { return new List\u0026lt;IdentityResource\u0026gt; { new IdentityResource( name: \u0026#34;profile\u0026#34;, userClaims: new[] { \u0026#34;name\u0026#34;, \u0026#34;email\u0026#34;, \u0026#34;website\u0026#34; }, displayName: \u0026#34;Your profile data\u0026#34;) }; } Once the resource is defined, you can give access to it to a client via the AllowedScopes option (other properties omitted):\nvar client = new Client { ClientId = \u0026#34;client\u0026#34;, AllowedScopes = { \u0026#34;openid\u0026#34;, \u0026#34;profile\u0026#34; } }; See the reference section for more information on the Client class.\nThe client can then request the resource using the scope parameter (other parameters omitted):\nhttps://demo.duendesoftware.com/connect/authorize?client_id=client\u0026amp;scope=openid profile IdentityServer will then use the scope names to create a list of requested claim types, and present that to your implementation of the profile service.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/diagnostics/logging/",
    "title": "Logging",
    "tags": [],
    "description": "",
    "content": "Duende IdentityServer uses the standard logging facilities provided by ASP.NET Core. You don\u0026rsquo;t need to do any extra configuration.\nThe Microsoft documentation has a good intro and a description of the built-in logging providers.\nWe are roughly following the Microsoft guidelines for usage of log levels:\nTrace\nFor information that is valuable only to a developer troubleshooting an issue. These messages may contain sensitive application data like tokens and should not be enabled in a production environment.\nDebug\nFor following the internal flow and understanding why certain decisions are made. Has short-term usefulness during development and debugging.\nInformation\nFor tracking the general flow of the application. These logs typically have some long-term value.\nWarning\nFor abnormal or unexpected events in the application flow. These may include errors or other conditions that do not cause the application to stop, but which may need to be investigated.\nError\nFor errors and exceptions that cannot be handled. Examples: failed validation of a protocol request.\nCritical\nFor failures that require immediate attention. Examples: missing store implementation, invalid key material\u0026hellip;\nIn production, logging might produce too much data. It is recommended you either turn it off, or default to the Warning level. Have a look at events for more high-level production instrumentation.\nSetup for Serilog We personally like Serilog and the Serilog.AspNetCore package a lot. Give it a try:\npublic class Program { public static int Main(string[] args) { Activity.DefaultIdFormat = ActivityIdFormat.W3C; Log.Logger = new LoggerConfiguration() .MinimumLevel.Debug() .MinimumLevel.Override(\u0026#34;Microsoft\u0026#34;, LogEventLevel.Warning) .MinimumLevel.Override(\u0026#34;Microsoft.Hosting.Lifetime\u0026#34;, LogEventLevel.Information) .MinimumLevel.Override(\u0026#34;System\u0026#34;, LogEventLevel.Warning) .MinimumLevel.Override(\u0026#34;Microsoft.AspNetCore.Authentication\u0026#34;, LogEventLevel.Information) .Enrich.FromLogContext() .WriteTo.Console(outputTemplate: \u0026#34;[{Timestamp:HH:mm:ss} {Level}] {SourceContext}{NewLine}{Message:lj}{NewLine}{Exception}{NewLine}\u0026#34;, theme: AnsiConsoleTheme.Code) .CreateLogger(); try { Log.Information(\u0026#34;Starting host...\u0026#34;); CreateHostBuilder(args).Build().Run(); return 0; } catch (Exception ex) { Log.Fatal(ex, \u0026#34;Host terminated unexpectedly.\u0026#34;); return 1; } finally { Log.CloseAndFlush(); } } public static IHostBuilder CreateHostBuilder(string[] args) =\u0026gt; Microsoft.Extensions.Hosting.Host.CreateDefaultBuilder(args) .UseSerilog() .ConfigureWebHostDefaults(webBuilder =\u0026gt; { webBuilder.UseStartup\u0026lt;Startup\u0026gt;(); }); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/deployment/proxies/",
    "title": "Proxy Servers and Load Balancers",
    "tags": [],
    "description": "",
    "content": "In typical deployments, your IdentityServer will be hosted behind a load balancer or reverse proxy. These and other network appliances often obscure information about the request before it reaches the host. Some of the behavior of IdentityServer and the ASP.NET authentication handlers depend on that information, most notably the scheme (HTTP vs HTTPS) of the request and the originating client IP address.\nRequests to your IdentityServer that come through a proxy will appear to come from that proxy instead of its true source on the Internet or corporate network. If the proxy performs TLS termination (that is, HTTPS requests are proxied over HTTP), the original HTTPS scheme will also no longer be present in the proxied request. Then, when the IdentityServer middleware and the ASP.NET authentication middleware process these requests, they will have incorrect values for the scheme and originating IP address.\nCommon symptoms of this problem are\nHTTPS requests get downgraded to HTTP Host names are incorrect in the discovery document or on redirect Cookies are not sent with the secure attribute, which can especially cause problems with the samesite cookie attribute. In almost all cases, these problems can be solved by adding the ASP.NET ForwardedHeaders middleware to your pipeline. Most network infrastructure that proxies requests will set the X-Forwarded-For and X-Forwarded-Proto HTTP headers to describe the original request\u0026rsquo;s IP address and scheme.\nThe ForwardedHeaders middleware reads the information in these headers on incoming requests and makes it available to the rest of the ASP.NET pipeline by updating the HttpContext.HttpRequest. This transformation should be done early in the pipeline, certainly before the IdentityServer middleware and ASP.NET authentication middleware process requests, so that the presence of a proxy is abstracted away first.\nThe appropriate configuration for the forwarded headers middleware depends on your environment. In general, you need to configure which headers it should respect, the IP address or IP address range of your proxy, and the number of proxies you expect (when there are multiple proxies, each one is captured in the X-Forwarded-* headers).\nThere are two ways to configure this middleware:\nEnable the environment variable ASPNETCORE_FORWARDEDHEADERS_ENABLED. This is the simplest option, but doesn\u0026rsquo;t give you as much control. It automatically adds the forwarded headers middlware to the pipeline, and configures it to accept forwarded headers from any single proxy, respecting the X-Forwarded-For and X-Forwarded-Proto headers. This is often the right choice for cloud hosted environments and Kubernetes clusters. Configure the ForwardedHeadersOptions in DI, and use the ForwardedHeaders middleware explicitly in your pipeline. The advantage of configuring the middleware explicitly is that you can configure it in a way that is appropriate for your environment, if the defaults used by ASPNETCORE_FORWARDEDHEADERS_ENABLED are not what you need. Most notably, you can use the KnownNetworks or KnownProxies options to only accept headers sent by a known proxy, and you can set the ForwardLimit to allow for multiple proxies in front of your IdentityServer. This is often the right choice when you have more complex proxing going on, or if your proxy has a stable IP address. Please consult the Microsoft documentation for more details.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/tokens/requesting/",
    "title": "Requesting a Token",
    "tags": [],
    "description": "Overview",
    "content": "A typical architecture is composed of two application (aka client) types - machine to machine calls and interactive applications.\nMachine to Machine communication In this scenario a headless application with no interactive user (e.g. a server daemon, batch job etc.) wants to call an API.\nPrerequisites are:\ndefine a client for the client credentials grant type define an API scope (and optionally a resource) grant the client access to the scope via the AllowedScopes property According to the OAuth specification, you request a token by posting to the token endpoint:\nPOST /connect/token CONTENT-TYPE application/x-www-form-urlencoded client_id=client1\u0026amp; client_secret=secret\u0026amp; grant_type=client_credentials\u0026amp; scope=scope1 In the success case, this will return a JSON response containing the access token:\nHTTP/1.1 200 OK Content-Type: application/json;charset=UTF-8 Cache-Control: no-store Pragma: no-cache { \u0026#34;access_token\u0026#34;: \u0026#34;2YotnFZFEjr1zCsicMWpAA\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;bearer\u0026#34;, \u0026#34;expires_in\u0026#34;: 3600, } .NET client library In .NET you can leverage the IdentityModel client library to request tokens.\nThe above token request would look like this in C#:\nusing IdentityModel.Client; var client = new HttpClient(); var response = await client.RequestClientCredentialsTokenAsync(new ClientCredentialsTokenRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/token\u0026#34;, ClientId = \u0026#34;m2m\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Scope = \u0026#34;api\u0026#34; }); Automating token requests in ASP.NET Core and Worker applications The IdentityModel.AspNetCore library can automate client credential request and token lifetime management for you.\nUsing this library, you only need to register the token client in DI:\npublic void ConfigureServices(IServiceCollection services) { services.AddAccessTokenManagement(options =\u0026gt; { options.Client.Clients.Add(\u0026#34;client\u0026#34;, new ClientCredentialsTokenRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/token\u0026#34;, ClientId = \u0026#34;m2m\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Scope = \u0026#34;api\u0026#34; }); }); } You can then add token management to an HTTP-factory provided client:\nservices.AddClientAccessTokenClient(\u0026#34;client\u0026#34;, configureClient: client =\u0026gt; { client.BaseAddress = new Uri(\u0026#34;https://demo.duendesoftware.com/api/\u0026#34;); }); \u0026hellip;and finally use the client with automatic token management in your application code:\npublic class DataController : Controller { IHttpClientFactory _factory; public DataController(IHttpClientFactory factory) { _factory = factory; } public IActionResult Index() { var client = _factory.CreateClient(\u0026#34;client\u0026#34;); // rest omitted } } Interactive applications In this scenario, an interactive application like a web application or mobile/desktop app wants to call an API in the context of an authenticated user (see spec here).\nYou will receive three tokens - an identity token containing details about the end-user authentication, the access token to call the API, and a refresh token for access token lifetime management. The access token will also contain some information about the end-user (e.g. the user ID), so that the API can do authorization based on the user\u0026rsquo;s identity.\nIn this scenario you typically use the authorization code flow which first involves a call to the authorize endpoint for all human interactions (e.g. login and/or consent). This returns a code, which you then redeem at the token endpoint to retrieve identity and access tokens.\nPrerequisites are:\ndefine a client for the authorization code grant type define an identity resource, e.g. openid define an API scope (and optionally a resource) grant the client access to both scopes via the AllowedScopes property Front-channel The call to the authorize endpoint is done using a redirect in the browser:\nGET /connect/authorize? client_id=client1\u0026amp; scope=openid api1\u0026amp; response_type=code\u0026amp; redirect_uri=https://myapp/callback\u0026amp; On success, the browser will ultimately redirect to the callback endpoint transmitting the authorization code (and other parameters like the granted scopes):\nGET /callback? code=abc\u0026amp; scope=openid api1 Back-channel The client then opens a back-channel communication to the token service to retrieve the tokens:\nPOST /connect/token CONTENT-TYPE application/x-www-form-urlencoded client_id=client1\u0026amp; client_secret=secret\u0026amp; grant_type=authorization_code\u0026amp; code=abc\u0026amp; redirect_uri=https://myapp/callback In this scenario, the token response will contain three tokens:\nHTTP/1.1 200 OK Content-Type: application/json;charset=UTF-8 Cache-Control: no-store Pragma: no-cache { \u0026#34;id_token\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;access_token\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;refresh_token\u0026#34;: \u0026#34;...\u0026#34; \u0026#34;token_type\u0026#34;: \u0026#34;bearer\u0026#34;, \u0026#34;expires_in\u0026#34;: 3600, } See the refresh token section for more information on how to deal with refresh tokens.\n.NET client library The most common client library for .NET is the OpenID Connect authentication handler for ASP.NET Core. This library handles the complete front- and back-channel interaction and coordination.\nYou only need to configure it in your startup code:\npublic void ConfigureServices(IServiceCollection services) { services.AddAuthentication(options =\u0026gt; { options.DefaultScheme = \u0026#34;cookie\u0026#34;; options.DefaultChallengeScheme = \u0026#34;duende\u0026#34;; }) .AddCookie(\u0026#34;cookie\u0026#34;) .AddOpenIdConnect(\u0026#34;duende\u0026#34;, \u0026#34;IdentityServer\u0026#34;, options =\u0026gt; { options.Authority = \u0026#34;https://demo.duendesoftware.com\u0026#34;; options.ClientId = \u0026#34;interactive.confidential\u0026#34;; options.ResponseType = \u0026#34;code\u0026#34;; options.ResponseMode = \u0026#34;query\u0026#34;; options.SaveTokens = true; options.Scope.Clear(); options.Scope.Add(\u0026#34;openid\u0026#34;); options.Scope.Add(\u0026#34;api\u0026#34;); options.Scope.Add(\u0026#34;offline_access\u0026#34;); options.TokenValidationParameters = new TokenValidationParameters { NameClaimType = \u0026#34;name\u0026#34;, RoleClaimType = \u0026#34;role\u0026#34; }; }); } Automating token management in ASP.NET Core The IdentityModel.AspNetCore library can also be used to automate token lifetime management in ASP.NET Core applications for you.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/tokens/authentication/shared_secret/",
    "title": "Shared Secrets",
    "tags": [],
    "description": "",
    "content": "Shared secrets is by far the most common technique for authenticating clients.\nFrom a security point of view they have some shortcomings\nthe shared secrets must be transmitted over the network during authentication they should not be persisted in clear text to reduce the risk of leaking them they should have high entropy to avoid brute-force attacks The following creates a shared secret:\n// loadSecret is responsible for loading a SHA256 or SHA512 hash of a good, // high-entropy secret from a secure storage location var hash = loadSecretHash(); var secret = new Secret(hash); IdentityServer\u0026rsquo;s Secrets are designed to operate on either a SHA256 or SHA512 hash of the shared secret. The shared secret is not stored in IdentityServer - only the hash. The client on the hand needs access to the clear text of the secret. It must send the clear text to authenticate itself.\nIdentityServer provides the Sha256 and Sha512 extension methods on strings as a convenience to produce their hashes. These extension methods can be used when prototyping or during demos to get started quickly. However, the clear text of secrets used in production should never be written down in your source code. Anyone with access to the repository can see the secret.\nvar compromisedSecret = new Secret(\u0026#34;just for demos, not prod!\u0026#34;.Sha256()); Authentication using a shared secret You can either send the client id/secret combination as part of the POST body::\nPOST /connect/token Content-type: application/x-www-form-urlencoded client_id=client\u0026amp; client_secret=secret\u0026amp; grant_type=authorization_code\u0026amp; code=hdh922\u0026amp; redirect_uri=https://myapp.com/callback ..or as a basic authentication header::\nPOST /connect/token Content-type: application/x-www-form-urlencoded Authorization: Basic xxxxx client_id=client1\u0026amp; client_secret=secret\u0026amp; grant_type=authorization_code\u0026amp; code=hdh922\u0026amp; redirect_uri=https://myapp.com/callback .NET client library You can use the IdentityModel client library to programmatically interact with the protocol endpoint from .NET code.\nusing IdentityModel.Client; var client = new HttpClient(); var response = await client.RequestAuthorizationCodeTokenAsync(new AuthorizationCodeTokenRequest { Address = TokenEndpoint, ClientId = \u0026#34;client\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Code = \u0026#34;...\u0026#34;, CodeVerifier = \u0026#34;...\u0026#34;, RedirectUri = \u0026#34;https://app.com/callback\u0026#34; }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/overview/terminology/",
    "title": "Terminology",
    "tags": [],
    "description": "",
    "content": "The specs, documentation and object model use a certain terminology that you should be aware of.\nDuende IdentityServer Duende IdentityServer is an OpenID Connect \u0026amp; OAuth engine - it implements the OpenID Connect and OAuth 2.0 family of protocols.\nDifferent literature uses different terms for the same role - you probably also find the terms security token service, identity provider, authorization server, IP-STS and more.\nBut they are in a nutshell all the same: a piece of software that issues security tokens to clients.\nA typical implementation of Duende IdentityServer has a number of jobs and features - including:\nmanage access to resources authenticate users using a local account store or via an external identity provider provide session management and single sign-on manage and authenticate clients issue identity and access tokens to clients User A user is a human that is using a registered client to access resources.\nClient A client is a piece of software that requests tokens from your IdentityServer - either for authenticating a user (requesting an identity token) or for accessing a resource (requesting an access token). A client must be first registered with your IdentityServer before it can request tokens.\nWhile there are many different client types, e.g. web applications, native mobile or desktop applications, SPAs, server processes etc., they can all be put into two high-level categories.\nMachine to Machine Communication In this scenario two machines talk to each other (e.g. background processes, batch jobs, server daemons), and there is no interactive user present. To authorize this communication, your IdentityServer issues a token to the caller.\nIn protocol terms, this scenario is called Client Credentials Flow and you can learn more about it in the issuing tokens section as well as in our Quickstart.\nInteractive Applications This is the most common type of client scenario: web applications, SPAs or native/mobile apps with interactive users. This scenario typically involves a browser for user interaction (e.g. for authentication or consent).\nIn protocol terms, this scenario is called Authorization Code Flow and you can learn more about it in the issuing tokens section as well as in our Quickstart.\nA client application can potentially have many instances - e.g. your web application might be physically deployed on multiple servers for load-balancing purposes, or your mobile application might be deployed to thousands of different phones. Logically these instances are still a single client.\nResources Resources are something you want to protect with your IdentityServer - either identity data of your users, or APIs.\nEvery resource has a unique name - and clients use this name to specify to which resources they want to get access to.\nIdentity data Identity information (aka claims) about a user, e.g. name or email address.\nAPIs APIs resources represent functionality a client wants to invoke - typically modelled as Web APIs, but not necessarily.\nIdentity Token An identity token represents the outcome of an authentication process. It contains at a bare minimum an identifier for the user (called the sub aka subject claim) and information about how and when the user authenticated. It can contain additional identity data.\nAccess Token An access token allows access to an API resource. Clients request access tokens and forward them to the API. Access tokens contain information about the client and the user (if present). APIs use that information to authorize access to their data and functionality.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/tokens/extension_grants/token_exchange/",
    "title": "Token Exchange",
    "tags": [],
    "description": "",
    "content": "The OAuth Token Exchange specification (RFC 8693) describes a general purpose mechanism for translating between token types. Common use cases are creating tokens for impersonation and delegation purposes - but it is not limited to that.\nYou can leverage the extension grant feature to implement your preferred token exchange logic.\nSome of the logic is boilerplate:\nread and validate incoming protocol parameters validate incoming token using the built-in token validator if the token was issued by the same token service using a token type specific library if the token is coming from a trusted (but different) token service read contents of token to apply custom logic/authorization if needed create response Here\u0026rsquo;s a simple implementation of the above steps:\npublic class TokenExchangeGrantValidator : IExtensionGrantValidator { private readonly ITokenValidator _validator; public TokenExchangeGrantValidator(ITokenValidator validator) { _validator = validator; } // register for urn:ietf:params:oauth:grant-type:token-exchange public string GrantType =\u0026gt; OidcConstants.GrantTypes.TokenExchange; public async Task ValidateAsync(ExtensionGrantValidationContext context) { // default response is error context.Result = new GrantValidationResult(TokenRequestErrors.InvalidRequest); // the spec allows for various token types, most commonly you return an access token var customResponse = new Dictionary\u0026lt;string, object\u0026gt; { { OidcConstants.TokenResponse.IssuedTokenType, OidcConstants.TokenTypeIdentifiers.AccessToken } }; // read the incoming token var subjectToken = context.Request.Raw.Get(OidcConstants.TokenRequest.SubjectToken); // and the token type var subjectTokenType = context.Request.Raw.Get(OidcConstants.TokenRequest.SubjectTokenType); // mandatory parameters if (string.IsNullOrWhiteSpace(subjectToken)) { return; } // for our impersonation/delegation scenario we require an access token if (!string.Equals(subjectTokenType, OidcConstants.TokenTypeIdentifiers.AccessToken)) { return; } // validate the incoming access token with the built-in token validator var validationResult = await _validator.ValidateAccessTokenAsync(subjectToken); if (validationResult.IsError) { return; } // these are two values you typically care about var sub = validationResult.Claims.First(c =\u0026gt; c.Type == JwtClaimTypes.Subject).Value; var clientId = validationResult.Claims.First(c =\u0026gt; c.Type == JwtClaimTypes.ClientId).Value; // add any custom logic here (if needed) // create response } } You then register your grant validator with DI:\nbuilder.AddExtensionGrantValidator\u0026lt;TokenExchangeGrantValidator\u0026gt;(); And configure your client to be able to use it:\nclient.AllowedGrantTypes = { OidcConstants.GrantTypes.TokenExchange }; Values sent to the token endpoint are logged, except well-known sensitive values that IdentityServer processes by default. Any sensitive values you use as input to your extension grant validator that you do not want included in the logs should be filtered. This can be done by adding those parameter names on the Logging.TokenRequestSensitiveValuesFilter collection on the IdentityServerOptions.\nToken Exchange for impersonation and delegation One of the primary use cases of the token exchange specification is creating tokens for identity delegation and impersonation scenarios. In these scenarios you want to forward certain token and identity information over multiple hops in a call chain.\nImpersonation In the impersonation use case, API 1 doing the token exchange becomes \u0026ldquo;invisible\u0026rdquo;. For API 2 it looks like as if the front end is doing a direct call. The token would look like this (simplified):\n{ \u0026#34;client_id\u0026#34;: \u0026#34;front_end\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;scope\u0026#34;: [ \u0026#34;api2\u0026#34; ] } Add the following code to the above validator to create an impersonation response:\n// set token client_id to original id context.Request.ClientId = clientId; // create impersonation response context.Result = new GrantValidationResult( subject: sub, authenticationMethod: GrantType, customResponse: customResponse); Delegation In the delegation use case, the call chain is preserved using the act claim, e.g.:\n{ \u0026#34;client_id\u0026#34;: \u0026#34;front-end\u0026#34;, \u0026#34;act\u0026#34;: { \u0026#34;client_id\u0026#34;: \u0026#34;api1\u0026#34; }, \u0026#34;sub\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;scope\u0026#34;: [ \u0026#34;api2\u0026#34; ] } For API 2 it still looks like that the front-end is making the call, but by inspecting the act claim, the API can learn about the traversed call chain.\nThe following code adds the act claim to the response:\n// set token client_id to original id context.Request.ClientId = clientId; // create actor data structure var actor = new { client_id = context.Request.Client.ClientId }; // create act claim var actClaim = new Claim(JwtClaimTypes.Actor, JsonSerializer.Serialize(actor), IdentityServerConstants.ClaimValueTypes.Json); context.Result = new GrantValidationResult( subject: sub, authenticationMethod: GrantType, claims: new[] { actClaim }, customResponse: customResponse); To emit the act claim into outgoing tokens, your profile service must know about it. The following simple profile service emits the act claim if the token request is in the context of a token exchange operation:\npublic class ProfileService : IProfileService { public override async Task GetProfileDataAsync(ProfileDataRequestContext context) { // add actor claim if needed if (context.Subject.GetAuthenticationMethod() == OidcConstants.GrantTypes.TokenExchange) { var act = context.Subject.FindFirst(JwtClaimTypes.Actor); if (act != null) { context.IssuedClaims.Add(act); } } // rest omitted } // rest omitted } See here for the full source code.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/apis/aspnetcore/jwt/",
    "title": "Using JWTs",
    "tags": [],
    "description": "",
    "content": "On ASP.NET Core, you typically use the JWT authentication handler for validating JWT bearer tokens.\nValidating a JWT token First you need to add a reference to the authentication handler in your API project:\n\u0026lt;PackageReference Include=\u0026#34;Microsoft.AspNetCore.Authentication.JwtBearer\u0026#34; /\u0026gt; If all you care about is making sure that an access token comes from your trusted IdentityServer, the following snippet shows the typical JWT validation configuration for ASP.NET Core:\npublic class Startup { public void ConfigureServices(IServiceCollection services) { services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) .AddJwtBearer(options =\u0026gt; { // base-address of your identityserver options.Authority = \u0026#34;https://demo.duendesoftware.com\u0026#34;; // audience is optional, make sure you read the following paragraphs // to understand your options options.TokenValidationParameters.ValidateAudience = false; // it\u0026#39;s recommended to check the type header to avoid \u0026#34;JWT confusion\u0026#34; attacks options.TokenValidationParameters.ValidTypes = new[] { \u0026#34;at+jwt\u0026#34; }; }); } } On .NET Core 3.1 you need to manually reference the System.IdentityModel.Tokens.Jwt NuGet package version 5.6 to be able to check the type header.\nAdding audience validation Simply making sure that the token is coming from a trusted issuer is not good enough for most cases. In more complex systems, you will have multiple resources and multiple clients. Not every client might be authorized to access every resource.\nIn OAuth there are two complementary mechanisms to embed more information about the \u0026ldquo;functionality\u0026rdquo; that the token is for - audience and scope (see defining resources for more information).\nIf you designed your APIs around the concept of API resources, your IdentityServer will emit the aud claim by default (api1 in this example):\n{ \u0026#34;typ\u0026#34;: \u0026#34;at+jwt\u0026#34;, \u0026#34;kid\u0026#34;: \u0026#34;123\u0026#34; }. { \u0026#34;aud\u0026#34;: \u0026#34;api1\u0026#34;, \u0026#34;client_id\u0026#34;: \u0026#34;mobile_app\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;read write delete\u0026#34; } If you want to express in your API, that only access tokens for the api1 audience (aka API resource name) are accepted, change the above code snippet to:\npublic class Startup { public void ConfigureServices(IServiceCollection services) { services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) .AddJwtBearer(options =\u0026gt; { options.Authority = \u0026#34;https://demo.duendesoftware.com\u0026#34;; options.Audience = \u0026#34;api1\u0026#34;; options.TokenValidationParameters.ValidTypes = new[] { \u0026#34;at+jwt\u0026#34; }; }); } } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/apis/aspnetcore/",
    "title": "Protecting APIs using ASP.NET Core",
    "tags": [],
    "description": "",
    "content": "Protecting APIs using ASP.NET Core Using JWTs Using Reference Tokens Authorization based on Scopes and other Claims Validating Proof-of-Possession "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/response_handling/authorize_interaction_response_generator/",
    "title": "Authorize Interaction Response Generator",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.ResponseHandling.IAuthorizeInteractionResponseGenerator The IAuthorizeInteractionResponseGenerator interface models the logic for determining if user must login or consent when making requests to the authorization endpoint.\nIf a custom implementation of IAuthorizeInteractionResponseGenerator is desired, then it\u0026rsquo;s recommended to derive from the built-in AuthorizeInteractionResponseGenerator to inherit all the default logic pertaining to login and consent semantics.\nIAuthorizeInteractionResponseGenerator APIs ProcessInteractionAsync\nReturns the InteractionResponse based on the ValidatedAuthorizeRequest an and optional ConsentResponse if the user was shown a consent page.\nInteractionResponse IsLogin\nSpecifies if the user must login.\nIsConsent\nSpecifies if the user must consent.\nIsCreateAccount\nAdded in v6.3.\nSpecifies if the user must create an account.\nIsError\nSpecifies if the user must be shown an error page.\nError\nThe error to display on the error page.\nErrorDescription\nThe description of the error to display on the error page.\nIsRedirect\nSpecifies if the user must be redirected to a custom page for custom processing.\nRedirectUrl\nThe URL for the redirect to the page for custom processing.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/quickstarts/js_clients/",
    "title": "Building JavaScript client applications",
    "tags": [],
    "description": "",
    "content": "JavaScript/SPA Client Applications When building JavaScript (or SPA) applications, there are two main styles: those with a backend and those without.\nJavaScript applications with a backend are more secure, making it the preferred style. This style uses the \u0026ldquo;Backend For Frontend\u0026rdquo; pattern, or \u0026ldquo;BFF\u0026rdquo; for short, which relies on the backend host to implement all of the security protocol interactions with the token server. The Duende.BFF library is used in this quickstart to easily support the BFF pattern.\nJavaScript applications without a backend need to do all the security protocol interactions on the client-side, including driving user authentication and token requests, session and token management, and token storage. This leads to more complex JavaScript, cross-browser incompatibilities, and a considerably higher attack surface. Since this style inherently needs to store security sensitive artifacts (like tokens) in JavaScript reachable locations, this style is not encouraged for applications dealing with sensitive data. As the \u0026ldquo;OAuth 2.0 for Browser-Based Apps\u0026rdquo; IETF/OAuth working group BCP document says\nthere is no browser API that allows to store tokens in a completely secure way.\nAdditionally, modern browsers have recently added or are planning to add privacy features that can break some front-channel protocol interactions. See here for more details.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/data/configuration/",
    "title": "Configuration Data",
    "tags": [],
    "description": "",
    "content": "Configuration data models the information for Clients and Resources.\nStores Store interfaces are designed to abstract accessing the configuration data. The stores used in Duende IdentityServer are:\nClient store for Client data. CORS policy service for CORS support. Given that this is so closely tied to the Client configuration data, the CORS policy service is considered one of the configuration stores. Resource store for IdentityResource, ApiResource, and ApiScope data. Identity Provider store for IdentityProvider data. Registering Custom Stores Custom implementations of the stores must be registered in the DI system. There are convenience methods for registering these. For example:\npublic void ConfigureServices(IServiceCollection services) { services.AddIdentityServer() .AddClientStore\u0026lt;YourCustomClientStore\u0026gt;() .AddCorsPolicyService\u0026lt;YourCustomCorsPolicyService\u0026gt;() .AddResourceStore\u0026lt;YourCustomResourceStore\u0026gt;() .AddIdentityProviderStore\u0026lt;YourCustomAddIdentityProviderStore\u0026gt;(); } Caching Configuration Data Configuration data is used frequently during request processing. If this data is loaded from a database or other external store, then it might be expensive to frequently re-load the same data.\nDuende IdentityServer provides convenience methods to enable caching data from the various stores. The caching implementation relies upon an ICache\u0026lt;T\u0026gt; service and must also be added to DI. For example:\npublic void ConfigureServices(IServiceCollection services) { services.AddIdentityServer() .AddClientStore\u0026lt;YourCustomClientStore\u0026gt;() .AddCorsPolicyService\u0026lt;YourCustomCorsPolicyService\u0026gt;() .AddResourceStore\u0026lt;YourCustomResourceStore\u0026gt;() .AddInMemoryCaching() .AddClientStoreCache\u0026lt;YourCustomClientStore\u0026gt;() .AddCorsPolicyCache\u0026lt;YourCustomCorsPolicyService\u0026gt;() .AddResourceStoreCache\u0026lt;YourCustomResourceStore\u0026gt;() .AddIdentityProviderStoreCache\u0026lt;YourCustomAddIdentityProviderStore\u0026gt;(); } The duration of the data in the default cache is configurable on the IdentityServerOptions. For example:\npublic void ConfigureServices(IServiceCollection services) { services.AddIdentityServer(options =\u0026gt; { options.Caching.ClientStoreExpiration = TimeSpan.FromMinutes(5); options.Caching.ResourceStoreExpiration = TimeSpan.FromMinutes(5); }) .AddClientStore\u0026lt;YourCustomClientStore\u0026gt;() .AddCorsPolicyService\u0026lt;YourCustomCorsPolicyService\u0026gt;() .AddResourceStore\u0026lt;YourCustomResourceStore\u0026gt;() .AddInMemoryCaching() .AddClientStoreCache\u0026lt;YourCustomClientStore\u0026gt;() .AddCorsPolicyCache\u0026lt;YourCustomCorsPolicyService\u0026gt;() .AddResourceStoreCache\u0026lt;YourCustomResourceStore\u0026gt;(); } Further customization of the cache is possible:\nIf you wish to customize the caching behavior for the specific configuration objects, you can replace the ICache\u0026lt;T\u0026gt; service implementation in the dependency injection system. The default implementation of the ICache\u0026lt;T\u0026gt; itself relies upon the IMemoryCache interface (and MemoryCache implementation) provided by .NET. If you wish to customize the in-memory caching behavior, you can replace the IMemoryCache implementation in the dependency injection system. In-Memory Stores The various in-memory configuration APIs allow for configuring IdentityServer from an in-memory list of the various configuration objects. These in-memory collections can be hard-coded in the hosting application, or could be loaded dynamically from a configuration file or a database. By design, though, these collections are only created when the hosting application is starting up.\nUse of these configuration APIs are designed for use when prototyping, developing, and/or testing where it is not necessary to dynamically consult database at runtime for the configuration data. This style of configuration might also be appropriate for production scenarios if the configuration rarely changes, or it is not inconvenient to require restarting the application if the value must be changed.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/validators/custom_authorize_request_validator/",
    "title": "Custom Authorize Request Validator",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Validation.ICustomAuthorizeRequestValidator Allows running custom code as part of the authorization issuance pipeline at the authorization endpoint.\n/// \u0026lt;summary\u0026gt; /// Allows inserting custom validation logic into authorize requests /// \u0026lt;/summary\u0026gt; public interface ICustomAuthorizeRequestValidator { /// \u0026lt;summary\u0026gt; /// Custom validation logic for the authorize request. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;context\u0026#34;\u0026gt;The context.\u0026lt;/param\u0026gt; Task ValidateAsync(CustomAuthorizeRequestValidationContext context); } ValidateAsync\nThis method gets called during authorize request processing. The context gives you access to request and response parameters.\nTo fail the request, set the the IsError, the Error, and optionally the ErrorDescription properties on the Result object on the CustomAuthorizeRequestValidationContext.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/fundamentals/hosting/",
    "title": "Hosting",
    "tags": [],
    "description": "",
    "content": "You add the Duende IdentityServer engine to any ASP.NET Core application by adding the relevant services to the dependency injection (DI) system and adding the middleware to the processing pipeline.\nWhile technically you could share the ASP.NET Core host between Duende IdentityServer, clients or APIs. We recommend putting your IdentityServer into a separate application.\nDI system You add the necessary services to the DI system by calling AddIdentityServer in your startup class:\npublic void ConfigureServices(IServiceCollection services) { var builder = services.AddIdentityServer(options =\u0026gt; { ... }); } Many of the fundamental configuration settings can be set on the options. See the IdentityServerOptions reference for more details.\nThe builder object has a number of extension methods to add additional services to DI. You can see the full list in the reference section, but very commonly you start by adding the configuration stores for clients and resources, e.g.:\nvar builder = services.AddIdentityServer() .AddInMemoryClients(Config.Clients) .AddInMemoryIdentityResources(Config.IdentityResources) .AddInMemoryApiScopes(Config.ApiScopes) The above is using the in-memory stores, but we also support EntityFramework-based implementations and custom stores. See here for more information.\nPipeline You need to add the Duende IdentityServer middleware to the pipeline by calling UseIdentityServer.\nSince ordering is important in the pipeline, you typically want to put the IdentityServer middleware after the static files, but before the UI framework like MVC.\nThis would be a very typical minimal pipeline:\npublic void Configure(IApplicationBuilder app) { app.UseStaticFiles(); app.UseRouting(); app.UseIdentityServer(); app.UseAuthorization(); app.UseEndpoints(endpoints =\u0026gt; { endpoints.MapDefaultControllerRoute(); }); } UseIdentityServer includes a call to UseAuthentication, so it’s not necessary to have both.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/options/",
    "title": "IdentityServer Options",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Configuration.IdentityServerOptions The IdentityServerOptions is the central place to configure fundamental settings in Duende IdentityServer.\nYou set the options when registering IdentityServer at startup time, using a lambda expression in the AddIdentityServer method:\nvar builder = services.AddIdentityServer(options =\u0026gt; { // configure options here.. }) Main Top-level settings. Available directly on the IdentityServerOptions object.\nIssuerUri\nThe name of the token server, used in the discovery document as the issuer claim and in JWT tokens and introspection responses as the iss claim.\nIt is not recommended to set this option. If it is not set (the default), the issuer is inferred from the URL used by clients. This better conforms to the OpenID Connect specification, which requires that issuer values be \u0026ldquo;identical to the Issuer URL that was directly used to retrieve the configuration information\u0026rdquo;. It is also more convenient for clients to validate the issuer of tokens, because they will not need additional configuration or customization to know the expected issuer.\nLowerCaseIssuerUri\nControls the casing of inferred IssuerUris. When set to false, the original casing of the IssuerUri in requests is preserved. When set to true, the IssuerUri is converted to lowercase. Defaults to true.\nAccessTokenJwtType\nThe value used for the typ header in JWT access tokens. Defaults to at+jwt, as specified by the RFC 9068. If AccessTokenJwtType is set to null or the empty string, the typ header will not be emitted in JWT access tokens.\nLogoutTokenJwtType\nThe value for the typ header in back-channel logout tokens. Defaults to \u0026ldquo;logout+jwt\u0026rdquo;, as specified by OpenID Connect Back-Channel Logout 1.0.\nEmitScopesAsSpaceDelimitedStringInJwt\nControls the format of scope claims in JWTs and introspection responses. Historically scopes values were emitted as an array in JWT access tokens. RFC 9068 now specifies a space delimited string instead. Defaults to false for backwards compatibility.\nEmitStaticAudienceClaim\nEmits a static aud claim in all access tokens with the format issuer/resources. Defaults to false.\nEmitIssuerIdentificationResponseParameter\nEmits the iss response parameter on authorize responses, as specified by RFC 9207. Defaults to true.\nEmitStateHash\nEmits the s_hash claim in identity tokens. The s_hash claim is a hash of the state parameter that is specified in the OpenID Connect Financial-grade API Security Profile. Defaults to false.\nStrictJarValidation\nStrictly validate JWT-secured authorization requests according to RFC 9101. When enabled, JWTs used to secure authorization requests must have the typ header value oauth-authz-req+jwt and JWT-secured authorization requests must have the HTTP content-type header value application/oauth-authz-req+jwt. This might break older OIDC conformant request objects. Defaults to false.\nValidateTenantOnAuthorization\nSpecifies if a user\u0026rsquo;s tenant claim is compared to the tenant acr_values parameter value to determine if the login page is displayed. Defaults to false.\nKey management Automatic key management settings. Available on the KeyManagement property of the IdentityServerOptions object.\nEnabled\nEnables automatic key management. Defaults to true.\nSigningAlgorithms\nThe signing algorithms for which automatic key management will manage keys.\nThis option is configured with a list of objects containing a Name property, which is the name of a supported signing algorithm, and a UseX509Certificate property, which is a flag indicating if the signing key should be wrapped in an X.509 certificate.\nThe first algorithm in the collection will be used as the default for clients that do not specify AllowedIdentityTokenSigningAlgorithms.\nThe supported signing algorithm names are RS256, RS384, RS512, PS256, PS384, PS512, ES256, ES384, and ES512.\nX.509 certificates are not supported for ES256, ES384, and ES512 keys.\nDefaults to RS256 without an X.509 certificate.\nRsaKeySize\nKey size (in bits) of RSA keys. The signing algorithms that use RSA keys (RS256, RS384, RS512, PS256, PS384, and PS512) will generate an RSA key of this length. Defaults to 2048.\nRotationInterval\nAge at which keys will no longer be used for signing, but will still be used in discovery for validation. Defaults to 90 days.\nPropagationTime\nTime expected to propagate new keys to all servers, and time expected all clients to refresh discovery. Defaults to 14 days.\nRetentionDuration\nDuration for keys to remain in discovery after rotation. Defaults to 14 days.\nDeleteRetiredKeys\nAutomatically delete retired keys. Defaults to true.\nKeyPath\nPath for storing keys when using the default file system store. Defaults to the \u0026ldquo;keys\u0026rdquo; directory relative to the hosting application.\nDataProtectKeys\nAutomatically protect keys in the storage using data protection. Defaults to true.\nKeyCacheDuration\nWhen in normal operation, duration to cache keys from store. Defaults to 24 hours.\nInitializationDuration\nWhen no keys have been created yet, this is the window of time considered to be an initialization period to allow all servers to synchronize if the keys are being created for the first time. Defaults to 5 minutes.\nInitializationSynchronizationDelay\nDelay used when re-loading from the store when the initialization period. It allows other servers more time to write new keys so other servers can include them. Defaults to 5 seconds.\nInitializationKeyCacheDuration\nCache duration when within the initialization period. Defaults to 1 minute.\nEndpoints Endpoint settings, including flags to disable individual endpoints and support for the request_uri JAR parameter. Available on the Endpoints property of the IdentityServerOptions object.\nEnableAuthorizeEndpoint\nEnables the authorize endpoint. Defaults to true.\nEnableTokenEndpoint\nEnables the token endpoint. Defaults to true.\nEnableDiscoveryEndpoint\nEnables the discovery endpoint. Defaults to true.\nEnableUserInfoEndpoint\nEnables the user info endpoint. Defaults to true.\nEnableEndSessionEndpoint\nEnables the end session endpoint. Defaults to true.\nEnableCheckSessionEndpoint\nEnables the check session endpoint. Defaults to true.\nEnableTokenRevocationEndpoint\nEnables the token revocation endpoint. Defaults to true.\nEnableIntrospectionEndpoint\nEnables the introspection endpoint. Defaults to true.\nEnableDeviceAuthorizationEndpoint\nEnables the device authorization endpoint. Defaults to true.\nEnableBackchannelAuthenticationEndpoint\nEnables the backchannel authentication endpoint. Defaults to true.\nEnableJwtRequestUri Enables the request_uri parameter for JWT-Secured Authorization Requests. This allows the JWT to be passed by reference. Disabled by default, due to the security implications of enabling the request_uri parameter (see RFC 9101 section 10.4).\nDiscovery Discovery settings, including flags to toggle sections of the discovery document and settings to add custom entries to it. Available on the Discovery property of the IdentityServerOptions object.\nIf you want to take full control over the rendering of the discovery and jwks documents, you can implement the IDiscoveryResponseGenerator interface (or derive from our default implementation).\nShowEndpoints\nShows endpoints (authorization_endpoint, token_endpoint, etc) in the discovery document. Defaults to true.\nShowKeySet\nShows the jwks_uri in the discovery document and enables the jwks endpoint. Defaults to true.\nShowIdentityScopes\nIncludes IdentityResources in the supported_scopes of the discovery document. Defaults to true.\nShowApiScopes\nIncludes ApiScopes in the supported_scopes of the discovery document. Defaults to true.\nShowClaims\nShows claims_supported in the discovery document. Defaults to true.\nShowResponseTypes\nShows response_types_supported in the discovery document. Defaults to true.\nShowResponseModes\nShows response_modes_supported in the discovery document. Defaults to true.\nShowGrantTypes\nShows grant_types_supported in the discovery document. Defaults to true.\nShowExtensionGrantTypes\nIncludes extension grant types in the grant_types_supported of the discovery document. Defaults to true.\nShowTokenEndpointAuthenticationMethods\nShows token_endpoint_auth_methods_supported in the discovery document. Defaults to true.\nCustomEntries Adds custom elements to the discovery document. For example:\nvar builder = services.AddIdentityServer(options =\u0026gt; { options.Discovery.CustomEntries.Add(\u0026#34;my_setting\u0026#34;, \u0026#34;foo\u0026#34;); options.Discovery.CustomEntries.Add(\u0026#34;my_complex_setting\u0026#34;, new { foo = \u0026#34;foo\u0026#34;, bar = \u0026#34;bar\u0026#34; }); }); ExpandRelativePathsInCustomEntries Expands paths in custom entries that begin with \u0026ldquo;~/\u0026rdquo; into absolute paths below the IdentityServer base address. Defaults to true. In the following example, if IdentityServer\u0026rsquo;s base address is https://localhost:5001, then my_custom_endpoint\u0026rsquo;s value will be expanded to https://localhost:5001/custom. options.Discovery.CustomEntries.Add(\u0026#34;my_custom_endpoint\u0026#34;, \u0026#34;~/custom\u0026#34;); Authentication Login/logout related settings. Available on the Authentication property of the IdentityServerOptions\nCookieAuthenticationScheme\nSets the cookie authentication scheme configured by the host used for interactive users. If not set, the scheme will be inferred from the host\u0026rsquo;s default authentication scheme. This setting is typically used when AddPolicyScheme is used in the host as the default scheme.\nCookieLifetime\nThe authentication cookie lifetime (only effective if the IdentityServer-provided cookie handler is used). Defaults to 10 hours.\nCookieSlidingExpiration\nSpecifies if the cookie should be sliding or not (only effective if the IdentityServer-provided cookie handler is used). Defaults to false.\nCookieSameSiteMode\nSpecifies the SameSite mode for the internal cookies. Defaults to None.\nRequireAuthenticatedUserForSignOutMessage\nIndicates if user must be authenticated to accept parameters to end session endpoint. Defaults to false.\nCheckSessionCookieName\nThe name of the cookie used for the check session endpoint. Defaults to the constant IdentityServerConstants.DefaultCheckSessionCookieName, which has the value \u0026ldquo;idsrv.session\u0026rdquo;.\nCheckSessionCookieDomain\nThe domain of the cookie used for the check session endpoint. Defaults to null.\nCheckSessionCookieSameSiteMode\nThe SameSite mode of the cookie used for the check session endpoint. Defaults to None.\nRequireCspFrameSrcForSignout\nEnables all content security policy headers on the end session endpoint. For historical reasons, this option\u0026rsquo;s name mentions frame-src, but the content security policy headers on the end session endpoint also include other fetch directives, including a default-src \u0026rsquo;none\u0026rsquo; directive, which prevents most resources from being loaded by the end session endpoint, and a style-src directive that specifies the hash of the expected style on the page.\nCoordinateClientLifetimesWithUserSession (added in 6.1)\nWhen enabled, all clients\u0026rsquo; token lifetimes (e.g. refresh tokens) will be tied to the user\u0026rsquo;s session lifetime. This means when the user logs out, any revokable tokens will be removed. If using server-side sessions, expired sessions will also remove any revokable tokens, and backchannel logout will be triggered. An individual client can override this setting with its own CoordinateLifetimeWithUserSession configuration setting.\nEvents Configures which events should be raised at the registered event sink.\nRaiseSuccessEvents\nEnables success events. Defaults to false. Success events include all the events whose names are postfixed with \u0026ldquo;SuccessEvent\u0026rdquo;. In general, they are raised when properly formed and valid requests are processed without errors.\nRaiseFailureEvents\nEnables failure events. Defaults to false. Failure events include all the events whose names are postfixed with \u0026ldquo;FailureEvent\u0026rdquo;. In general, they are raised when an action has failed because of incorrect or badly formed parameters in a request. They indicate that the user or client calling IdentityServer has done something wrong and are analogous to a 400: bad request error.\nRaiseErrorEvents\nEnables Error events. Defaults to false. Error events are raised when an error has occurred, either because of invalid configuration or an unhandled exception. They indicate that there is something wrong within the token server or its configuration and are analogous to a 500: internal server error.\nRaiseInformationEvents\nEnables Information events. Defaults to false. Information events are emitted when an action has occurred that is of informational interest, but that is neither a success nor a failure. For example, when the end user grants, denies, or revokes consent, that is considered an information event, because these events capture a valid choice of the user rather than success or failure.\nLogging Logging related settings, including filters that will remove sensitive values and unwanted exceptions from logs. Available on the Logging property of the IdentityServerOptions object.\nAuthorizeRequestSensitiveValuesFilter\nCollection of parameter names passed to the authorize endpoint that are considered sensitive and will be excluded from logging. Defaults to id_token_hint.\nTokenRequestSensitiveValuesFilter\nCollection of parameter names passed to the token endpoint that are considered sensitive and will be excluded from logging. Defaults to client_secret, password, client_assertion, refresh_token, and device_code.\nBackchannelAuthenticationRequestSensitiveValuesFilter\nCollection of parameter names passed to the backchannel authentication endpoint that are considered senstivie and will be excluded from logging. Defaults to client_secret, client_assertion, and id_token_hint.\nUnhandledExceptionLoggingFilter (Added in 6.2)\nA function that is called when the IdentityServer middleware detects an unhandled exception, and is used to determine if the exception is logged. The arguments to the function are the HttpContext and the Exception. It should return true to log the exception, and false to suppress. The default is to suppress TaskCanceledExceptions when the CancellationToken on the HttpContext has requested cancellation. Such exceptions are thrown when Http requests are canceled, which is an expected occurrence. Logging them creates unnecessary noise in the logs.\nInputLengthRestrictions Settings that control the allowed length of various protocol parameters, such as client id, scope, redirect URI etc. Available on the InputLengthRestrictions property of the IdentityServerOptions object.\nClientId\nMax length for ClientId. Defaults to 100.\nClientSecret\nMax length for external client secrets. Defaults to 100.\nScope\nMax length for scope. Defaults to 300.\nRedirectUri\nMax length for redirect_uri. Defaults to 400.\nNonce\nMax length for nonce. Defaults to 300.\nUiLocale\nMax length for ui_locale. Defaults to 100.\nLoginHint\nMax length for login_hint. Defaults to 100.\nAcrValues\nMax length for acr_values. Defaults to 300.\nGrantType\nMax length for grant_type. Defaults to 100.\nUserName\nMax length for username. Defaults to 100.\nPassword\nMax length for password. Defaults to 100.\nCspReport\nMax length for CSP reports. Defaults to 2000.\nIdentityProvider\nMax length for external identity provider name. Defaults to 100.\nExternalError\nMax length for external identity provider errors. Defaults to 100.\nAuthorizationCode\nMax length for authorization codes. Defaults to 100.\nDeviceCode\nMax length for device codes. Defaults to 100.\nRefreshToken\nMax length for refresh tokens. Defaults to 100.\nTokenHandle\nMax length for token handles. Defaults to 100.\nJwt\nMax length for JWTs. Defaults to 51200.\nCodeChallengeMinLength\nMin length for the code challenge. Defaults to 43.\nCodeChallengeMaxLength\nMax length for the code challenge. Defaults to 128.\nCodeVerifierMinLength\nMin length for the code verifier. Defaults to 43.\nCodeVerifierMaxLength\nMax length for the code verifier. Defaults to 128.\nResourceIndicatorMaxLength\nMax length for resource indicator parameter. Defaults to 512.\nBindingMessage\nMax length for binding_message. Defaults to 100.\nUserCode\nMax length for user_code. Defaults to 100.\nIdTokenHint\nMax length for id_token_hint. Defaults to 4000.\nLoginHintToken\nMax length for login_hint_token. Defaults to 4000.\nAuthenticationRequestId Max length for auth_req_id. Defaults to 100.\nUserInteraction User interaction settings, including urls for pages in the UI, names of parameters to those pages, and other settings related to interactive flows. Available on the UserInteraction property of the IdentityServerOptions object.\nLoginUrl, LogoutUrl, ConsentUrl, ErrorUrl, DeviceVerificationUrl\nSets the URLs for the login, logout, consent, error and device verification pages.\nCreateAccountUrl\nAdded in v6.3.\nSets the URL for the create account page, which is used by OIDC requests that include the prompt=create parameter. When this option is set, including the prompt=create parameter will cause the user to be redirected to the specified url. create will also be added to the discovery document\u0026rsquo;s prompt_values_supported array to announce support for this feature. When this option is not set, the prompt=create parameter is ignored, and create is not added to discovery. Defaults to null.\nLoginReturnUrlParameter\nSets the name of the return URL parameter passed to the login page. Defaults to returnUrl.\nLogoutIdParameter\nSets the name of the logout message id parameter passed to the logout page. Defaults to logoutId.\nConsentReturnUrlParameter\nSets the name of the return URL parameter passed to the consent page. Defaults to returnUrl.\nErrorIdParameter\nSets the name of the error message id parameter passed to the error page. Defaults to errorId.\nCustomRedirectReturnUrlParameter\nSets the name of the return URL parameter passed to a custom redirect from the authorization endpoint. Defaults to returnUrl.\nDeviceVerificationUserCodeParameter\nSets the name of the user code parameter passed to the device verification page. Defaults to userCode.\nCookieMessageThreshold\nCertain interactions between IdentityServer and some UI pages require a cookie to pass state and context (any of the pages above that have a configurable \u0026ldquo;message id\u0026rdquo; parameter). Since browsers have limits on the number of cookies and their size, this setting is used to prevent too many cookies being created. The value sets the maximum number of message cookies of any type that will be created. The oldest message cookies will be purged once the limit has been reached. This effectively indicates how many tabs can be opened by a user when using IdentityServer. Defaults to 2.\nAllowOriginInReturnUrl\nFlag that allows return URL validation to accept full URL that includes the IdentityServer origin. Defaults to false.\nCaching Caching settings for the stores. Available on the Caching property of the IdentityServerOptions object. These settings only apply if the respective caching has been enabled in the services configuration in startup.\nClientStoreExpiration\nCache duration of client configuration loaded from the client store. Defaults to 15 minutes.\nResourceStoreExpiration\nCache duration of identity and API resource configuration loaded from the resource store. Defaults to 15 minutes.\nCorsExpiration\nCache duration of CORS configuration loaded from the CORS policy service. Defaults to 15 minutes.\nIdentityProviderCacheDuration\nCache duration of identity provider configuration loaded from the identity provider store. Defaults to 60 minutes.\nCacheLockTimeout\nThe timeout for concurrency locking in the default cache. Defaults to 60 seconds.\nCORS CORS settings for IdentityServer\u0026rsquo;s endpoints. Available on the Cors property of the IdentityServerOptions object. The underlying CORS implementation is provided from ASP.NET Core, and as such it is automatically registered in the dependency injection system.\nCorsPolicyName\nName of the CORS policy that will be evaluated for CORS requests into IdentityServer. Defaults to IdentityServer. The policy provider that handles this is implemented in terms of the ICorsPolicyService registered in the dependency injection system. If you wish to customize the set of CORS origins allowed to connect, then it is recommended that you provide a custom implementation of ICorsPolicyService.\nCorsPaths\nThe endpoints within IdentityServer where CORS is supported. Defaults to the discovery, user info, token, and revocation endpoints.\nPreflightCacheDuration\nIndicates the value to be used in the preflight Access-Control-Max-Age response header. Defaults to null indicating no caching header is set on the response.\nContent Security Policy Settings for Content Security Policy (CSP) headers that IdentityServer emits. Available on the Csp property of the IdentityServerOptions object.\nLevel\nThe level of CSP to use. CSP Level 2 is used by default, but this can be changed to CspLevel.One to accommodate older browsers.\nAddDeprecatedHeader\nIndicates if the older X-Content-Security-Policy CSP header should also be emitted in addition to the standards-based header value. Defaults to true.\nDevice Flow OAuth device flow settings. Available on the DeviceFlow property of the IdentityServerOptions object.\nDefaultUserCodeType\nThe user code type to use, unless set at the client level. Defaults to Numeric, a 9-digit code.\nInterval\nThe maximum frequency in seconds that a client may poll the token endpoint in the device flow. Defaults to 5.\nMutual TLS Mutual TLS settings. Available on the MutualTls property of the IdentityServerOptions object.\nvar builder = services.AddIdentityServer(options =\u0026gt; { options.MutualTls.Enabled = true; // use mtls sub-domain options.MutualTls.DomainName = \u0026#34;mtls\u0026#34;; options.MutualTls.AlwaysEmitConfirmationClaim = true; }) Enabled\nSpecifies if MTLS support should be enabled. Defaults to false.\nClientCertificateAuthenticationScheme\nSpecifies the name of the authentication handler for X.509 client certificates. Defaults to Certificate.\nDomainName\nSpecifies either the name of the sub-domain or full domain for running the MTLS endpoints. MTLS will use path-based endpoints if not set (the default). Use a simple string (e.g. \u0026ldquo;mtls\u0026rdquo;) to set a sub-domain, use a full domain name (e.g. \u0026ldquo;identityserver-mtls.io\u0026rdquo;) to set a full domain name. When a full domain name is used, you also need to set the IssuerName to a fixed value.\nAlwaysEmitConfirmationClaim\nSpecifies whether a cnf claim gets emitted for access tokens if a client certificate was present. Normally the cnf claims only gets emitted if the client used the client certificate for authentication, setting this to true, will set the claim regardless of the authentication method. Defaults to false.\nPersistentGrants Shared settings for persisted grants behavior.\nDataProtectData\nData protect the persisted grants \u0026ldquo;data\u0026rdquo; column. Defaults to true. If your database is already protecting data at rest, then you can consider disabling this.\nDeleteOneTimeOnlyRefreshTokensOnUse (added in 6.3)\nWhen Refresh tokens that are configured with RefreshTokenUsage.OneTime are used, this option controls if they will be deleted immediately or retained and marked as consumed. The default is on - immediately delete.\nDynamic Providers Settings for dynamic providers. Available on the DynamicProviders property of the IdentityServerOptions object.\nPathPrefix\nPrefix in the pipeline for callbacks from external providers. Defaults to \u0026ldquo;/federation\u0026rdquo;.\nSignInScheme\nScheme used for signin. Defaults to the constant IdentityServerConstants.ExternalCookieAuthenticationScheme, which has the value \u0026ldquo;idsrv.external\u0026rdquo;.\nSignOutScheme\nScheme for signout. Defaults to the constant IdentityServerConstants.DefaultCookieAuthenticationScheme, which has the value \u0026ldquo;idsrv\u0026rdquo;.\nCIBA CIBA settings. Available on the Ciba property of the IdentityServerOptions object.\nDefaultLifetime\nThe default lifetime of the pending authentication requests in seconds. Defaults to 300.\nDefaultPollingInterval\nThe maximum frequency in seconds that a client may poll the token endpoint in the CIBA flow. Defaults to 5.\nServer-side Sessions Settings for server-side sessions. Added in 6.1. Available on the ServerSideSessions property of the IdentityServerOptions object.\nUserDisplayNameClaimType\nClaim type used for the user\u0026rsquo;s display name. Unset by default due to possible PII concerns. If used, this would commonly be JwtClaimTypes.Name, JwtClaimType.Email or a custom claim.\nRemoveExpiredSessions\nEnables periodic cleanup of expired sessions. Defaults to true.\nRemoveExpiredSessionsFrequency\nFrequency that expired sessions will be removed. Defaults to 10 minutes.\nRemoveExpiredSessionsBatchSize\nNumber of expired session records to be removed at a time. Defaults to 100.\nExpiredSessionsTriggerBackchannelLogout\nIf enabled, when server-side sessions are removed due to expiration, back-channel logout notifications will be sent. This will, in effect, tie a user\u0026rsquo;s session lifetime at a client to their session lifetime at IdentityServer. Defaults to true.\nValidation InvalidRedirectUriPrefixes\nCollection of URI scheme prefixes that should never be used as custom URI schemes in the redirect_uri passed to tha authorize endpoint or the post_logout_redirect_uri passed to the end_session endpoint. Defaults to [\u0026ldquo;javascript:\u0026rdquo;, \u0026ldquo;file:\u0026rdquo;, \u0026ldquo;data:\u0026rdquo;, \u0026ldquo;mailto:\u0026rdquo;, \u0026ldquo;ftp:\u0026rdquo;, \u0026ldquo;blob:\u0026rdquo;, \u0026ldquo;about:\u0026rdquo;, \u0026ldquo;ssh:\u0026rdquo;, \u0026ldquo;tel:\u0026rdquo;, \u0026ldquo;view-source:\u0026rdquo;, \u0026ldquo;ws:\u0026rdquo;, \u0026ldquo;wss:\u0026rdquo;].\nDPoP Added in 6.3.0.\nDemonstration of Proof-of-Possession settings. Available on the DPoP property of the IdentityServerOptions object.\nProofTokenValidityDuration\nDuration that DPoP proof tokens are considered valid. Defaults to 1 minute.\nServerClockSkew\nClock skew used in validating DPoP proof token expiration using a server-generated nonce value. Defaults to 0.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/configuration/dcr/installation/",
    "title": "Installation and Hosting",
    "tags": [],
    "description": "",
    "content": "The Configuration API can be installed in a separate host from IdentityServer, or in the same host. In many cases it is desirable to host the configuration API and IdentityServer separately. This facilitates the ability to restrict access to the configuration API at the network level separately from IdentityServer and keeps IdentityServer\u0026rsquo;s access to the configuration data read-only. In other cases, you may find that hosting the two systems together better fits your needs.\nSeparate Host for Configuration API To host the configuration API separately from IdentityServer:\nCreate a new empty web application dotnet new web -n Configuration Add the Duende.IdentityServer.Configuration package cd Configuration dotnet add package Duende.IdentityServer.Configuration Configure Services builder.Services.AddIdentityServerConfiguration(opt =\u0026gt; opt.LicenseKey = \u0026#34;\u0026lt;license\u0026gt;\u0026#34;; ); The Configuration API feature is included in the IdentityServer Business edition license and higher. Use the same license key for IdentityServer and the Configuration API.\nAdd and configure the store implementation The Configuration API uses the IClientConfigurationStore abstraction to persist new clients to the configuration store. Your Configuration API host needs an implementation of this interface. You can either use the built-in Entity Framework based implementation, or implement the interface yourself. See the IClientConfigurationStore reference for more details. If you wish to use the built-in implementation, install its NuGet package and add it to DI.\ndotnet add package Duende.IdentityServer.Configuration.EntityFramework builder.Services.AddIdentityServerConfiguration(opt =\u0026gt; opt.LicenseKey = \u0026#34;\u0026lt;license\u0026gt;\u0026#34; ).AddClientConfigurationStore(); var connectionString = builder.Configuration.GetConnectionString(\u0026#34;DefaultConnection\u0026#34;); builder.Services.AddConfigurationDbContext\u0026lt;ConfigurationDbContext\u0026gt;(options =\u0026gt; { options.ConfigureDbContext = builder =\u0026gt; builder.UseSqlite(connectionString); }); Map Configuration Endpoints app.MapDynamicClientRegistration().RequireAuthorization(\u0026#34;DCR\u0026#34;); MapDynamicClientRegistration registers the DCR endpoints and returns an IEndpointConventionBuilder which you can use to define authorization requirements for your DCR endpoint. See Authorization for more details.\nShared Host for Configuration API and IdentityServer To host the configuration API in the same host as IdentityServer:\nAdd the Duende.IdentityServer.Configuration package dotnet add package Duende.IdentityServer.Configuration Add the Configuration API\u0026rsquo;s services to the service collection: builder.Services.AddIdentityServerConfiguration(); Add and configure the store implementation The Configuration API uses the IClientConfigurationStore abstraction to persist new clients to the configuration store. Your Configuration API host needs an implementation of this interface. You can either use the built-in Entity Framework-based implementation, or implement the interface yourself. See the IClientConfigurationStore reference for more details. If you wish to use the built-in implementation, install its NuGet package and add it to DI.\ndotnet add package Duende.IdentityServer.Configuration.EntityFramework builder.Services.AddIdentityServerConfiguration(opt =\u0026gt; opt.LicenseKey = \u0026#34;\u0026lt;license\u0026gt;\u0026#34; ).AddClientConfigurationStore(); var connectionString = builder.Configuration.GetConnectionString(\u0026#34;DefaultConnection\u0026#34;); builder.Services.AddConfigurationDbContext\u0026lt;ConfigurationDbContext\u0026gt;(options =\u0026gt; { options.ConfigureDbContext = builder =\u0026gt; builder.UseSqlite(connectionString); }); Map Configuration Endpoints: app.MapDynamicClientRegistration().RequireAuthorization(\u0026#34;DCR\u0026#34;); MapDynamicClientRegistration registers the DCR endpoints and returns an IEndpointConventionBuilder which you can use to define authorization requirements for your DCR endpoint. See Authorization for more details.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/quickstarts/js_clients/js_with_backend/",
    "title": "JavaScript applications with a backend",
    "tags": [],
    "description": "",
    "content": " We recommend you do the quickstarts in order. If you\u0026rsquo;d like to start here, begin from a copy of the reference implementation of Quickstart 3. Throughout this quickstart, paths are written relative to the base quickstart directory created in part 1, which is the root directory of the reference implementation. You will also need to install the IdentityServer templates.\nIn this quickstart, you will build a browser-based JavaScript client application with a backend. This means your application will have server-side code that supports the frontend application code. This is known as the Backend For Frontend (BFF) pattern.\nYou will implement the BFF pattern with the help of the Duende.BFF library. The backend will implement all of the security protocol interactions with the token server and will be responsible for management of the tokens. The client-side JavaScript authenticates with the BFF using traditional cookie authentication. This simplifies the JavaScript in the client-side, and reduces the attack surface of the application.\nThe features that will be shown in this quickstart will allow the user to login with IdentityServer, invoke a local API hosted in the backend (secured with cookie authentication), invoke a remote API running in a different host (secured with an access token), and logout of IdentityServer.\nNew Project for the JavaScript client and BFF Begin by creating a new project to host the JavaScript application and its BFF. A single project containing the front-end and its BFF facilitates cookie authentication - the front end and BFF need to be on the same host so that cookies will be sent from the front end to the BFF.\nCreate a new ASP.NET Core web application and add it to the solution by running the following commands from the src directory:\ndotnet new web -n JavaScriptClient cd .. dotnet sln add ./src/JavaScriptClient/JavaScriptClient.csproj Add additional NuGet packages Install NuGet packages to add BFF and OIDC support to the new project by running the following commands from the src/JavaScriptClient directory:\ndotnet add package Microsoft.AspNetCore.Authentication.OpenIdConnect dotnet add package Duende.BFF dotnet add package Duende.BFF.Yarp Modify hosting Modify the JavaScriptClient project to run on https://localhost:5003. Its Properties/launchSettings.json should look like this:\n{ \u0026#34;profiles\u0026#34;: { \u0026#34;JavaScriptClient\u0026#34;: { \u0026#34;commandName\u0026#34;: \u0026#34;Project\u0026#34;, \u0026#34;dotnetRunMessages\u0026#34;: true, \u0026#34;launchBrowser\u0026#34;: true, \u0026#34;applicationUrl\u0026#34;: \u0026#34;https://localhost:5003\u0026#34;, \u0026#34;environmentVariables\u0026#34;: { \u0026#34;ASPNETCORE_ENVIRONMENT\u0026#34;: \u0026#34;Development\u0026#34; } } } } Add services In the BFF pattern, the server-side code triggers and receives OpenID Connect requests and responses. To do that, it needs the same services configured as the WebClient did in the prior web application quickstart. Additionally, the BFF services need to be added with AddBff().\nAdd the following to src/JavaScriptClient/Program.cs:\nusing System.IdentityModel.Tokens.Jwt; using System.Security.Claims; using Duende.Bff.Yarp; using Microsoft.AspNetCore.Authorization; var builder = WebApplication.CreateBuilder(args); builder.Services.AddAuthorization(); builder.Services .AddBff() .AddRemoteApis(); JwtSecurityTokenHandler.DefaultMapInboundClaims = false; builder.Services .AddAuthentication(options =\u0026gt; { options.DefaultScheme = \u0026#34;Cookies\u0026#34;; options.DefaultChallengeScheme = \u0026#34;oidc\u0026#34;; options.DefaultSignOutScheme = \u0026#34;oidc\u0026#34;; }) .AddCookie(\u0026#34;Cookies\u0026#34;) .AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { options.Authority = \u0026#34;https://localhost:5001\u0026#34;; options.ClientId = \u0026#34;bff\u0026#34;; options.ClientSecret = \u0026#34;secret\u0026#34;; options.ResponseType = \u0026#34;code\u0026#34;; options.Scope.Add(\u0026#34;api1\u0026#34;); options.SaveTokens = true; options.GetClaimsFromUserInfoEndpoint = true; }); var app = builder.Build(); Add middleware Similarly, the middleware pipeline for this application will resemble the WebClient, with the addition of the BFF middleware and the BFF endpoints. Continuing by adding the following to src/JavaScriptClient/Program.cs:\nvar app = builder.Build(); if (app.Environment.IsDevelopment()) { app.UseDeveloperExceptionPage(); } app.UseDefaultFiles(); app.UseStaticFiles(); app.UseRouting(); app.UseAuthentication(); app.UseBff(); app.UseAuthorization(); app.UseEndpoints(endpoints =\u0026gt; { endpoints.MapBffManagementEndpoints(); }); app.Run(); Add your HTML and JavaScript files Next, add HTML and JavaScript files for your client-side application to the wwwroot directory in the JavaScriptClient project. Create that directory (src/JavaScriptClient/wwwroot) and add an index.html and an app.js file to it.\nindex.html\nThe index.html file will be the main page in your application. It contains\nbuttons for the user to login, logout, and call the APIs a \u0026lt;pre\u0026gt; container used to show messages to the user a \u0026lt;script\u0026gt; tag to include our JavaScript file It should look like this:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=\u0026#34;login\u0026#34;\u0026gt;Login\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;local\u0026#34;\u0026gt;Call Local API\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;remote\u0026#34;\u0026gt;Call Remote API\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;logout\u0026#34;\u0026gt;Logout\u0026lt;/button\u0026gt; \u0026lt;pre id=\u0026#34;results\u0026#34;\u0026gt;\u0026lt;/pre\u0026gt; \u0026lt;script src=\u0026#34;app.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; app.js\nThe app.js file will contain the client-side code for your application.\nFirst, add a helper function to display messages in the \u0026lt;pre\u0026gt;:\nfunction log() { document.getElementById(\u0026#34;results\u0026#34;).innerText = \u0026#34;\u0026#34;; Array.prototype.forEach.call(arguments, function (msg) { if (typeof msg !== \u0026#34;undefined\u0026#34;) { if (msg instanceof Error) { msg = \u0026#34;Error: \u0026#34; + msg.message; } else if (typeof msg !== \u0026#34;string\u0026#34;) { msg = JSON.stringify(msg, null, 2); } document.getElementById(\u0026#34;results\u0026#34;).innerText += msg + \u0026#34;\\r\\n\u0026#34;; } }); } Next, you can use the BFF user management endpoint to query if the user is logged in or not. Notice the userClaims variable is global; it will be needed elsewhere.\nlet userClaims = null; (async function () { var req = new Request(\u0026#34;/bff/user\u0026#34;, { headers: new Headers({ \u0026#34;X-CSRF\u0026#34;: \u0026#34;1\u0026#34;, }), }); try { var resp = await fetch(req); if (resp.ok) { userClaims = await resp.json(); log(\u0026#34;user logged in\u0026#34;, userClaims); } else if (resp.status === 401) { log(\u0026#34;user not logged in\u0026#34;); } } catch (e) { log(\u0026#34;error checking user status\u0026#34;); } })(); Next, register click event handlers on the buttons:\ndocument.getElementById(\u0026#34;login\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, login, false); document.getElementById(\u0026#34;local\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, localApi, false); document.getElementById(\u0026#34;remote\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, remoteApi, false); document.getElementById(\u0026#34;logout\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, logout, false); Next, implement the login and logout functions.\nLogin is simple - just redirect the user to the BFF login endpoint.\nfunction login() { window.location = \u0026#34;/bff/login\u0026#34;; } Logout is more involved, as you need to redirect the user to the BFF logout endpoint, which requires an anti-forgery token to prevent cross site request forgery attacks. The userClaims that you populated earlier contain that token and the full logout URL in its bff:logout_url claim, so redirect to that url:\nfunction logout() { if (userClaims) { var logoutUrl = userClaims.find( (claim) =\u0026gt; claim.type === \u0026#34;bff:logout_url\u0026#34; ).value; window.location = logoutUrl; } else { window.location = \u0026#34;/bff/logout\u0026#34;; } } Finally, add empty stubs for the other button event handler functions. You will implement those after you get login and logout working.\nasync function localApi() { } async function remoteApi() { } Add a client registration to IdentityServer for the JavaScript client Now that the client application is ready to go, you need to define a configuration entry in IdentityServer for the new JavaScript client.\nIn the IdentityServer project locate the client configuration in src/IdentityServer/Config.cs. Add a new Client to the list for your new JavaScript application. Because this client uses the BFF pattern, the configuration will be very similar to the Web client. It should have the configuration listed below:\n// JavaScript BFF client new Client { ClientId = \u0026#34;bff\u0026#34;, ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, AllowedGrantTypes = GrantTypes.Code, // where to redirect to after login RedirectUris = { \u0026#34;https://localhost:5003/signin-oidc\u0026#34; }, // where to redirect to after logout PostLogoutRedirectUris = { \u0026#34;https://localhost:5003/signout-callback-oidc\u0026#34; }, AllowedScopes = new List\u0026lt;string\u0026gt; { IdentityServerConstants.StandardScopes.OpenId, IdentityServerConstants.StandardScopes.Profile, \u0026#34;api1\u0026#34; } } Run and test login and logout At this point, you should be able to run the JavaScriptClient application. You should see that the user is not logged in initially.\nWhen you click the login button, you\u0026rsquo;ll be redirected to IdentityServer to login. After you login, you\u0026rsquo;ll be redirected back to the JavaScriptClient application, where you\u0026rsquo;ll be signed into the Cookies authentication scheme with your tokens saved in the session.\nThe app loads again, but this time it has a session cookie. So, when it makes the HTTP request to get userClaims, that cookie is included in the request. This allows the BFF middleware to authenticate the user and return user info. Once the JavaScriptClient application receives the response, the user should appear logged in and their claims should be displayed.\nFinally, the logout button should successfully get the user logged out.\nAdd API support Now that you have login and logout working, you will add support to invoke both local and remote APIs.\nA local API is an endpoint that is hosted in the same backend as the JavaScriptClient application. Local APIs are intended to be APIs that only exist to support the JavaScript frontend, typically by providing UI specific data or aggregating data from other sources. Local APIs are authenticated with the user\u0026rsquo;s session cookie.\nA remote API is an API running in some other host than the JavaScriptClient application. This is useful for APIs that are shared by many different applications (e.g. mobile app, other web apps, etc). Remote APIs are authenticated with an access token. Fortunately, the JavaScriptClient application has an access token stored in the user\u0026rsquo;s session. You will use the BFF proxy feature to accept a call from the JavaScript running in the browser authenticated with the user\u0026rsquo;s session cookie, retrieve the access token for the user from the user\u0026rsquo;s session, and then proxy the call to the remote API, sending the access token for authentication.\nDefine a local API Local APIs can be defined using controllers or with Minimal API Route Handlers. For simplicity, this quickstart uses a minimal API with its handler defined directly in Program.cs, but you can organize your Local APIs however you like.\nAdd a handler to src/JavaScriptClient/Program.cs for the the local API:\n[Authorize] static IResult LocalIdentityHandler(ClaimsPrincipal user) { var name = user.FindFirst(\u0026#34;name\u0026#34;)?.Value ?? user.FindFirst(\u0026#34;sub\u0026#34;)?.Value; return Results.Json(new { message = \u0026#34;Local API Success!\u0026#34;, user = name }); } Local APIs often make requests to remote APIs that are authorized with the user\u0026rsquo;s access token. To get the access token, call the GetUserAccessTokenAsync extension method on the HttpContext. For example: var token = await HttpContext.GetUserAccessTokenAsync();\nUpdate routing to accept local and remote API calls Next, you need to register both the local API and the BFF proxy for the remote API in the ASP.NET Core routing system. Add the code below to the UseEndpoints call in src/JavaScriptClient/Program.cs.\napp.UseEndpoints(endpoints =\u0026gt; { endpoints.MapBffManagementEndpoints(); // Uncomment this for Controller support // endpoints.MapControllers() // .AsBffApiEndpoint(); endpoints.MapGet(\u0026#34;/local/identity\u0026#34;, LocalIdentityHandler) .AsBffApiEndpoint(); endpoints.MapRemoteBffApiEndpoint(\u0026#34;/remote\u0026#34;, \u0026#34;https://localhost:6001\u0026#34;) .RequireAccessToken(Duende.Bff.TokenType.User); }); The call to the AsBffApiEndpoint() fluent helper method adds BFF support to the local APIs. This includes anti-forgery protection as well as suppressing login redirects on authentication failures and instead returning 401 and 403 status codes under the appropriate circumstances.\nMapRemoteBffApiEndpoint() registers the BFF proxy for the remote API and configures it to pass the user\u0026rsquo;s access token.\nCall the APIs from JavaScript Back in src/JavaScriptClient/wwwroot/app.js, implement the two API button event handlers like this:\nasync function localApi() { var req = new Request(\u0026#34;/local/identity\u0026#34;, { headers: new Headers({ \u0026#34;X-CSRF\u0026#34;: \u0026#34;1\u0026#34;, }), }); try { var resp = await fetch(req); let data; if (resp.ok) { data = await resp.json(); } log(\u0026#34;Local API Result: \u0026#34; + resp.status, data); } catch (e) { log(\u0026#34;error calling local API\u0026#34;); } } async function remoteApi() { var req = new Request(\u0026#34;/remote/identity\u0026#34;, { headers: new Headers({ \u0026#34;X-CSRF\u0026#34;: \u0026#34;1\u0026#34;, }), }); try { var resp = await fetch(req); let data; if (resp.ok) { data = await resp.json(); } log(\u0026#34;Remote API Result: \u0026#34; + resp.status, data); } catch (e) { log(\u0026#34;error calling remote API\u0026#34;); } } The path for the local API is exactly what you set in the the call to MapGet in src/JavaScriptClient/Program.cs.\nThe path for the remote API uses a \u0026ldquo;/remote\u0026rdquo; prefix to indicate that the BFF proxy should be used, and the remaining path is what\u0026rsquo;s then passed when invoking the remote API (\u0026quot;/identity\u0026quot; in this case).\nNotice both API calls require a \u0026lsquo;X-CSRF\u0026rsquo;: \u0026lsquo;1\u0026rsquo; header, which acts as the anti-forgery token.\nSee the client credentials quickstart for information on how to create the remote API used in the code above.\nRun and test the API calls At this point, you should be able to run the JavaScriptClient application and invoke the APIs. The local API should return something like this:\nAnd the remote API should return something like this:\nYou now have the start of a JavaScript client application that uses IdentityServer for sign-in, sign-out, and authenticating calls to local and remote APIs, using Duende.BFF.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/apis/local/",
    "title": "Local APIs",
    "tags": [],
    "description": "",
    "content": "A Local API is an API that is located within the BFF host. Local APIs are implemented with the familiar ASP.NET abstractions of API controllers or minimal API endpoints.\nThere are two styles of local APIs:\nSelf-contained Local APIs Local APIs that Make Requests using Managed Access Tokens Self-Contained Local APIs These APIs reside within the BFF and don\u0026rsquo;t make HTTP requests to other APIs. They access data controlled by the BFF itself, which can simplify the architecture of the system by reducing the number of APIs that must be deployed and managed. They are suitable for scenarios where the BFF is the sole consumer of the data. If you require data accessibility from other applications or services, this approach is probably not suitable.\nLocal APIs that Make Requests using Managed Access Tokens Alternatively, you can make the data available as a service and make HTTP requests to that service from your BFF\u0026rsquo;s local endpoints. The benefits of this style of Local Endpoint include\nYour frontend\u0026rsquo;s network access can be simplified into an aggregated call for the specific data that it needs, which reduces the amount of data that must be sent to the client. Your BFF endpoint can expose a subset of your remote APIs so that they are called in a more controlled manner than if the BFF proxied all requests to the endpoint. Your BFF endpoint can include business logic to call the appropriate endpoints, which simplifies your front end code. Your local endpoints can leverage services like the HTTP client factory and Duende.BFF token management to make the outgoing calls. The following is a simplified example showing how local endpoints can obtain managed access tokens and use them to make requests to remote APIs.\n[Route(\u0026#34;myApi\u0026#34;)] public class MyApiController : ControllerBase { private readonly IHttpClientFactory _httpClientFactory; public MyApiController(IHttpClientFactory httpClientFactory) { _httpClientFactory = httpClientFactory; } public async Task\u0026lt;IActionResult\u0026gt; Get(string id) { // create HTTP client var client = _httpClientFactory.CreateClient(); // get current user access token and set it on HttpClient var token = await HttpContext.GetUserAccessTokenAsync(); client.SetBearerToken(token); // call remote API var response = await client.GetAsync($\u0026#34;https://remoteServer/remoteApi?id={id}\u0026#34;); // maybe process response and return to frontend return new JsonResult(await response.Content.ReadAsStringAsync()); } } The example above is simplified to demonstrate the way that you might obtain a token. Real local endpoints will typically enforce constraints on the way the API is called, aggregate multiple calls, or perform other business logic. Local endpoints that merely forward requests from the frontend to the remote API may not be needed at all. Instead, you could proxy the requests through the BFF using either the simple http forwarder or YARP.\nSecuring Local API Endpoints Regardless of the style of data access used by a local API, it must be protected against threats such as CSRF (Cross-Site Request Forgery) attacks. To defend against such attacks and ensure that only the frontend can access these endpoints, we recommend implementing two layers of protection.\nSameSite cookies The SameSite cookie attribute is a feature of modern browsers that restricts cookies so that they are only sent to pages originating from the site where the cookie was originally issued.\nThis is a good first layer of defense, but makes the assumption that you can trust all subdomains of your site. All subdomains within a registrable domain are considered the same site for purposes of SameSite cookies. Thus, if another application hosted on a subdomain within your site is infected with malware, it can make CSRF attacks against your application.\nAnti-forgery header For this reason, we recommend requiring an additional custom header on API endpoints, for example:\nGET /endpoint x-csrf: 1 The value of the header is not important, but its presence, combined with the cookie requirement, triggers a CORS preflight request for cross-origin calls. This effectively isolates the caller to the same origin as the backend, providing a robust security guarantee.\nAdditionally, API endpoints should handle scenarios where the session has expired or authorization fails without triggering an authentication redirect to the upstream identity provider. Instead, they should return Ajax-friendly status codes.\nSetup Duende.BFF can automate both the pre-processing step of requiring the custom anti-forgery header and the post-processing step of converting response codes for API endpoints. To do so, first add the BFF middleware to the pipeline, and then decorate your endpoints to indicate that they should receive BFF pre and post processing.\nAdd Middleware Add the BFF middleware to the pipeline by calling UseBFF. Note that the middleware must be placed before the authorization middleware, but after routing.\npublic void Configure(IApplicationBuilder app) { // rest omitted app.UseAuthentication(); app.UseRouting(); app.UseBff(); app.UseAuthorization(); app.UseEndpoints(endpoints =\u0026gt; { /* ... */ } } Decorate Endpoints Endpoints that require the pre and post processing described above must be decorated with a call to AsBffApiEndpoint().\nFor minimal API endpoints, you can apply BFF pre- and post-processing when they are mapped.\nendpoints.MapPost(\u0026#34;/foo\u0026#34;, context =\u0026gt; { ... }) .RequireAuthorization() // no anonymous access .AsBffApiEndpoint(); // BFF pre/post processing For MVC controllers, you can similarly apply BFF pre- and post-processing to controller actions when they are mapped.\nendpoints.MapControllers() .RequireAuthorization() // no anonymous access .AsBffApiEndpoint(); // BFF pre/post processing Alternatively, you can apply the [BffApi] attribute directly to the controller or action.\n[Route(\u0026#34;myApi\u0026#34;)] [BffApi] public class MyApiController : ControllerBase { ... } Disabling Anti-forgery Protection Disabling anti-forgery protection is possible but not recommended. Antiforgery protection defends against CSRF attacks, so opting out may cause security vulnerabilities.\nHowever, if you are defending against CSRF attacks with some other mechanism, you can opt-out of Duende.BFF\u0026rsquo;s CSRF protection. Depending on the version of Duende.BFF, use one of the following approaches.\nFor version 1.x, set the requireAntiForgeryCheck parameter to false when adding the endpoint. For example:\napp.UseEndpoints(endpoints =\u0026gt; { // MVC controllers endpoints.MapControllers() .RequireAuthorization() // WARNING: Disabling antiforgery protection may make // your APIs vulnerable to CSRF attacks .AsBffApiEndpoint(requireAntiforgeryCheck: false); // simple endpoint endpoints.MapPost(\u0026#34;/foo\u0026#34;, context =\u0026gt; { /* ... */ }) .RequireAuthorization() // WARNING: Disabling antiforgery protection may make // your APIs vulnerable to CSRF attacks .AsBffApiEndpoint(requireAntiforgeryCheck: false); }); On MVC controllers and actions you can set the RequireAntiForgeryCheck as a flag in the BffApiAttribute, like this:\n[Route(\u0026#34;sample\u0026#34;)] // WARNING: Disabling antiforgery protection may make // your APIs vulnerable to CSRF attacks [BffApi(requireAntiForgeryCheck: false)] public class SampleApiController : ControllerBase { /* ... */ } In version 2.x, use the SkipAntiforgery fluent API when adding the endpoint. For example:\napp.UseEndpoints(endpoints =\u0026gt; { // MVC controllers endpoints.MapControllers() .RequireAuthorization() .AsBffApiEndpoint() // WARNING: Disabling antiforgery protection may make // your APIs vulnerable to CSRF attacks .SkipAntiforgery(); // simple endpoint endpoints.MapPost(\u0026#34;/foo\u0026#34;, context =\u0026gt; { /* ... */ }) .RequireAuthorization() .AsBffApiEndpoint() // WARNING: Disabling antiforgery protection may make // your APIs vulnerable to CSRF attacks .SkipAntiforgery(); }); MVC controllers and actions can use the BffApiSkipAntiforgeryAttribute (which is independent of the BffApiAttribute), like this:\n[Route(\u0026#34;sample\u0026#34;)] // WARNING: Disabling antiforgery protection may make // your APIs vulnerable to CSRF attacks [BffApiSkipAntiforgeryAttribute] public class SampleApiController : ControllerBase { /* ... */ } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/ui/login/",
    "title": "Login",
    "tags": [],
    "description": "",
    "content": "Login Page The login page is responsible for establishing the user\u0026rsquo;s authentication session. This requires a user to present credentials and typically involves these steps:\nProvide the user with a page to allow them to enter credentials locally, use an external login provider, or use some other means of authenticating. Start the session by creating the authentication session cookie in your IdentityServer. If the login is client initiated, redirect the user back to the client. When IdentityServer needs to show the login page, it redirects the user to a configurable LoginUrl.\nbuilder.Services.AddIdentityServer(opt =\u0026gt; { opt.UserInteraction.LoginUrl = \u0026#34;/path/to/login\u0026#34;; }) If no LoginUrl is set, IdentityServer will infer it from the LoginPath of your Cookie Authentication Handler. For example:\nbuilder.Services.AddAuthentication() .AddCookie(\u0026#34;cookie-handler-with-custom-path\u0026#34;, options =\u0026gt; { options.LoginPath = \u0026#34;/path/to/login/from/cookie/handler\u0026#34;; }) If you are using ASP.NET Identity, configure its cookie authentication handler like this:\nbuilder.Services .AddIdentityServer() .AddAspNetIdentity\u0026lt;ApplicationUser\u0026gt;(); builder.Services .ConfigureApplicationCookie(options =\u0026gt; { options.LoginPath = \u0026#34;/path/to/login/for/aspnet_identity\u0026#34;; }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/ui/logout/",
    "title": "Logout",
    "tags": [],
    "description": "",
    "content": "Logout Page The logout page is responsible for terminating the user\u0026rsquo;s authentication session. This is a potentially complicated process and involves these steps:\nEnding the session by removing the authentication session cookie in your IdentityServer. Possibly triggering sign-out in an external provider if an external login was used. Notify all client applications that the user has signed out. If the logout is client initiated, redirect the user back to the client. When IdentityServer needs to show the logout page, it redirects the user to a configurable LogoutUrl.\nbuilder.Services.AddIdentityServer(opt =\u0026gt; { opt.UserInteraction.LogoutUrl = \u0026#34;/path/to/logout\u0026#34;; }) If no LogoutUrl is set, IdentityServer will infer it from the LogoutPath of your Cookie Authentication Handler. For example:\nbuilder.Services.AddAuthentication() .AddCookie(\u0026#34;cookie-handler-with-custom-path\u0026#34;, options =\u0026gt; { options.LogoutPath = \u0026#34;/path/to/logout/from/cookie/handler\u0026#34;; }) If you are using ASP.NET Identity, configure its cookie authentication handler like this:\nbuilder.Services .AddIdentityServer() .AddAspNetIdentity\u0026lt;ApplicationUser\u0026gt;(); builder.Services .ConfigureApplicationCookie(options =\u0026gt; { options.LogoutPath = \u0026#34;/path/to/logout/for/aspnet_identity\u0026#34;; }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/ui/logout/logout_context/",
    "title": "Logout Context",
    "tags": [],
    "description": "",
    "content": "To correctly perform all the steps for logout, your logout page needs contextual information about the user\u0026rsquo;s session and the client that initiated logout request. This information is provided by the LogoutRequest class and will provide your logout page data needed for the logout workflow.\nAccessing the LogoutRequest and the logoutId The logout page can be triggered in different ways:\nClient Initiated Logout (protocol) External Provider Logout Notification (protocol) Direct User Access (non-protocol) If the logout page is being triggered by a protocol workflow, then this means Duende IdentityServer has redirected the user\u0026rsquo;s browser to the logout page. In these scenarios, a logoutId parameter will be passed that represents the logout context. The logoutId value can be exchanged with the GetLogoutContextAsync API on the interaction service to obtain a LogoutRequest object.\nIf the page is directly accessed by the user then there will be no logoutId parameter, but the context can still be accessed by calling GetLogoutContextAsync just without passing any parameters.\nIn either case, the LogoutRequest contains the data to perform client notification, and redirect the user back to the client after logout.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/tokens/pop/mtls/",
    "title": "Mutual TLS",
    "tags": [],
    "description": "",
    "content": "Proof-of-possession using Mutual TLS RFC 8705 specifies how to bind a TLS client certificate to an access token. With this method your IdentityServer will embed the SHA-256 thumbprint of the X.509 client certificate into the access token via the cnf claim, e.g.:\n{ // rest omitted \u0026#34;cnf\u0026#34;: { \u0026#34;x5t#S256\u0026#34;: \u0026#34;bwcK0esc3ACC3DB2Y5_lESsXE8o9ltc05O89jdN-dg2\u0026#34; } } This is done automatically if you authenticate the client using a TLS client certificate.\nThe client must then use the same client certificate to call the APIs, and your APIs can validate the cnf claim by comparing it to the thumbprint of the client certificate on the TLS channel.\nIf the access token would leak, it cannot be replayed without having access to the additional private key of the X.509 client certificate.\nCombine TLS proof-of-possession with other authentication methods It is not mandatory to authenticate your clients with a client certificate to get the benefit of proof-of-possession. You can combine this feature with an arbitrary client authentication method - or even no client authentication at all (e.g. for public mobile/native clients).\nIn this scenario, the client would create an X.509 certificate on the fly, and use that to establish the TLS channel to your IdentityServer. As long as the certificate is accepted by your web server, your IdentityServer can embed the cnf claim, and your APIs can validate it.\n.NET Client In .NET it is straight-forward to create an X.509 certificate on the fly and use it to open a TLS connection.\nstatic X509Certificate2 CreateClientCertificate(string name) { X500DistinguishedName distinguishedName = new X500DistinguishedName($\u0026#34;CN={name}\u0026#34;); using (RSA rsa = RSA.Create(2048)) { var request = new CertificateRequest(distinguishedName, rsa, HashAlgorithmName.SHA256,RSASignaturePadding.Pkcs1); request.CertificateExtensions.Add( new X509KeyUsageExtension( X509KeyUsageFlags.DataEncipherment | X509KeyUsageFlags.KeyEncipherment | X509KeyUsageFlags.DigitalSignature , false)); request.CertificateExtensions.Add( new X509EnhancedKeyUsageExtension( new OidCollection { new Oid(\u0026#34;1.3.6.1.5.5.7.3.2\u0026#34;) }, false)); return request.CreateSelfSigned( new DateTimeOffset(DateTime.UtcNow.AddDays(-1)), new DateTimeOffset(DateTime.UtcNow.AddDays(10))); } } Then use this client certificate on the TLS channel to request the token:\nstatic async Task\u0026lt;TokenResponse\u0026gt; RequestTokenAsync() { var client = new HttpClient(GetHandler(ClientCertificate)); var disco = await client.GetDiscoveryDocumentAsync(\u0026#34;https://demo.duendesoftware.com\u0026#34;); if (disco.IsError) throw new Exception(disco.Error); var response = await client.RequestClientCredentialsTokenAsync(new ClientCredentialsTokenRequest { Address = disco.MtlsEndpointAliases.TokenEndpoint, ClientId = \u0026#34;client\u0026#34;, Scope = \u0026#34;api1\u0026#34; }); if (response.IsError) throw new Exception(response.Error); return response; } static SocketsHttpHandler GetHandler(X509Certificate2 certificate) { var handler = new SocketsHttpHandler(); handler.SslOptions.ClientCertificates = new X509CertificateCollection { certificate }; return handler; } Enabling support in your IdentityServer The last step is to enable that feature in the options:\nvar builder = services.AddIdentityServer(options =\u0026gt; { // other settings options.MutualTls.AlwaysEmitConfirmationClaim = true; }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/efoptions/operational/",
    "title": "Operational Options",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.EntityFramework.Options.OperationalStoreOptions These options are configurable when using the Entity Framework Core for the operational store:\nYou set the options at startup time in your AddOperationalStore method:\nvar builder = services.AddIdentityServer() .AddOperationalStore(options =\u0026gt; { // configure options here.. }) Pooling Settings that affect the DbContext pooling feature of Entity Framework Core.\nEnablePooling\nGets or set if EF DbContext pooling is enabled. Defaults to false.\nPoolSize\nGets or set the pool size to use when DbContext pooling is enabled. If not set, the EF default is used.\nSchema Settings that affect the database schema and table names.\nDefaultSchema\nGets or sets the default schema. Defaults to null.\nTableConfiguration settings for each individual table (schema and name) managed by this feature:\nPersistedGrants DeviceFlowCodes Keys ServerSideSessions Persisted Grants Cleanup Settings that affect the background cleanup of expired entries (tokens) from the persisted grants table.\nEnableTokenCleanup\nGets or sets a value indicating whether stale entries will be automatically cleaned up from the database. This is implemented by periodically connecting to the database (according to the TokenCleanupInterval) from the hosting application. Defaults to false.\nRemoveConsumedTokens\nGets or sets a value indicating whether consumed tokens will included in the automatic clean up. Defaults to false.\nTokenCleanupInterval\nGets or sets the token cleanup interval (in seconds). The default is 3600 (1 hour).\nTokenCleanupBatchSize\nGets or sets the number of records to remove at a time. Defaults to 100.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/ui/server_side_sessions/session_management/",
    "title": "Session Management",
    "tags": [],
    "description": "Server Side Sessions",
    "content": "When using server-side sessions, there is a record of the user\u0026rsquo;s authentication activity at IdentityServer. This allows administrative and management tooling to be built on top of that data to query those sessions, as well as terminate them. In addition, since the session data has its own unique id and tracks clients that a user has used, then some types of tokens issued to these clients can be revoked. Finally, if clients support back-channel logout, then they can be notified that a user\u0026rsquo;s session has been terminated, which allows them to also terminate the user\u0026rsquo;s session within the client application.\nThese features are all provided via the ISessionManagementService service.\nISessionManagementService The session management service provides administrative operations for querying and revoking the server-side sessions.\nQuickstart UI The Quickstart UI contains a simple administrative page (under the \u0026ldquo;ServerSideSessions\u0026rdquo; folder) that uses the ISessionManagementService API.\nIt looks something like this (but of course you are free to customize or change it as needed):\nQuerying sessions Use the QuerySessionsAsync API to access a paged list of user sessions. You can optionally filter on a user\u0026rsquo;s claims mentioned above (subject identifier, session identifier, and/or display name).\nFor example:\nvar userSessions = await _sessionManagementService.QuerySessionsAsync(new SessionQuery { CountRequested = 10, SubjectId = \u0026#34;12345\u0026#34;, DisplayName = \u0026#34;Bob\u0026#34;, }); The results returned contains the matching users\u0026rsquo; session data, as well as paging information (depending if the store and backing database supports certain features such as total count and current page number).\nThis paging information contains a ResultsToken and allows subsequent requests for next or previous pages (set RequestPriorResults to true for the previous page, otherwise the next page is assumed):\n// this requests the first page var userSessions = await _sessionManagementService.QuerySessionsAsync(new SessionQuery { CountRequested = 10, }); // this requests the next page relative to the previous results userSessions = await _sessionManagementService.QuerySessionsAsync(new SessionQuery { ResultsToken = userSessions.ResultsToken, CountRequested = 10, }); // this requests the prior page relative to the previous results userSessions = await _sessionManagementService.QuerySessionsAsync(new SessionQuery { ResultsToken = userSessions.ResultsToken, RequestPriorResults = true, CountRequested = 10, }); Terminating sessions To terminate session(s) for a user, use the RemoveSessionsAsync API. This accepts a RemoveSessionsContext which can filter on the subject and/or the session identifier to terminate. It then also has flags for what to terminate or revoke. This allows deleting a user\u0026rsquo;s session record in the store, any associated tokens or consents in the operational database, and/or notifying any clients via back-channel logout that the user\u0026rsquo;s session has ended. There is also a list of client identifiers to control which clients are affected.\nAn example to revoke everything for current sessions for subject id 12345 might be:\nawait _sessionManagementService.RemoveSessionsAsync(new RemoveSessionsContext { SubjectId = \u0026#34;12345\u0026#34; }); Or to just revoke all refresh tokens for current sessions for subject id 12345 might be:\nawait _sessionManagementService.RemoveSessionsAsync(new RemoveSessionsContext { SubjectId = \u0026#34;12345\u0026#34;, RevokeTokens = true, RemoveServerSideSession = false, RevokeConsents = false, SendBackchannelLogoutNotification = false, }); Internally this uses the IServerSideTicketStore, IPersistedGrantStore and IBackChannelLogoutService features from IdentityServer.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/configuration/dcr/reference/validation/",
    "title": "Validation",
    "tags": [],
    "description": "DCR Reference",
    "content": "IDynamicClientRegistrationValidator The IDynamicClientRegistrationValidator is the contract for the service that validates a dynamic client registration request. It contains a single ValidateAsync(\u0026hellip;) method.\nConceptually, the validation step is responsible for checking the validity of the metadata supplied in the registration request, and using that metadata to set properties of a Client model. In contrast, the IDynamicClientRegistrationRequestProcessor is responsible for setting properties on the Client model that are generated by the Configuration API itself.\nIDynamicClientRegistrationValidator.ValidateAsync Validates a dynamic client registration request.\npublic Task\u0026lt;IDynamicClientRegistrationValidationResult\u0026gt; ValidateAsync( DynamicClientRegistrationContext context) parameter description context Contextual information about the DCR request. Return Value A task that returns an IDynamicClientRegistrationValidationResult, indicating success or failure.\nDynamicClientRegistrationValidator public class DynamicClientRegistrationValidator : IDynamicClientRegistrationValidator The DynamicClientRegistrationValidator class is the default implementation of the IDynamicClientRegistrationValidator. If you need to customize some aspect of Dynamic Client Registration validation, we recommend that you extend this class and override the appropriate methods.\nValidation Steps Each of these methods represents one step in the validation process. Each step is passed a DynamicClientRegistrationContext and returns a task that returns an IStepResult. The DynamicClientRegistrationContext includes the client model that will have its properties set, the DCR request, and other contextual information. The IStepResult either represents that the step succeeded or failed.\nThe steps are invoked in the same order as they appear in this table.\nname description ValidateSoftwareStatementAsync(…) Validates the software statement of the request. The default implementation does nothing, and is included as an extension point. SetGrantTypesAsync(…) Validates requested grant types and uses them to set the allowed grant types of the client. SetRedirectUrisAsync(…) Validates requested redirect uris and uses them to set the redirect uris of the client. SetScopesAsync(…) Validates requested scopes and uses them to set the scopes of the client. SetDefaultScopes(…) Sets scopes on the client when no scopes are requested. The default implementation sets no scopes and is intended as an extension point. SetSecretsAsync(…) Validates the requested jwks to set the secrets of the client. SetClientNameAsync(…) Validates the requested client name uses it to set the name of the client. SetLogoutParametersAsync(…) Validates the requested client parameters related to logout and uses them to set the corresponding properties in the client. Those parameters include the post logout redirect uris, front channel and back channel uris, and flags for the front and back channel uris indicating if they require session ids. SetMaxAgeAsync(…) Validates the requested default max age and uses it to set the user sso lifetime of the client. SetUserInterfaceProperties(…) Validates details of the request that control the user interface, including the logo uri, client uri, initiate login uri, enable local login flag, and identity provider restrictions, and uses them to set the corresponding client properties. SetPublicClientProperties(…) Validates the requested client parameters related to public clients and uses them to set the corresponding properties in the client. Those parameters include the require client secret flag and the allowed cors origins. SetAccessTokenProperties(…) Validates the requested client parameters related to access tokens and uses them to set the corresponding properties in the client. Those parameters include the allowed access token type and access token lifetime. SetIdTokenProperties(…) Validates the requested client parameters related to id tokens and uses them to set the corresponding properties in the client. Those parameters include the id token lifetime and the allowed id token signing algorithms. SetServerSideSessionProperties(…) Validates the requested client parameters related to server side sessions and uses them to set the corresponding properties in the client. Those parameters include the coordinate lifetime with user session flag. "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/efoptions/",
    "title": "EF Options",
    "tags": [],
    "description": "",
    "content": "Entity Framework Core Options If using the Entity Framework Core store implementation, you might need to configure those specific options.\nOperational Options Configuration Options "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/architecture/ui-hosting/",
    "title": "UI Hosting",
    "tags": [],
    "description": "",
    "content": "Hosting Options for the UI There are several options for hosting the UI assets when using a BFF.\nHost the assets within the BFF host using the static file middleware Host the assets within the BFF host using the Microsoft SPA Templates Host the UI and BFF separately on subdomains of the same site and use CORS to allow cross origin requests Serves the index page of the UI from the BFF host, and all other assets are loaded from another domain, such as a CDN Static File Middleware Hosting the UI together with the BFF is the simplest choice, as requests from the front end to the backend will automatically include the authentication cookie and not require CORS headers. If you create a BFF host using our templates, the UI will be hosted in this way:\ndotnet new bffremoteapi # or dotnet new bfflocalapi Host UI in the BFF using Microsoft Templates Many frontend applications require a build process, which complicates the use of the static file middleware at development time. Visual Studio include\u0026rsquo;s SPA templates that start up a SPA and proxy requests to it during development. Samples of Duende.BFF that take this approach using React and Angular are available.\nMicrosoft\u0026rsquo;s templates are easy to use at dev time from Visual Studio. They allow you to simply run the solution, and the template proxies requests to the front end for you. At deploy time, that proxy is removed and the static assets of the site are served by the static file middleware.\nHost the UI separately You may want to host the UI outside of the BFF. At development time, UI developers might prefer to run the frontend outside of Visual Studio (e.g., using the node cli). You might also want to have separate deployments of the frontend and the BFF, and you might want your static UI assets hosted on a CDN. If that is your preference, there are a couple of options for hosting the frontend outside of the C# project.\nFirst, you can host the BFF and SPA entirely separately, and use CORS to make requests from the frontend to the backend. In order to include the auth cookie in those requests, the frontend code will have to declare that it should send credentials using the credentials: \u0026ldquo;include\u0026rdquo; option. You\u0026rsquo;ll also need to ensure that the two components are hosted on subdomains of the same domain so that third party cookie blocking doesn\u0026rsquo;t prevent the frontend from including cookies in its requests to the BFF host.\nA sample of this approach is available.\nServe the index page from the BFF host Secondly, you could serve the index page of the SPA from the BFF, but have all of the other static assets hosted on another host (presumably a CDN). This technique makes the UI and BFF have exactly the same origin, so the authentication cookie will be sent from the frontend to the BFF automatically, and third party cookie blocking and the SameSite cookie attribute won\u0026rsquo;t present any problems.\nSetting this up for local development takes a bit of effort however. As you make changes to the frontend, the UI\u0026rsquo;s build process might generate a change to the index page. If it does, you\u0026rsquo;ll need to arrange for the index page being served by the BFF host to reflect that change.\nAdditionally, the front end will need to be configurable so that it is able to load its assets from other hosts. The mechanism for doing so will vary depending on the technology used to build the frontend. For instance, Angular includes a number of deployment options that allow you to control where it expects to find assets.\nThe added complexity of this technique is justified when there is a requirement to host the front end on a different site (typically a CDN) from the BFF.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/architecture/third-party-cookies/",
    "title": "Third Party Cookies",
    "tags": [],
    "description": "",
    "content": "If the BFF and OpenID Connect Provider (OP) are hosted on different sites, then some browsers will block cookies from being sent during navigation between those sites. Almost all browsers have the option of blocking third party cookies. Safari and Firefox are the most widely used browsers that do so by default, while Chrome is planning to do so in the future. This change is being made to protect user privacy, but it also impacts OIDC flows traditionally used by SPAs.\nA couple of particularly notable OIDC flows that don\u0026rsquo;t work for SPAs when third party cookies are blocked are OIDC Session Management and OIDC Silent Login via the prompt=none parameter.\nSession Management OIDC Session Management allows a client SPA to monitor the session at the OP by reading a cookie from the OP in a hidden iframe. If third party cookie blocking prevents the iframe from seeing that cookie, the SPA will not be able to monitor the session. The BFF solves this problem using OIDC back-channel logout.\nThe BFF is able to operate server side, and is therefore able to have a back channel to the OP. When the session ends at the OP, it can send a back-channel message to the BFF, ending the session at the BFF.\nSilent Login OIDC Silent Login allows a client application to start its session without needing any user interaction if the OP has an ongoing session. The main benefit is that a SPA can load in the browser and then start a session without navigating away from the SPA for an OIDC flow, preventing the need to reload the SPA.\nSimilarly to OIDC Session Management, OIDC Silent Login relies on a hidden iframe, though in this case, the hidden iframe makes requests to the OP, passing the prompt=none parameter to indicate that user interaction isn\u0026rsquo;t sensible. If that request includes the OP\u0026rsquo;s session cookie, the OP can respond successfully and the application can obtain tokens. But if the request does not include a session - either because no session has been started or because the cookie has been blocked - then the silent login will fail, and the user will have to be redirected to the OP for an interactive login.\nBFF with a Federation Gateway The BFF supports silent login from the SPA with the /bff/silent-login endpoint. This endpoint is intended to be invoked in an iframe and issues a challenge to login non-interactively with prompt=none. Just as in a traditional SPA, this technique will be disrupted by third party cookie blocking when the BFF and OP are third parties.\nIf you need silent login with a third party OP, we recommend that you use the Federation Gateway pattern. In the federation gateway pattern, one identity provider (the gateway) federates with other remote identity providers. Because the client applications only interact with the gateway, the implementation details of the remote identity providers are abstracted. In this case, we shield the client application from the fact that the remote identity provider is a third party by hosting the gateway as a first party to the client. This makes the client application\u0026rsquo;s requests for silent login always first party.\nAlternatives Alternatively, you can accomplish a similar goal (logging in without needing to initially load the SPA, only to redirect away from it) by detecting that the user is not authenticated in the BFF and issuing a challenge before the site is ever loaded. This approach is not typically our first recommendation, because it makes allowing anonymous access to parts of the UI difficult and because it requires samesite=lax cookies (see below).\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/quickstarts/7_blazor/",
    "title": "Building Blazor WASM client applications",
    "tags": [],
    "description": "",
    "content": "Similar to JavaScript SPAs, you can build Blazor WASM applications with and without a backend. Not having a backend has all the security disadvantages we discussed already in the JavaScript quickstart.\nIf you are building Blazor WASM apps that do not deal with sensitive data and you want to use the no-backend approach, have a look at the standard Microsoft templates, which are using this style.\nIn this quickstart we will focus on how to build a Blazor WASM application using our Duende.BFF security framework. You can find the full source code here\nTo keep things simple, we will utilize our demo IdentityServer instance hosted at https://demo.duendesoftware.com. We will provide more details on how to configure a Blazor client in your own IdentityServer at then end.\nSetting up the project The .NET 6 CLI includes a Blazor WASM with backend template. Create the directory where you want to work in, and run the following command:\ndotnet new blazorwasm --hosted This will create three projects - server, client and shared.\nConfiguring the backend First add the following package references to the server project:\n\u0026lt;PackageReference Include=\u0026#34;Microsoft.AspNetCore.Authentication.OpenIdConnect\u0026#34; Version=\u0026#34;6.0.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Duende.BFF\u0026#34; Version=\u0026#34;1.1.0\u0026#34; /\u0026gt; Next, we will add OpenID Connect and OAuth support to the backend. For this we are adding the Microsoft OpenID Connect authentication handler for the protocol interactions with the token service, and the cookie authentication handler for managing the resulting authentication session. See here for more background information.\nThe BFF services provide the logic to invoke the authentication plumbing from the frontend (more about this later).\nAdd the following snippet to your Program.cs above the call to builder.Build();\nbuilder.Services.AddBff(); builder.Services.AddAuthentication(options =\u0026gt; { options.DefaultScheme = \u0026#34;cookie\u0026#34;; options.DefaultChallengeScheme = \u0026#34;oidc\u0026#34;; options.DefaultSignOutScheme = \u0026#34;oidc\u0026#34;; }) .AddCookie(\u0026#34;cookie\u0026#34;, options =\u0026gt; { options.Cookie.Name = \u0026#34;__Host-blazor\u0026#34;; options.Cookie.SameSite = SameSiteMode.Strict; }) .AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { options.Authority = \u0026#34;https://demo.duendesoftware.com\u0026#34;; options.ClientId = \u0026#34;interactive.confidential\u0026#34;; options.ClientSecret = \u0026#34;secret\u0026#34;; options.ResponseType = \u0026#34;code\u0026#34;; options.ResponseMode = \u0026#34;query\u0026#34;; options.Scope.Clear(); options.Scope.Add(\u0026#34;openid\u0026#34;); options.Scope.Add(\u0026#34;profile\u0026#34;); options.Scope.Add(\u0026#34;api\u0026#34;); options.Scope.Add(\u0026#34;offline_access\u0026#34;); options.MapInboundClaims = false; options.GetClaimsFromUserInfoEndpoint = true; options.SaveTokens = true; }); The last step is to add the required middleware for authentication, authorization and BFF session management. Add the following snippet after the call to UseRouting:\napp.UseAuthentication(); app.UseBff(); app.UseAuthorization(); app.MapBffManagementEndpoints(); Finally you can run the server project. This will start the host, which will in turn deploy the Blazor application to your browser.\nTry to manually invoke the BFF login endpoint on /bff/login - this should bring you to the demo IdentityServer. After login (e.g. using bob/bob), the browser will return to the Blazor application.\nIn other words, the fundamental authentication plumbing is already working. Now we need to make the frontend aware of it.\nModifying the frontend (part 1) A couple of steps are necessary to add the security and identity plumbing to a Blazor application.\na) Add the authentication/authorization related package to the client project file:\n\u0026lt;PackageReference Include=\u0026#34;Microsoft.AspNetCore.Components.WebAssembly.Authentication\u0026#34; Version=\u0026#34;6.0.0\u0026#34; /\u0026gt; b) Add a using statement to _Imports.razor to bring the above package in scope:\n@using Microsoft.AspNetCore.Components.Authorization c) To propagate the current authentication state to all pages in your Blazor client, you add a special component called CascadingAuthenticationState to your application. This is done by wrapping the Blazor router with that component in App.razor:\n\u0026lt;CascadingAuthenticationState\u0026gt; \u0026lt;Router AppAssembly=\u0026#34;@typeof(App).Assembly\u0026#34;\u0026gt; \u0026lt;Found Context=\u0026#34;routeData\u0026#34;\u0026gt; \u0026lt;RouteView RouteData=\u0026#34;@routeData\u0026#34; DefaultLayout=\u0026#34;@typeof(MainLayout)\u0026#34;/\u0026gt; \u0026lt;FocusOnNavigate RouteData=\u0026#34;@routeData\u0026#34; Selector=\u0026#34;h1\u0026#34;/\u0026gt; \u0026lt;/Found\u0026gt; \u0026lt;NotFound\u0026gt; \u0026lt;PageTitle\u0026gt;Not found\u0026lt;/PageTitle\u0026gt; \u0026lt;LayoutView Layout=\u0026#34;@typeof(MainLayout)\u0026#34;\u0026gt; \u0026lt;p role=\u0026#34;alert\u0026#34;\u0026gt;Sorry, there\u0026#39;s nothing at this address.\u0026lt;/p\u0026gt; \u0026lt;/LayoutView\u0026gt; \u0026lt;/NotFound\u0026gt; \u0026lt;/Router\u0026gt; \u0026lt;/CascadingAuthenticationState\u0026gt; d) Last but not least, we will add some conditional rendering to the layout page to be able to trigger login/logout as well as displaying the current user name when logged in. This is achieved by using the AuthorizeView component in MainLayout.razor:\n\u0026lt;div class=\u0026#34;page\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;sidebar\u0026#34;\u0026gt; \u0026lt;NavMenu /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;top-row px-4\u0026#34;\u0026gt; \u0026lt;AuthorizeView\u0026gt; \u0026lt;Authorized\u0026gt; \u0026lt;strong\u0026gt;Hello, @context.User.Identity.Name!\u0026lt;/strong\u0026gt; \u0026lt;a href=\u0026#34;@context.User.FindFirst(\u0026#34;bff:logout_url\u0026#34;)?.Value\u0026#34;\u0026gt;Log out\u0026lt;/a\u0026gt; \u0026lt;/Authorized\u0026gt; \u0026lt;NotAuthorized\u0026gt; \u0026lt;a href=\u0026#34;bff/login\u0026#34;\u0026gt;Log in\u0026lt;/a\u0026gt; \u0026lt;/NotAuthorized\u0026gt; \u0026lt;/AuthorizeView\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content px-4\u0026#34;\u0026gt; @Body \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; When you now run the Blazor application, you will see the following error in your browser console:\ncrit: Microsoft.AspNetCore.Components.WebAssembly.Rendering.WebAssemblyRenderer[100] Unhandled exception rendering component: Cannot provide a value for property \u0026#39;AuthenticationStateProvider\u0026#39; on type \u0026#39;Microsoft.AspNetCore.Components.Authorization.CascadingAuthenticationState\u0026#39;. There is no registered service of type \u0026#39;Microsoft.AspNetCore.Components.Authorization.AuthenticationStateProvider\u0026#39;. CascadingAuthenticationState is an abstraction over an arbitrary authentication system. It internally relies on a service called AuthenticationStateProvider to return the required information about the current authentication state and the information about the currently logged on user.\nThis component needs to be implemented, and that\u0026rsquo;s what we\u0026rsquo;ll do next.\nModifying the frontend (part 2) The BFF library has a server-side component that allows querying the current authentication session and state (see here). We will now add a Blazor AuthenticationStateProvider that will internally use this endpoint.\nAdd a file with the following content:\nusing System.Net; using System.Net.Http.Json; using System.Security.Claims; using Microsoft.AspNetCore.Components.Authorization; namespace Blazor6.Client.BFF; public class BffAuthenticationStateProvider : AuthenticationStateProvider { private static readonly TimeSpan UserCacheRefreshInterval = TimeSpan.FromSeconds(60); private readonly HttpClient _client; private readonly ILogger\u0026lt;BffAuthenticationStateProvider\u0026gt; _logger; private DateTimeOffset _userLastCheck = DateTimeOffset.FromUnixTimeSeconds(0); private ClaimsPrincipal _cachedUser = new ClaimsPrincipal(new ClaimsIdentity()); public BffAuthenticationStateProvider( HttpClient client, ILogger\u0026lt;BffAuthenticationStateProvider\u0026gt; logger) { _client = client; _logger = logger; } public override async Task\u0026lt;AuthenticationState\u0026gt; GetAuthenticationStateAsync() { return new AuthenticationState(await GetUser()); } private async ValueTask\u0026lt;ClaimsPrincipal\u0026gt; GetUser(bool useCache = true) { var now = DateTimeOffset.Now; if (useCache \u0026amp;\u0026amp; now \u0026lt; _userLastCheck + UserCacheRefreshInterval) { _logger.LogDebug(\u0026#34;Taking user from cache\u0026#34;); return _cachedUser; } _logger.LogDebug(\u0026#34;Fetching user\u0026#34;); _cachedUser = await FetchUser(); _userLastCheck = now; return _cachedUser; } record ClaimRecord(string Type, object Value); private async Task\u0026lt;ClaimsPrincipal\u0026gt; FetchUser() { try { _logger.LogInformation(\u0026#34;Fetching user information.\u0026#34;); var response = await _client.GetAsync(\u0026#34;bff/user?slide=false\u0026#34;); if (response.StatusCode == HttpStatusCode.OK) { var claims = await response.Content.ReadFromJsonAsync\u0026lt;List\u0026lt;ClaimRecord\u0026gt;\u0026gt;(); var identity = new ClaimsIdentity( nameof(BffAuthenticationStateProvider), \u0026#34;name\u0026#34;, \u0026#34;role\u0026#34;); foreach (var claim in claims) { identity.AddClaim(new Claim(claim.Type, claim.Value.ToString())); } return new ClaimsPrincipal(identity); } } catch (Exception ex) { _logger.LogWarning(ex, \u0026#34;Fetching user failed.\u0026#34;); } return new ClaimsPrincipal(new ClaimsIdentity()); } } ..and register it in the client\u0026rsquo;s Program.cs:\nbuilder.Services.AddAuthorizationCore(); builder.Services.AddScoped\u0026lt;AuthenticationStateProvider, BffAuthenticationStateProvider\u0026gt;(); If you run the server app now again, you will see a different error:\nfail: Duende.Bff.Endpoints.BffMiddleware[1] Anti-forgery validation failed. local path: \u0026#39;/bff/user\u0026#39; This is due to the antiforgery protection that is applied automatically to the management endpoints in the BFF host. To properly secure the call, you need to add a static X-CSRF header to the call. See here for more background information.\nThis can be easily accomplished by a delegating handler that can be plugged into the default HTTP client used by the Blazor frontend. Let\u0026rsquo;s first add the handler:\npublic class AntiforgeryHandler : DelegatingHandler { protected override Task\u0026lt;HttpResponseMessage\u0026gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken) { request.Headers.Add(\u0026#34;X-CSRF\u0026#34;, \u0026#34;1\u0026#34;); return base.SendAsync(request, cancellationToken); } } ..and register it in the client\u0026rsquo;s Program.cs (overriding the standard HTTP client configuration; requires package Microsoft.Extensions.Http):\n// HTTP client configuration builder.Services.AddTransient\u0026lt;AntiforgeryHandler\u0026gt;(); builder.Services.AddHttpClient(\u0026#34;backend\u0026#34;, client =\u0026gt; client.BaseAddress = new Uri(builder.HostEnvironment.BaseAddress)) .AddHttpMessageHandler\u0026lt;AntiforgeryHandler\u0026gt;(); builder.Services.AddTransient(sp =\u0026gt; sp.GetRequiredService\u0026lt;IHttpClientFactory\u0026gt;().CreateClient(\u0026#34;backend\u0026#34;)); This requires an additional reference in the client project:\n\u0026lt;PackageReference Include=\u0026#34;Microsoft.Extensions.Http\u0026#34; Version=\u0026#34;6.0.0\u0026#34; /\u0026gt; If you restart the application again, the logon/logoff logic should work now. In addition you can display the contents of the session on the main page by adding this code to Index.razor:\n@page \u0026#34;/\u0026#34; \u0026lt;PageTitle\u0026gt;Home\u0026lt;/PageTitle\u0026gt; \u0026lt;h1\u0026gt;Hello, Blazor BFF!\u0026lt;/h1\u0026gt; \u0026lt;AuthorizeView\u0026gt; \u0026lt;Authorized\u0026gt; \u0026lt;dl\u0026gt; @foreach (var claim in @context.User.Claims) { \u0026lt;dt\u0026gt;@claim.Type\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;@claim.Value\u0026lt;/dd\u0026gt; } \u0026lt;/dl\u0026gt; \u0026lt;/Authorized\u0026gt; \u0026lt;/AuthorizeView\u0026gt; Securing the local API The standard Blazor template contains an API endpoint (WeatherForecastController.cs). Try invoking the weather page from the UI. It works both in logged in and anonymous state. We want to change the code to make sure, that only authenticated users can call the API.\nThe standard way in ASP.NET Core would be to add an authorization requirement to the endpoint, either on the controller/action or via the endpoint routing, e.g.:\napp.MapControllers() .RequireAuthorization(); When you now try to invoke the API anonymously, you will see the following error in the browser console:\nAccess to fetch at \u0026#39;https://demo.duendesoftware.com/connect/authorize?client_id=...[shortened]... (redirected from \u0026#39;https://localhost:5002/WeatherForecast\u0026#39;) from origin \u0026#39;https://localhost:5002\u0026#39; has been blocked by CORS policy: Response to preflight request doesn\u0026#39;t pass access control check: No \u0026#39;Access-Control-Allow-Origin\u0026#39; header is present on the requested resource. If an opaque response serves your needs, set the request\u0026#39;s mode to \u0026#39;no-cors\u0026#39; to fetch the resource with CORS disabled. This happens because the ASP.NET Core authentication plumbing is triggering a redirect to the OpenID Connect provider for authentication. What we really want in that case is an API friendly status code - 401 in this scenario.\nThis is one of the features of the BFF middleware, but you need to mark the endpoint as a BFF API endpoint for that to take effect:\napp.MapControllers() .RequireAuthorization() .AsBffApiEndpoint(); After making this change, you should see a much better error message:\nResponse status code does not indicate success: 401 (Unauthorized). The client code can properly respond to this, e.g. triggering a login redirect.\nWhen you logon now and call the API, you can put a breakpoint server-side and inspect that the API controller has access to the claims of the authenticated user via the .User property.\nSetting up a Blazor BFF client in IdentityServer In essence a BFF client is \u0026ldquo;just\u0026rdquo; a normal authorization code flow client:\nuse the code grant type set a client secret enable AllowOfflineAccess if you want to use refresh tokens enable the required identity and resource scopes set the redirect URIs for the OIDC handler Below is a typical code snippet for the client definition:\nvar bffClient = new Client { ClientId = \u0026#34;bff\u0026#34;, ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, AllowedGrantTypes = GrantTypes.Code, RedirectUris = { \u0026#34;https://bff_host/signin-oidc\u0026#34; }, FrontChannelLogoutUri = \u0026#34;https://bff_host/signout-oidc\u0026#34;, PostLogoutRedirectUris = { \u0026#34;https://bff_host/signout-callback-oidc\u0026#34; }, AllowOfflineAccess = true, AllowedScopes = { \u0026#34;openid\u0026#34;, \u0026#34;profile\u0026#34;, \u0026#34;remote_api\u0026#34; } }; Further experiments Our Blazor BFF sample is based on this Quickstart. In addition it shows concepts like\nbetter organization with components reacting to logout using the authorize attribute to trigger automatic redirects to the login page "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/extensibility/management/silent-login/",
    "title": "BFF Silent Login Endpoint Extensibility",
    "tags": [],
    "description": "",
    "content": "The BFF silent login endpoint can be customized by implementing the ISilentLoginService or by extending DefaultSilentLoginService, its default implementation.\nRequest Processing ProcessRequestAsync is the top level function called in the endpoint service and can be used to add arbitrary logic to the endpoint.\nFor example, you could take whatever actions you need before normal processing of the request like this:\npublic override Task ProcessRequestAsync(HttpContext context) { // Custom logic here return base.ProcessRequestAsync(context); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/session/management/",
    "title": "BFF Session Management Endpoints",
    "tags": [],
    "description": "",
    "content": "Duende.BFF adds endpoints for performing typical session-management operations such as triggering login and logout and getting information about the currently logged-on user. These endpoint are meant to be called by the frontend.\nIn addition Duende.BFF adds an implementation of the OpenID Connect back-channel notification endpoint to overcome the restrictions of third party cookies in front-channel notification in modern browsers.\nYou enable the endpoints by adding the relevant services into the DI container:\npublic void ConfigureServices(IServiceCollection services) { // Add BFF services to DI - also add server-side session management services.AddBff(options =\u0026gt; { // default value options.ManagementBasePath = \u0026#34;/bff\u0026#34;; }; // rest omitted } Endpoint routing is used to map the management endpoints:\npublic void Configure(IApplicationBuilder app) { // rest omitted app.UseEndpoints(endpoints =\u0026gt; { endpoints.MapBffManagementEndpoints(); }); MapBffManagementEndpoints adds all BFF management endpoints. You can also map each endpoint individually by calling the various MapBffManagementXxxEndpoint methods, for example endpoints.MapBffManagementLoginEndpoint().\nThe following pages describe the default behavior of the management endpoints. See the extensibility section for information about how to customize the behavior of the endpoints.\nBFF Login Endpoint BFF User Endpoint BFF Logout Endpoint BFF Silent Login Endpoint BFF Diagnostics Endpoint BFF Back-Channel Logout Endpoint "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/fundamentals/",
    "title": "Fundamentals",
    "tags": [],
    "description": "",
    "content": "Fundamentals Hosting Resources Clients Users and Logging In Claims Key Management License Key "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/apis/add_apis/",
    "title": "Adding API Endpoints to your IdentityServer",
    "tags": [],
    "description": "",
    "content": "It\u0026rsquo;s a common scenario to add additional API endpoints to the application hosting IdentityServer. These endpoints are typically protected by IdentityServer itself.\nFor simple scenarios, we give you some helpers. See the advanced section to understand more of the internal plumbing.\nYou could achieve the same by using either Microsoft\u0026rsquo;s JwtBearer handler. But this requires more configuration and creates dependencies on external libraries that might lead to conflicts in future updates.\nStart by registering your API as an ApiScope, (or resource) e.g.:\nvar scopes = new List\u0026lt;ApiScope\u0026gt; { // local API new ApiScope(IdentityServerConstants.LocalApi.ScopeName), }; ..and give your clients access to this API, e.g.:\nnew Client { // rest omitted AllowedScopes = { IdentityServerConstants.LocalApi.ScopeName }, } The value of IdentityServerConstants.LocalApi.ScopeName is IdentityServerApi.\nTo enable token validation for local APIs, add the following to your IdentityServer startup:\nservices.AddLocalApiAuthentication(); To protect an API controller, decorate it with an Authorize attribute using the LocalApi.PolicyName policy:\n[Route(\u0026#34;localApi\u0026#34;)] [Authorize(LocalApi.PolicyName)] public class LocalApiController : ControllerBase { public IActionResult Get() { // omitted } } Authorized clients can then request a token for the IdentityServerApi scope and use it to call the API.\nDiscovery You can also add your endpoints to the discovery document if you want, e.g like this::\nservices.AddIdentityServer(options =\u0026gt; { options.Discovery.CustomEntries.Add(\u0026#34;local_api\u0026#34;, \u0026#34;~/localapi\u0026#34;); }) Advanced Under the covers, the AddLocalApiAuthentication helper does a couple of things:\nadds an authentication handler that validates incoming tokens using IdentityServer\u0026rsquo;s built-in token validation engine (the name of this handler is IdentityServerAccessToken or IdentityServerConstants.LocalApi.AuthenticationScheme configures the authentication handler to require a scope claim inside the access token of value IdentityServerApi sets up an authorization policy that checks for a scope claim of value IdentityServerApi This covers the most common scenarios. You can customize this behavior in the following ways:\nAdd the authentication handler yourself by calling services.AddAuthentication().AddLocalApi(\u0026hellip;) this way you can specify the required scope name yourself, or (by specifying no scope at all) accept any token from the current IdentityServer instance Do your own scope validation/authorization in your controllers using custom policies or code, e.g.: services.AddAuthorization(options =\u0026gt; { options.AddPolicy(IdentityServerConstants.LocalApi.PolicyName, policy =\u0026gt; { policy.AddAuthenticationSchemes(IdentityServerConstants.LocalApi.AuthenticationScheme); policy.RequireAuthenticatedUser(); // custom requirements }); }); Claims Transformation You can provide a callback to transform the claims of the incoming token after validation. Either use the helper method, e.g.:\nservices.AddLocalApiAuthentication(principal =\u0026gt; { principal.Identities.First().AddClaim(new Claim(\u0026#34;additional_claim\u0026#34;, \u0026#34;additional_value\u0026#34;)); return Task.FromResult(principal); }); \u0026hellip;or implement the event on the options if you add the authentication handler manually.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/fundamentals/resources/api_scopes/",
    "title": "API Scopes",
    "tags": [],
    "description": "Overview",
    "content": "Designing your API surface can be a complicated task. Duende IdentityServer provides a couple of primitives to help you with that.\nThe original OAuth 2.0 specification has the concept of scopes, which is just defined as the scope of access that the client requests. Technically speaking, the scope parameter is a list of space delimited values - you need to provide the structure and semantics of it.\nIn more complex systems, often the notion of a resource is introduced. This might be e.g. a physical or logical API. In turn each API can potentially have scopes as well. Some scopes might be exclusive to that resource, and some scopes might be shared.\nLet\u0026rsquo;s start with simple scopes first, and then we\u0026rsquo;ll have a look how resources can help structure scopes.\nScopes Let\u0026rsquo;s model something very simple - a system that has three logical operations read, write, and delete.\nYou can define them using the ApiScope class:\npublic static IEnumerable\u0026lt;ApiScope\u0026gt; GetApiScopes() { return new List\u0026lt;ApiScope\u0026gt; { new ApiScope(name: \u0026#34;read\u0026#34;, displayName: \u0026#34;Read your data.\u0026#34;), new ApiScope(name: \u0026#34;write\u0026#34;, displayName: \u0026#34;Write your data.\u0026#34;), new ApiScope(name: \u0026#34;delete\u0026#34;, displayName: \u0026#34;Delete your data.\u0026#34;) }; } You can then assign the scopes to various clients, e.g.:\nvar webViewer = new Client { ClientId = \u0026#34;web_viewer\u0026#34;, AllowedScopes = { \u0026#34;openid\u0026#34;, \u0026#34;profile\u0026#34;, \u0026#34;read\u0026#34; } }; var mobileApp = new Client { ClientId = \u0026#34;mobile_app\u0026#34;, AllowedScopes = { \u0026#34;openid\u0026#34;, \u0026#34;profile\u0026#34;, \u0026#34;read\u0026#34;, \u0026#34;write\u0026#34;, \u0026#34;delete\u0026#34; } } Authorization based on Scopes When a client asks for a scope (and that scope is allowed via configuration and not denied via consent), the value of that scope will be included in the resulting access token as a claim of type scope (for both JWTs and introspection), e.g.:\n{ \u0026#34;typ\u0026#34;: \u0026#34;at+jwt\u0026#34; }. { \u0026#34;client_id\u0026#34;: \u0026#34;mobile_app\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;read write delete\u0026#34; } The format of the scope parameter can be controlled by the EmitScopesAsSpaceDelimitedStringInJwt setting on the options. Historically IdentityServer emitted scopes as an array, but you can switch to a space delimited string instead.\nThe consumer of the access token can use that data to make sure that the client is actually allowed to invoke the corresponding functionality. See the APIs section for more information on protecting APIs with access tokens.\nBe aware, that scopes are purely for authorizing clients, not users. In other words, the write scope allows the client to invoke the functionality associated with the scope and is unrelated to the user\u0026rsquo;s permission to do so. This additional user centric authorization is application logic and not covered by OAuth, yet still possibly important to implement in your API.\nAdding user claims You can add more identity information about the user to the access token. The additional claims added are based on the scope requested. The following scope definition tells the configuration system that when a write scope gets granted the user_level claim should be added to the access token:\nvar writeScope = new ApiScope( name: \u0026quot;write\u0026quot;, displayName: \u0026quot;Write your data.\u0026quot;, userClaims: new[] { \u0026quot;user_level\u0026quot; }); This will pass the user_level claim as a requested claim type to the profile service, so that the consumer of the access token can use this data as input for authorization decisions or business logic.\nWhen using the scope-only model, no aud (audience) claim will be added to the token since this concept does not apply. If you need an aud claim, you can enable the EmitStaticAudienceClaim setting on the options. This will emit an aud claim in the issuer_name/resources format. If you need more control of the aud claim, use API resources.\nParameterized Scopes Sometimes scopes have a certain structure, e.g. a scope name with an additional parameter: transaction:id or read_patient:patientid.\nIn this case you would create a scope without the parameter part and assign that name to a client, but in addition provide some logic to parse the structure of the scope at runtime using the IScopeParser interface or by deriving from our default implementation, e.g.:\npublic class ParameterizedScopeParser : DefaultScopeParser { public ParameterizedScopeParser(ILogger\u0026lt;DefaultScopeParser\u0026gt; logger) : base(logger) { } public override void ParseScopeValue(ParseScopeContext scopeContext) { const string transactionScopeName = \u0026#34;transaction\u0026#34;; const string separator = \u0026#34;:\u0026#34;; const string transactionScopePrefix = transactionScopeName + separator; var scopeValue = scopeContext.RawValue; if (scopeValue.StartsWith(transactionScopePrefix)) { // we get in here with a scope like \u0026#34;transaction:something\u0026#34; var parts = scopeValue.Split(separator, StringSplitOptions.RemoveEmptyEntries); if (parts.Length == 2) { scopeContext.SetParsedValues(transactionScopeName, parts[1]); } else { scopeContext.SetError(\u0026#34;transaction scope missing transaction parameter value\u0026#34;); } } else if (scopeValue != transactionScopeName) { // we get in here with a scope not like \u0026#34;transaction\u0026#34; base.ParseScopeValue(scopeContext); } else { // we get in here with a scope exactly \u0026#34;transaction\u0026#34;, which is to say we\u0026#39;re ignoring it // and not including it in the results scopeContext.SetIgnore(); } } } You then have access to the parsed value throughout the pipeline, e.g. in the profile service:\npublic class HostProfileService : IProfileService { public override async Task GetProfileDataAsync(ProfileDataRequestContext context) { var transaction = context.RequestedResources.ParsedScopes.FirstOrDefault(x =\u0026gt; x.ParsedName == \u0026#34;transaction\u0026#34;); if (transaction?.ParsedParameter != null) { context.IssuedClaims.Add(new Claim(\u0026#34;transaction_id\u0026#34;, transaction.ParsedParameter)); } } } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/deployment/data_protection/",
    "title": "ASP.NET Core Data Protection",
    "tags": [],
    "description": "",
    "content": "Duende IdentityServer makes extensive use of ASP.NET\u0026rsquo;s data protection feature. It is crucial that you configure data protection correctly before you start using your IdentityServer in production.\nIn local development, ASP.NET automatically creates data protection keys, but in a deployed environment, you will need to ensure that your data protection keys are stored in a persistent way and shared across all load balanced instances of your IdentityServer implementation. This means you\u0026rsquo;ll need to choose where to store and how to protect the data protection keys, as appropriate for your environment. Microsoft has extensive documentation here describing how to configure storage and protection of data protection keys.\nA typical IdentityServer implementation should include data protection configuration code, like this:\nbuilder.Services.AddDataProtection() // Choose an extension method for key persistence, such as // PersistKeysToFileSystem, PersistKeysToDbContext, // PersistKeysToAzureBlobStorage, or PersistKeysToAWSSystemsManager .PersistKeysToFoo() // Choose an extension method for key protection, such as // ProtectKeysWithCertificate, ProtectKeysWithAzureKeyVault .ProtectKeysWithBar() // Explicitly set an application name to prevent issues with // key isolation. .SetApplicationName(\u0026#34;IdentityServer\u0026#34;); Data Protection Keys and IdentityServer\u0026rsquo;s Signing Keys ASP.NET\u0026rsquo;s data protection keys are sometimes confused with IdentityServer\u0026rsquo;s signing keys, but the two are completely separate keys with different purposes. IdentityServer implementations need both to function correctly.\nData Protection Keys Data protection is a cryptographic library that is part of the ASP.NET framework. Data protection uses private key cryptography to encrypt and sign sensitive data to ensure that it is only written and read by the application. The framework uses data protection to secure data that is commonly used by IdentityServer implementations, such as authentication cookies and anti-forgery tokens. In addition, IdentityServer itself uses data protection to protect sensitive data at rest, such as persisted grants, as well as sensitive data passed through the browser, such as the context objects passed to pages in the UI. The data protection keys are critical secrets for an IdentityServer implementation because they encrypt a great deal of sensitive data at rest and prevent sensitive data that is roundtripped through the browser from being tampered with.\nIdentityServer Signing Key Separately, IdentityServer needs cryptographic keys, called signing keys, to sign tokens such as JWT access tokens and id tokens. The signing keys use public key cryptography to allow client applications and APIs to validate token signatures using the public keys, which are published by IdentityServer through discovery. The private key component of the signing keys are also critical secrets for IdentityServer because a valid signature provides integrity and non-repudiation guarantees that allow client applications and APIs to trust those tokens.\nCommon Problems Common data protection problems occur when data is protected with a key that is not available when the data is later read. A common symptom is CryptographicExceptions in the IdentityServer logs. For example, when automatic key management fails to read its signing keys due to a data protection failure, IdentityServer will log an error message such as \u0026ldquo;Error unprotecting key with kid {Signing Key ID}.\u0026rdquo;, and log the underlying System.Security.Cryptography.CryptographicException, with a message like \u0026ldquo;The key {Data Protection Key ID} was not found in the key ring.\u0026rdquo;\nFailures to read automatic signing keys are often the first place where a data protection problem manifests, but any of many places where IdentityServer and ASP.NET use data protection might also throw CryptographicExceptions.\nThere are several ways that data protection problems can occur:\nIn load balanced environments, every instance of IdentityServer needs to be configured to share data protection keys. Without shared data protection keys, each load balanced instance will only be able to read the data that it writes. Data protected data could be generated in a development environment and then accidentally included into the build output. This is most commonly the case for automatically managed signing keys that are stored on disk. If you are using automatic signing key management with the default file system based key store, you should exclude the ~/keys directory from source control and make sure keys are not included in your builds. Note that if you are using our Entity Framework based implementation of the operational data stores, then the keys will instead be stored in the database. Data protection creates keys isolated by application name. If you don\u0026rsquo;t specify a name, the content root path of the application will be used. But, beginning in .NET 6.0 Microsoft changed how they handle the path, which can cause data protection keys to break. Their docs on the problem are here, including a work-around where you de-normalize the path. Then, in .NET 7.0, this change was reverted. The solution is always to specify an explicit application name, and if you have old keys that were generated without an explicit application name, you need to set your application name to match the default behavior that produced the keys you want to be able to read. If your IdentityServer is hosted by IIS, special configuration is needed for data protection. In most default deployments, IIS lacks the permissions required to persist data protection keys, and falls back to using an ephemeral key generated every time the site starts up. Microsoft\u0026rsquo;s docs on this issue are here. Identity Server\u0026rsquo;s Usage of Data Protection Duende IdentityServer\u0026rsquo;s features that rely on data protection include\nprotecting signing keys at rest (if automatic key management is used and enabled) protecting persisted grants at rest (if enabled) protecting server-side session data at rest (if enabled) protecting the state parameter for external OIDC providers (if enabled) protecting message payloads sent between pages in the UI (e.g. logout context and error context). session management (because the ASP.NET Core cookie authentication handler requires it) "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/session/management/login/",
    "title": "BFF Login Endpoint",
    "tags": [],
    "description": "",
    "content": "The /bff/login endpoint begins the authentication process. To use it, typically javascript code will navigate away from the frontend application to the login endpoint:\nwindow.location = \u0026#34;/bff/login\u0026#34;; In Blazor, instead use the NavigationManager to navigate to the login endpoint:\nNavigation.NavigateTo($\u0026#34;bff/login\u0026#34;, forceLoad: true); The login endpoint triggers an authentication challenge using the default challenge scheme, which will typically use the OpenID Connect handler.\nReturn Url After authentication is complete, the login endpoint will redirect back to your front end application. By default, this redirect goes to the root of the application. You can use a different URL instead by including a local URL as the returnUrl query parameter.\nwindow.location = \u0026#34;/bff/login?returnUrl=/logged-in\u0026#34;; "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/di/",
    "title": "DI Extension Methods",
    "tags": [],
    "description": "",
    "content": "AddIdentityServer return a builder object that provides many extension methods to add IdentityServer specific services to DI. Here\u0026rsquo;s a list grouped by feature areas.\npublic void ConfigureServices(IServiceCollection services) { var builder = services.AddIdentityServer(); } Many of the fundamental configuration settings can be set on the options. See the IdentityServerOptions reference for more details.\nConfiguration Stores Several convenience methods are provided for registering custom stores:\nAddClientStore\u0026lt;T\u0026gt;\nRegisters a custom IClientStore implementation.\nAddCorsPolicyService\u0026lt;T\u0026gt;\nRegisters a custom ICorsPolicyService implementation.\nAddResourceStore\u0026lt;T\u0026gt;\nRegisters a custom IResourceStore implementation.\nAddIdentityProviderStore\u0026lt;T\u0026gt;\nRegisters a custom IIdentityProviderStore implementation.\nThe in-memory configuration stores can be registered in DI with the following extension methods.\nAddInMemoryClients\nRegisters IClientStore and ICorsPolicyService implementations based on the in-memory collection of Client configuration objects.\nAddInMemoryIdentityResources\nRegisters IResourceStore implementation based on the in-memory collection of IdentityResource configuration objects.\nAddInMemoryApiScopes\nRegisters IResourceStore implementation based on the in-memory collection of ApiScope configuration objects.\nAddInMemoryApiResources\nRegisters IResourceStore implementation based on the in-memory collection of ApiResource configuration objects.\nCaching Configuration Data Extension methods to enable caching for configuration data:\nAddInMemoryCaching\u0026lt;T\u0026gt;\nTo use any of the caches described below, an implementation of ICache\u0026lt;T\u0026gt; must be registered in DI. This API registers a default in-memory implementation of ICache\u0026lt;T\u0026gt; that\u0026rsquo;s based on ASP.NET Core\u0026rsquo;s MemoryCache.\nAddClientStoreCache\u0026lt;T\u0026gt; Registers a IClientStore decorator implementation which will maintain an in-memory cache of Client configuration objects. The cache duration is configurable on the Caching configuration options on the IdentityServerOptions.\nAddResourceStoreCache\u0026lt;T\u0026gt;\nRegisters a IResourceStore decorator implementation which will maintain an in-memory cache of IdentityResource and ApiResource configuration objects. The cache duration is configurable on the Caching configuration options on the IdentityServerOptions.\nAddCorsPolicyCache\u0026lt;T\u0026gt;\nRegisters a ICorsPolicyService decorator implementation which will maintain an in-memory cache of the results of the CORS policy service evaluation. The cache duration is configurable on the Caching configuration options on the IdentityServerOptions.\nAddIdentityProviderStoreCache\u0026lt;T\u0026gt;\nRegisters a IIdentityProviderStore decorator implementation which will maintain an in-memory cache of IdentityProvider configuration objects. The cache duration is configurable on the Caching configuration options on the IdentityServerOptions.\nTest Stores The TestUser class models a user, their credentials, and claims in IdentityServer.\nUse of TestUser is similar to the use of the \u0026ldquo;in-memory\u0026rdquo; stores in that it is intended for when prototyping, developing, and/or testing. The use of TestUser is not recommended in production.\nAddTestUsers\nRegisters TestUserStore based on a collection of TestUser objects. TestUserStore is e.g. used by the default quickstart UI. Also registers implementations of IProfileService and IResourceOwnerPasswordValidator that uses the test users as a backing store.\nSigning keys Duende IdentityServer needs key material to sign tokens. This key material can either be created and managed automatically or configured statically.\nWe recommend that you use automatic key management. This section covers the configuration methods needed for manual configuration of signing keys, which are usually only needed if your license does not include automatic key management or if you are migrating from manually managed keys to automatic key management.\nDuende IdentityServer supports X.509 certificates (both raw files and a reference to the certificate store), RSA keys and EC keys for token signatures and validation. Each key can be configured with a (compatible) signing algorithm, e.g. RS256, RS384, RS512, PS256, PS384, PS512, ES256, ES384 or ES512.\nYou can configure the key material with the following methods:\nAddSigningCredential\nAdds a signing key that provides the specified key material to the various token creation/validation services.\nAddDeveloperSigningCredential\nCreates temporary key material at startup time. This is for dev scenarios. The generated key will be persisted in the local directory by default (or just kept in memory).\nAddValidationKey\nAdds a key for validating tokens. They will be used by the internal token validator and will show up in the discovery document.\nAdditional services The following are convenient to add additional features to your IdentityServer.\nAddExtensionGrantValidator\nAdds an IExtensionGrantValidator implementation for use with extension grants.\nAddSecretParser\nAdds an ISecretParser implementation for parsing client or API resource credentials.\nAddSecretValidator\nAdds an ISecretValidator implementation for validating client or API resource credentials against a credential store.\nAddResourceOwnerValidator\nAdds an IResourceOwnerPasswordValidator implementation for validating user credentials for the resource owner password credentials grant type.\nAddProfileService\nAdds an IProfileService implementation. The default implementation (found in DefaultProfileService) relies upon the authentication cookie as the only source of claims for issuing in tokens.\nAddAuthorizeInteractionResponseGenerator\nAdds an IAuthorizeInteractionResponseGenerator implementation to customize logic at authorization endpoint for when a user must be shown a UI for error, login, consent, or any other custom page. The default implementation can be found in the AuthorizeInteractionResponseGenerator class, so consider deriving from this existing class if you need to augment the existing behavior.\nAddCustomAuthorizeRequestValidator\nAdds an ICustomAuthorizeRequestValidator implementation to customize request parameter validation at the authorization endpoint.\nAddCustomTokenRequestValidator\nAdds an ICustomTokenRequestValidator implementation to customize request parameter validation at the token endpoint.\nAddRedirectUriValidator\nAdds an IRedirectUriValidator implementation to customize redirect URI validation.\nAddAppAuthRedirectUriValidator\nAdds an \u0026ldquo;AppAuth\u0026rdquo; (OAuth 2.0 for Native Apps) compliant redirect URI validator (does strict validation but also allows http://127.0.0.1 with random port).\nAddJwtBearerClientAuthentication\nAdds support for client authentication using JWT bearer assertions.\nAddMutualTlsSecretValidators\nAdds the X509 secret validators for mutual TLS.\nAddIdentityProviderConfigurationValidator\nAdds an IdentityProvider configuration validator.\nAddBackchannelAuthenticationUserValidator\nAdds the backchannel login user validator.\nAddBackchannelAuthenticationUserNotificationService\nAdds the backchannel login user validator.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/diagnostics/events/",
    "title": "Events",
    "tags": [],
    "description": "",
    "content": "While logging is more low level \u0026ldquo;printf\u0026rdquo; style - events represent higher level information about certain operations in IdentityServer. Events are structured data and include event IDs, success/failure information, categories and details. This makes it easy to query and analyze them and extract useful information that can be used for further processing.\nEvents work great with structured logging stores like ELK, Seq or Splunk.\nEmitting events Events are not turned on by default - but can be globally configured in the ConfigureServices method, e.g.:\nservices.AddIdentityServer(options =\u0026gt; { options.Events.RaiseSuccessEvents = true; options.Events.RaiseFailureEvents = true; options.Events.RaiseErrorEvents = true; }); To emit an event use the IEventService from the DI container and call the RaiseAsync method, e.g.:\npublic async Task\u0026lt;IActionResult\u0026gt; Login(LoginInputModel model) { if (_users.ValidateCredentials(model.Username, model.Password)) { // issue authentication cookie with subject ID and username var user = _users.FindByUsername(model.Username); await _events.RaiseAsync(new UserLoginSuccessEvent(user.Username, user.SubjectId, user.Username)); } else { await _events.RaiseAsync(new UserLoginFailureEvent(model.Username, \u0026#34;invalid credentials\u0026#34;)); } } Custom sinks Our default event sink will simply serialize the event class to JSON and forward it to the ASP.NET Core logging system. If you want to connect to a custom event store, implement the IEventSink interface and register it with DI.\nThe following example uses Seq to emit events:\npublic class SeqEventSink : IEventSink { private readonly Logger _log; public SeqEventSink() { _log = new LoggerConfiguration() .WriteTo.Seq(\u0026#34;http://localhost:5341\u0026#34;) .CreateLogger(); } public Task PersistAsync(Event evt) { if (evt.EventType == EventTypes.Success || evt.EventType == EventTypes.Information) { _log.Information(\u0026#34;{Name} ({Id}), Details: {@details}\u0026#34;, evt.Name, evt.Id, evt); } else { _log.Error(\u0026#34;{Name} ({Id}), Details: {@details}\u0026#34;, evt.Name, evt.Id, evt); } return Task.CompletedTask; } } Add the Serilog.Sinks.Seq package to your host to make the above code work.\nBuilt-in events The following events are defined in IdentityServer:\nApiAuthenticationFailureEvent \u0026amp; ApiAuthenticationSuccessEvent\nGets raised for successful/failed API authentication at the introspection endpoint.\nClientAuthenticationSuccessEvent \u0026amp; ClientAuthenticationFailureEvent\nGets raised for successful/failed client authentication at the token endpoint.\nTokenIssuedSuccessEvent \u0026amp; TokenIssuedFailureEvent\nGets raised for successful/failed attempts to request identity tokens, access tokens, refresh tokens and authorization codes.\nTokenIntrospectionSuccessEvent \u0026amp; TokenIntrospectionFailureEvent\nGets raised for successful token introspection requests.\nTokenRevokedSuccessEvent\nGets raised for successful token revocation requests.\nUserLoginSuccessEvent \u0026amp; UserLoginFailureEvent\nGets raised by the quickstart UI for successful/failed user logins.\nUserLogoutSuccessEvent\nGets raised for successful logout requests.\nConsentGrantedEvent \u0026amp; ConsentDeniedEvent\nGets raised in the consent UI.\nUnhandledExceptionEvent\nGets raised for unhandled exceptions.\nDeviceAuthorizationFailureEvent \u0026amp; DeviceAuthorizationSuccessEvent\nGets raised for successful/failed device authorization requests.\nCustom events You can create your own events and emit them via our infrastructure.\nYou need to derive from our base Event class which injects contextual information like activity ID, timestamp, etc. Your derived class can then add arbitrary data fields specific to the event context::\npublic class UserLoginFailureEvent : Event { public UserLoginFailureEvent(string username, string error) : base(EventCategories.Authentication, \u0026#34;User Login Failure\u0026#34;, EventTypes.Failure, EventIds.UserLoginFailure, error) { Username = username; } public string Username { get; set; } } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/models/identity_resource/",
    "title": "Identity Resource",
    "tags": [],
    "description": "Reference",
    "content": "Duende.IdentityServer.Models.IdentityResource This class models an identity resource.\npublic static readonly IEnumerable\u0026lt;IdentityResource\u0026gt; IdentityResources = new[] { // some standard scopes from the OIDC spec new IdentityResources.OpenId(), new IdentityResources.Profile(), new IdentityResources.Email(), // custom identity resource with some associated claims new IdentityResource(\u0026#34;custom.profile\u0026#34;, userClaims: new[] { JwtClaimTypes.Name, JwtClaimTypes.Email, \u0026#34;location\u0026#34;, JwtClaimTypes.Address }) }; Enabled\nIndicates if this resource is enabled and can be requested. Defaults to true.\nName\nThe unique name of the identity resource. This is the value a client will use for the scope parameter in the authorize request.\nDisplayName\nThis value will be used e.g. on the consent screen.\nDescription\nThis value will be used e.g. on the consent screen.\nRequired\nSpecifies whether the user can de-select the scope on the consent screen (if the consent screen wants to implement such a feature). Defaults to false.\nEmphasize\nSpecifies whether the consent screen will emphasize this scope (if the consent screen wants to implement such a feature). Use this setting for sensitive or important scopes. Defaults to false.\nShowInDiscoveryDocument\nSpecifies whether this scope is shown in the discovery document. Defaults to true.\nUserClaims\nList of associated user claim types that should be included in the identity token.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/tokens/authentication/jwt/",
    "title": "Private Key JWTs",
    "tags": [],
    "description": "",
    "content": "The OpenID Connect specification recommends a client authentication method based on asymmetric keys. With this approach, instead of transmitting the shared secret over the network, the client creates a JWT and signs it with its private key. Your IdentityServer only needs to store the corresponding key to be able to validate the signature.\nThe technique is described here and is based on the OAuth JWT assertion specification (RFC 7523).\nSetting up a private key JWT secret The default private key JWT secret validator expects either a base64 encoded X.509 certificate or a JSON Web Key formatted RSA, EC or symmetric key on the secret definition:\nvar client = new Client { ClientId = \u0026quot;client.jwt\u0026quot;, ClientSecrets = { new Secret { // base64 encoded X.509 certificate Type = IdentityServerConstants.SecretTypes.X509CertificateBase64, Value = \u0026quot;MIID...xBXQ=\u0026quot; } new Secret { // JWK formatted RSA key Type = IdentityServerConstants.SecretTypes.JsonWebKey, Value = \u0026quot;{'e':'AQAB','kid':'Zz...GEA','kty':'RSA','n':'wWw...etgKw'}\u0026quot; } }, AllowedGrantTypes = GrantTypes.ClientCredentials, AllowedScopes = { \u0026quot;api1\u0026quot;, \u0026quot;api2\u0026quot; } }; You can share the same key for client authentication and signed authorize requests.\nAuthentication using a private key JWT On the client side the, the caller must first generate the JWT, and then send it on the assertion body field:\nPOST /connect/token Content-type: application/x-www-form-urlencoded client_assertion=\u0026lt;jwt\u0026gt;\u0026amp; client_assertion_type=urn:ietf:params:oauth:grant-type:jwt-bearer\u0026amp; grant_type=authorization_code\u0026amp; code=hdh922\u0026amp; redirect_uri=https://myapp.com/callback .NET client library You can use the Microsoft JWT library to create JSON Web Tokens.\nprivate static string CreateClientToken(SigningCredentials credential, string clientId, string tokenEndpoint) { var now = DateTime.UtcNow; var token = new JwtSecurityToken( clientId, tokenEndpoint, new List\u0026lt;Claim\u0026gt;() { new Claim(JwtClaimTypes.JwtId, Guid.NewGuid().ToString()), new Claim(JwtClaimTypes.Subject, clientId), new Claim(JwtClaimTypes.IssuedAt, now.ToEpochTime().ToString(), ClaimValueTypes.Integer64) }, now, now.AddMinutes(1), credential ); var tokenHandler = new JwtSecurityTokenHandler(); return tokenHandler.WriteToken(token); } ..and the IdentityModel client library to programmatically interact with the protocol endpoint from .NET code.\nusing IdentityModel.Client; static async Task\u0026lt;TokenResponse\u0026gt; RequestTokenAsync(SigningCredentials credential) { var client = new HttpClient(); var disco = await client.GetDiscoveryDocumentAsync(\u0026#34;https://demo.duendesoftware.com\u0026#34;); if (disco.IsError) throw new Exception(disco.Error); var clientToken = CreateClientToken(credential, \u0026#34;private.key.jwt\u0026#34;, disco.TokenEndpoint); var response = await client.RequestClientCredentialsTokenAsync(new ClientCredentialsTokenRequest { Address = disco.TokenEndpoint, Scope = \u0026#34;api1.scope1\u0026#34;, ClientAssertion = { Type = OidcConstants.ClientAssertionTypes.JwtBearer, Value = clientToken } }); if (response.IsError) throw new Exception(response.Error); return response; } See here for a sample for using JWT-based authentication.\nUsing ASP.NET Core The OpenID Connect authentication handler in ASP.NET Core allows for replacing a static client secret with a dynamically created client assertion.\nThis is accomplished by handling the various events on the handler. We recommend to encapsulate the event handler in a separate type. This makes it easier to consume services from DI:\npublic void ConfigureServices(IServiceCollection services) { // some details omitted services.AddTransient\u0026lt;OidcEvents\u0026gt;(); services.AddAuthentication(options =\u0026gt; .AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { options.Authority = Constants.Authority; // no static client secret options.ClientId = \u0026#34;mvc.jar.jwt\u0026#34;; // specifies type that handles events options.EventsType = typeof(OidcEvents); })); } In your event handler you can inject code before the handler redeems the code:\npublic class OidcEvents : OpenIdConnectEvents { private readonly AssertionService _assertionService; public OidcEvents(AssertionService assertionService) { _assertionService = assertionService; } public override Task AuthorizationCodeReceived(AuthorizationCodeReceivedContext context) { context.TokenEndpointRequest.ClientAssertionType = OidcConstants.ClientAssertionTypes.JwtBearer; context.TokenEndpointRequest.ClientAssertion = _assertionService.CreateClientToken(); return Task.CompletedTask; } } The assertion service would be a helper to create the JWT as shown above in the CreateClientToken method. See here for a sample for using JWT-based authentication (and signed authorize requests) in ASP.NET Core.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/tokens/refresh/",
    "title": "Refreshing a Token",
    "tags": [],
    "description": "",
    "content": "Access tokens have finite lifetimes. If a client needs long-lived access to a resource, refresh tokens can be used to request a new access token. This can be done with an API call and does not require any user interaction or interruption.\nSince this is a privileged operation, the clients needs to be explicitly authorized to be able to use refresh tokens by setting the AllowOfflineAccess property to true. See the client reference section for additional refresh token related settings.\nRefresh tokens are supported for the following flows: authorization code, hybrid and resource owner password credential flow.\nRequesting a refresh token You can request a refresh token by adding a scope called offline_access to the scope parameter list of the authorize request.\nRequesting an access token using a refresh token To get a new access token, you send the refresh token to the token endpoint. This will result in a new token response containing a new access token and its expiration and potentially also a new refresh token depending on the client configuration (see rotation).\nPOST /connect/token client_id=client\u0026amp; client_secret=secret\u0026amp; grant_type=refresh_token\u0026amp; refresh_token=hdh922 .NET client library On .NET you can leverage the IdentityModel client library to request refresh tokens, e.g.:\nusing IdentityModel.Client; var client = new HttpClient(); var response = await client.RequestRefreshTokenAsync(new RefreshTokenRequest { Address = TokenEndpoint, ClientId = \u0026#34;client\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, RefreshToken = \u0026#34;...\u0026#34; }); The Duende.AccessTokenManagement library can be used to automate refresh \u0026amp; access token lifetime management in ASP.NET Core.\nRefresh token security considerations Refresh tokens are a high-value target for attackers, because they typically have a much higher lifetime than access tokens.\nIt is recommended that a refresh token is either bound to the client via a client secret (for confidential/credentialed clients), or rotated for public clients.\nThe following techniques can be used to reduce the attack surface of refresh tokens.\nConsent We encourage you to request consent when a client requests a refresh token, as it not only makes the user aware of the action being taken, but also provides them with an opportunity to opt-out if they choose.\nDuende IdentityServer will always ask for consent (if enabled) if the client asks for the offline_access scope which follows the recommendations in the OpenID Connect specification.\nSliding expiration Refresh tokens usually have a much longer lifetime than access tokens. You can reduce their exposure by adding a sliding lifetime on top of the absolute lifetime. This allows for scenarios where a refresh token can be silently used if the user is regularly using the client, but needs a fresh authorize request if the client has not been used for a certain time. In other words, they auto-expire much quicker without potentially interfering with the typical usage pattern.\nYou can use the AbsoluteRefreshTokenLifetime and SlidingRefreshTokenLifetime client settings to fine tune this behavior.\nRotation The security of refresh tokens used by public clients can be improved by rotating the tokens on every use. Rotation is configured with the RefreshTokenUsage client setting and is enabled by default. However, rotation is only recommended for public clients. For confidential clients, we recommend changing the RefreshTokenUsage to allow reusable refresh tokens.\nPublic clients need to rotate refresh tokens for security. Rotating refresh tokens reduces their attack surface because there is a chance that a stolen token will be unusable by the attacker. If a token is exfiltrated from some storage mechanism, a network trace, or log file, but the owner of the token uses it before the attacker, then the attack fails.\nWhen RefreshTokenUsage is configured for OneTime usage, rotation is enabled and refresh tokens can only be used once. When refresh tokens are used with OneTime usage configured, a new refresh token is included in the response along with the new access token. Each time the client application uses the refresh token, it must use the most recent refresh token. This chain of tokens will each appear as distinct token values to the client, but will have identical creation and expiration timestamps in the datastore.\nIn version 6.3, the configuration option DeleteOneTimeOnlyRefreshTokensOnUse controls what happens to refresh tokens configured for OneTime usage. If the flag is on, then refresh tokens are deleted immediately on use. If the flag is off, the token is marked as consumed instead. Prior to version 6.3, OneTime usage refresh tokens are always marked as consumed.\nConfidential Clients Should Not Rotate Refresh Tokens Confidential clients do not need one-time use refresh tokens because their tokens are bound to the authenticated client. One-time use tokens do not improve the security of confidential clients (see OAuth 2.0 Security Best Current Practice for more details).\nReusable refresh tokens are robust to network failures in a way that one time use tokens are not. If a one-time use refresh token is used to produce a new token, but the response containing the new refresh token is lost due to a network issue, the client application has no way to recover without the user logging in again. Reusable refresh tokens do not have this problem.\nReusable tokens may have better performance in the persisted grants store. One-time use refresh tokens require additional records to be written to the store whenever a token is refreshed. Using reusable refresh tokens avoids those writes.\nAccepting Consumed Tokens To make one time use tokens more robust to network failures, you can customize the behavior of the RefreshTokenService such that consumed tokens can be used under certain circumstances, perhaps for a small length of time after they are consumed. To do so, create a subclass of the DefaultRefreshTokenService and override its AcceptConsumedTokenAsync(RefreshToken refreshToken) method. This method takes a consumed refresh token and returns a boolean flag that indicates if that token should be accepted, that is, allowed to be used to obtain an access token. The default implementation in the DefaultRefreshTokenService rejects all consumed tokens, but your customized implementation could create a time window where consumed tokens can be used.\nNew options added In 6.3 interact with this feature. The PersistentGrantOptions.DeleteOneTimeOnlyRefreshTokensOnUse flag will cause OneTime refresh tokens to be deleted on use, rather than marked as consumed. This flag will need to be disabled in order to allow a customized Refresh Token Service to use consumed tokens.\nConsumed tokens can be cleaned up by a background process, enabled with the existing OperationalStoreOptions.EnableTokenCleanup and OperationalStoreOptions.RemoveConsumedTokens flags. Starting in 6.3, the cleanup job can be further configured with the OperationalStoreOptions.ConsumedTokenCleanupDelay. This delay is the amount of time that must elapse before tokens marked as consumed will be deleted. If you are customizing the Refresh Token Service to allow for consumed tokens to be used for some period of time, then we recommend configuring the ConsumedTokenCleanupDelay to the same time period.\nThis customization must be registered in the DI system as an implementation of the IRefreshTokenService:\nbuilder.Services.TryAddTransient\u0026lt;IRefreshTokenService, YourCustomRefreshTokenService\u0026gt;(); Replay detection In addition to one-time only usage semantics, you might wish to add replay detection for refresh tokens. If a refresh token is configured for one-time only use but used multiple times, that means that either the client application is accidentally mis-using the token (a bug), a network failure is preventing the client application from rotating properly (see above), or an attacker is attempting a replay attack. Depending on your security requirements, you might decide to treat this situation as an attack, and take action. What you might do is, if a consumed refresh token is ever used, revoke all access for that client/user combination. This could include deleting refresh tokens, revoking access tokens (if they are introspection tokens), ending the user\u0026rsquo;s server side session, and sending back-channel logout notifications to client applications. You might also consider alerting the user to suspicious activity on their account. Keep in mind that these actions are disruptive and possibly alarming to the user, and there is a potential for false positives.\nImplementing replay detection is similar to accepting consumed tokens. Extend the AcceptConsumedTokenAsync method of the DefaultRefreshTokenService and add the additional revocation or alerting behavior that you choose. In 6.3, the same new options that interact with accepting consumed tokens also interact with replay detection. The PersistentGrantOptions.DeleteOneTimeOnlyRefreshTokensOnUse flag needs to be disabled so that used tokens persist and can be used to detect replays. The cleanup job should also be configured to not delete consumed tokens.\nSee also: The IRefreshTokenService reference.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/extensibility/sessions/",
    "title": "Session Management",
    "tags": [],
    "description": "BFF Extensibility",
    "content": "User Session Store If using the server-side sessions feature, you will need to have a store for the session data. An Entity Framework Core based implementation of this store is provided. If you wish to use some other type of store, then you can implement the IUserSessionStore interface:\n/// \u0026lt;summary\u0026gt; /// User session store /// \u0026lt;/summary\u0026gt; public interface IUserSessionStore { /// \u0026lt;summary\u0026gt; /// Retrieves a user session /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;cancellationToken\u0026#34;\u0026gt;A token that can be used to request cancellation of the asynchronous operation.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task\u0026lt;UserSession?\u0026gt; GetUserSessionAsync(string key, CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// Creates a user session /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;session\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;cancellationToken\u0026#34;\u0026gt;A token that can be used to request cancellation of the asynchronous operation.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task CreateUserSessionAsync(UserSession session, CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// Updates a user session /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;session\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;cancellationToken\u0026#34;\u0026gt;A token that can be used to request cancellation of the asynchronous operation.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task UpdateUserSessionAsync(string key, UserSessionUpdate session, CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// Deletes a user session /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;cancellationToken\u0026#34;\u0026gt;A token that can be used to request cancellation of the asynchronous operation.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task DeleteUserSessionAsync(string key, CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// Queries user sessions based on the filter. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;filter\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;cancellationToken\u0026#34;\u0026gt;A token that can be used to request cancellation of the asynchronous operation.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task\u0026lt;IReadOnlyCollection\u0026lt;UserSession\u0026gt;\u0026gt; GetUserSessionsAsync(UserSessionsFilter filter, CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// Deletes user sessions based on the filter. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;filter\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;cancellationToken\u0026#34;\u0026gt;A token that can be used to request cancellation of the asynchronous operation.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task DeleteUserSessionsAsync(UserSessionsFilter filter, CancellationToken cancellationToken = default); } Once you have an implementation, you can register it when you enable server-side sessions:\npublic void ConfigureServices(IServiceCollection services) { services.AddBff() .AddServerSideSessions\u0026lt;YourStoreClassName\u0026gt;(); } User Session Store Cleanup The IUserSessionStoreCleanup interface is used to model cleaning up expired sessions.\n/// \u0026lt;summary\u0026gt; /// User session store cleanup /// \u0026lt;/summary\u0026gt; public interface IUserSessionStoreCleanup { /// \u0026lt;summary\u0026gt; /// Deletes expired sessions /// \u0026lt;/summary\u0026gt; Task DeleteExpiredSessionsAsync(CancellationToken cancellationToken = default); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/apis/aspnetcore/reference/",
    "title": "Using Reference Tokens",
    "tags": [],
    "description": "",
    "content": "If you are using reference tokens, you need an authentication handler that implements the back-channel validation via the OAuth 2.0 token introspection protocol, e.g. this one:.\nservices.AddAuthentication(\u0026#34;token\u0026#34;) .AddOAuth2Introspection(\u0026#34;token\u0026#34;, options =\u0026gt; { options.Authority = Constants.Authority; // this maps to the API resource name and secret options.ClientId = \u0026#34;resource1\u0026#34;; options.ClientSecret = \u0026#34;secret\u0026#34;; }); Supporting both JWTs and reference tokens It is not uncommon to use the same API with both JWTs and reference tokens. In this case you setup two authentication handlers, make one the default handler and provide some forwarding logic, e.g.:\nservices.AddAuthentication(\u0026#34;token\u0026#34;) // JWT tokens .AddJwtBearer(\u0026#34;token\u0026#34;, options =\u0026gt; { options.Authority = Constants.Authority; options.Audience = \u0026#34;resource1\u0026#34;; options.TokenValidationParameters.ValidTypes = new[] { \u0026#34;at+jwt\u0026#34; }; // if token does not contain a dot, it is a reference token options.ForwardDefaultSelector = Selector.ForwardReferenceToken(\u0026#34;introspection\u0026#34;); }) // reference tokens .AddOAuth2Introspection(\u0026#34;introspection\u0026#34;, options =\u0026gt; { options.Authority = Constants.Authority; options.ClientId = \u0026#34;resource1\u0026#34;; options.ClientSecret = \u0026#34;secret\u0026#34;; }); The logic of the forward selector looks like this:\n/// \u0026lt;summary\u0026gt; /// Provides a forwarding func for JWT vs reference tokens (based on existence of dot in token) /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;introspectionScheme\u0026#34;\u0026gt;Scheme name of the introspection handler\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static Func\u0026lt;HttpContext, string\u0026gt; ForwardReferenceToken(string introspectionScheme = \u0026#34;introspection\u0026#34;) { string Select(HttpContext context) { var (scheme, credential) = GetSchemeAndCredential(context); if (scheme.Equals(\u0026#34;Bearer\u0026#34;, StringComparison.OrdinalIgnoreCase) \u0026amp;\u0026amp; !credential.Contains(\u0026#34;.\u0026#34;)) { return introspectionScheme; } return null; } return Select; } /// \u0026lt;summary\u0026gt; /// Extracts scheme and credential from Authorization header (if present) /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;context\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static (string, string) GetSchemeAndCredential(HttpContext context) { var header = context.Request.Headers[\u0026#34;Authorization\u0026#34;].FirstOrDefault(); if (string.IsNullOrEmpty(header)) { return (\u0026#34;\u0026#34;, \u0026#34;\u0026#34;); } var parts = header.Split(\u0026#39; \u0026#39;, StringSplitOptions.RemoveEmptyEntries); if (parts.Length != 2) { return (\u0026#34;\u0026#34;, \u0026#34;\u0026#34;); } return (parts[0], parts[1]); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/session/",
    "title": "Authentication &amp; Session Management",
    "tags": [],
    "description": "",
    "content": "Authentication \u0026amp; Session Management This section deals with setting up the following components\nthe ASP.NET Core authentication system the OpenID Connect handler the cookie handler the BFF session management endpoints server-side sessions back-channel logout support "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/fundamentals/resources/",
    "title": "Resources",
    "tags": [],
    "description": "Index",
    "content": "Resources The ultimate job of Duende IdentityServer is to control access to resources.\nIdentity Resources API Scopes API Resources Resource Isolation "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/ui/login/session/",
    "title": "Authentication Session",
    "tags": [],
    "description": "",
    "content": "Authentication Session Regardless of how the user proves their identity on the login page, an authentication session must be established. This authentication session is based on ASP.NET Core’s authentication system, and is tracked with a cookie managed by the cookie authentication handler.\nTo establish the session, ASP.NET Core provides a SignInAsync extension method on the HttpContext. This API accepts a ClaimsPrincipal which contains claims that describe the user. IdentityServer requires a special claim called sub whose value uniquely identifies the user. On your login page, this would be the code to establish the authentication session and issue the cookie:\nvar claims = new Claim[] { new Claim(\u0026#34;sub\u0026#34;, \u0026#34;unique_id_for_your_user\u0026#34;) }; var identity = new ClaimsIdentity(claims, \u0026#34;pwd\u0026#34;); var user = new ClaimsPrincipal(identity); await HttpContext.SignInAsync(user); The sub claim is the subject identifier and is the most important claim your IdentityServer will issue. It will uniquely identify the user and must never change and must never be reassigned to a different user. A GUID data type is a very common choice for the sub.\nAdditional claims can be added to the cookie if desired or needed at other UI pages. For example, it\u0026rsquo;s common to also issue a name claim which represents the user\u0026rsquo;s display name.\nThe claims issued in the cookie are passed as the Subject on the ProfileDataRequestContext in the profile service.\nWell Known Claims Issued From the Login Page There are some claims beyond sub that can be issued by your login page to capture additional information about the user\u0026rsquo;s authentication session. Internally Duende IdentityServer will set some of these values if you do not specify them when calling SignInAsync. The claims are:\nname: The display name of the user. amr: Name of the authentication method used for user authentication (defaults to pwd). auth_time: Time in epoch format the user entered their credentials (defaults to the current time). idp: Authentication scheme name of the external identity provider used for login. When not specified then the value defaults to local indicating that it was a local login. This is used to determine if a user must re-authenticate when clients make authorization requests using the acr_values with an idp value, or the client has IdentityProviderRestrictions. If the user’s idp does not match the request, then they should re-authenticate. tenant: Tenant identifier the user is associated with (if needed). This is used to determine if a user must re-authenticate when clients make authorization requests using the acr_values with a tenant value. If the user\u0026rsquo;s tenant does not match the request, then they should re-authenticate. While you can create the ClaimsPrincipal yourself, you can alternatively use IdentityServer extension methods and the IdentityServerUser class to make this easier:\nvar user = new IdentityServerUser(\u0026#34;unique_id_for_your_user\u0026#34;) { DisplayName = user.Username }; await HttpContext.SignInAsync(user); Cookie Handler Configuration Duende IdentityServer registers a cookie authentication handler by default for the authentication session. The scheme that the handler in the authentication system is identified by is from the constant IdentityServerConstants.DefaultCookieAuthenticationScheme.\nWhen configuring IdentityServer, the AuthenticationOptions expose some settings to control the cookie (e.g. expiration and sliding). For example:\npublic void ConfigureServices(IServiceCollection services) { services.AddIdentityServer(options =\u0026gt; { options.Authentication.CookieLifetime = TimeSpan.FromHours(1); options.Authentication.CookieSlidingExpiration = false; }); } In addition to the authentication cookie, IdentityServer will issue an additional cookie which defaults to the name idsrv.session. This cookie is derived from the main authentication cookie, and it used for the check session endpoint for browser-based JavaScript clients at signout time. It is kept in sync with the authentication cookie, and is removed when the user signs out.\nIf you require more control over the cookie authentication handler you can register your own cookie handler. You can then configure IdentityServer to use your cookie handler by setting the CookieAuthenticationScheme on the AuthenticationOptions. For example:\npublic void ConfigureServices(IServiceCollection services) { services.AddAuthentication() .AddCookie(\u0026#34;your_cookie\u0026#34;, options =\u0026gt; { // ... }); services.AddIdentityServer(options =\u0026gt; { options.Authentication.CookieAuthenticationScheme = \u0026#34;your_cookie\u0026#34;; }); } If the CookieAuthenticationScheme is not set, the DefaultAuthenticationScheme configured for ASP.NET Core will be used instead. Note that the AddAuthentication call that sets the default can come after the AddIdentityServer call. For example:\npublic void ConfigureServices(IServiceCollection services) { // No cookie authentication scheme is set here. // Identity Server will use the default scheme from ASP.NET Core, // even though it is not yet defined. services.AddIdentityServer(); // Default scheme is registered. IdentityServer will use this scheme. services.AddAuthentication(defaultScheme: \u0026#34;your_cookie\u0026#34;) .AddCookie(\u0026#34;your_cookie\u0026#34;, options =\u0026gt; { // ... }); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/configuration/dcr/authorization/",
    "title": "Authorization",
    "tags": [],
    "description": "",
    "content": "You should consider your requirements and design authentication and authorization policy for the Configuration API, if required. The specifications that define DCR envision both open registration, where authentication and authorization are absent and all client software can register with the authorization server, and protected registration, where an initial access token is required in order to register.\nThe Configuration API creates standard ASP.NET endpoints that can be protected through traditional ASP.NET authorization. Alternatively, the dynamic client registration software_statement parameter can be used to authenticate requests.\nTraditional ASP.NET Authorization You can authorize access to the Configuration API Endpoints using authorization policies just like any other endpoint created in an ASP.NET Web application. That authorization policy can use any criteria that an authorization policy might enforce, such as checking for particular claims or scopes.\nOne possibility is to authenticate the provisioning system, that is, the system making the DCR call, using OAuth. The resulting access token could include a scope that grants access to the Configuration API.\nFor example, you might protect the Configuration APIs with a JWT-bearer authentication scheme and an authorization policy that requires a particular scope to be present in the JWTs. You could choose any name for the scope that gives access to the Configuration APIs. Let\u0026rsquo;s use the name \u0026ldquo;IdentityServer.Configuration\u0026rdquo; for this example. You would then define the \u0026ldquo;IdentityServer.Configuration\u0026rdquo; scope as an ApiScope in your IdentityServer and allow the appropriate clients to access it. An automated process running in a CI pipeline could be configured as an OAuth client that uses the client credentials flow and is allowed to request the \u0026ldquo;IdentityServer.Configuration\u0026rdquo; scope. It could obtain a token using its client id and secret and then present that token when it calls the Configuration API. You might also have an interactive web application with a user interface that makes calls to the Configuration API. Again, you would define the application as an OAuth client allowed to request the appropriate scope, but this time, you\u0026rsquo;d use the authorization code flow.\nSoftware Statement The metadata within requests to the Configuration API can be bundled together into a JWT and sent in the software_statement parameter. If you can establish a trust relationship between the Configuration API and the issuer of the software statement, then that can be used to decide if you want to accept registration requests.\nIn order to use a software statement in this way, you would need to design the specific semantics of your software statements, how you will issue them, how you will create the necessary trust relationship between the issuer and your Configuration API, and how the Configuration API will validate the software statements. The configuration API doesn\u0026rsquo;t make any assumptions about that design. By default it does nothing with the software_statement parameter; to make use of it, customize the DynamicClientRegistrationValidator.ValidateSoftwareStatementAsync extension point.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/configuration/dcr/calling-registration/",
    "title": "Calling the Registration Endpoint",
    "tags": [],
    "description": "",
    "content": "The registration endpoint is invoked by making an HTTP POST request to the /connect/dcr endpoint with a json payload containing metadata describing the desired client as described in RFC 7591 and OpenID Connect Dynamic Client Registration 1.0.\nThe supported metadata properties are listed in the reference section on the DynamicClientRegistrationRequest model. A mixture of standardized and IdentityServer-specific properties are supported. Most standardized properties that are applicable to the client credentials or code flow grants (the two grants we support) are supported. Where IdentityServer\u0026rsquo;s configuration model includes important properties that are not standardized, we have included those properties as extensions. For example, there are no standardized properties describing token lifetimes, so the dynamic client registration endpoint adds absolute_refresh_token_lifetime, access_token_lifetime, identity_token_lifetime, etc.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/efoptions/configuration/",
    "title": "Configuration Options",
    "tags": [],
    "description": "Entity Framework",
    "content": "Duende.IdentityServer.EntityFramework.Options.ConfigurationStoreOptions These options are configurable when using the Entity Framework Core for the configuration store:\nYou set the options at startup time in your AddConfigurationStore method:\nvar builder = services.AddIdentityServer() .AddConfigurationStore(options =\u0026gt; { // configure options here.. }) Pooling Settings that affect the DbContext pooling feature of Entity Framework Core.\nEnablePooling\nGets or set if EF DbContext pooling is enabled. Defaults to false.\nPoolSize\nGets or set the pool size to use when DbContext pooling is enabled. If not set, the EF default is used.\nSchema Settings that affect the database schema and table names.\nDefaultSchema\nGets or sets the default schema. Defaults to null.\nTableConfiguration settings for each individual table (schema and name) managed by this feature:\nIdentity Resource related tables:\nIdentityResource IdentityResourceClaim IdentityResourceProperty API Resource related tables:\nApiResource ApiResourceSecret ApiResourceScope ApiResourceClaim ApiResourceProperty Client related tables:\nClient ClientGrantType ClientRedirectUri ClientPostLogoutRedirectUri ClientScopes ClientSecret ClientClaim ClientIdPRestriction ClientCorsOrigin ClientProperty API Scope related tables:\nApiScope ApiScopeClaim ApiScopeProperty Identity provider related tables:\nIdentityProvider "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/validators/custom_token_request_validator/",
    "title": "Custom Token Request Validator",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Validation.ICustomTokenRequestValidator Allows running custom code as part of the token issuance pipeline at the token endpoint.\n/// \u0026lt;summary\u0026gt; /// Allows inserting custom validation logic into token requests /// \u0026lt;/summary\u0026gt; public interface ICustomTokenRequestValidator { /// \u0026lt;summary\u0026gt; /// Custom validation logic for a token request. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;context\u0026#34;\u0026gt;The context.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt; /// The validation result /// \u0026lt;/returns\u0026gt; Task ValidateAsync(CustomTokenRequestValidationContext context); } ValidateAsync\nThis method gets called during token request processing. The context gives you access to request and response parameters.\nYou can also change certain parameters on the validated request object, e.g. the token lifetime, token type, confirmation method and client claims.\nThe CustomResponse dictionary allows emitting additional response fields.\nTo fail the request, set the the IsError, the Error, and optionally the ErrorDescription properties on the Result object on the CustomTokenRequestValidationContext.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/tokens/pop/dpop/",
    "title": "DPoP",
    "tags": [],
    "description": "",
    "content": "Proof-of-possession using Demonstrating Proof-of-Possession at the Application Layer (DPoP) Added in 6.3.0.\nDPoP is a security measure that addresses token replay attacks by making it difficult for attackers to use stolen tokens. Support for DPoP is included in IdentityServer Enterprise Edition. DPoP specifies how to bind an asymmetric key stored within a JSON Web Key (JWK) to an access token. With this enabled your IdentityServer will embed the thumbprint of the public key JWK into the access token via the cnf claim, e.g.:\n{ // rest omitted \u0026#34;cnf\u0026#34;: { \u0026#34;jkt\u0026#34;: \u0026#34;JGSVlE73oKtQQI1dypYg8_JNat0xJjsQNyOI5oxaZf4\u0026#34; } } The client must then prove possession of the private key to call the APIs, and your APIs can validate the cnf claim by comparing it to the thumbprint of the client\u0026rsquo;s public key in the JWK.\nIf the access token would leak, it cannot be replayed without having access to the private key of the JWK the client controls.\nThe mechanism by which the client proves control of the private key (both when connecting to the token server and when calling an API) is by sending an additional JWT called a proof token on HTTP requests. This proof token is passed via the DPoP request header and contains the public portion of the JWK, and is signed by the corresponding private key.\nThe creation and management of this DPoP key is up to the policy of the client. For example is can be dynamically created when the client starts up, and can be periodically rotated. The main constraint is that it must be stored for as long as the client uses any access tokens (and possibly refresh tokens) that they are bound to.\nEnabling DPoP in IdentityServer DPoP is something a client can use dynamically with no configuration in IdentityServer, but you can configure it as required. This is a per-client setting in your IdentityServer. There are additional client as well as global DPoP settings to control the behavior.\nnew Client { ClientId = \u0026#34;dpop_client\u0026#34;, RequireDPoP = true, // ... } Enabling DPoP support in your client The easiest approach for supporting DPoP in your client is to use the DPoP support in the Duende.AccessTokenManagement library (docs available here). It provides DPoP client support for both client credentials and code flow style clients. DPoP is enabled by simply assigning the DPoPJsonWebKey on the client configuration.\nFor example, here\u0026rsquo;s how to configure a client credentials client:\nservices.AddClientCredentialsTokenManagement() .AddClient(\u0026#34;demo_dpop_client\u0026#34;, client =\u0026gt; { client.TokenEndpoint = \u0026#34;https://demo.duendesoftware.com/connect/token\u0026#34;; client.DPoPJsonWebKey = \u0026#34;...\u0026#34;; // ... }); And here\u0026rsquo;s how to configure a code flow client:\nservices.AddAuthentication(...) .AddCookie(\u0026#34;cookie\u0026#34;, ...) .AddOpenIdConnect(\u0026#34;oidc\u0026#34;, ...); services.AddOpenIdConnectAccessTokenManagement(options =\u0026gt; { options.DPoPJsonWebKey = \u0026#34;...\u0026#34;; }); In either case, you will need to create a JWK. One approach to creating a JWK in string format is to use the .NET crypto APIs, for example:\nvar rsaKey = new RsaSecurityKey(RSA.Create(2048)); var jsonWebKey = JsonWebKeyConverter.ConvertFromSecurityKey(rsaKey); jsonWebKey.Alg = \u0026#34;PS256\u0026#34;; string jwk = JsonSerializer.Serialize(jsonWebKey); Once your client configuration has a DPoPJsonWebKey, then any protocol requests to obtain access tokens from the token server will automatically include a DPoP proof token created from the DPoPJsonWebKey. Furthermore, any API invocations using the AddClientCredentialsHttpClient or AddUserAccessTokenHttpClient helpers will also automatically include a DPoP proof token. The implication is that the DPoPJsonWebKey is a critical secret that must be carefully managed, because any tokens requested with this secret will be bound to it; if the secret is lost, the tokens can longer be used, and if the secret is leaked, the security benefits of DPoP are lost.\nEnabling DPoP support in your API See here for documentation describing how to enable DPoP in your APIs.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/ui/logout/session_cleanup/",
    "title": "Ending the Session",
    "tags": [],
    "description": "",
    "content": "Removing the Authentication Cookie To remove the authentication cookie, simply use the ASP.NET Core SignOutAsync extension method on the HttpContext. You will need to pass the scheme used (which is provided by IdentityServerConstants.DefaultCookieAuthenticationScheme unless you have changed it):\nawait HttpContext.SignOutAsync(IdentityServerConstants.DefaultCookieAuthenticationScheme); Or you can use the overload that will simply sign-out of the default authentication scheme:\nawait HttpContext.SignOutAsync(); If you are integrating with ASP.NET Identity, sign out using its SignInManager instead:\nawait _signInManager.SignOutAsync(); Prompting the User to Logout Typically you should prompt the user to logout which requires a POST to remove the cookie. Otherwise an attacker could hotlink to your logout page causing the user to be automatically logged out. This means you will need a page to prompt the user to logout.\nIf a logoutId is passed to the logout page and the returned LogoutRequest\u0026rsquo;s ShowSignoutPrompt is false then it is safe to skip the prompt. This would occur when the logout page is requested due to a validated client initiated logout via the end session endpoint. Your logout page process can continue as if the user submitted the post back to logout, in essence calling SignOutAsync.\nExternal Logins If your user has signed in with an external login, then it\u0026rsquo;s likely that they should perform an external logout of the external provider as well.\nRevoking Client Tokens at Logout During a user\u0026rsquo;s session, long-lived tokens (e.g. refresh tokens) might have been created for client applications. If at logout time you would like to have those tokens revoked, then this can be done automatically by setting the CoordinateLifetimeWithUserSession property on the client configuration, or globally on the IdentityServer Authentication Options.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/quickstarts/js_clients/js_without_backend/",
    "title": "JavaScript applications without a backend",
    "tags": [],
    "description": "",
    "content": " We recommend you do the quickstarts in order. If you\u0026rsquo;d like to start here, begin from a copy of the reference implementation of Quickstart 3. Throughout this quickstart, paths are written relative to the base quickstart directory created in part 1, which is the root directory of the reference implementation. You will also need to install the IdentityServer templates.\nThis quickstart will show how to build a browser-based JavaScript client application without a backend. This means your application has no server-side code that can support the frontend application code, and thus all OpenID Connect/OAuth protocol interactions occur from the JavaScript code running in the browser. Also, invoking the API will be performed directly from the JavaScript in the browser.\nThis design adds complexity (and thus security concerns) to your application, so consider if the \u0026ldquo;BFF\u0026rdquo; pattern might be a better choice.\nIn this quickstart the user will login to IdentityServer, invoke an API with an access token issued by IdentityServer, and logout of IdentityServer. All of this will be driven from the JavaScript running in the browser.\nNew Project for the JavaScript client Create a new project for the JavaScript application. Beyond being able to serve your application\u0026rsquo;s html and javascript, there are no requirements on the backend. You could use anything from an empty ASP.NET Core application to a Node.js application. This quickstart will use an ASP.NET Core application.\nCreate a new ASP.NET Core web application and add it to the solution by running the following commands from the src directory:\ndotnet new web -n JavaScriptClient cd .. dotnet sln add ./src/JavaScriptClient/JavaScriptClient.csproj Modify hosting Modify the JavaScriptClient project to run on https://localhost:5003. Its Properties/launchSettings.json should look like this:\n{ \u0026#34;profiles\u0026#34;: { \u0026#34;JavaScriptClient\u0026#34;: { \u0026#34;commandName\u0026#34;: \u0026#34;Project\u0026#34;, \u0026#34;dotnetRunMessages\u0026#34;: true, \u0026#34;launchBrowser\u0026#34;: true, \u0026#34;applicationUrl\u0026#34;: \u0026#34;https://localhost:5003\u0026#34;, \u0026#34;environmentVariables\u0026#34;: { \u0026#34;ASPNETCORE_ENVIRONMENT\u0026#34;: \u0026#34;Development\u0026#34; } } } } Add the static file middleware Given that this project is designed to run client-side, all we need ASP.NET Core to do is to serve up the static HTML and JavaScript files that will make up our application. The static file middleware is designed to do this.\nRegister the static file middleware in src/JavaScriptClient/Program.cs. The entire file should look like this:\nvar builder = WebApplication.CreateBuilder(args); var app = builder.Build(); app.UseDefaultFiles(); app.UseStaticFiles(); app.Run(); This middleware will now serve up static files from the application\u0026rsquo;s src/JavaScriptClient/wwwroot directory. This is where we will put our HTML and JavaScript files. If that directory does not exist in your project, create it now.\nReference oidc-client In the prior web application quickstart, we used a .NET library to handle the OpenID Connect protocol. In this quickstart, we need a similar library in the JavaScriptClient project, except one that works in JavaScript and is designed to run in the browser. The oidc-client library is one such library. It is available via NPM, or as a direct download from github.\nNPM\nIf you want to use NPM to download oidc-client, then run these commands from the src/JavaScriptClient directory:\nnpm i oidc-client copy node_modules/oidc-client/dist/* wwwroot This downloads the latest oidc-client package locally, and then copies the relevant JavaScript files into src/JavaScriptClient/wwwroot so they can be served by your application.\nManual download\nIf you want to download the oidc-client JavaScript files manually, browse to the GitHub repository and download the JavaScript files. Once downloaded, copy them into src/JavaScriptClient/wwwroot so they can be served by your application.\nAdd your HTML and JavaScript files Next, add HTML and JavaScript files to the src/JavaScriptClient/wwwroot directory. You will need two HTML files and one JavaScript file (in addition to the oidc-client.js library). Add index.html, callback.html, and app.js to wwwroot.\nindex.html\nThis will be the main page in your application. It contains\nbuttons for the user to login, logout, and call the API a \u0026lt;pre\u0026gt; container used to show messages to the user \u0026lt;script\u0026gt; tags to include your two JavaScript files It should look like this:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=\u0026#34;login\u0026#34;\u0026gt;Login\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;api\u0026#34;\u0026gt;Call API\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;logout\u0026#34;\u0026gt;Logout\u0026lt;/button\u0026gt; \u0026lt;pre id=\u0026#34;results\u0026#34;\u0026gt;\u0026lt;/pre\u0026gt; \u0026lt;script src=\u0026#34;oidc-client.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;app.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; app.js\nThis will contain the main code for your application. First, add a helper function to display messages in the \u0026lt;pre\u0026gt;:\nfunction log() { document.getElementById(\u0026#34;results\u0026#34;).innerText = \u0026#34;\u0026#34;; Array.prototype.forEach.call(arguments, function (msg) { if (typeof msg !== \u0026#34;undefined\u0026#34;) { if (msg instanceof Error) { msg = \u0026#34;Error: \u0026#34; + msg.message; } else if (typeof msg !== \u0026#34;string\u0026#34;) { msg = JSON.stringify(msg, null, 2); } document.getElementById(\u0026#34;results\u0026#34;).innerText += msg + \u0026#34;\\r\\n\u0026#34;; } }); } Next, add code to register click event handlers to the three buttons:\ndocument.getElementById(\u0026#34;login\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, login, false); document.getElementById(\u0026#34;api\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, api, false); document.getElementById(\u0026#34;logout\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, logout, false); Next, you will set up the UserManager class from the oidc-client library to manage the OpenID Connect protocol. It requires similar configuration that was necessary in the WebClient (albeit with different values). Add this code to configure and instantiate the UserManager:\nvar config = { authority: \u0026#34;https://localhost:5001\u0026#34;, client_id: \u0026#34;js\u0026#34;, redirect_uri: \u0026#34;https://localhost:5003/callback.html\u0026#34;, response_type: \u0026#34;code\u0026#34;, scope: \u0026#34;openid profile api1\u0026#34;, post_logout_redirect_uri: \u0026#34;https://localhost:5003/index.html\u0026#34;, }; var mgr = new Oidc.UserManager(config); Next, use the UserManager.getUser function to determine if the user is logged into the JavaScript application. It uses a JavaScript Promise to return the results asynchronously. The returned User object has a profile property which contains the claims for the user. There\u0026rsquo;s also an event called UserSignedOut that can be handled to detect if the user signs out of the token server while the SPA application is being used (presumably in a different tab). Add this code to detect the user\u0026rsquo;s session status in the JavaScript application:\nmgr.events.addUserSignedOut(function () { log(\u0026#34;User signed out of IdentityServer\u0026#34;); }); mgr.getUser().then(function (user) { if (user) { log(\u0026#34;User logged in\u0026#34;, user.profile); } else { log(\u0026#34;User not logged in\u0026#34;); } }); Next, implement the login, api, and logout functions. The UserManager provides a signinRedirect to log the user in, and a signoutRedirect to log the user out. The User object that we obtained above also has an access_token property which can be used to authenticate to a web API. The access_token will be passed to the web API via the Authorization header with the Bearer scheme. Add this code to implement those three functions in your application:\nfunction login() { mgr.signinRedirect(); } function api() { mgr.getUser().then(function (user) { var url = \u0026#34;https://localhost:6001/identity\u0026#34;; var xhr = new XMLHttpRequest(); xhr.open(\u0026#34;GET\u0026#34;, url); xhr.onload = function () { log(xhr.status, JSON.parse(xhr.responseText)); }; xhr.setRequestHeader(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer \u0026#34; + user.access_token); xhr.send(); }); } function logout() { mgr.signoutRedirect(); } See the client credentials quickstart for information on how to create the remote API used in the code above.\ncallback.html\nThis HTML file is the designated redirect_uri page once the user has logged into IdentityServer. It will complete the OpenID Connect protocol sign-in handshake with IdentityServer. The code for this is all provided by the UserManager class we used earlier. Once the sign-in is complete, we can then redirect the user back to the main index.html page. Add this code to complete the signin process:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script src=\u0026#34;oidc-client.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; new Oidc.UserManager({response_mode:\u0026#34;query\u0026#34;}).signinRedirectCallback().then(function() { window.location = \u0026#34;index.html\u0026#34;; }).catch(function(e) { console.error(e); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Add a client registration to IdentityServer for the JavaScript client Now that the client application is ready to go, you need to define a configuration entry in IdentityServer for the new JavaScript client.\nIn the IdentityServer project locate the client configuration in src/IdentityServer/Config.cs. Add a new Client to the list for your new JavaScript application. It should have the configuration listed below:\n// JavaScript Client new Client { ClientId = \u0026#34;js\u0026#34;, ClientName = \u0026#34;JavaScript Client\u0026#34;, AllowedGrantTypes = GrantTypes.Code, RequireClientSecret = false, RedirectUris = { \u0026#34;https://localhost:5003/callback.html\u0026#34; }, PostLogoutRedirectUris = { \u0026#34;https://localhost:5003/index.html\u0026#34; }, AllowedCorsOrigins = { \u0026#34;https://localhost:5003\u0026#34; }, AllowedScopes = { IdentityServerConstants.StandardScopes.OpenId, IdentityServerConstants.StandardScopes.Profile, \u0026#34;api1\u0026#34; } } Allowing Ajax calls to the Web API with CORS One last bit of configuration that is necessary is to configure CORS in the API project. This will allow Ajax calls to be made from https://localhost:5003 to https://localhost:6001.\nConfigure CORS\nAdd the CORS services to the dependency injection system in src/Api/Program.cs:\nbuilder.Services.AddCors(options =\u0026gt; { // this defines a CORS policy called \u0026#34;default\u0026#34; options.AddPolicy(\u0026#34;default\u0026#34;, policy =\u0026gt; { policy.WithOrigins(\u0026#34;https://localhost:5003\u0026#34;) .AllowAnyHeader() .AllowAnyMethod(); }); }); Then add the CORS middleware to the pipeline in src/Api/Program.cs. It should come before the call to UseAuthentication.\napp.UseHttpsRedirection(); app.UseCors(\u0026#34;default\u0026#34;); app.UseAuthentication(); app.UseAuthorization(); Run the JavaScript application Now you should be able to run the JavaScript client application:\nClick the \u0026ldquo;Login\u0026rdquo; button to sign the user in. Once the user is returned back to the JavaScript application, you should see their profile information:\nAnd click the \u0026ldquo;API\u0026rdquo; button to invoke the web API:\nAnd finally click \u0026ldquo;Logout\u0026rdquo; to sign the user out.\nYou now have the start of a JavaScript client application that uses IdentityServer for sign-in, sign-out, and authenticating calls to web APIs.\nSome browsers limit cross-site interactions (especially in iframes). In Safari, Firefox, or Brave you will notice that some important features will not work such as silent token renewal and check session monitoring.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/data/operational/",
    "title": "Operational Data",
    "tags": [],
    "description": "",
    "content": "Operational Data For certain operations, IdentityServer needs a persistence store to keep dynamically created state. This data is collectively called operational data, and includes:\nGrants for authorization and device codes, reference and refresh tokens, and remembered user consent Keys managing dynamically created signing keys Server Side Sessions for storing authentication session data for interactive users server-side "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/apis/remote/",
    "title": "Remote APIs",
    "tags": [],
    "description": "",
    "content": "A Remote API is an API that is deployed separately from the BFF host. Remote APIs use access tokens to authenticate and authorize requests, but the frontend does not possess an access token to make requests to remote APIs directly. Instead, all access to remote APIs is proxied through the BFF, which authenticates the frontend using its authentication cookie, obtains the appropriate access token, and forwards the request to the Remote API with the token attached.\nThere are two different ways to set up Remote API proxying in Duende.BFF. This page describes the built-in simple HTTP forwarder. Alternatively, you can integrate Duende.BFF with Microsoft\u0026rsquo;s reverse proxy YARP, which allows for more complex reverse proxy features provided by YARP combined with the security and identity features of Duende.BFF.\nSimple HTTP forwarder Duende.BFF\u0026rsquo;s simple HTTP forwarder maps routes in the BFF to a remote API surface. It uses Microsoft YARP internally, but is much simpler to configure than YARP. The intent is to provide a developer-centric and simplified way to proxy requests from the BFF to remote APIs when more complex reverse proxy features are not needed.\nThese routes receive automatic anti-forgery protection and integrate with automatic token management.\nTo enable this feature, add a reference to the Duende.BFF.Yarp Nuget package, add the remote APIs service to DI, and call the MapRemoteBFFApiEndpoint method to create the mappings.\nAdd Remote API Service to DI services.AddBff() .AddRemoteApis(); Map Remote APIs This example routes a local /api/customers endpoint to a remote API, and forwards the user\u0026rsquo;s access token in the outgoing call:\napp.UseEndpoints(endpoints =\u0026gt; { endpoints.MapRemoteBffApiEndpoint( \u0026#34;/api/customers\u0026#34;, \u0026#34;https://remoteHost/customers\u0026#34;) .RequireAccessToken(TokenType.User); }); This example opens up the complete /customers API namespace to the frontend and thus to the outside world. Try to be as specific as possible when designing the forwarding paths.\nSecuring Remote APIs Remote APIs typically require access control and must be protected against threats such as CSRF (Cross-Site Request Forgery) attacks.\nTo provide access control, you can specify authorization policies on the mapped routes, and configure them with access token requirements.\nTo defend against CSRF attacks, you should use SameSite cookies to authenticate calls from the frontend to the BFF. As an additional layer of defense, APIs mapped with MapRemoteBffApiEndpoint are automatically protected with an anti-forgery header.\nSameSite cookies The SameSite cookie attribute is a feature of modern browsers that restricts cookies so that they are only sent to pages originating from the site where the cookie was originally issued. This prevents CSRF attacks, because cross site requests will no longer implicitly include the user\u0026rsquo;s credentials.\nThis is a good first layer of defense, but makes the assumption that you can trust all subdomains of your site. All subdomains within a registrable domain are considered the same site for purposes of SameSite cookies. Thus, if another application hosted on a subdomain within your site is infected with malware, it can make CSRF attacks against your application.\nAnti-forgery header For this reason, remote APIs automatically require an additional custom header on API endpoints. For example:\nGET /endpoint x-csrf: 1 The value of the header is not important, but its presence, combined with the cookie requirement, triggers a CORS preflight request for cross-origin calls. This effectively isolates the caller to the same origin as the backend, providing a robust security guarantee.\nRequire authorization The MapRemoteBffApiEndpoint method returns the appropriate type to integrate with the ASP.NET Core authorization system. You can attach authorization policies to remote endpoints using RequireAuthorization, just as you would for a standard ASP.NET core endpoint created with MapGet, and the authorization middleware will then enforce that policy before forwarding requests on that route to the remote endpoint.\nAccess token requirements Remote APIs sometimes allow anonymous access, but usually require an access token, and the type of access token (user or client) will vary as well. You can specify access token requirements via the RequireAccessToken extension method. Its TokenType parameter has three options:\nUser\nA valid user access token is required and will be forwarded to the remote API. A user access token is an access token obtained during an OIDC flow (or subsequent refresh), and is associated with a particular user. User tokens are obtained when the user initially logs in, and will be automatically refreshed using a refresh token when they expire.\nClient\nA valid client access token is required and will be forwarded to the remote API. A client access token is an access token obtained through the client credentials flow, and is associated with the client application, not any particular user. Client tokens can be obtained even if the user is not logged in.\nUserOrClient\nEither a valid user access token or a valid client access token (as fallback) is required and will be forwarded to the remote API.\nYou can also use the WithOptionalUserAccessToken extension method to specify that the API should be called with a user access token if one is available and anonymously if not.\nThese settings only specify the logic that is applied before the API call gets proxied. The remote APIs you are calling should always specify their own authorization and token requirements.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/configuration/dcr/reference/processing/",
    "title": "Request Processing",
    "tags": [],
    "description": "",
    "content": "IDynamicClientRegistrationRequestProcessor The IDynamicClientRegistrationValidator is the contract for the service that processes a dynamic client registration request. It contains a single ProcessAsync(\u0026hellip;) method.\nConceptually, the request processing step is responsible for setting properties on the Client model that are generated by the Configuration API itself. In contrast, the IDynamicClientRegistrationRequestProcessor is responsible for checking the validity of the metadata supplied in the registration request, and using that metadata to set properties of a Client model. The request processor is also responsible for passing the finished Client to the store\nMembers name description ProcessAsync(…) Processes a valid dynamic client registration request, setting properties of the client that are not specified in the request, and storing the new client in the IClientConfigurationStore. DynamicClientRegistrationRequestProcessor The DynamicClientRegistrationRequestProcessor is the default implementation of the IDynamicClientRegistrationRequestProcessor. If you need to customize some aspect of Dynamic Client Registration request processing, we recommend that you extend this class and override the appropriate virtual methods.\npublic class DynamicClientRegistrationRequestProcessor : IDynamicClientRegistrationRequestProcessor Request Processing Steps Each of these virtual methods represents one step of request processing. Each step is passed a DynamicClientRegistrationContext and returns a task that returns an IStepResult. The DynamicClientRegistrationContext includes the client model that will have its properties set, the DCR request, and other contextual information. The IStepResult either represents that the step succeeded or failed.\nname description virtual AddClientId Generates a client ID and adds it to the validatedRequest\u0026rsquo;s client model. virtual AddClientSecret Adds a client secret to a dynamic client registration request. Secret Generation The AddClientSecret method is responsible for adding the client\u0026rsquo;s secret and plaintext of that secret to the context\u0026rsquo;s Items dictionary for later use. If you want to customize secret generation more simply, you can override the GenerateSecret method, which only needs to return a tuple containing the secret and its plaintext.\nname description virtual GenerateSecret Generates a secret for a dynamic client registration request. "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/ui/server_side_sessions/session_expiration/",
    "title": "Session Expiration",
    "tags": [],
    "description": "",
    "content": "If a user abandons their session without triggering logout, the server-side session data will remain in the store by default. In order to clean up these expired records, there is an automatic cleanup mechanism that periodically scans for expired sessions. When these records are cleaned up, you can optionally notify the client that the session has ended via back-channel logout.\nExpiration Configuration The expiration configuration features can be configured with the server-side session options. It is enabled by default, but if you wish to disable it or change how often IdentityServer will check for expired sessions, you can.\nFor example:\npublic void ConfigureServices(IServiceCollection services) { services.AddIdentityServer(options =\u0026gt; { options.ServerSideSessions.RemoveExpiredSessionsFrequency = TimeSpan.FromSeconds(60); }) .AddServerSideSessions(); } Back-channel Logout When the session cleanup job removes expired records, it will by default also trigger back-channel logout notifications to client applications participating in the session. You can use this mechanism to create an inactivity timeout that applies across all your client applications.\nThe ServerSideSessions.ExpiredSessionsTriggerBackchannelLogout flag enables this behavior, and it is on by default.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/response_handling/token_response_generator/",
    "title": "Token Response Generator",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.ResponseHandling.ITokenResponseGenerator The ITokenResponseGenerator interface is the contract for the service that generates responses to valid requests to the token endpoint. The default implementation is the TokenResponseGenerator class. You can customize the behavior of the token endpoint by providing your own implementation of the ITokenResponseGenerator to the DI system.\nTo create a customized implementation of ITokenResponseGenerator, we recommend that you create a class that derives from the default implementation. Your custom implementation should override the appropriate virtual methods of the default implementation and add your custom behavior to those overrides, possibly calling the base methods first and then manipulating their results.\nITokenResponseGenerator The ITokenResponseGenerator contains a single method to process validated token requests and return token responses.\nProcessInteractionAsync\nReturns the TokenResponse based on the ValidatedTokenRequest.\nTokenResponseGenerator The default implementation of the ITokenResponseGenerator contains virtual methods that can be overridden to customize particular behavior for particular token requests.\nProcessAsync\nReturns the TokenResponse for any TokenRequestValidationResult.\nProcessClientCredentialsRequestAsync\nReturns the TokenResponse for a TokenRequestValidationResult from the client credentials flow.\nProcessPasswordRequestAsync\nReturns the TokenResponse for a TokenRequestValidationResult from the resource owner password flow.\nProcessAuthorizationCodeRequestAsync\nReturns the TokenResponse for a TokenRequestValidationResult from the authorization code flow.\nProcessRefreshTokenRequestAsync\nReturns the TokenResponse for a TokenRequestValidationResult from the refresh token flow.\nProcessDeviceCodeRequestAsync\nReturns the TokenResponse for a TokenRequestValidationResult from the device code flow.\nProcessCibaRequestAsync\nReturns the TokenResponse for a TokenRequestValidationResult from the CIBA flow.\nProcessExtensionGrantRequestAsync\nReturns the TokenResponse for a TokenRequestValidationResult from an extension grant.\nCreateAccessTokenAsync\nCreates an access token and optionally a refresh token.\nCreateIdTokenFromRefreshTokenRequestAsync\nCreates an ID token in a refresh token request.\nTokenResponse The TokenResponse class represents the data that will be included in the body of the response returned from the token endpoint. It contains properties for the various tokens that can be returned, the scope and expiration of the access token, and a mechanism for adding custom properties to the result. Omitting property values will cause the entire property to be absent from the response.\nIdentityToken\nThe identity token.\nAccessToken\nThe access token.\nRefreshToken\nThe refresh token.\nAccessTokenLifetime\nThe access token lifetime in seconds.\nScope\nThe scope.\nCustom\nA dictionary of strings to objects that will be serialized to json and added to the token response.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/samples/ui/",
    "title": "User Interaction",
    "tags": [],
    "description": "Samples",
    "content": "These samples illustrate customization of the interactive pages used in your IdentityServer.\nCustom Profile Service This sample shows how to create a custom profile service to control what claims are issued from your IdentityServer. The majority of the sample is captured in CustomProfileService.cs in the IdentityServer project.\nAlso, another part of the sample shows how to collect a custom claim during the login workflow when using an external login provider (this is done in the ExternalLogin/Callback.cshtml.cs processing logic). This claim value is then stored in the user\u0026rsquo;s session, and is then ultimately copied into the created tokens via the custom profile service logic.\nlink to source code\nStep Up This sample shows how to implement step up. The Demo consists of 3 projects:\nIdentityServerHost is a token server implemented with Duende IdentityServer. Api is a protected resource that uses the IdentityServerHost as its authority and can make Step-Up responses when requests don\u0026rsquo;t meet its authentication requirements. Client is a client application that uses IdentityServerHost to login and makes requests to the Api. To run the demo, start all three projects and navigate to the Client application at https://localhost:6001. From there, you can click on links to pages that will trigger step up in various ways. For example, you could\nClick on the secure page to trigger login. Authenticate with user alice, password alice. Note that alice does not require MFA to log in. Click on the MFA page to make an API request that requires MFA. This will trigger step up for Alice, who should be shown a fake MFA page at IdentityServer before returning to the Client application. Finally, click on the Recent Auth page to make an API request that requires an authentication in the past minute. The page will show the age of the authentication. It may be necessary to refresh the page after a minute has passed to trigger step up. From there, you can experiment with other interactions. You can go to the Recent Auth with MFA page that has both authentication requirements, or try the user bob, who always requires MFA.\nlink to source code\nSPA-style login page This sample shows an example of building the interactive pages (login, consent, logout, and error) as client-rendered (typical of SPAs), rather than server-rendered. Since there are many different SPA frameworks, the actual pages are coded using vanilla JavaScript.\nKey takeaways:\nhow to handle the necessary request parameters how to contact the backend of IdentityServer to implement the various workflows (login, logout, etc.) how to implement a backend to support the frontend pages link to source code\nDynamic providers The dynamic providers feature allows for loading OpenID Connect identity provider configuration dynamically from a store. This sample sets up a simple database with one dynamic OIDC provider.\nSome key points about the IdentityServer project in the sample:\nExecute the command \u0026ldquo;dotnet run /seed\u0026rdquo; to create and populate the Sqlite database. SeedData.cs has the code to populate the dynamic provider in the database. In the Account/Login/Index.cshtml.cs file, the code to build the UI to list the dynamic providers is in the BuildModelAsync helper. It uses the IIdentityProviderStore to query the dynamic provider database. link to source code\nAdding other protocol types to dynamic providers The dynamic providers feature allows for loading OpenID Connect identity provider configuration dynamically from a store. This sample shows how to extend the dynamic providers feature to support additional protocol types, and specifically WS-Federation.\nKey takeaways:\nhow to define a custom identity provider model how to map from the custom identity provider model to the protocol options how to register the custom protocol type with IdentityServer how to register the custom protocol type with IdentityServer how to use the existing provider store to persist custom provider model data link to source code\nUsing Sustainsys.Saml2 with dynamic providers The Sustainsys.Saml2 open source library adds Saml2 protocol support to Asp.Net Core. It can be used together with the Duende dynamic identity providers feature. The sample is minimalistic to show a simple Saml2 config and does not handle the complete set of Saml2 config options.\nlink to source code\nClient Initiated Backchannel Login (CIBA) This sample shows how a client can make CIBA login requests using Duende IdentityServer. To run the sample, the IdentityServer and API hosts should be started first. Next run the ConsoleCibaClient which will initiate the backchannel login request. The URL the user would receive to login and approve the request is being written out to the IdentityServer log (visible in the console window). Follow that URL, login as \u0026ldquo;alice\u0026rdquo;, and then approve the login request to allow the client to receive the results.\nlink to source code\nWindows Authentication with IIS Hosting This sample shows how to use Windows Authentication when hosting your IdentityServer behind IIS (or IIS Express). The salient piece to understand is a new LoginWithWindows action method in the AccountController from the quickstarts. Windows authentication is triggered, and once the result is determined the main authentication session cookie is created based on the WindowsIdentity results. Also, note there is some configuration in Startup with a call to Configure\u0026lt;IISOptions\u0026gt; (mainly to set AutomaticAuthentication to false).\nlink to source code\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/session/management/user/",
    "title": "BFF User Endpoint",
    "tags": [],
    "description": "",
    "content": "The /bff/user endpoint returns data about the currently logged-on user and the session. It is typically invoked at application startup to check if the user has authenticated, and if so, to get profile data about the user. It can also be used to periodically query if the session is still valid.\nOutput If there is no current session, the user endpoint returns a response indicating that the user is anonymous. By default, this is a 401 status code, but this can be configured.\nIf there is a current session, the user endpoint returns a JSON array containing the claims in the ASP.NET Core authentication session as well as several BFF specific claims. For example:\n[ { \u0026#34;type\u0026#34;: \u0026#34;sid\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;173E788068FFB728806501F4F46C52D6\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;sub\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;88421113\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;idp\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;local\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Bob Smith\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;bff:logout_url\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;/bff/logout?sid=173E788068FFB728806501F4F46C52D6\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;bff:session_expires_in\u0026#34;, \u0026#34;value\u0026#34;: 28799 }, { \u0026#34;type\u0026#34;: \u0026#34;bff:session_state\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;q-Hl1V9a7FCZE5o-vH9qpmyVKOaeVfMQBUJLrq-lDJU.013E58C33C7409C6011011B8291EF78A\u0026#34; } ] User Claims Since the user endpoint returns the claims that are in the ASP.NET Core session, anything that changes the session will be reflected in its output. You can customize the contents of the session via the OpenID Connect handler\u0026rsquo;s ClaimAction infrastructure, or by using claims transformation. For example, if you add a claim to the userinfo endpoint at IdentityServer that you would like to include in the /bff/user endpoint, you need to add a corresponding ClaimAction in the BFF\u0026rsquo;s OpenID Connect Handler to include the claim in the BFF\u0026rsquo;s session.\nManagement Claims In addition to the claims in the ASP.NET Core Session, Duende.BFF adds three additional claims:\nbff:session_expires_in\nThis is the number of seconds the current session will be valid for.\nbff:session_state\nThis is the session state value of the upstream OIDC provider that can be use for the JavaScript check_session mechanism (if provided).\nbff:logout_url\nThis is the URL to trigger logout. If the upstream provider includes a sid claim, the BFF logout endpoint requires this value as a query string parameter for CSRF protection. This behavior can be configured with the RequireLogoutSessionId in the options.\nTypical Usage To use the endpoint, make an http GET request to it from your frontend javascript code. For example, your application could use the fetch api to make requests to the user endpoint like this:\nvar req = new Request(\u0026#34;/bff/user\u0026#34;, { headers: new Headers({ \u0026#34;X-CSRF\u0026#34;: \u0026#34;1\u0026#34;, }), }); var resp = await fetch(req); if (resp.ok) { userClaims = await resp.json(); console.log(\u0026#34;user logged in\u0026#34;, userClaims); } else if (resp.status === 401) { console.log(\u0026#34;user not logged in\u0026#34;); } Cross-Site Request Forgery To protect against cross-site request forgery, you need to add a static header to the GET request. The header\u0026rsquo;s name and required value can be configured in the options.\nAnonymous Session Response Option The AnonymousSessionResponse option allows you to change the behavior of the user endpoint to return 200 instead of 401 when the user is anonymous. If AnonymousSessionResponse is set to AnonymousSessionResponse.Response200, then the endpoint\u0026rsquo;s response will set its status code to 200 and its payload will contain the literal null (the response body will be the characters \u0026rsquo;n\u0026rsquo;, \u0026lsquo;u\u0026rsquo;, \u0026rsquo;l\u0026rsquo;, \u0026rsquo;l\u0026rsquo; without quotes).\nCookie Sliding If your ASP.NET Core session cookie is configured to use a sliding expiration, you need to be able to query the session state without extending the session\u0026rsquo;s lifetime; a periodic check for user activity shouldn\u0026rsquo;t itself count as user activity. To prevent the call to the user endpoint from sliding the cookie, add the slide=false parameter to the request.\nvar req = new Request(\u0026#34;/bff/user?slide=false\u0026#34;, { headers: new Headers({ \u0026#34;X-CSRF\u0026#34;: \u0026#34;1\u0026#34;, }), }); The cookie sliding prevention feature requires either usage of server-side sessions or .NET 6 or higher (or both).\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/models/api_scope/",
    "title": "API Scope",
    "tags": [],
    "description": "Model Reference",
    "content": "Duende.IdentityServer.Models.ApiScope This class models an OAuth scope.\nEnabled\nIndicates if this resource is enabled and can be requested. Defaults to true.\nName\nThe unique name of the API. This value is used for authentication with introspection and will be added to the audience of the outgoing access token.\nDisplayName\nThis value can be used e.g. on the consent screen.\nDescription\nThis value can be used e.g. on the consent screen.\nUserClaims\nList of associated user claim types that should be included in the access token.\nDefining API scope in appsettings.json The AddInMemoryApiResource extension method also supports adding clients from the ASP.NET Core configuration file::\n\u0026#34;IdentityServer\u0026#34;: { \u0026#34;IssuerUri\u0026#34;: \u0026#34;urn:sso.company.com\u0026#34;, \u0026#34;ApiScopes\u0026#34;: [ { \u0026#34;Name\u0026#34;: \u0026#34;IdentityServerApi\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;resource1.scope1\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;resource2.scope1\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;scope3\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;shared.scope\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;transaction\u0026#34;, \u0026#34;DisplayName\u0026#34;: \u0026#34;Transaction\u0026#34;, \u0026#34;Description\u0026#34;: \u0026#34;A transaction\u0026#34; } ] } Then pass the configuration section to the AddInMemoryApiScopes method:\nbuilder.AddInMemoryApiScopes(configuration.GetSection(\u0026#34;IdentityServer:ApiScopes\u0026#34;)) "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/extensibility/management/silent-login-callback/",
    "title": "BFF Silent Login Callback Extensibility",
    "tags": [],
    "description": "",
    "content": "The BFF silent login callback endpoint can be customized by implementing the ISilentLoginCallbackService or by extending DefaultSilentLoginCallbackService, its default implementation.\nRequest Processing ProcessRequestAsync is the top level function called in the endpoint service and can be used to add arbitrary logic to the endpoint.\nFor example, you could take whatever actions you need before normal processing of the request like this:\npublic override Task ProcessRequestAsync(HttpContext context) { // Custom logic here return base.ProcessRequestAsync(context); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/session/management/logout/",
    "title": "BFF Logout Endpoint",
    "tags": [],
    "description": "",
    "content": "The /bff/logout endpoint signs out of the appropriate ASP.NET Core authentication schemes to both delete the BFF\u0026rsquo;s session cookie and to sign out from the remote identity provider. To use the logout endpoint, typically your javascript code will navigate away from your front end to the logout endpoint, similar to the login endpoint. However, unlike the login endpoint, the logout endpoint requires CSRF protection, otherwise an attacker could destroy sessions by making cross-site GET requests. The session id is used to provide this CSRF protection by requiring it as a query parameter to the logout endpoint (assuming that a session id was included during login). For convenience, the correct logout url is made available as a claim in the /bff/user endpoint, making typical logout usage look like this:\nvar logoutUrl = userClaims[\u0026#34;bff:logout_url\u0026#34;]; // assumes userClaims is the result of a call to /bff/user window.location = logoutUrl; Return Url After signout is complete, the logout endpoint will redirect back to your front end application. By default, this redirect goes to the root of the application. You can use a different URL instead by including a local URL as the returnUrl query parameter.\nvar logoutUrl = userClaims[\u0026#34;bff:logout_url\u0026#34;]; window.location = `${logoutUrl}\u0026amp;returnUrl=/logged-out`; Revocation of Refresh Tokens If the user has a refresh token, the logout endpoint can revoke it. This is enabled by default because revoking refresh tokens that will not be used any more is generally good practice. Normally any refresh tokens associated with the current session won\u0026rsquo;t be used after logout, as the session where they are stored is deleted as part of logout. However, you can disable this revocation with the RevokeRefreshTokenOnLogout option.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/models/api_resource/",
    "title": "API Resource",
    "tags": [],
    "description": "Model Reference",
    "content": "Duende.IdentityServer.Models.ApiResource This class models an API.\nEnabled\nIndicates if this resource is enabled and can be requested. Defaults to true.\nName\nThe unique name of the API. This value is used for authentication with introspection and will be added to the audience of the outgoing access token.\nDisplayName\nThis value can be used e.g. on the consent screen.\nDescription\nThis value can be used e.g. on the consent screen.\nRequireResourceIndicator\nIndicates if this API resource requires the resource indicator to request it, and expects access tokens issued to it will only ever contain this API resource as the audience.\nApiSecrets\nThe API secret is used for the introspection endpoint. The API can authenticate with introspection using the API name and secret.\nAllowedAccessTokenSigningAlgorithms\nList of allowed signing algorithms for access token. If empty, will use the server default signing algorithm.\nUserClaims\nList of associated user claim types that should be included in the access token.\nScopes\nList of API scope names. You need to create those using ApiScope.\nDefining API resources in appsettings.json The AddInMemoryApiResource extensions method also supports adding API resources from the ASP.NET Core configuration file::\n\u0026quot;IdentityServer\u0026quot;: { \u0026quot;IssuerUri\u0026quot;: \u0026quot;urn:sso.company.com\u0026quot;, \u0026quot;ApiResources\u0026quot;: [ { \u0026quot;Name\u0026quot;: \u0026quot;resource1\u0026quot;, \u0026quot;DisplayName\u0026quot;: \u0026quot;Resource #1\u0026quot;, \u0026quot;Scopes\u0026quot;: [ \u0026quot;resource1.scope1\u0026quot;, \u0026quot;shared.scope\u0026quot; ] }, { \u0026quot;Name\u0026quot;: \u0026quot;resource2\u0026quot;, \u0026quot;DisplayName\u0026quot;: \u0026quot;Resource #2\u0026quot;, \u0026quot;UserClaims\u0026quot;: [ \u0026quot;name\u0026quot;, \u0026quot;email\u0026quot; ], \u0026quot;Scopes\u0026quot;: [ \u0026quot;resource2.scope1\u0026quot;, \u0026quot;shared.scope\u0026quot; ] } ] } Then pass the configuration section to the AddInMemoryApiResource method:\nbuilder.AddInMemoryApiResources(configuration.GetSection(\u0026#34;IdentityServer:ApiResources\u0026#34;)) "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/fundamentals/resources/api_resources/",
    "title": "API Resources",
    "tags": [],
    "description": "Overview",
    "content": "When the API/resource surface gets larger, a flat list of scopes might become hard to manage.\nIn Duende IdentityServer, the ApiResource class allows for some additional organization as well as grouping and isolation of scopes as well as providing some common settings.\nLet\u0026rsquo;s use the following scope definition as an example:\npublic static IEnumerable\u0026lt;ApiScope\u0026gt; GetApiScopes() { return new List\u0026lt;ApiScope\u0026gt; { // invoice API specific scopes new ApiScope(name: \u0026#34;invoice.read\u0026#34;, displayName: \u0026#34;Reads your invoices.\u0026#34;), new ApiScope(name: \u0026#34;invoice.pay\u0026#34;, displayName: \u0026#34;Pays your invoices.\u0026#34;), // customer API specific scopes new ApiScope(name: \u0026#34;customer.read\u0026#34;, displayName: \u0026#34;Reads you customers information.\u0026#34;), new ApiScope(name: \u0026#34;customer.contact\u0026#34;, displayName: \u0026#34;Allows contacting one of your customers.\u0026#34;), // shared scopes new ApiScope(name: \u0026#34;manage\u0026#34;, displayName: \u0026#34;Provides administrative access.\u0026#34;) new ApiScope(name: \u0026#34;enumerate\u0026#34;, displayName: \u0026#34;Allows enumerating data.\u0026#34;) }; } With ApiResource you can now create two logical APIs and their corresponding scopes:\npublic static readonly IEnumerable\u0026lt;ApiResource\u0026gt; GetApiResources() { return new List\u0026lt;ApiResource\u0026gt; { new ApiResource(\u0026#34;invoice\u0026#34;, \u0026#34;Invoice API\u0026#34;) { Scopes = { \u0026#34;invoice.read\u0026#34;, \u0026#34;invoice.pay\u0026#34;, \u0026#34;manage\u0026#34;, \u0026#34;enumerate\u0026#34; } }, new ApiResource(\u0026#34;customer\u0026#34;, \u0026#34;Customer API\u0026#34;) { Scopes = { \u0026#34;customer.read\u0026#34;, \u0026#34;customer.contact\u0026#34;, \u0026#34;manage\u0026#34;, \u0026#34;enumerate\u0026#34; } } }; } Using the API resource grouping gives you the following additional features\nsupport for the JWT aud claim. The value(s) of the audience claim will be the name of the API resource(s) support for adding common user claims across all contained scopes support for introspection by assigning an API secret to the resource support for configuring the access token signing algorithm for the resource Let\u0026rsquo;s have a look at some example access tokens for the above resource configuration.\nClient requests: invoice.read and invoice.pay:\n{ \u0026#34;typ\u0026#34;: \u0026#34;at+jwt\u0026#34; }. { \u0026#34;client_id\u0026#34;: \u0026#34;client\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;aud\u0026#34;: \u0026#34;invoice\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;invoice.read invoice.pay\u0026#34; } Client requests: invoice.read and customer.read:\n{ \u0026#34;typ\u0026#34;: \u0026#34;at+jwt\u0026#34; }. { \u0026#34;client_id\u0026#34;: \u0026#34;client\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;aud\u0026#34;: [ \u0026#34;invoice\u0026#34;, \u0026#34;customer\u0026#34; ], \u0026#34;scope\u0026#34;: \u0026#34;invoice.read customer.read\u0026#34; } Client requests: manage:\n{ \u0026#34;typ\u0026#34;: \u0026#34;at+jwt\u0026#34; }. { \u0026#34;client_id\u0026#34;: \u0026#34;client\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;aud\u0026#34;: [ \u0026#34;invoice\u0026#34;, \u0026#34;customer\u0026#34; ], \u0026#34;scope\u0026#34;: \u0026#34;manage\u0026#34; } Adding user claims You can specify that an access token for an API resource (regardless of which scope is requested) should contain additional user claims.\nvar customerResource = new ApiResource(\u0026#34;customer\u0026#34;, \u0026#34;Customer API\u0026#34;) { Scopes = { \u0026#34;customer.read\u0026#34;, \u0026#34;customer.contact\u0026#34;, \u0026#34;manage\u0026#34;, \u0026#34;enumerate\u0026#34; }, // additional claims to put into access token UserClaims = { \u0026#34;department_id\u0026#34;, \u0026#34;sales_region\u0026#34; } } If a client now requested a scope belonging to the customer resource, the access token would contain the additional claims (if provided by your profile service).\n{ \u0026#34;typ\u0026#34;: \u0026#34;at+jwt\u0026#34; }. { \u0026#34;client_id\u0026#34;: \u0026#34;client\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;aud\u0026#34;: [ \u0026#34;invoice\u0026#34;, \u0026#34;customer\u0026#34; ], \u0026#34;scope\u0026#34;: \u0026#34;invoice.read customer.read\u0026#34;, \u0026#34;department_id\u0026#34;: 5, \u0026#34;sales_region\u0026#34;: \u0026#34;south\u0026#34; } Setting a signing algorithm Your APIs might have certain requirements for the cryptographic algorithm used to sign the access tokens for that resource. An example could be regulatory requirements, or that you are starting to migrate your system to higher security algorithms.\nThe following sample sets PS256 as the required signing algorithm for the invoices API:\nvar invoiceApi = new ApiResource(\u0026#34;invoice\u0026#34;, \u0026#34;Invoice API\u0026#34;) { Scopes = { \u0026#34;invoice.read\u0026#34;, \u0026#34;invoice.pay\u0026#34;, \u0026#34;manage\u0026#34;, \u0026#34;enumerate\u0026#34; }, AllowedAccessTokenSigningAlgorithms = { SecurityAlgorithms.RsaSsaPssSha256 } } Make sure that you have configured your IdentityServer for the required signing algorithm. See here for more details.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/apis/aspnetcore/authorization/",
    "title": "Authorization based on Scopes and other Claims",
    "tags": [],
    "description": "",
    "content": "The access token will include additional claims that can be used for authorization, e.g. the scope claim will reflect the scope the client requested (and was granted) during the token request.\nIn ASP.NET core, the contents of the JWT payload get transformed into claims and packaged up in a ClaimsPrincipal. So you can always write custom validation or authorization logic in C#:\npublic IActionResult Get() { var isAllowed = User.HasClaim(\u0026#34;scope\u0026#34;, \u0026#34;read\u0026#34;); // rest omitted } For better encapsulation and re-use, consider using the ASP.NET Core authorization policy feature.\nWith this approach, you would first turn the claim requirement(s) into a named policy:\npublic void ConfigureServices(IServiceCollection services) { services.AddAuthorization(options =\u0026gt; { options.AddPolicy(\u0026#34;read_access\u0026#34;, policy =\u0026gt; policy.RequireClaim(\u0026#34;scope\u0026#34;, \u0026#34;read\u0026#34;)); }); } ..and then enforce it, e.g. using the routing table:\napp.UseEndpoints(endpoints =\u0026gt; { endpoints.MapControllers().RequireAuthorization(\u0026#34;read_access\u0026#34;); }); \u0026hellip;or imperatively inside the controller:\npublic class DataController : ControllerBase { IAuthorizationService _authz; public DataController(IAuthorizationService authz) { _authz = authz; } public async Task\u0026lt;IActionResult\u0026gt; Get() { var allowed = _authz.CheckAccess(User, \u0026#34;read_access\u0026#34;); // rest omitted } } \u0026hellip; or declaratively:\npublic class DataController : ControllerBase { [Authorize(\u0026#34;read_access\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Get() { var allowed = authz.CheckAccess(User, \u0026#34;read_access\u0026#34;); // rest omitted } } Scope claim format Historically, Duende IdentityServer emitted the scope claims as an array in the JWT. This works very well with the .NET deserialization logic, which turns every array item into a separate claim of type scope.\nThe newer JWT Profile for OAuth spec mandates that the scope claim is a single space delimited string. You can switch the format by setting the EmitScopesAsSpaceDelimitedStringInJwt on the options. But this means that the code consuming access tokens might need to be adjusted. The following code can do a conversion to the multiple claims format that .NET prefers:\nnamespace IdentityModel.AspNetCore.AccessTokenValidation { /// \u0026lt;summary\u0026gt; /// Logic for normalizing scope claims to separate claim types /// \u0026lt;/summary\u0026gt; public static class ScopeConverter { /// \u0026lt;summary\u0026gt; /// Logic for normalizing scope claims to separate claim types /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;principal\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static ClaimsPrincipal NormalizeScopeClaims(this ClaimsPrincipal principal) { var identities = new List\u0026lt;ClaimsIdentity\u0026gt;(); foreach (var id in principal.Identities) { var identity = new ClaimsIdentity(id.AuthenticationType, id.NameClaimType, id.RoleClaimType); foreach (var claim in id.Claims) { if (claim.Type == \u0026#34;scope\u0026#34;) { if (claim.Value.Contains(\u0026#39; \u0026#39;)) { var scopes = claim.Value.Split(\u0026#39; \u0026#39;, StringSplitOptions.RemoveEmptyEntries); foreach (var scope in scopes) { identity.AddClaim(new Claim(\u0026#34;scope\u0026#34;, scope, claim.ValueType, claim.Issuer)); } } else { identity.AddClaim(claim); } } else { identity.AddClaim(claim); } } identities.Add(identity); } return new ClaimsPrincipal(identities); } } } The above code could then be called as an extension method or as part of claims transformation.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/fundamentals/clients/",
    "title": "Clients",
    "tags": [],
    "description": "Fundamentals",
    "content": "Clients represent applications that can request tokens from your IdentityServer.\nThe details vary, but you typically define the following common settings for a client:\na unique client ID a secret if needed the allowed interactions with the token service (called a grant type) a network location where identity and/or access token gets sent to (called a redirect URI) a list of scopes (aka resources) the client is allowed to access Defining a client for server to server communication In this scenario no interactive user is present - a service (i.e. the client) wants to communicate with an API (i.e. the resource that supports the scope):\npublic class Clients { public static IEnumerable\u0026lt;Client\u0026gt; Get() { return new List\u0026lt;Client\u0026gt; { new Client { ClientId = \u0026#34;service.client\u0026#34;, ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, AllowedGrantTypes = GrantTypes.ClientCredentials, AllowedScopes = { \u0026#34;api1\u0026#34;, \u0026#34;api2.read_only\u0026#34; } } }; } } Defining an interactive application for use authentication and delegated API access Interactive applications (e.g. web applications or native desktop/mobile) use the authorization code flow. This flow gives you the best security because the access tokens are transmitted via back-channel calls only (and gives you access to refresh tokens):\nvar interactiveClient = new Client { ClientId = \u0026#34;interactive\u0026#34;, AllowedGrantTypes = GrantTypes.Code, AllowOfflineAccess = true, ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, RedirectUris = { \u0026#34;http://localhost:21402/signin-oidc\u0026#34; }, PostLogoutRedirectUris = { \u0026#34;http://localhost:21402/\u0026#34; }, FrontChannelLogoutUri = \u0026#34;http://localhost:21402/signout-oidc\u0026#34;, AllowedScopes = { IdentityServerConstants.StandardScopes.OpenId, IdentityServerConstants.StandardScopes.Profile, IdentityServerConstants.StandardScopes.Email, \u0026#34;api1\u0026#34;, \u0026#34;api2.read_only\u0026#34; }, }; Defining clients in appsettings.json The AddInMemoryClients extensions method also supports adding clients from the ASP.NET Core configuration file. This allows you to define static clients directly from the appsettings.json file:\n\u0026#34;IdentityServer\u0026#34;: { \u0026#34;Clients\u0026#34;: [ { \u0026#34;Enabled\u0026#34;: true, \u0026#34;ClientId\u0026#34;: \u0026#34;local-dev\u0026#34;, \u0026#34;ClientName\u0026#34;: \u0026#34;Local Development\u0026#34;, \u0026#34;ClientSecrets\u0026#34;: [ { \u0026#34;Value\u0026#34;: \u0026#34;\u0026lt;Insert Sha256 hash of the secret encoded as Base64 string\u0026gt;\u0026#34; } ], \u0026#34;AllowedGrantTypes\u0026#34;: [ \u0026#34;client_credentials\u0026#34; ], \u0026#34;AllowedScopes\u0026#34;: [ \u0026#34;api1\u0026#34; ], } ] } Then pass the configuration section to the AddInMemoryClients method:\nAddInMemoryClients(configuration.GetSection(\u0026#34;IdentityServer:Clients\u0026#34;)) "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/endpoints/",
    "title": "Endpoints",
    "tags": [],
    "description": "",
    "content": "Endpoints Discovery Endpoint Authorize Endpoint Token Endpoint UserInfo Endpoint Introspection Endpoint Revocation Endpoint End Session Endpoint Device Authorization Endpoint Backchannel Authentication Endpoint "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/ui/error/",
    "title": "Error",
    "tags": [],
    "description": "",
    "content": "The error page is used to display to the end user that an error has ocurred during a request to the authorize endpoint.\nWhen an error occurs, IdentityServer will redirect the user to a configurable ErrorUrl.\nbuilder.Services.AddIdentityServer(opt =\u0026gt; { opt.UserInteraction.ErrorUrl = \u0026#34;/path/to/error\u0026#34;; }) The default ErrorUrl is \u0026ldquo;/home/error\u0026rdquo;. The quickstart UI includes a basic implementation of an error page at that route.\nErrors are commonly due to misconfiguration, and there\u0026rsquo;s not much an end user can do about that. But this allows the user to understand that something went wrong and that they are not in the middle of a successful workflow.\nError Context Details of the error are provided to the error page via a query string parameter. That parameter\u0026rsquo;s name is configurable using the ErrorId option.\nbuilder.Services.AddIdentityServer(opt =\u0026gt; { opt.UserInteraction.ErrorId = \u0026#34;ErrorQueryStringParamName\u0026#34;; }) By default, the ErrorId is simply the string \u0026ldquo;errorId\u0026rdquo;.\nThe interaction service provides a GetErrorContextAsync API that will load error details for an ErrorId. The returned ErrorMessage object contains these details.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/deployment/data_stores/",
    "title": "IdentityServer Data Stores",
    "tags": [],
    "description": "Deployment",
    "content": "IdentityServer itself is stateless and does not require server affinity - but there is data that needs to be shared between in multi-instance deployments.\nConfiguration data This typically includes:\nresources clients startup configuration, e.g. key material, external provider settings etc… The way you store that data depends on your environment. In situations where configuration data rarely changes we recommend using the in-memory stores and code or configuration files. In highly dynamic environments (e.g. Saas) we recommend using a database or configuration service to load configuration dynamically.\nOperational data For certain operations, IdentityServer needs a persistence store to keep state, this includes:\nissuing authorization codes issuing reference and refresh tokens storing consent automatic management for signing keys You can either use a traditional database for storing operational data, or use a cache with persistence features like Redis.\nDuende IdentityServer includes storage implementations for above data using EntityFramework, and you can build your own. See the data stores section for more information.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/tokens/password_grant/",
    "title": "Issuing Tokens based on User Passwords",
    "tags": [],
    "description": "",
    "content": "The password grant type is an OAuth 2.0 protocol flow for authenticating end-users at the token endpoint. It is designed for legacy applications, and it is generally recommended to use a browser-based flow instead - but in certain situation it is not feasible to change existing applications.\nThe password grant type is deprecated per OAuth 2.1.\nRequesting a token using Password grant First you need to add the GrantType.Password to the AllowedGrantTypes list of the client you want to use.\nThen your client application would provide some means for the end-user to enter their credentials and post them to the token endpoint:\nPOST /token HTTP/1.1 Host: demo.duendesoftware.com Content-Type: application/x-www-form-urlencoded client_id=client\u0026amp; client_secret=secret\u0026amp; grant_type=password\u0026amp; username=bob\u0026amp; password=password .NET client library On .NET you can use the IdentityModel client library to request tokens using the password grant type, e.g.:\nusing IdentityModel.Client; var client = new HttpClient(); var response = await client.RequestPasswordTokenAsync(new PasswordTokenRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/token\u0026#34;, ClientId = \u0026#34;client\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Scope = \u0026#34;api1\u0026#34;, UserName = \u0026#34;bob\u0026#34;, Password = \u0026#34;password\u0026#34; }); Validating the token request Since this flow is not generally recommended, no standard implementation for validating the token request and user credentials is included. To add support for it you need to to implement and register an implementation of the IResourceOwnerPasswordValidator interface::\npublic interface IResourceOwnerPasswordValidator { /// \u0026lt;summary\u0026gt; /// Validates the resource owner password credential /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;context\u0026#34;\u0026gt;The context.\u0026lt;/param\u0026gt; Task ValidateAsync(ResourceOwnerPasswordValidationContext context); } The context contains parsed protocol parameters like UserName and Password as well as the raw request.\nIt is the job of the validator to implement the password validation and set the Result property on the context accordingly (see the Grant Validation Result reference).\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/diagnostics/otel/",
    "title": "OpenTelemetry",
    "tags": [],
    "description": "",
    "content": "(added in v6.1)\nOpenTelemetry is a collection of tools, APIs, and SDKs for generating and collecting telemetry data (metrics, logs, and traces). This is very useful for analyzing software performance and behavior - especially in highly distributed systems.\nNow that the tracing part of OTel is finalized, we started adding instrumentation to all relevant parts of IdentityServer - especially around input validators, response generators and stores.\nThe output is very useful for visualizing the control flow and finding performance bottlenecks.\nHere\u0026rsquo;s e.g. the output for a request to the discovery endpoint:\nWhen multiple applications send their traces to the same OTel server, this becomes super useful for following e.g. authentication flows over service boundaries.\nThe following screenshot shows the ASP.NET Core OpenID Connect authentication handler redeeming the authorization code:\n\u0026hellip;and then contacting the userinfo endpoint:\nThe above screenshots are from https://www.honeycomb.io.\nSetup To start emitting Otel tracing information you need\nadd the Otel libraries to your IdentityServer and client applications start collecting traces from the various IdentityServer sources (and other sources e.g. ASP.NET Core) builder.Services.AddOpenTelemetryTracing(builder =\u0026gt; { builder .AddSource(IdentityServerConstants.Tracing.Basic) .AddSource(IdentityServerConstants.Tracing.Cache) .AddSource(IdentityServerConstants.Tracing.Services) .AddSource(IdentityServerConstants.Tracing.Stores) .AddSource(IdentityServerConstants.Tracing.Validation) .SetResourceBuilder( ResourceBuilder.CreateDefault() .AddService(\u0026#34;MyIdentityServerHost\u0026#34;)) .AddHttpClientInstrumentation() .AddAspNetCoreInstrumentation() .AddSqlClientInstrumentation() .AddOtlpExporter(option =\u0026gt; { // wire up OTel server }); }); This sample uses the console exporter and can be used as a starting point.\nTracing sources IdentityServer can emit very fine grained traces which is useful for performance troubleshooting and general exploration of the control flow.\nThis might be too detailed in production.\nYou can select which information you are interested in by selectively listening to various traces:\nIdentityServerConstants.Tracing.Basic\nHigh level request processing like request validators and response generators\nIdentityServerConstants.Tracing.Cache\nCaching related tracing\nIdentityServerConstants.Tracing.Services\nServices related tracing\nIdentityServerConstants.Tracing.Stores\nStore related tracing\nIdentityServerConstants.Tracing.Validation\nMore detailed tracing related to validation\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/overview/specs/",
    "title": "Supported Specifications",
    "tags": [],
    "description": "",
    "content": "Duende IdentityServer implements the following specifications:\nOpenID Connect OpenID Connect Core 1.0 (spec) OpenID Connect Discovery 1.0 (spec) OpenID Connect RP-Initiated Logout 1.0 (spec) OpenID Connect Session Management 1.0 (spec) OpenID Connect Front-Channel Logout 1.0 (spec) OpenID Connect Back-Channel Logout 1.0 (spec) Multiple Response Types (spec) Form Post Response Mode (spec) Enterprise Edition: OpenID Connect Client-Initiated Backchannel Authentication (CIBA) (spec). OAuth 2.x OAuth 2.0 (RFC 6749) OAuth 2.0 Bearer Token Usage (RFC 6750) JSON Web Token (RFC 7519) OAuth 2.0 Token Revocation (RFC 7009) OAuth 2.0 Token Introspection (RFC 7662) Proof Key for Code Exchange by OAuth Public Clients (RFC 7636) OAuth 2.0 JSON Web Tokens for Client Authentication (RFC 7523) OAuth 2.0 Device Authorization Grant (RFC 8628) Proof-of-Possession Key Semantics for JSON Web Tokens (RFC 7800) OAuth 2.0 Mutual TLS Client Authentication and Certificate-Bound Access Tokens (RFC 8705) OAuth 2.0 Token Exchange (RFC 8693) JWT Secured Authorization Request / JAR (RFC 9101) JWT Profile for OAuth 2.0 Access Tokens (RFC 9068) OAuth 2.0 Authorization Server Issuer Identifier in Authorization Response (RFC 9207) OAuth 2.0 Step-up Authentication Challenge Protocol (RFC pending) Business Edition: OAuth 2.0 Dynamic Client Registration Protocol (RFC 7591) Business Edition: OAuth 2.0 Pushed Authorization Requests (RFC 9126) Enterprise Edition: Resource Indicators for OAuth 2.0 (RFC 8707) Enterprise Edition: OAuth 2.0 Demonstrating Proof-of-Possession at the Application Layer / DPoP (RFC 9449) "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/tokens/authentication/mtls/",
    "title": "TLS Client Certificates",
    "tags": [],
    "description": "",
    "content": "Clients can use an X.509 client certificate as an authentication mechanism to endpoints in your IdentityServer.\nFor this you need to associate a client certificate with a client in your IdentityServer and enable MTLS support on the options.\nvar builder = service.AddIdentityServer(options =\u0026gt; { options.MutualTls.Enabled = true; }) Use the DI extensions methods to add the services to DI which contain a default implementation to do that either thumbprint or common-name based:\nbuilder.AddMutualTlsSecretValidators(); Then add client secret of type SecretTypes.X509CertificateName (for PKI-based scenarios) or SecretTypes.X509CertificateThumbprint (for self-issued certificates) to the client you want to authenticate.\nFor example::\nnew Client { ClientId = \u0026#34;mtls.client\u0026#34;, AllowedGrantTypes = GrantTypes.ClientCredentials, AllowedScopes = { \u0026#34;api1\u0026#34; }, ClientSecrets = { // name based new Secret(@\u0026#34;CN=client, OU=production, O=company\u0026#34;, \u0026#34;client.dn\u0026#34;) { Type = SecretTypes.X509CertificateName }, // or thumbprint based new Secret(\u0026#34;bca0d040847f843c5ee0fa6eb494837470155868\u0026#34;, \u0026#34;mtls.tb\u0026#34;) { Type = SecretTypes.X509CertificateThumbprint }, } } .NET client library When writing a client to connect to IdentityServer, the SocketsHttpHandler (or HttpClientHandler depending on your .NET version) class provides a convenient mechanism to add a client certificate to outgoing requests.\nUse such a handler with HttpClient to perform the client certificate authentication handshake at the TLS channel. The following snippet is using IdentityModel to read the discovery document and request a token:\nstatic async Task\u0026lt;TokenResponse\u0026gt; RequestTokenAsync() { var handler = new SocketsHttpHandler(); var cert = new X509Certificate2(\u0026#34;client.p12\u0026#34;, \u0026#34;password\u0026#34;); handler.SslOptions.ClientCertificates = new X509CertificateCollection { cert }; var client = new HttpClient(handler); var disco = await client.GetDiscoveryDocumentAsync(Constants.Authority); if (disco.IsError) throw new Exception(disco.Error); var response = await client.RequestClientCredentialsTokenAsync(new ClientCredentialsTokenRequest { Address = disco.MtlEndpointAliases.TokenEndpoint ClientId = \u0026#34;mtls.client\u0026#34;, Scope = \u0026#34;api1\u0026#34; }); if (response.IsError) throw new Exception(response.Error); return response; } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/extensibility/tokens/",
    "title": "Token Management",
    "tags": [],
    "description": "BFF - Customization",
    "content": "The token management library does essentially two things:\nstores access and refresh tokens in the current session refreshes access tokens automatically at the token service when needed Both aspects can be customized.\nToken service communication The token management library uses a named HTTP client from the HTTP client factory for all token service communication. You can provide a customized HTTP client yourself using the well-known name after calling AddBff:\nservices.AddHttpClient(AccessTokenManagementDefaults.BackChannelHttpClientName, configureClient =\u0026gt; { ... }); You can also supply client assertions to the token management library. See this sample for JWT-based client authentication.\nCustom token storage We recommend that you use the default storage mechanism, as this will automatically be compatible with the Duende.BFF server-side sessions.\nIf you do not use server-side sessions, then the access and refresh token will be stored in the protected session cookie. If you want to change this, you can take over token storage completely.\nThis would involve two steps\nturn off the SaveTokens flag on the OpenID Connect handler and handle the relevant events manually to store the tokens in your custom store implement and register the Duende.AccessTokenManagement.IUserTokenStore interface The interface is responsible to storing, retrieving and clearing tokens for the automatic token management:\npublic interface IUserTokenStore { /// \u0026lt;summary\u0026gt; /// Stores tokens /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;user\u0026#34;\u0026gt;User the tokens belong to\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;token\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;parameters\u0026#34;\u0026gt;Extra optional parameters\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task StoreTokenAsync( ClaimsPrincipal user, UserToken token, UserTokenRequestParameters? parameters = null); /// \u0026lt;summary\u0026gt; /// Retrieves tokens from store /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;user\u0026#34;\u0026gt;User the tokens belong to\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;parameters\u0026#34;\u0026gt;Extra optional parameters\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;access and refresh token and access token expiration\u0026lt;/returns\u0026gt; Task\u0026lt;UserToken\u0026gt; GetTokenAsync( ClaimsPrincipal user, UserTokenRequestParameters? parameters = null); /// \u0026lt;summary\u0026gt; /// Clears the stored tokens for a given user /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;user\u0026#34;\u0026gt;User the tokens belong to\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;parameters\u0026#34;\u0026gt;Extra optional parameters\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task ClearTokenAsync( ClaimsPrincipal user, UserTokenRequestParameters? parameters = null); } Per-route customized token retrieval The token store defines how tokens are retrieved globally. However, you can add custom logic that changes the way that access tokens are retrieved on a per-route basis. For example, you might need to exchange a token to perform delegation or impersonation for some API calls, depending on the remote API. The interface that describes this extension point is the IAccessTokenRetriever.\n/// \u0026lt;summary\u0026gt; /// Retrieves access tokens /// \u0026lt;/summary\u0026gt; public interface IAccessTokenRetriever { /// \u0026lt;summary\u0026gt; /// Asynchronously gets the access token. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;context\u0026#34;\u0026gt;Context used to retrieve the token.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;A task that contains the access token result, which is an /// object model that can represent various types of tokens (bearer, dpop), /// the absence of an optional token, or an error. \u0026lt;/returns\u0026gt; Task\u0026lt;AccessTokenResult\u0026gt; GetAccessToken(AccessTokenRetrievalContext context); } You can implement this interface yourself or extend the DefaultAccessTokenRetriever. The AccessTokenResult class represents the result of this operation. It is an abstract class with concrete implementations that represent successfully retrieving a bearer token (BearerTokenResult), successfully retrieving a DPoP token (DPoPTokenResult), failing to find an optional token (NoAccessTokenResult), which is not an error, and failure to retrieve a token (AccessTokenRetrievalError). Your implementation of GetAccessToken should return one of those types.\nImplementations of the IAccessTokenRetriever can be added to endpoints when they are mapped using the WithAccessTokenRetriever extension method:\nendpoints.MapRemoteBffApiEndpoint(\u0026#34;/api/impersonation\u0026#34;, \u0026#34;https://api.example.com/endpoint/requiring/impersonation\u0026#34;) .RequireAccessToken(TokenType.User) .WithAccessTokenRetriever\u0026lt;ImpersonationAccessTokenRetriever\u0026gt;(); The GetAccessToken method will be invoked on every call to APIs that use the access token retriever. If retrieving the token is an expensive operation, you may need to cache it. It is up to your retriever code to perform caching.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/quickstarts/",
    "title": "Quickstarts",
    "tags": [],
    "description": "",
    "content": "Quickstarts The following hands-on tutorials guide you through a couple of common scenarios.\nOverview Protecting an API using Client Credentials Interactive Applications with ASP.NET Core ASP.NET Core and API access Using EntityFramework Core for configuration and operational data Using ASP.NET Core Identity Building JavaScript client applications Building Blazor WASM client applications "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/samples/aspid/",
    "title": "ASP.NET Identity Integration",
    "tags": [],
    "description": "Sample",
    "content": "link to source code\nThis sample shows using ASP.NET Identity with Duende IdentityServer. The intent was to show the least amount of code needed to get a working sample that used Microsoft\u0026rsquo;s ASP.NET Identity user management library.\nThe first step in creating the sample was to create a new project that used the ASP.NET Identity templates from Visual Studio (\u0026ldquo;Individual Accounts\u0026rdquo; for the authentication type). This provides all of the \u0026ldquo;out of the box\u0026rdquo; features from ASP.NET Identity for user management with only minor modifications, which are described below.\nThen Duende IdentityServer was added to add OIDC/OAuth2 capabilities to the application. Only the minimal configuration was done to get Duende IdentityServer functional for this sample.\nFinally another project was added which acts as a OIDC client application to exercise the OIDC login (and logout) capabilities.\nThe changes to the template in the ASP.NET Identity project (i.e. \u0026ldquo;IdentityServerAspNetIdentity\u0026rdquo;):\nSqlite support was added, replacing the default of SqlServer. Duende IdentityServer was configured in Startup.cs with the necessary information about the client application, and the OIDC scopes it would be requesting. Debug level logging was enabled for the \u0026ldquo;Duende\u0026rdquo; prefix to allow viewing the logging emitted during request processing. In the middleware pipeline, UseIdentityServer replaced UseAuthentication. The logout page was scaffolded to allow modification (located in Areas/Identity/Pages/Account/Logout.cshtml). The default logout page from the template is unaware of OIDC single signout, so this feature was added. In the client application:\nA simple ASP.NET Core Razor Web Application was used as the starting point. In Startup.cs the standard cookie and OIDC authentication configuration was added. A secure page (Secure.cshtml) that required an authenticated user will render the logged in user\u0026rsquo;s claim in the page. The index page (Index.cshtml) was modified to allow a POST to trigger OIDC logout. A logout button was added to trigger the POST. "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/validators/ciba_user_validator/",
    "title": "Backchannel Authentication User Validator",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Validation.IBackchannelAuthenticationUserValidator The IBackchannelAuthenticationUserValidator interface is used to validate request hints and identify the user for whom the CIBA request is intended. To use CIBA, you are expected to implement this interface and register it in the DI system.\nIBackchannelAuthenticationUserValidator APIs ValidateRequestAsync\nValidates the backchannel login request with the provided BackchannelAuthenticationUserValidatorContext for the current request. Returns a BackchannelAuthenticationUserValidationResult object.\nBackchannelAuthenticationUserValidatorContext Models the information to validate and identity the user for a CIBA login request.\nClient\nThe Client making the request.\nLoginHintToken\nThe login hint request parameter from the request.\nIdTokenHint\nThe id token hint request parameter from the request.\nIdTokenHintClaims\nThe claims contained in the validated id token hint from the request.\nLoginHint\nThe login hint request parameter from the request.\nUserCode\nThe user code request parameter from the request.\nBindingMessage\nThe binding request parameter from the request.\nBackchannelAuthenticationUserValidationResult Models the result of a CIBA login request.\nSubject\nThe ClaimsPrincipal that represents the user that was successfully identified for the login request. This must contain the user\u0026rsquo;s \u0026ldquo;sub\u0026rdquo; claim.\nError\nThe error if the user validation failed.\nErrorDescription\nThe error description if the user validation failed.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/data/operational/grants/",
    "title": "Grants",
    "tags": [],
    "description": "",
    "content": "Many protocol flows produce state that represents a grant of one type or another. These include authorization and device codes, reference and refresh tokens, and remembered user consent.\nStores The persistence for grants is abstracted behind two interfaces:\nThe persisted grant store is a common store for most grants. The device flow store is a specialized store for device grants. Registering Custom Stores Custom implementations of IPersistedGrantStore, and/or IDeviceFlowStore must be registered in the DI system. For example:\npublic void ConfigureServices(IServiceCollection services) { services.AddIdentityServer(); services.AddTransient\u0026lt;IPersistedGrantStore, YourCustomPersistedGrantStore\u0026gt;(); services.AddTransient\u0026lt;IDeviceFlowStore, YourCustomDeviceFlowStore\u0026gt;(); } Grant Expiration and Consumption The presence of the record in the store without a ConsumedTime and while still within the Expiration represents the validity of the grant. Setting either of these two values, or removing the record from the store effectively revokes the grant.\nSome grant types are one-time use only (either by definition or configuration). Once they are \u0026ldquo;used\u0026rdquo;, rather than deleting the record, the ConsumedTime value is set in the database marking them as having been used. This \u0026ldquo;soft delete\u0026rdquo; allows for custom implementations to either have flexibility in allowing a grant to be re-used (typically within a short window of time), or to be used in risk assessment and threat mitigation scenarios (where suspicious activity is detected) to revoke access. For refresh tokens, this sort of custom logic would be performed in the IRefreshTokenService.\nGrant Data The Data property of the model contains the authoritative copy of the values in the store. This data is protected at rest using the ASP.NET Data Protection API. With the exception of ConsumedTime, The other properties of the model should be treated as read-only.\nPersisted Grant Service Working with the grants store directly might be too low level. As such, a higher level service called the IPersistedGrantService is provided. It abstracts and aggregates the different grant types into one concept, and allows querying and revoking the persisted grants for a user.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/ui/server_side_sessions/inactivity_timeout/",
    "title": "Inactivity Timeout",
    "tags": [],
    "description": "",
    "content": "A common requirement in several industries is the concept of a system-wide \u0026ldquo;inactivity timeout\u0026rdquo;. The expectation is that if a user is active in the system, then their authentication session should continue to be active. But if the user were to be inactive for some amount of time (e.g. after walking away from their computer), then this inactivity should cause the user to be logged out of the entire system.\nUnfortunately, the OpenID Connect protocol is primarily focused with signing users into applications, not distributed session management due to user inactivity. What makes this difficult to achieve is that there are many different artifacts from the protocol each with their own expiration (e.g. cookies, refresh tokens, and access tokens). Also, different entities in the system have control over the lifetime and renewal of these artifacts. Coordinating all of their expirations to become invalid at the same time is not trivial.\nDespite the protocol not providing a formal solution to this requirement, it is still possible to achieve this while using features of the protocols and not resorting to the use of custom, out-of-band techniques.\nDesign To achieve the goal of distributed session management, there must be a single record tracking the user\u0026rsquo;s session. Using server-side sessions at IdentityServer provides this central location to monitor user activity and track session expiration.\nUser Activity Monitoring As a user is active interactively at IdentityServer, the session\u0026rsquo;s expiration will be extended given the normal cookie authentication handler mechanics of ASP.NET Core. Most of the time, though, a user is active at the client applications, not at IdentityServer. This makes it difficult for the session at IdentityServer to be extended.\nFortunately as a user uses a client application, it\u0026rsquo;s common for that client to make server to server protocol invocations back to IdentityServer on behalf of the user (e.g. with the refresh token). These invocations can be used as the signal to the server-side session management at IdentityServer that the user is still active, and thus can be used to extend the session.\nIn addition to refresh tokens, any client activity using an access token that originated from the user\u0026rsquo;s session could also be used to extend the user\u0026rsquo;s server-side session at IdentityServer. This would only work if IdentityServer were aware of this activity, but userinfo and introspection endpoint requests are examples of those types of activity.\nInternally IdentityServer provides a ISessionCoordinationService which is invoked from the endpoints describes above. Its purpose is to then extend the lifetime of the server-side session. Below is a picture of the various types of requests to do this:\nUser Inactivity Detection and Session Termination When the user becomes inactive, the server-side session management system at IdentityServer can detect and remove the abandoned session. When this happens, the ISessionCoordinationService provides another operation to perform any client related cleanup for the session. This could invoke back-channel logout for any client the user has logged into during their session, or this could revoke any grants in the operational store issued during the user\u0026rsquo;s session.\nClients that receive back-channel logout would know the user\u0026rsquo;s session has ended, and can cleanup appropriately. But if back-channel is not used, then the client would need some other signal to consider the user\u0026rsquo;s session has ended. The obvious signal would be if the refresh token request failed, then that would be an appropriate signal that the user\u0026rsquo;s session has also ended.\nGiven this understanding, client applications can participate in this convention and IdentityServer can coordinate to achieve this system-wide \u0026ldquo;inactivity timeout\u0026rdquo; requirement.\nConfiguration Configuration is needed in both IdentityServer and client applications.\nIdentityServer To prepare IdentityServer, these features need to be enabled:\nServer-side sessions need to be enabled. Either the global CoordinateClientLifetimesWithUserSession option should be enabled, or the client-specific CoordinateLifetimeWithUserSession option should be enabled. Enable back-channel logout for session expiration with the ExpiredSessionsTriggerBackchannelLogout option. Client Applications Depending on what protocol features the client is using, different approaches will need to be taken. The two main actions a client must take are to 1) notify IdentityServer of the user\u0026rsquo;s activity, and 2) detect user inactivity at IdentityServer and terminate the user\u0026rsquo;s session in the client.\nClients with Refresh Tokens As the client uses the refresh token at IdentityServer, the user\u0026rsquo;s session expiration will be extended. Be sure to configure the access token lifetime to be less than the server-side session lifetime at IdentityServer.\nTo detect inactivity:\nEither handle refresh token request failure, and consider the session ended. Or implement back-channel logout. Clients with Reference Access Tokens but without Refresh Tokens It\u0026rsquo;s possible a client is using a reference access token and no refresh token. The API would then use introspection to validate the token, which would then extend the associated user\u0026rsquo;s session at IdentityServer.\nTo detect inactivity:\nEither handle 401 errors from the API, and then consider the session ended. Or implement back-channel logout. Clients without Access Tokens Clients without access tokens have no way to notify IdentityServer that the user is still active. But they can implement back-channel logout to be notified that the user\u0026rsquo;s session has ended.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/ui/login/redirect/",
    "title": "Redirecting back to the client",
    "tags": [],
    "description": "",
    "content": "The Return URL and the Login Workflow Once the user has been logged in, they must complete the protocol workflow so they can ultimately be logged into the client. To facilitate this, the login page is passed a returnUrl query parameter which refers to the URL the prior request came from. This URL is, in essence, the same authorization endpoint to which the client made the original authorize request.\nIn the request to your login page where it logs the user in with a call to SignInAsync, it would then simply use the returnUrl to redirect the response back. This will cause the browser to re-issue the original authorize request from the client allowing your IdentityServer to complete the protocol work. An example of this redirect can be seen in the local login topic.\nBeware open-redirect attacks via the returnUrl parameter. You should validate that the returnUrl refers to a well-known location. Either use the Url.IsLocalUrl helper from ASP.NET Core, or use the interaction service from Duende IdentityServer for APIs to validate the returnUrl parameter.\nKeep in mind that this returnUrl is state that needs to be maintained during the user\u0026rsquo;s login workflow. If your workflow involves page post-backs, redirecting the user to an external login provider, or just sending the user through a custom workflow, then this value must be preserved across all of those page transitions.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/samples/tokens/",
    "title": "Requesting tokens",
    "tags": [],
    "description": "Samples",
    "content": "Extension grants and Token Exchange link to source code\nThis sample shows an implementation of the Token Exchange specification RFC 8693 via the Duende IdentityServer extension grant mechanism.\nSee here for more information on extension grants.\nPersonal Access Tokens (PAT) link to source code\nThis sample shows how to provide a self-service UI to create access tokens. This is a common approach to enable integrations with APIs without having to create full-blown OAuth clients.\nWhen combining PATs with the reference token feature, you also get automatic validation and revocation support. This is very similar to API keys, but does not require custom infrastructure. The sample also contains an API that accepts both JWT and reference tokens.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/configuration/dcr/reference/store/",
    "title": "Store",
    "tags": [],
    "description": "DCR Reference",
    "content": "IClientConfigurationStore The IClientConfigurationStore interface defines the contract for a service that communication with the client configuration data store. It contains a single AddAsync method.\npublic interface IClientConfigurationStore Members name description AddAsync(…) Adds a client to the configuration store. ClientConfigurationStore The ClientConfigurationStore is the default implementation of the IClientConfigurationStore. It uses Entity Framework to communicate with the client configuration store, and is intended to be used when IdentityServer is configured to use the Entity Framework based configuration stores.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/apis/yarp/",
    "title": "YARP extensions",
    "tags": [],
    "description": "",
    "content": "Duende.BFF integrates with Microsoft\u0026rsquo;s full-featured reverse proxy YARP.\nYARP includes many advanced features such as load balancing, service discovery, and session affinity. It also has its own extensibility mechanism. Duende.BFF includes YARP extensions for token management and anti-forgery protection so that you can combine the security and identity features of Duende.BFF with the flexible reverse proxy features of YARP.\nAdding YARP To enable Duende.BFF\u0026rsquo;s YARP integration, add a reference to the Duende.BFF.Yarp Nuget package to your project and add YARP and the BFF\u0026rsquo;s YARP extensions to DI:\nservices.AddBff(); // adds YARP with BFF extensions var builder = services.AddReverseProxy() .AddBffExtensions(); Configuring YARP YARP is most commonly configured by a config file. The following simple example forwards a local URL to a remote API:\n\u0026#34;ReverseProxy\u0026#34;: { \u0026#34;Routes\u0026#34;: { \u0026#34;todos\u0026#34;: { \u0026#34;ClusterId\u0026#34;: \u0026#34;cluster1\u0026#34;, \u0026#34;Match\u0026#34;: { \u0026#34;Path\u0026#34;: \u0026#34;/todos/{**catch-all}\u0026#34;, } } }, \u0026#34;Clusters\u0026#34;: { \u0026#34;cluster1\u0026#34;: { \u0026#34;Destinations\u0026#34;: { \u0026#34;destination1\u0026#34;: { \u0026#34;Address\u0026#34;: \u0026#34;https://api.mycompany.com/todos\u0026#34; } } } } } See the Microsoft documentation for the complete configuration schema.\nAnother option is to configure YARP in code using the in-memory config provider included in the BFF extensions for YARP. The above configuration as code would look like this:\nbuilder.LoadFromMemory( new[] { new RouteConfig() { RouteId = \u0026#34;todos\u0026#34;, ClusterId = \u0026#34;cluster1\u0026#34;, Match = new() { Path = \u0026#34;/todos/{**catch-all}\u0026#34; } } }, new[] { new ClusterConfig { ClusterId = \u0026#34;cluster1\u0026#34;, Destinations = new Dictionary\u0026lt;string, DestinationConfig\u0026gt;(StringComparer.OrdinalIgnoreCase) { { \u0026#34;destination1\u0026#34;, new() { Address = \u0026#34;https://api.mycompany.com/todos\u0026#34; } }, } } }); Token management Duende.BFF\u0026rsquo;s YARP extensions provide access token management and attach user or client access tokens automatically to proxied API calls. To enable this, add metadata with the name Duende.Bff.Yarp.TokenType to the route or cluster configuration:\n\u0026#34;ReverseProxy\u0026#34;: { \u0026#34;Routes\u0026#34;: { \u0026#34;todos\u0026#34;: { \u0026#34;ClusterId\u0026#34;: \u0026#34;cluster1\u0026#34;, \u0026#34;Match\u0026#34;: { \u0026#34;Path\u0026#34;: \u0026#34;/todos/{**catch-all}\u0026#34;, }, \u0026#34;Metadata\u0026#34;: { \u0026#34;Duende.Bff.Yarp.TokenType\u0026#34;: \u0026#34;User\u0026#34; } } }, // rest omitted } Similarly to the simple HTTP forwarder, the allowed values for the token type are User, Client, UserOrClient.\nRoutes that set the Duende.Bff.Yarp.TokenType metadata require the given type of access token. If it is unavailable (for example, if the User token type is specified but the request to the BFF is anonymous), then the proxied request will not be sent, and the BFF will return an HTTP 401: Unauthorized response.\nIf you are using the code config method, call the WithAccessToken extension method to achieve the same thing:\nbuilder.LoadFromMemory( new[] { new RouteConfig() { RouteId = \u0026#34;todos\u0026#34;, ClusterId = \u0026#34;cluster1\u0026#34;, Match = new RouteMatch { Path = \u0026#34;/todos/{**catch-all}\u0026#34; } }.WithAccessToken(TokenType.User) }, // rest omitted ); Again, the WithAccessToken method causes the route to require the given type of access token. If it is unavailable, the proxied request will not be made and the BFF will return an HTTP 401: Unauthorized response.\nOptional User Access Tokens You can also attach user access tokens optionally by adding metadata named \u0026ldquo;Duende.Bff.Yarp.OptionalUserToken\u0026rdquo; to a YARP route.\n\u0026#34;ReverseProxy\u0026#34;: { \u0026#34;Routes\u0026#34;: { \u0026#34;todos\u0026#34;: { \u0026#34;ClusterId\u0026#34;: \u0026#34;cluster1\u0026#34;, \u0026#34;Match\u0026#34;: { \u0026#34;Path\u0026#34;: \u0026#34;/todos/{**catch-all}\u0026#34;, }, \u0026#34;Metadata\u0026#34;: { \u0026#34;Duende.Bff.Yarp.OptionalUserToken\u0026#34;: \u0026#34;true\u0026#34; } } }, // rest omitted } This metadata causes the user\u0026rsquo;s access token to be sent with the proxied request when the user is logged in, but makes the request anonymously when the user is not logged in. It is an error to set both Duende.Bff.Yarp.TokenType and Duende.Bff.Yarp.OptionalUserToken, since they have conflicting semantics (TokenType requires the token, OptionalUserToken makes it optional).\nIf you are using the code config method, call the WithOptionalUserAccessToken extension method to achieve the same thing:\nbuilder.LoadFromMemory( new[] { new RouteConfig() { RouteId = \u0026#34;todos\u0026#34;, ClusterId = \u0026#34;cluster1\u0026#34;, Match = new RouteMatch { Path = \u0026#34;/todos/{**catch-all}\u0026#34; } }.WithOptionalUserAccessToken() }, // rest omitted ); Anti-forgery protection Duende.BFF\u0026rsquo;s YARP extensions can also add anti-forgery protection to proxied API calls. Anti-forgery protection defends against CSRF attacks by requiring a custom header on API endpoints, for example:\nGET /endpoint x-csrf: 1 The value of the header is not important, but its presence, combined with the cookie requirement, triggers a CORS preflight request for cross-origin calls. This effectively isolates the caller to the same origin as the backend, providing a robust security guarantee.\nYou can add the anti-forgery protection to all YARP routes by calling the AsBffApiEndpoint extension method:\nendpoints.MapReverseProxy() .AsBffApiEndpoint(); // or shorter endpoints.MapBffReverseProxy(); If you need more fine grained control over which routes should enforce the anti-forgery header, you can also annotate the route configuration by adding the Duende.Bff.Yarp.AntiforgeryCheck metadata to the route config:\n\u0026#34;ReverseProxy\u0026#34;: { \u0026#34;Routes\u0026#34;: { \u0026#34;todos\u0026#34;: { \u0026#34;ClusterId\u0026#34;: \u0026#34;cluster1\u0026#34;, \u0026#34;Match\u0026#34;: { \u0026#34;Path\u0026#34;: \u0026#34;/todos/{**catch-all}\u0026#34;, }, \u0026#34;Metadata\u0026#34;: { \u0026#34;Duende.Bff.Yarp.AntiforgeryCheck\u0026#34; : \u0026#34;true\u0026#34; } } }, // rest omitted } This is also possible in code:\nbuilder.LoadFromMemory( new[] { new RouteConfig() { RouteId = \u0026#34;todos\u0026#34;, ClusterId = \u0026#34;cluster1\u0026#34;, Match = new RouteMatch { Path = \u0026#34;/todos/{**catch-all}\u0026#34; } }.WithAntiforgeryCheck() }, // rest omitted ); You can combine the token management feature with the anti-forgery check.\nTo enforce the presence of the anti-forgery headers, you need to add a middleware to the YARP pipeline:\nendpoints.MapReverseProxy(proxyApp =\u0026gt; { proxyApp.UseAntiforgeryCheck(); }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/stores/resource_store/",
    "title": "Resource Store",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Stores.IResourceStore Used to dynamically load resource configuration.\n/// \u0026lt;summary\u0026gt; /// Resource retrieval /// \u0026lt;/summary\u0026gt; public interface IResourceStore { /// \u0026lt;summary\u0026gt; /// Gets identity resources by scope name. /// \u0026lt;/summary\u0026gt; Task\u0026lt;IEnumerable\u0026lt;IdentityResource\u0026gt;\u0026gt; FindIdentityResourcesByScopeNameAsync(IEnumerable\u0026lt;string\u0026gt; scopeNames); /// \u0026lt;summary\u0026gt; /// Gets API scopes by scope name. /// \u0026lt;/summary\u0026gt; Task\u0026lt;IEnumerable\u0026lt;ApiScope\u0026gt;\u0026gt; FindApiScopesByNameAsync(IEnumerable\u0026lt;string\u0026gt; scopeNames); /// \u0026lt;summary\u0026gt; /// Gets API resources by scope name. /// \u0026lt;/summary\u0026gt; Task\u0026lt;IEnumerable\u0026lt;ApiResource\u0026gt;\u0026gt; FindApiResourcesByScopeNameAsync(IEnumerable\u0026lt;string\u0026gt; scopeNames); /// \u0026lt;summary\u0026gt; /// Gets API resources by API resource name. /// \u0026lt;/summary\u0026gt; Task\u0026lt;IEnumerable\u0026lt;ApiResource\u0026gt;\u0026gt; FindApiResourcesByNameAsync(IEnumerable\u0026lt;string\u0026gt; apiResourceNames); /// \u0026lt;summary\u0026gt; /// Gets all resources. /// \u0026lt;/summary\u0026gt; Task\u0026lt;Resources\u0026gt; GetAllResourcesAsync(); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/session/management/silent-login/",
    "title": "BFF Silent Login Endpoint",
    "tags": [],
    "description": "",
    "content": "Added in v1.2.0.\nThe /bff/silent-login endpoint triggers authentication similarly to the login endpoint, but in a non-interactive way.\nThe expected usage pattern is that the application code loads in the browser and triggers a request to the User Endpoint. If that indicates that there is no BFF session, then the Silent Login Endpoint can be requested to attempt to automatically log the user in, using an existing session at the remote identity provider.\nThis non-interactive design relies upon the use of an iframe to make the silent login request. The result of the silent login request in the iframe will then use postMessage to notify the parent window of the outcome. If the result is that a session has been established, then the application logic can either re-trigger a call to the User Endpoint, or simply reload the entire page (depending on the preferred design). If the result is that a session has not been established, then the application redirects to the login endpoint to log the user in interactively.\nTo trigger the silent login, the application code must have an iframe and then set its src to the silent login endpoint. For example in your HTML:\n\u0026lt;iframe id=\u0026#34;bff-silent-login\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; And then in JavaScript:\ndocument.querySelector(\u0026#39;#bff-silent-login\u0026#39;).src = \u0026#39;/bff/silent-login\u0026#39;; To receive the result, the application should handle the message event in the browser and look for the data.isLoggedIn property on the event object:\nwindow.addEventListener(\u0026#34;message\u0026#34;, e =\u0026gt; { if (e.data \u0026amp;\u0026amp; e.data.source === \u0026#39;bff-silent-login\u0026#39; \u0026amp;\u0026amp; e.data.isLoggedIn) { // we now have a user logged in silently, so reload this window window.location.reload(); } }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/models/client/",
    "title": "Client",
    "tags": [],
    "description": "Model Reference",
    "content": "Duende.IdentityServer.Models.Client The Client class models an OpenID Connect or OAuth 2.0 client - e.g. a native application, a web application or a JS-based application.\npublic static IEnumerable\u0026lt;Client\u0026gt; Get() { return new List\u0026lt;Client\u0026gt; { /////////////////////////////////////////// // machine to machine client ////////////////////////////////////////// new Client { ClientId = \u0026#34;machine\u0026#34;, ClientSecrets = { Configuration[\u0026#34;machine.secret\u0026#34;] }, AllowedGrantTypes = GrantTypes.ClientCredentials, AllowedScopes = machineScopes }, /////////////////////////////////////////// // web client ////////////////////////////////////////// new Client { ClientId = \u0026#34;web\u0026#34;, ClientSecrets = { new Secret(Configuration[\u0026#34;web.secret\u0026#34;]) }, AllowedGrantTypes = GrantTypes.Code, RedirectUris = { \u0026#34;https://myapp.com:/signin-oidc\u0026#34; }, PostLogoutRedirectUris = { \u0026#34;https://myapp.com/signout-callback-oidc\u0026#34; }, BackChannelLogoutUri = \u0026#34;https://myapp.com/backchannel-logout\u0026#34;, AllowOfflineAccess = true, AllowedScopes = webScopes } } } Basics Enabled\nSpecifies if client is enabled. Defaults to true.\nClientId\nUnique ID of the client\nClientSecrets\nList of client secrets - credentials to access the token endpoint.\nRequireClientSecret\nSpecifies whether this client needs a secret to request tokens from the token endpoint (defaults to true)\nRequireRequestObject\nSpecifies whether this client needs to wrap the authorize request parameters in a JWT (defaults to false)\nAllowedGrantTypes\nSpecifies the grant types the client is allowed to use. Use the GrantTypes class for common combinations.\nRequirePkce\nSpecifies whether clients using an authorization code based grant type must send a proof key (defaults to true).\nAllowPlainTextPkce\nSpecifies whether clients using PKCE can use a plain text code challenge (not recommended - and defaults to false)\nRedirectUris\nSpecifies the allowed URIs to return tokens or authorization codes to\nAllowedScopes\nBy default a client has no access to any resources - specify the allowed resources by adding the corresponding scopes names\nAllowOfflineAccess\nSpecifies whether this client can request refresh tokens (be requesting the offline_access scope)\nAllowAccessTokensViaBrowser\nSpecifies whether this client is allowed to receive access tokens via the browser. This is useful to harden flows that allow multiple response types (e.g. by disallowing a hybrid flow client that is supposed to use code id_token to add the token response type and thus leaking the token to the browser).\nProperties\nDictionary to hold any custom client-specific values as needed.\nAuthentication / Session Management PostLogoutRedirectUris\nSpecifies allowed URIs to redirect to after logout.\nFrontChannelLogoutUri\nSpecifies logout URI at client for HTTP based front-channel logout.\nFrontChannelLogoutSessionRequired\nSpecifies if the user\u0026rsquo;s session id should be sent to the FrontChannelLogoutUri. Defaults to true.\nBackChannelLogoutUri\nSpecifies logout URI at client for HTTP based back-channel logout.\nBackChannelLogoutSessionRequired\nSpecifies if the user\u0026rsquo;s session id should be sent in the request to the BackChannelLogoutUri. Defaults to true.\nEnableLocalLogin\nSpecifies if this client can use local accounts, or external IdPs only. Defaults to true.\nIdentityProviderRestrictions\nSpecifies which external IdPs can be used with this client (if list is empty all IdPs are allowed). Defaults to empty.\nUserSsoLifetime\nThe maximum duration (in seconds) since the last time the user authenticated. Defaults to null. You can adjust the lifetime of a session token to control when and how often a user is required to reenter credentials instead of being silently authenticated, when using a web application.\nAllowedCorsOrigins\nIf specified, will be used by the default CORS policy service implementations (In-Memory and EF) to build a CORS policy for JavaScript clients.\nCoordinateLifetimeWithUserSession (added in v6.1)\nWhen enabled, the client\u0026rsquo;s token lifetimes (e.g. refresh tokens) will be tied to the user\u0026rsquo;s session lifetime. This means when the user logs out, any revokable tokens will be removed. If using server-side sessions, expired sessions will also remove any revokable tokens, and backchannel logout will be triggered. This client\u0026rsquo;s setting overrides the global CoordinateTokensWithUserSession configuration setting.\nToken IdentityTokenLifetime\nLifetime to identity token in seconds (defaults to 300 seconds / 5 minutes)\nAllowedIdentityTokenSigningAlgorithms\nList of allowed signing algorithms for identity token. If empty, will use the server default signing algorithm.\nAccessTokenLifetime\nLifetime of access token in seconds (defaults to 3600 seconds / 1 hour)\nAuthorizationCodeLifetime\nLifetime of authorization code in seconds (defaults to 300 seconds / 5 minutes)\nAccessTokenType\nSpecifies whether the access token is a reference token or a self contained JWT token (defaults to Jwt).\nIncludeJwtId\nSpecifies whether JWT access tokens should have an embedded unique ID (via the jti claim). Defaults to true.\nClaims\nAllows settings claims for the client (will be included in the access token).\nAlwaysSendClientClaims\nIf set, the client claims will be sent for every flow. If not, only for client credentials flow (default is false)\nAlwaysIncludeUserClaimsInIdToken\nWhen requesting both an id token and access token, should the user claims always be added to the id token instead of requiring the client to use the userinfo endpoint. Default is false.\nClientClaimsPrefix\nIf set, the prefix client claim types will be prefixed with. Defaults to client_. The intent is to make sure they don\u0026rsquo;t accidentally collide with user claims.\nPairWiseSubjectSalt Salt value used in pair-wise subjectId generation for users of this client. Currently not implemented.\nRefresh Token AbsoluteRefreshTokenLifetime\nMaximum lifetime of a refresh token in seconds. Defaults to 2592000 seconds / 30 days\nSlidingRefreshTokenLifetime\nSliding lifetime of a refresh token in seconds. Defaults to 1296000 seconds / 15 days\nRefreshTokenUsage\nReUse\nthe refresh token handle will stay the same when refreshing tokens\nOneTime\nthe refresh token handle will be updated when refreshing tokens. This is the default.\nRefreshTokenExpiration\nAbsolute\nthe refresh token will expire on a fixed point in time (specified by the AbsoluteRefreshTokenLifetime). This is the default.\nSliding\nwhen refreshing the token, the lifetime of the refresh token will be renewed (by the amount specified in SlidingRefreshTokenLifetime). The lifetime will not exceed AbsoluteRefreshTokenLifetime.\nUpdateAccessTokenClaimsOnRefresh\nGets or sets a value indicating whether the access token (and its claims) should be updated on a refresh token request.\nConsent Screen Consent screen specific settings.\nRequireConsent\nSpecifies whether a consent screen is required. Defaults to false.\nAllowRememberConsent\nSpecifies whether user can choose to store consent decisions. Defaults to true.\nConsentLifetime\nLifetime of a user consent in seconds. Defaults to null (no expiration).\nClientName\nClient display name (used for logging and consent screen).\nClientUri\nURI to further information about client.\nLogoUri\nURI to client logo.\nCross Device Flows Settings used in the CIBA and OAuth device flows.\nPollingInterval\nMaximum polling interval for the client in cross device flows. If the client polls more frequently than the polling interval during those flows, it will receive a slow_down error response. Defaults to null, which means the throttling will use the global default appropriate for the flow (IdentityServerOptions.Ciba.DefaultPollingInterval or IdentityServerOptions.DeviceFlow.Interval).\nDevice Flow Device flow specific settings.\nUserCodeType\nSpecifies the type of user code to use for the client. Otherwise falls back to default.\nDeviceCodeLifetime\nLifetime to device code in seconds (defaults to 300 seconds / 5 minutes)\nCIBA Client initiated backchannel authentication specific settings.\nCibaLifetime\nSpecifies the backchannel authentication request lifetime in seconds. Defaults to null.\nDPoP Added in 6.3.0.\nSettings specific to the Demonstration of Proof-of-Possession at the Application Layer (DPoP) feature.\nRequireDPoP\nSpecifies whether a DPoP (Demonstrating Proof-of-Possession) token is requied to be used by this client. Defaults to false.\nDPoPValidationMode\nEnum setting to control validation for the DPoP proof token expiration. This supports both the client generated \u0026lsquo;iat\u0026rsquo; value and/or the server generated \u0026rsquo;nonce\u0026rsquo; value. Defaults to DPoPTokenExpirationValidationMode.Iat, which only validates the \u0026lsquo;iat\u0026rsquo; value.\nDPoPClockSkew\nClock skew used in validating the client\u0026rsquo;s DPoP proof token \u0026lsquo;iat\u0026rsquo; claim value. Defaults to 5 minutes.\nThird-Party Initiated Login Added in 6.3.0.\nInitiateLoginUri\nAn optional URI that can be used to initiate login from the IdentityServer host or a third party. This is most commonly used to create a client application portal within the IdentityServer host. Defaults to null.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/models/idp/",
    "title": "Identity Provider",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Models.OidcProvider The OidcProvider models an external OpenID Connect provider for use in the dynamic providers feature. Its properties map to the Open ID Connect options class from ASP.NET Core, and those properties include:\nEnabled\nSpecifies if provider is enabled. Defaults to true.\nScheme\nScheme name for the provider.\nDisplayName\nDisplay name for the provider.\nType\nProtocol type of the provider. Defaults to \u0026ldquo;oidc\u0026rdquo; for the OidcProvider.\nAuthority\nThe base address of the OIDC provider.\nResponseType\nThe response type. Defaults to \u0026ldquo;id_token\u0026rdquo;.\nClientId\nThe client id.\nClientSecret\nThe client secret. By default this is the plaintext client secret and great consideration should be taken if this value is to be stored as plaintext in the store. It is possible to store this in a protected way and then unprotect when loading from the store either by implementing a custom IIdentityProviderStore or registering a custom IConfigureNamedOptions\u0026lt;OpenIdConnectOptions\u0026gt;.\nScope\nSpace separated list of scope values.\nGetClaimsFromUserInfoEndpoint\nIndicates if userinfo endpoint is to be contacted. Defaults to true.\nUsePkce\nIndicates if PKCE should be used. Defaults to true.\nDuende.IdentityServer.Models.IdentityProviderName The IdentityProviderName models the display name of an identity provider.\nEnabled\nSpecifies if provider is enabled. Defaults to true.\nScheme\nScheme name for the provider.\nDisplayName\nDisplay name for the provider.\nDuende.IdentityServer.Models.IdentityProvider The IdentityProvider is a base class to model arbitrary identity providers, which OidcProvider derives from. This leaves open the possibility for extensions to the dynamic provider feature to support other protocol types (as distinguished by the Type property).\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/stores/client_store/",
    "title": "Client Store",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Stores.IClientStore Used to dynamically load client configuration.\n/// \u0026lt;summary\u0026gt; /// Retrieval of client configuration /// \u0026lt;/summary\u0026gt; public interface IClientStore { /// \u0026lt;summary\u0026gt; /// Finds a client by id /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;clientId\u0026#34;\u0026gt;The client id\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;The client\u0026lt;/returns\u0026gt; Task\u0026lt;Client\u0026gt; FindClientByIdAsync(string clientId); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/stores/cors_policy_service/",
    "title": "CORS Policy Service",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Stores.ICorsPolicyService Used to determine if CORS requests are allowed to certain protocol endpoints.\n/// \u0026lt;summary\u0026gt; /// Service that determines if CORS is allowed. /// \u0026lt;/summary\u0026gt; public interface ICorsPolicyService { /// \u0026lt;summary\u0026gt; /// Determines whether origin is allowed. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;origin\u0026#34;\u0026gt;The origin.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task\u0026lt;bool\u0026gt; IsOriginAllowedAsync(string origin); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/stores/idp_store/",
    "title": "Identity Provider Store",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Stores.IIdentityProviderStore Used to dynamically load identity provider configuration.\n/// \u0026lt;summary\u0026gt; /// Interface to model storage of identity providers. /// \u0026lt;/summary\u0026gt; public interface IIdentityProviderStore { /// \u0026lt;summary\u0026gt; /// Gets all identity providers name. /// \u0026lt;/summary\u0026gt; Task\u0026lt;IEnumerable\u0026lt;IdentityProviderName\u0026gt;\u0026gt; GetAllSchemeNamesAsync(); /// \u0026lt;summary\u0026gt; /// Gets the identity provider by scheme name. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;scheme\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task\u0026lt;IdentityProvider\u0026gt; GetBySchemeAsync(string scheme); } The IdentityProvider is intended to be a base class to model arbitrary identity providers. The default implementation included in Duende IdentityServer will return a derived class for OpenID Connect providers, via the OidcProvider class.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/extensibility/management/logout/",
    "title": "BFF Logout Endpoint Extensibility",
    "tags": [],
    "description": "",
    "content": "The BFF logout endpoint has extensibility points in two interfaces. The IlogoutService is the top level abstraction that processes requests to the endpoint. This service can be used to add custom request processing logic. The IReturnUrlValidator ensures that the returnUrl parameter passed to the logout endpoint is safe to use.\nRequest Processing ProcessRequestAsync is the top level function called in the endpoint service and can be used to add arbitrary logic to the endpoint.\nFor example, you could take whatever actions you need before normal processing of the request like this:\npublic override Task ProcessRequestAsync(HttpContext context) { // Custom logic here return base.ProcessRequestAsync(context); } Return URL Validation To prevent open redirector attacks, the returnUrl parameter to the logout endpoint must be validated. You can customize this validation by implementing the IReturnUrlValidator interface. The default implementation enforces that return urls are local.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/session/management/diagnostics/",
    "title": "BFF Diagnostics Endpoint",
    "tags": [],
    "description": "",
    "content": "The /bff/diagnostics endpoint returns the current user and client access token for testing purposes.\nTo use the diagnostics endpoint, make a GET request to /bff/diagnostics. Typically this is done in a browser to diagnose a problem during development.\nThis endpoint is only enabled in Development mode.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/ui/consent/",
    "title": "Consent",
    "tags": [],
    "description": "",
    "content": "During an authorization request, if user consent is required the browser will be redirected to the consent page.\nYou can configure the consent requirement per client. By default no consent is required, but this setting can be changed via the RequireConsent setting.\nConsent is used to allow an end user to grant a client access to resources.\nConsent Page In order for the user to grant consent, a consent page must be provided by the hosting application. When IdentityServer needs to prompt the user for consent, it will redirect the user to a configurable ConsentUrl.\nbuilder.Services.AddIdentityServer(opt =\u0026gt; { opt.UserInteraction.ConsentUrl = \u0026#34;/path/to/consent\u0026#34;; }) By default, the ConsentUrl is set to \u0026ldquo;/consent\u0026rdquo;. The quickstart UI includes a basic implementation of a consent page at that route.\nA consent page normally renders the display name of the current user, the display name of the client requesting access, the logo of the client, a link for more information about the client, and the list of resources the client is requesting access to. It\u0026rsquo;s also common to allow the user to indicate that their consent should be \u0026ldquo;remembered\u0026rdquo; so they are not prompted again in the future for the same client.\nOnce the user has provided consent, the consent page must inform your IdentityServer of the consent, and then the browser must be redirected back to the authorization endpoint.\nAuthorization Context Your IdentityServer will pass a returnUrl parameter to the consent page which contains the parameters of the authorization request. These parameters provide the context for the consent page, and can be read with help from the interaction service.\nThe GetAuthorizationContextAsync API will return an instance of AuthorizationRequest. Additional details about the client or resources can be obtained using the IClientStore and IResourceStore interfaces.\nInforming IdentityServer of the consent result The GrantConsentAsync API on the interaction service allows the consent page to inform your IdentityServer of the outcome of consent (which might also be to deny the client access).\nYour IdentityServer will temporarily persist the outcome of the consent. This persistence uses a cookie by default, as it only needs to last long enough to convey the outcome back to the authorization endpoint. This temporary persistence is different than the persistence used for the \u0026ldquo;remember my consent\u0026rdquo; feature (and it is the authorization endpoint which persists the \u0026ldquo;remember my consent\u0026rdquo; for the user). If you wish to use some other persistence between the consent page and the authorization redirect, then you can implement IMessageStore and register the implementation in DI.\nReturning the user to the authorization endpoint Once the consent page has informed IdentityServer of the outcome, the user can be redirected back to the returnUrl. Your consent page should protect against open redirects by verifying that the returnUrl is valid. This can be done by calling IsValidReturnUrl on the interaction service.\nAlso, if GetAuthorizationContextAsync returns a non-null result, then you can also trust that the returnUrl is valid.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/deployment/caching/",
    "title": "Distributed Caching",
    "tags": [],
    "description": "",
    "content": "Some optional features rely on ASP.NET Core distributed caching:\nState data formatter for OpenID Connect Replay cache (e.g. for JWT client credentials) Device flow throttling service Authorization parameter store In order to work in a multi server environment, this needs to be set up correctly. Please consult the Microsoft documentation for more details.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/extensibility/http_forwarder/",
    "title": "HTTP Forwarder",
    "tags": [],
    "description": "",
    "content": "You can customize the HTTP forwarder behavior in two ways\nprovide a customized HTTP client for outgoing calls provide custom request/response transformation Custom HTTP clients By default, Duende.BFF will create and cache an HTTP client per configured route or local path.\nThis invoker is setup like this:\nvar client = new HttpMessageInvoker(new SocketsHttpHandler { UseProxy = false, AllowAutoRedirect = false, AutomaticDecompression = DecompressionMethods.None, UseCookies = false }); If you want to customize the HTTP client for specific paths, you can either implement the IHttpMessageInvokerFactory interface or derive from the DefaultHttpMessageInvokerFactory, e.g.:\npublic class MyInvokerFactory : DefaultHttpMessageInvokerFactory { public override HttpMessageInvoker CreateClient(string localPath) { if (localPath == \u0026#34;/foo\u0026#34;) { return Clients.GetOrAdd(localPath, (key) =\u0026gt; { return new HttpMessageInvoker(new SocketsHttpHandler { // this API needs a proxy UseProxy = true, Proxy = new WebProxy(\u0026#34;https://myproxy\u0026#34;), AllowAutoRedirect = false, AutomaticDecompression = DecompressionMethods.None, UseCookies = false }); }); } return base.CreateClient(localPath); } } ..and override our registration:\nservices.AddSingleton\u0026lt;IHttpMessageInvokerFactory, MyInvokerFactory\u0026gt;(); Custom transformations In the standard configuration, BFF uses the YARP default behavior for forwarding HTTP requests. In addition we\nremove the sensitive session cookie add the current access token If you want to modify this behavior you can either implement IHttpTransformerFactory from scratch:\npublic interface IHttpTransformerFactory { /// \u0026lt;summary\u0026gt; /// Creates a HTTP transformer based on the local path /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;localPath\u0026#34;\u0026gt;Local path the remote API is mapped to\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;accessToken\u0026#34;\u0026gt;The access token to attach to the request (if present)\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; HttpTransformer CreateTransformer(string localPath, string accessToken = null); } \u0026hellip;or derive from the DefaultHttpTransformerFactory.\nThe transformations are based on YARP\u0026rsquo;s transform library and are extensible. See here for a full list of built-in transforms.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/models/",
    "title": "Models",
    "tags": [],
    "description": "Reference",
    "content": "Models Identity Resource API Scope API Resource Client Identity Provider Grant Validation Result Secrets Backchannel User Login Request "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/overview/packaging/",
    "title": "Packaging and Builds",
    "tags": [],
    "description": "",
    "content": "Product The licensed and supported libraries can be accessed via Nuget:\nDuende IdentityServer Duende IdentityServer EntityFramework Integration Duende IdentityServer ASP.NET Identity Integration UI Duende IdentityServer does not contain any UI, because this is always custom to the project. We still provide you a starting point for your modifications.\nstandard UI UI with ASP.NET Identity integration Templates Contains templates for the dotnet CLI.\nNuGet package source code You can install the templates using the following command:\ndotnet new -i Duende.IdentityServer.Templates Source Code You can find the Duende IdentityServer source code on GitHub.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/services/profile_service/",
    "title": "Profile Service",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Services.IProfileService Encapsulates retrieval of user claims from a data source of your choice. See here for a sample.\n/// \u0026lt;summary\u0026gt; /// This interface allows IdentityServer to connect to your user and profile store. /// \u0026lt;/summary\u0026gt; public interface IProfileService { /// \u0026lt;summary\u0026gt; /// This method is called whenever claims about the user are requested (e.g. during token creation or via the userinfo endpoint) /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;context\u0026#34;\u0026gt;The context.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task GetProfileDataAsync(ProfileDataRequestContext context); /// \u0026lt;summary\u0026gt; /// This method gets called whenever identity server needs to determine if the user is valid or active (e.g. if the user\u0026#39;s account has been deactivated since they logged in). /// (e.g. during token issuance or validation). /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;context\u0026#34;\u0026gt;The context.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task IsActiveAsync(IsActiveContext context); } GetProfileDataAsync\nThe API that is expected to load claims for a user. It is passed an instance of ProfileDataRequestContext.\nIsActiveAsync\nThe API that is expected to indicate if a user is currently allowed to obtain tokens. It is passed an instance of IsActiveContext.\nDuende.IdentityServer.Models.ProfileDataRequestContext Models the request for user claims and is the vehicle to return those claims. It contains these properties:\nSubject\nThe ClaimsPrincipal modeling the user associated with this request for profile data. When the profile service is invoked for tokens, the Subject property will contain the principal that was issued during user sign-in. When the profile service is called for requests to the userinfo endpoint, the Subject property will contain a claims principal populated with the claims in the access token used to authorize the userinfo call.\nClient\nThe Client for which the claims are being requested.\nRequestedClaimTypes\nThe collection of claim types being requested. This data is source from the requested scopes and their associated claim types.\nCaller\nAn identifier for the context in which the claims are being requested (e.g. an identity token, an access token, or the user info endpoint). The IdentityServerConstants.ProfileDataCallers class contains the different constant values.\nIssuedClaims\nThe list of claims that will be returned. This is expected to be populated by the custom IProfileService implementation.\nAddRequestedClaims\nExtension method on the ProfileDataRequestContext to populate the IssuedClaims, but first filters the claims based on RequestedClaimTypes.\nDuende.IdentityServer.Models.IsActiveContext Models the request to determine if the user is currently allowed to obtain tokens. It contains these properties:\nSubject\nThe ClaimsPrincipal modeling the user.\nClient\nThe Client for which the claims are being requested.\nCaller\nAn identifier for the context in which the claims are being requested (e.g. an identity token, an access token, or the user info endpoint. The constant IdentityServerConstants.ProfileIsActiveCallers contains the different constant values.\nIsActive\nThe flag indicating if the user is allowed to obtain tokens. This is expected to be assigned by the custom IProfileService implementation.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/fundamentals/resources/isolation/",
    "title": "Resource Isolation",
    "tags": [],
    "description": "",
    "content": " This is an Enterprise Edition feature.\nOAuth itself only knows about scopes - the (API) resource concept does not exist from a pure protocol point of view. This means that all the requested scope and audience combination get merged into a single access token. This has a couple of downsides, e.g.\ntokens can become very powerful (and big) if such a token leaks, it allows access to multiple resources resources within that single token might have conflicting settings, e.g. user claims of all resources share the same token resource specific processing like signing or encryption algorithms conflict without sender-constraints, a resource could potentially re-use (or abuse) a token to call another contained resource directly To solve this problem RFC 8707 adds an additional request parameter for the authorize and token endpoint called resource. This allows requesting a token for a specific resource (in other words - making sure the audience claim has a single value only, and all scopes belong to that single resource).\nUsing the resource parameter Let\u0026rsquo;s assume you have the following resource design and that the client is allowed access to all scopes:\nvar resources = new[] { new ApiResource(\u0026#34;urn:invoices\u0026#34;) { Scopes = { \u0026#34;read\u0026#34;, \u0026#34;write\u0026#34; } }, new ApiResource(\u0026#34;urn:products\u0026#34;) { Scopes = { \u0026#34;read\u0026#34;, \u0026#34;write\u0026#34; } } }; If the client would simply request a token for the read scope, the resulting access token would contain the audience of both the invoice and the products API and thus be accepted at both APIs.\nMachine to machine scenarios If the client in addition passes the resource parameter specifying the name of the resource where it wants to use the access token, the token engine can down-scope the resulting access token to the single resource, e.g.:\nPOST /token grant_type=client_credentials\u0026amp; client_id=client\u0026amp; client_secret=...\u0026amp; scope=read\u0026amp; resource=urn:invoices Thus resulting in an access token like this (some details omitted):\n{ \u0026#34;aud\u0026#34;: [ \u0026#34;urn:invoice\u0026#34; ], \u0026#34;scope\u0026#34;: \u0026#34;read\u0026#34;, \u0026#34;client_id\u0026#34;: \u0026#34;client\u0026#34; } Interactive applications The authorize endpoint supports the resource parameter as well, e.g.:\nGET /authorize?client_id=client\u0026amp;response_type=code\u0026amp;scope=read\u0026amp;resource=urn:invoices Once the front-channel operations are done, the resulting code can be redeemed by passing the resource name on the token endpoint:\nPOST /token grant_type=authorization_code\u0026amp; client_id=client\u0026amp; client_secret=...\u0026amp; authorization_code=...\u0026amp; redirect_uri=...\u0026amp; resource=urn:invoices Requesting access to multiple resources It is also possible to request access to multiple resources. This will result in multiple access tokens - one for each request resource.\nGET /authorize?client_id=client\u0026amp;response_type=code\u0026amp;scope=read offline_access\u0026amp;resource=urn:invoices\u0026amp;resource=urn:products When you redeem the code, you need to specify for which resource you want to have an access token, e.g.:\nPOST /token grant_type=authorization_code\u0026amp; client_id=client\u0026amp; client_secret=...\u0026amp; authorization_code=...\u0026amp; redirect_uri=...\u0026amp; resource=urn:invoices Which will return an access token for the invoices API and a refresh token. If you want to also retrieve the access token for the products API, you use the refresh token and make another roundtrip to the token endpoint.\nPOST /token grant_type=refresh_token\u0026amp; client_id=client\u0026amp; client_secret=...\u0026amp; refresh_token=...\u0026amp; resource=urn:products The end-result will be that the client has two access tokens - one for each resource and can manage their lifetime via the refresh token.\nEnforcing resource isolation All examples so far used the resource parameter optionally. If you have API resources, where you want to make sure they are not sharing access tokens with other resources, you can enforce the resource indicator, e.g.:\nvar resources = new[] { new ApiResource(\u0026#34;urn:invoices\u0026#34;) { Scopes = { \u0026#34;read\u0026#34;, \u0026#34;write\u0026#34; }, RequireResourceIndicator = true }, new ApiResource(\u0026#34;urn:products\u0026#34;) { Scopes = { \u0026#34;read\u0026#34;, \u0026#34;write\u0026#34; } } }; "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/ui/",
    "title": "User Interaction",
    "tags": [],
    "description": "Overview",
    "content": "User Interaction and Pages The design goal of Duende IdentityServer is to provide a full implementation of the OpenID Connect and OAuth protocols that is extremely flexible and easily customizable. One facet of IdentityServer that implementations typically customize is the user interface that users see when they need to log in, log out, etc. This UI is almost always branded to have the same look and feel as other applications of the organization that is implementing IdentityServer. But the customization that is possible within the UI goes much deeper than a logo or stylesheet. The entire user experience in your IdentityServer implementation is code that you control. This allows you to build customizations such as\nMulti-factor authentication Knowledge-based authentication Passwordless authentication Requiring the user to accept terms of service or other legal agreements Home-realm discovery to determine which user store or external authentication provider should be used Reconciliation of accounts across multiple user stores Gathering additional user information and provisioning resources when new users arrive from external providers To allow full flexibility of the UI, including business rules and user flow, the UI is separated from the core IdentityServer engine. The engine implements the endpoints specified in the protocols and hands off control to your code in the UI as necessary.\nOur templates include a quick start UI as well as a quick start UI adapted to ASP.NET Identity which provide a starting point for all the necessary pages, ready to be customized.\nRequired Pages As browser requests are made to the protocol endpoints in your IdentityServer implementation, they will be redirected to the interactive pages for the user to see. Depending on the features required, the pages expected in your IdentityServer implementation are:\nLogin: allows the user to login. This could be achieved with a local credential, or could utilize an external login provider (e.g. social or enterprise federation system). Logout: allows the user to logout (including providing single sign-out). Error: display error information to the end user, typically when there are workflow errors. Consent: allows the user to grant resource access to clients (typically only used if the client is third-party). Additional custom pages that you might want are then also possible (e.g. password reset, registration), and those are typically available to the user as links from one of the above pages.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/fundamentals/users/",
    "title": "Users and Logging In",
    "tags": [],
    "description": "",
    "content": "Users and User Interface The design of Duende IdentityServer allows you to use any user database and build any user interface (UI) workflow needed to satisfy your requirements. This means you have the ability to customize any UI page (registration, login, password reset, etc.), support any credential type (password, MFA, etc.), use any user database (greenfield or legacy), and/or use federated logins from any provider (social or enterprise). You have the ability to control the entire user experience while Duende IdentityServer provides the implementation of the security protocol (OpenID Connect and OAuth).\nWhile you can use any custom user database or identity management library for your users, we provide integration support for ASP.NET Identity.\nAuthorization Endpoint and Login Page Workflow The standard mechanism to allow users to login is for the client application to use a web browser. This is obvious if the client application is a web application, but it\u0026rsquo;s also the recommended practice for native and mobile applications.\nWhen a user must login, the client application will redirect the user to the protocol endpoint called the authorization endpoint in your IdentityServer server to request authentication. As part of the authorize request, your IdentityServer will typically display a login page for the user to enter their credentials. Once the user has authenticated, your IdentityServer will redirect the user back to the application with the protocol response.\nA user\u0026rsquo;s authentication session is managed using Microsoft\u0026rsquo;s ASP.NET cookie authentication framework. It is very important that you understand how it works when building the login pages in IdentityServer.\nRecall the diagram showing the relationship of your custom UI pages and the IdentityServer middleware in your IdentityServer host application:\nWhen your IdentityServer receives an authorize request, it will inspect it for a current authentication session for a user. This authentication session is based on ASP.NET Core\u0026rsquo;s authentication system and is ultimately determined by a cookie issued from your login page.\nIf the user has never logged in there will be no cookie, and then the request to the authorize endpoint will result in a redirect to your login page. This is the entry point into your custom workflow that can take over to get the user logged in.\nOnce the login page has finished logging in the user with the ASP.NET Core authentication system, it will redirect the user back to the authorize endpoint. This time the request to the authorize endpoint will have an authenticated session for the user, and it can then create the protocol response and redirect to the client application.\nAdditional Pages In addition to the login page, there are other pages that Duende IdentityServer expects (e.g. logout, error, consent), and you could implement custom pages as well (e.g. register, forgot password, etc.). Details about building these pages, and coverage of additional topics are in the User Interaction section of this documentation.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/apis/aspnetcore/confirmation/",
    "title": "Validating Proof-of-Possession",
    "tags": [],
    "description": "",
    "content": "IdentityServer can bind tokens to clients using either mTLS or DPoP, creating a Proof-of-Possession (PoP) access token. When one of these mechanisms is used, APIs that use those access tokens for authorization need to validate the binding between the client and token. This document describes how to perform such validation, depending on which mechanism was used to produce a PoP token.\nValidating mTLS Proof-of-Possession If you are using a mutual TLS connection to establish proof-of-possession, the resulting access token will contain a cnf claim containing the client\u0026rsquo;s certificate thumbprint. APIs validate such tokens by comparing this thumbprint to the thumbprint of the client certificate in the mTLS connection. This validation should be performed early in the pipeline, ideally immediately after the standard validation of the access token.\nYou can do so with custom middleware like this:\npublic void Configure(IApplicationBuilder app) { // rest omitted // normal token validation happens here app.UseAuthentication(); // This adds custom middleware to validate cnf claim app.UseConfirmationValidation(); app.UseAuthorization(); // rest omitted } Here, UseConfirmationValidation is an extension method that registers the middleware that performs the necessary validation:\npublic static class ConfirmationValidationExtensions { public static IApplicationBuilder UseConfirmationValidation(this IApplicationBuilder app, ConfirmationValidationMiddlewareOptions options = default) { return app.UseMiddleware\u0026lt;ConfirmationValidationMiddleware\u0026gt;(options ?? new ConfirmationValidationMiddlewareOptions()); } } And this is the actual middleware that validates the cnf claim:\n// this middleware validates the cnf claim (if present) against the thumbprint of the X.509 client certificate for the current client public class ConfirmationValidationMiddleware { private readonly RequestDelegate _next; private readonly ILogger _logger; private readonly ConfirmationValidationMiddlewareOptions _options; public ConfirmationValidationMiddleware( RequestDelegate next, ILogger\u0026lt;ConfirmationValidationMiddlewareOptions\u0026gt; logger, ConfirmationValidationMiddlewareOptions options = null) { _next = next; _logger = logger; _options ??= new ConfirmationValidationMiddlewareOptions(); } public async Task Invoke(HttpContext ctx) { if (ctx.User.Identity.IsAuthenticated) { // read the cnf claim from the validated token var cnfJson = ctx.User.FindFirst(\u0026#34;cnf\u0026#34;)?.Value; if (!String.IsNullOrWhiteSpace(cnfJson)) { // if present, make sure a valid certificate was presented as well var certResult = await ctx.AuthenticateAsync(_options.CertificateSchemeName); if (!certResult.Succeeded) { await ctx.ChallengeAsync(_options.CertificateSchemeName); return; } // get access to certificate from transport var certificate = await ctx.Connection.GetClientCertificateAsync(); var thumbprint = Base64UrlTextEncoder.Encode(certificate.GetCertHash(HashAlgorithmName.SHA256)); // retrieve value of the thumbprint from cnf claim var cnf = JObject.Parse(cnfJson); var sha256 = cnf.Value\u0026lt;string\u0026gt;(\u0026#34;x5t#S256\u0026#34;); // compare thumbprint claim with thumbprint of current TLS client certificate if (String.IsNullOrWhiteSpace(sha256) || !thumbprint.Equals(sha256, StringComparison.OrdinalIgnoreCase)) { _logger.LogError(\u0026#34;certificate thumbprint does not match cnf claim.\u0026#34;); await ctx.ChallengeAsync(_options.JwtBearerSchemeName); return; } _logger.LogDebug(\u0026#34;certificate thumbprint matches cnf claim.\u0026#34;); } } await _next(ctx); } } public class ConfirmationValidationMiddlewareOptions { public string CertificateSchemeName { get; set; } = CertificateAuthenticationDefaults.AuthenticationScheme; public string JwtBearerSchemeName { get; set; } = JwtBearerDefaults.AuthenticationScheme; } Validating DPoP Proof-of-Possession If you are using DPoP for proof-of-possession, there is a non-trivial amount of work needed to validate the cnf claim. In addition to the normal validation mechanics of the access token itself, DPoP requires additional validation of the DPoP proof token sent in the \u0026ldquo;DPoP\u0026rdquo; HTTP request header. DPoP proof token processing involves requiring the DPoP scheme on the authorization header where the access token is sent, JWT validation of the proof token, \u0026ldquo;cnf\u0026rdquo; claim validation, HTTP method and URL validation, replay detection (which requires some storage for the replay information), nonce generation and validation, additional clock skew logic, and emitting the correct response headers in the case of the various validation errors.\nGiven that there are no off-the-shelf libraries that implement this, we have developed a full-featured sample implementation. With this sample the configuration necessary in your startup can be as simple as this:\npublic void ConfigureServices(IServiceCollection services) { // adds the normal JWT bearer validation services.AddAuthentication(\u0026#34;token\u0026#34;) .AddJwtBearer(\u0026#34;token\u0026#34;, options =\u0026gt; { options.Authority = Constants.Authority; options.TokenValidationParameters.ValidateAudience = false; options.MapInboundClaims = false; options.TokenValidationParameters.ValidTypes = new[] { \u0026#34;at+jwt\u0026#34; }; }); // extends the \u0026#34;token\u0026#34; scheme above with DPoP processing and validation services.ConfigureDPoPTokensForScheme(\u0026#34;token\u0026#34;); } You can find this sample here. To use the ConfigureDPoPTokensForScheme shown above, copy the *~/Api/DPoP code from the sample into you APIs.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/tokens/extension_grants/",
    "title": "Extension Grants",
    "tags": [],
    "description": "",
    "content": "Extension Grants OAuth defines an extensibility point called extension grants.\nExtension grants allow adding support for non-standard token issuance scenarios, e.g.\ntoken transformation SAML to JWT, or Windows to JWT delegation or impersonation federation encapsulating custom input parameters You can add support for additional grant types by implementing the IExtensionGrantValidator interface.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/apis/",
    "title": "API Endpoints",
    "tags": [],
    "description": "",
    "content": "Securing and Accessing API Endpoints A frontend application using the BFF pattern can call two types of APIs:\nRemote APIs These APIs are deployed on a different host than the BFF, which allows them to be shared between multiple frontends or (more generally speaking) multiple clients. These APIs can only be called via the BFF host acting as a proxy.\nLocal APIs These APIs only exist to support the specific frontend; they are not shared with other frontends or services. They are located in the BFF host and can be called directly by the frontend.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/samples/bff/",
    "title": "Backend for Frontend Pattern",
    "tags": [],
    "description": "",
    "content": "This section contains a collection of clients using our BFF security framework.\nJavaScript Frontend This sample shows how to use the BFF framework with a JavaScript-based frontend (e.g. SPA).\nlink to source code\nReactJs Frontend This sample shows how to use the BFF framework with the .NET 6 React template.\nlink to source code\nAngular Frontend This sample shows how to use the BFF framework with the .NET 6 Angular template.\nlink to source code\nBlazor WASM This sample shows how to use the BFF framework with Blazor WASM.\nlink to source code\nYARP Integration This sample shows how to use the BFF extensions for Microsoft YARP\nlink to source code\nSeparate Host for UI This sample shows how to have separate projects from the frontend and backend, using CORS to allow cross-site requests from the frontend to the backend.\nlink to source code\nDPoP This sample shows how to configure the BFF to use DPoP to obtain sender-constrained tokens.\nlink to source code\nToken Exchange using the IAccessTokenRetriever This sample shows how to extend the BFF with an IAccessTokenRetriever. This example of an IAccessTokenRetriever performs token exchange for impersonation. If you are logged in as alice you will get a token for bob, and vice versa.\nlink to source code\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/validators/dpop_proof_validator/",
    "title": "DPoP Proof Validator",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Validation.IDPoPProofValidator The IDPoPProofValidator interface is used to validate DPoP proof tokens submitted to IdentityServer. A default implementation is provided and can be overridden as necessary.\nIDPoPProofValidator APIs ValidateAsync\nValidates a DPoP proof token with the provided DPoPProofValidationContext for the current request. Returns a DPoPProofValidationResult object.\nDPoPProofValidationContext Models the information to validate a DPoP proof token request.\nClient\nThe Client making the request.\nProofToken\nThe proof token sent with the request.\nDPoPProofValidationResult Models the result of a DPoP proof token validation.\nIsError\nFlag to indicate if validation failed.\nError\nThe error code if the validation failed.\nErrorDescription\nThe error description if the validation failed.\nJsonWebKey\nThe serialized JWK from the validated DPoP proof token.\nJsonWebKeyThumbprint\nThe JWK thumbprint from the validated DPoP proof token.\nConfirmation\nThe \u0026lsquo;cnf\u0026rsquo; value for the DPoP proof token.\nPayload\nThe payload values of the DPoP proof token.\nTokenId\nThe \u0026lsquo;jti\u0026rsquo; value read from the payload.\nNonce\nThe \u0026rsquo;nonce\u0026rsquo; value read from the payload.\nIssuedAt\nThe \u0026lsquo;iat\u0026rsquo; value read from the payload.\nServerIssuedNonce\nThe \u0026rsquo;nonce\u0026rsquo; value issued by the server that should be emitted on the response.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/upgrades/v6.2_to_v6.3/",
    "title": "Duende IdentityServer v6.2 to v6.3",
    "tags": [],
    "description": "",
    "content": "This upgrade guide covers upgrading from Duende IdentityServer v6.2 to v6.3 (release notes).\nWhat\u0026rsquo;s New Duende IdentityServer 6.3 adds:\nSupport for OAuth 2.0 Demonstrating Proof-of-Possession at the Application Layer (DPoP) , a new OAuth specification for sender-constraining refresh tokens and access tokens.\nA new Configuration API distributed through the separate Duende.IdentityServer.Configuration NuGet package that supports the OAuth and OIDC Dynamic Client Registration specifications.\nSupport for 3rd party initiated login through the new client configuration property InitiateLoginUri. This is typically used to create a client application portal page within an IdentityServer host.\nSupport for the OIDC prompt=create parameter, which gives the client application the ability to provide a hint that the user needs to register.\nNew configuration options for managing refresh token rotation.\nSupport for the unmet_authentication_requirements error response code, improving error responses during step-up flows.\nNullable reference type annotations on many public APIs.\nProgrammer quality of life improvements, bug fixes, and more! See the release notes for more details.\nStep 1: Update NuGet package In your IdentityServer host project, update the version of the NuGet package reference. For example in your project file:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;6.2.0\u0026#34; /\u0026gt; would change to:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;6.3.0\u0026#34; /\u0026gt; Step 2: Update Database Schema (if necessary) IdentityServer 6.3 adds new four new properties to the Duende.IdentityServer.Models.Client model that are needed to support DPoP and 3rd party initiated login. If you are storing you Client configuration in a database, then you will need to update the database\u0026rsquo;s schema.\nThe InitiateLoginUri string is a nullable string used for Third Party Initiated Login. Existing clients only need a value set for this property if the IdentityServer host itself is using third party initiated login (e.g., if you are building a client application portal within your IdentityServer) and want the client to be part of the portal.\nNew properties added to the Client Model for DPoP support:\nRequireDPoP is a non-nullable boolean flag that controls if a client is required to use DPoP. Existing clients that are not using DPoP can set this to false. DPoPValidationMode is a non-nullable column that stores a \u0026ldquo;flags\u0026rdquo;-style enum that controls the DPoP validation mechanism. In most databases, this is represented as an integer. Existing clients that are not using DPoP can set its value to 0. DPoPClockSkew is a non-nullable timespan that controls how much clock skew is allowed for a particular DPoP client. Existing clients that are not using DPoP can set its value to a timespan of length 0. IdentityServer is abstracted from the data store on multiple levels, so the exact steps involved in updating your data store will depend on your implementation details.\nCustom Store Implementations The core of IdentityServer is written against the store interfaces, which abstract all the implementation details of actually storing data. If your IdentityServer implementation includes a custom implementation of those stores, then you will have to determine how best to include the changes in the model in the underlying data store and make any necessary changes to schemas, if your data store requires that.\nDuende.IdentityServer.EntityFramework We also provide a default implementation of the stores in the Duende.IdentityServer.EntityFramework package, but this implementation is still highly abstracted because it is usable with any database that has an EF provider. Different database vendors have very different dialects of sql that have different syntax and type systems, so we don\u0026rsquo;t provide schema changes directly. Instead, we provide the Entity Framework entities and mappings which can be used with Entity Framework\u0026rsquo;s migrations feature to generate the schema updates that are needed in your database.\nTo generate a migration for the new columns, run the command below. Note that you might need to adjust paths based on your specific organization of the migration files.\ndotnet ef migrations add Update_DuendeIdentityServer_v6_3 -c ConfigurationDbContext -o Migrations/ConfigurationDb Then to apply this migration to your database:\ndotnet ef database update -c ConfigurationDbContext Some organizations prefer to use other tools for managing schema changes. You\u0026rsquo;re free to manage your schema however you see fit, as long as the entities can be successfully mapped. Even if you\u0026rsquo;re not going to ultimately use Entity Framework migrations to manage your database changes, generating a migration can be a useful development step to get an idea of what needs to be done.\nStep 3: Verify Data Protection Configuration IdentityServer depends on ASP.NET Data Protection. Data Protection encrypts and signs data using keys managed by ASP.NET. Those keys are isolated by application name, which by default is set to the content root path of the host. This prevents multiple applications from sharing encryption keys, which is necessary to protect your encryption against certain forms of attack. However, this means that if your content root path changes, the default settings for data protection will prevent you from using your old keys. Beginning in .NET 6, the content root path was normalized so that it ends with a directory separator. In .NET 7 that change was reverted. This means that your content root path might change if you upgrade from .NET 6 to .NET 7. This can be mitigated by explicitly setting the application name and removing the separator character. See Microsoft\u0026rsquo;s documentation for more information.\nStep 4: Breaking changes A new ITokenCleanupService interface has been extracted from the TokenCleanupService, and IdentityServer now depends on that interface, rather than the service itself. Customizations of TokenCleanupService that previously were implemented by deriving from that class and registering the derived class in the DI system need to\nRegister the derived class as an implementation of ITokenCleanupService, and Remove the IServerSideSessionsMarker from any calls to the base constructor. See issue #981.\nThe TokenCleanupService.RemoveExpiredGrantsAsync method was renamed to CleanupGrantsAsync to reflect that it performs all grant cleanup work, including removing consumed grants and expired device codes in addition to expired grants. In the strictest sense, this is a breaking change, but it is very unlikely to cause issues during an upgrade because even though RemoveExpiredGrantsAsync was public, it was not virtual. If you were using RemoveExpiredGrantsAsync elsewhere, update your code to use the new name.\nSee issue #981.\nThe value of the typ claim in the header of Logout tokens has changed to logout+jwt, which complies with OpenID Connect Back-Channel Logout 1.0. Clients that were previously validating the typ need to be updated, or the old typ can continue to be used via the new LogoutTokenJwtType configuration option.\nSee issue #1169.\nThe TokenResponseGenerator.ProcessTokenRequestAsync virtual method, which generates access and refresh tokens and adds them to a response object, is now called by all token flows except the refresh token flow. This unifies the programming and extensibility model of the generator, which previously had duplicated code in some flows. If you have overridden this virtual method, be aware that it will now be called in all flows. Previously, the authorization code flow, device code flow, and CIBA flow did not invoke this method.\nSee pull request: #1178.\nOne time use (rotated) refresh tokens are now deleted immediately when they are used by default. If you rely on the existing behavior of marking refresh tokens as consumed (perhaps to allow for lenient rotations or replay detection), set the new PersistentGrantOptions.DeleteOneTimeOnlyRefreshTokensOnUse option to false.\nSee issue #1102.\nStep 5: Done! That\u0026rsquo;s it. Of course, at this point you can and should test that your IdentityServer is updated and working properly.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/data/operational/keys/",
    "title": "Keys",
    "tags": [],
    "description": "",
    "content": "The automatic key management feature in Duende IdentityServer requires a store to persist keys that are dynamically created.\nSigning Key Store By default, the file system is used, but the storage of these keys is abstracted behind a extensible store interface. The ISigningKeyStore is that storage interface.\nRegistering a custom signing key store To register a custom signing key store in the DI container, there is a AddSigningKeyStore helper on the IIdentityServerBuilder. For example:\npublic void ConfigureServices(IServiceCollection services) { services.AddIdentityServer() .AddSigningKeyStore\u0026lt;YourCustomStore\u0026gt;(); } Key Lifecycle When keys are required, LoadKeysAsync will be called to load them all from the store. They are then cached automatically for some amount of time based on configuration. Periodically a new key will be created, and StoreKeyAsync will be used to persist the new key. Once a key is past its retirement, DeleteKeyAsync will be used to purge the key from the store.\nSerialized Key The SerializedKey is the model that contains the key data to persist.\nIt is expected that the Id is the unique identifier for the key in the store. The Data property is the main payload of the key and contains a copy of all the other values. Some of the properties affect how the Data is processed (e.g. DataProtected), and the other properties are considered read-only and thus can\u0026rsquo;t be changed to affect the behavior (e.g. changing the Created value will not affect the key lifetime, nor will changing Algorithm change which signing algorithm the key is used for).\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/ui/login/context/",
    "title": "Login Context",
    "tags": [],
    "description": "",
    "content": "The returnUrl query parameter passed to the login page refers to the URL the prior request came from. This URL typically refers to the IdentityServer authorization endpoint and contains the original request parameters sent from the client. These parameters might contain information your login page needs to customize its workflow. Some examples would be for branding, dynamic page customization (e.g. which external login providers to use), or controlling what credentials the client application expects (e.g. perhaps MFA is required).\nAuthorization Request Context In order to read the original authorize request parameter values, you can use the interaction service. It provides a GetAuthorizationContextAsync API that will extract that information from the returnUrl and return an AuthorizationRequest object which contains these values.\nIt is unnecessary (and discouraged) for your login page logic to parse the returnUrl itself.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/configuration/dcr/reference/response/",
    "title": "Response Generation",
    "tags": [],
    "description": "DCR Reference",
    "content": "IDynamicClientRegistrationResponseGenerator The IDynamicClientRegistrationResponseGenerator interface defines the contract for a service that generates dynamic client registration responses.\npublic interface IDynamicClientRegistrationResponseGenerator Members name description WriteBadRequestError(…) Writes a bad request error to the HTTP context. WriteContentTypeError(…) Writes a content type error to the HTTP response. WriteProcessingError(…) Writes a processing error to the HTTP context. WriteResponse(…) Writes a response object to the HTTP context with the given status code. WriteSuccessResponse(…) Writes a success response to the HTTP context. WriteValidationError(…) Writes a validation error to the HTTP context. DynamicClientRegistrationResponseGenerator The DynamicClientRegistrationResponseGenerator is the default implementation of the IDynamicClientRegistrationResponseGenerator. If you wish to customize a particular aspect of response generation, you can extend this class and override the appropriate methods. You can also set JSON serialization options by overriding its SerializerOptions property.\nMembers name description SerializerOptions { get; set; } The options used for serializing json in responses. "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/session/server_side_sessions/",
    "title": "Server-side Sessions",
    "tags": [],
    "description": "BFF",
    "content": "By default, ASP.NET Core\u0026rsquo;s cookie handler will store all user session data in a protected cookie. This works very well unless cookie size or revocation becomes an issue.\nDuende.BFF includes all the plumbing to store your sessions server-side. The cookie will then only be used to transmit the session ID between the browser and the BFF host. This has the following advantages\nthe cookie size will be very small and constant - regardless how much data (e.g. token or claims) is stored in the authentication session the session can be also revoked outside the context of a browser interaction, for example when receiving a back-channel logout notification from the upstream OpenID Connect provider Configuring Server-side Sessions Server-side session can be enabled in Startup:\nservices.AddBff() .AddServerSideSessions(); The default implementation stores the session in-memory. This is useful for testing, but for production you typically want a more robust storage mechanism. We provide an implementation of the session store built with EntityFramework (EF) that can be used with any database with an EF provider (e.g. Microsoft SQL Server). You can also use a custom store. See extensibility for more information.\nUsing Entity Framework for the Server-side Session Store To use the EF session store, register it by calling AddEntityFrameworkServerSideSessions, like this:\nvar cn = _configuration.GetConnectionString(\u0026#34;db\u0026#34;); services.AddBff() .AddEntityFrameworkServerSideSessions(options=\u0026gt; { options.UseSqlServer(cn); }); Entity Framework Migrations Most datastores that you might use with Entity Framework use a schema to define the structure of their data. Duende.BFF.EntityFramework doesn\u0026rsquo;t make any assumptions about the underlying datastore, how (or indeed even if) it defines its schema, or how schema changes are managed by your organization. For these reasons, Duende does not directly support database creation, schema changes, or data migration by publishing database scripts. You are expected to manage your database in the way your organization sees fit. Using EF migrations is one possible approach to that, which Duende facilitates by publishing entity classes in each version of Duende.BFF.EntityFramework. An example project that uses those entities to create migrations is here.\nSession Store Cleanup Added in v1.2.0.\nAbandoned sessions will remain in the store unless something removes the stale entries. If you wish to have such sessions cleaned up periodically, then you can configure the EnableSessionCleanup and SessionCleanupInterval options:\nservices.AddBff(options =\u0026gt; { options.EnableSessionCleanup = true; options.SessionCleanupInterval = TimeSpan.FromMinutes(5); }) .AddServerSideSessions(); This requires an implementation of IUserSessionStoreCleanup in the DI system.\nIf using Entity Framework Core, then the IUserSessionStoreCleanup implementation is provided for you when you use AddEntityFrameworkServerSideSessions. Just enable session cleanup:\nvar cn = _configuration.GetConnectionString(\u0026#34;db\u0026#34;); services.AddBff(options =\u0026gt; { options.EnableSessionCleanup = true; }) .AddEntityFrameworkServerSideSessions(options=\u0026gt; { options.UseSqlServer(cn); }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/stores/persisted_grant_store/",
    "title": "Persisted Grant Store",
    "tags": [],
    "description": "",
    "content": "The IPersistedGrantStore interface is the contract for a service that stores, retrieves, and deletes persisted grants. A grant is a somewhat abstract concept that is used in various protocol flows and represents that a resource owner has given authorization of some kind. Grants that require server side state in IdentityServer are the persisted grants stored by the IPersistedGrantStore.\nThe IPersistedGrantStore is abstracted to allow for storage of several grant types, including authorization codes, refresh tokens, user consent, and reference tokens. Some specialized grant types, including device flow and CIBA, use their own specialized stores instead.\nIdentityServer includes two implementations of the IPersistedGrantStore. The InMemoryPersistedGrantStore unsurprisingly persists grants in memory and is intended for demos, tests, and other situations where persistent storage is not actually necessary. In contrast, the Duende.IdentityServer.EntityFramework.Stores.PersistedGrantStore durably persists grants to a database using EntityFramework, and can be used with any database with an EF provider.\nYou can also provide your own implementation of the IPersistedGrantStore. This allows for complete control of the data access code so that you can support other data stores that lack an EF provider, and so that you can optimize the data access for your environment and usage.\nDuende.IdentityServer.Stores.IPersistedGrantStore Members name description Task StoreAsync(PersistedGrant grant); Stores a grant. Task GetAsync(string key); Retrieves a grant by its key. Task\u0026lt;IEnumerable\u0026gt; GetAllAsync(PersistedGrantFilter filter); Retrieves all grants that fulfill the conditions of a filter. Task RemoveAsync(string key); Removes a grant by key. Task RemoveAllAsync(PersistedGrantFilter filter); Removes all grants that fulfill the conditions of a filter. Duende.IdentityServer.Models.PersistedGrant Members name description string Key A string that uniquely identifies the grant. string Type A string that specifies the type of grant. The possible values are constants in the PersistedGrantTypes class (see below). string SubjectId The identifier of the subject that granted authorization. string SessionId The identifier of the session where the grant was made, if applicable. string ClientId The identifier of the client that was granted authorization. string Description The description the user assigned to the device being authorized. DateTime CreationTime The time that the grant was created. DateTime? Expiration The time that the grant expires. DateTime? ConsumedTime The time that the grant was consumed. string Data A serialized and data protected representation of the grant. Key Property The Key property contains a SHA256 hash of the value used to refer to individual grants. For authorization codes, refresh tokens, and reference tokens, the stored Key hashes the actual value sent to the client as part of the protocol flow. For example, refresh token records use a hash of the actual refresh token parameter sent to the client as their Key. In contrast, user consent is not identified by a single protocol parameter. Instead, the Key value for user consent records comes from a hash of a combination of subject id and client id. In all cases, the value that is hashed to compute the Key also includes the grant type.\nBeginning in v6.0, the hashes that IdentityServer passes to the IPersistedGrantStore to use as Key values are formatted as hex values. In earlier versions, the Keys were base-64 encoded. That occasionally caused database collation issues in case-insensitive databases, which prompted the change to hex encoding. To facilitate migration, IdentityServer adds a version suffix (\u0026quot;-1\u0026quot;) to indicate that the newer hex encoding should be used during hashing. For example, the refresh token parameter \u0026ldquo;27931A10FBCA75583C5576DAFB5DBDF0A9BCA8D6BD38B7CF142C47D6E44ED24D-1\u0026rdquo; ends in the \u0026ldquo;-1\u0026rdquo; suffix, so when IdentityServer searches for its persisted grant record, it computes the hash of the parameter value, applies hex encoding, and then calls IPersistedGrantStore.GetAsync(\u0026hellip;), passing the resulting hex encoded value. A refresh token created before v6.0 would not include the \u0026ldquo;-1\u0026rdquo; suffix, so IdentityServer would instead pass a base-64 encoded hash to the GetAsync method.\nHowever, consent records were not migrated to use hex encoding of their Key values until IdentityServer v7.0. Since there\u0026rsquo;s no protocol parameter that corresponds to consent records, there\u0026rsquo;s no way to use the protocol parameters to determine which encoding to use. So, prior to v7.0, the consent Key values remained in the base-64 encoding.\nBeginning in v7.0, IdentityServer uses hex encoding for Consent Key values, but falls back to base-64 encoding when hex encoding fails to find a grant. In that case, IdentityServer will automatically update the grant to use a hex encoded Key.\nData Property The Data property contains information that is specific to the grant type. For example, consent records contain the scopes that the user consented to grant to the client.\nThe Data property also contains a copy of the SubjectId, SessionId, ClientId, Description, CreationTime, and Expiration properties when those properties are applicable to the grant type. The copy in the Data is treated as authoritative by IdentityServer, in the sense that the copy is used when grants are retrieved from the store. The other properties exist to enable querying the grants and/or for informational purposes and should be treated as read-only.\nBy default, the Data property is encrypted at rest using the ASP.NET Data Protection API. The DataProtectData option can be used to disable this encryption.\nTime Stamps All grants set their CreationTime when they are created as a UTC timestamp.\nGrants that expire set their Expiration when they are created as well. Consent records only expire if the ConsentLifetime property of the Client is set. By default, ConsentLifetime is not set and consent lasts until it is revoked. Authorization code records always include an Expiration. They expire after the AuthorizationCodeLifetime has elapsed, so they are initialized with their Expiration set that far into the future. Reference token records expire in the same way, with their Expiration controlled by the AccessTokenLifetime. Refresh token records also always include Expiration, controlled by the AbsoluteRefreshTokenLifetime and SlidingRefreshTokenLifetime client settings. Custom grant records should set the Expiration to indicate that they are only usable for a length of time, or not set it to indicate that they can be used indefinitely.\nSome grants can set a ConsumedTime when they are used. This applies to grants that are intended to be used once and that need to be retained after their use for some purpose (for example, replay detection or to allow certain kinds of limited reuse). Refresh tokens can be configured to have one-time use semantics. Refresh tokens that are configured this way set a ConsumedTime when they are used. Authorization codes do not set a ConsumedTime. They are instead always removed on use. ConsumedTime is not applicable to reference tokens and consent, so they both never set it. Custom grant records should set the ConsumedTime if one-time use semantics are appropriate for the grant.\nPersistedGrantFilter /// \u0026lt;summary\u0026gt; /// Represents a filter used when accessing the persisted grants store. /// Setting multiple properties is interpreted as a logical \u0026#39;AND\u0026#39; to further filter the query. /// At least one value must be supplied. /// \u0026lt;/summary\u0026gt; public class PersistedGrantFilter { /// \u0026lt;summary\u0026gt; /// Subject id of the user. /// \u0026lt;/summary\u0026gt; public string SubjectId { get; set; } /// \u0026lt;summary\u0026gt; /// Session id used for the grant. /// \u0026lt;/summary\u0026gt; public string SessionId { get; set; } /// \u0026lt;summary\u0026gt; /// Client id the grant was issued to. /// \u0026lt;/summary\u0026gt; public string ClientId { get; set; } /// \u0026lt;summary\u0026gt; /// Client ids the grant was issued to. /// \u0026lt;/summary\u0026gt; public IEnumerable\u0026lt;string\u0026gt; ClientIds { get; set; } /// \u0026lt;summary\u0026gt; /// The type of grant. /// \u0026lt;/summary\u0026gt; public string Type { get; set; } /// \u0026lt;summary\u0026gt; /// The types of grants. /// \u0026lt;/summary\u0026gt; public IEnumerable\u0026lt;string\u0026gt; Types { get; set; } } PersistedGrantTypes The types of persisted grants are defined by the IdentityServerConstants.PersistedGrantTypes constants:\npublic static class PersistedGrantTypes { public const string AuthorizationCode = \u0026#34;authorization_code\u0026#34;; public const string BackChannelAuthenticationRequest = \u0026#34;ciba\u0026#34;; public const string ReferenceToken = \u0026#34;reference_token\u0026#34;; public const string RefreshToken = \u0026#34;refresh_token\u0026#34;; public const string UserConsent = \u0026#34;user_consent\u0026#34;; public const string DeviceCode = \u0026#34;device_code\u0026#34;; public const string UserCode = \u0026#34;user_code\u0026#34;; } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/stores/device_flow_store/",
    "title": "Device Flow Store",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Stores.IDeviceFlowStore Models storage of grants for the device flow.\n/// \u0026lt;summary\u0026gt; /// Interface for the device flow store /// \u0026lt;/summary\u0026gt; public interface IDeviceFlowStore { /// \u0026lt;summary\u0026gt; /// Stores the device authorization request. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;deviceCode\u0026#34;\u0026gt;The device code.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;userCode\u0026#34;\u0026gt;The user code.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;The data.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task StoreDeviceAuthorizationAsync(string deviceCode, string userCode, DeviceCode data); /// \u0026lt;summary\u0026gt; /// Finds device authorization by user code. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;userCode\u0026#34;\u0026gt;The user code.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task\u0026lt;DeviceCode\u0026gt; FindByUserCodeAsync(string userCode); /// \u0026lt;summary\u0026gt; /// Finds device authorization by device code. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;deviceCode\u0026#34;\u0026gt;The device code.\u0026lt;/param\u0026gt; Task\u0026lt;DeviceCode\u0026gt; FindByDeviceCodeAsync(string deviceCode); /// \u0026lt;summary\u0026gt; /// Updates device authorization, searching by user code. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;userCode\u0026#34;\u0026gt;The user code.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;The data.\u0026lt;/param\u0026gt; Task UpdateByUserCodeAsync(string userCode, DeviceCode data); /// \u0026lt;summary\u0026gt; /// Removes the device authorization, searching by device code. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;deviceCode\u0026#34;\u0026gt;The device code.\u0026lt;/param\u0026gt; Task RemoveByDeviceCodeAsync(string deviceCode); } DeviceCode /// \u0026lt;summary\u0026gt; /// Represents data needed for device flow. /// \u0026lt;/summary\u0026gt; public class DeviceCode { /// \u0026lt;summary\u0026gt; /// Gets or sets the creation time. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The creation time. /// \u0026lt;/value\u0026gt; public DateTime CreationTime { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the lifetime. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The lifetime. /// \u0026lt;/value\u0026gt; public int Lifetime { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the client identifier. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The client identifier. /// \u0026lt;/value\u0026gt; public string ClientId { get; set; } /// \u0026lt;summary\u0026gt; /// Gets the description the user assigned to the device being authorized. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The description. /// \u0026lt;/value\u0026gt; public string Description { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets a value indicating whether this instance is open identifier. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt; if this instance is open identifier; otherwise, \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;. /// \u0026lt;/value\u0026gt; public bool IsOpenId { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets a value indicating whether this instance is authorized. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt; if this instance is authorized; otherwise, \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;. /// \u0026lt;/value\u0026gt; public bool IsAuthorized { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the requested scopes. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The authorized scopes. /// \u0026lt;/value\u0026gt; public IEnumerable\u0026lt;string\u0026gt; RequestedScopes { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the authorized scopes. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The authorized scopes. /// \u0026lt;/value\u0026gt; public IEnumerable\u0026lt;string\u0026gt; AuthorizedScopes { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the subject. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The subject. /// \u0026lt;/value\u0026gt; public ClaimsPrincipal Subject { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the session identifier. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The session identifier. /// \u0026lt;/value\u0026gt; public string SessionId { get; set; } } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/services/persisted_grant_service/",
    "title": "Persisted Grant Service",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Services.IPersistedGrantService Provides access to a user\u0026rsquo;s grants.\n/// \u0026lt;summary\u0026gt; /// Implements persisted grant logic /// \u0026lt;/summary\u0026gt; public interface IPersistedGrantService { /// \u0026lt;summary\u0026gt; /// Gets all grants for a given subject ID. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;subjectId\u0026#34;\u0026gt;The subject identifier.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task\u0026lt;IEnumerable\u0026lt;Grant\u0026gt;\u0026gt; GetAllGrantsAsync(string subjectId); /// \u0026lt;summary\u0026gt; /// Removes all grants for a given subject id, and optionally client id and session id combination. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;subjectId\u0026#34;\u0026gt;The subject identifier.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;clientId\u0026#34;\u0026gt;The client identifier (optional).\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;sessionId\u0026#34;\u0026gt;The session id (optional).\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task RemoveAllGrantsAsync(string subjectId, string clientId = null, string sessionId = null); } Grant /// \u0026lt;summary\u0026gt; /// Models a grant the user has given. /// \u0026lt;/summary\u0026gt; public class Grant { /// \u0026lt;summary\u0026gt; /// Gets or sets the subject identifier. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The subject identifier. /// \u0026lt;/value\u0026gt; public string SubjectId { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the client identifier. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The client identifier. /// \u0026lt;/value\u0026gt; public string ClientId { get; set; } /// \u0026lt;summary\u0026gt; /// Gets the description the user assigned to the device being authorized. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The description. /// \u0026lt;/value\u0026gt; public string Description { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the scopes. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The scopes. /// \u0026lt;/value\u0026gt; public IEnumerable\u0026lt;string\u0026gt; Scopes { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the creation time. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The creation time. /// \u0026lt;/value\u0026gt; public DateTime CreationTime { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the expiration. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The expiration. /// \u0026lt;/value\u0026gt; public DateTime? Expiration { get; set; } } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/fundamentals/claims/",
    "title": "Claims",
    "tags": [],
    "description": "",
    "content": "IdentityServer emits claims about users and clients into tokens. You are in full control of which claims you want to emit, in which situations you want to emit those claims, and where to retrieve those claims from.\nUser claims User claims can be emitted in both identity and access tokens and in the userinfo endpoint. The central extensibility point to implement to emit claims is called the profile service. The profile service is responsible for both gathering claim data and deciding which claims should be emitted.\nWhenever IdentityServer needs the claims for a user, it invokes the registered profile service with a context that presents detailed information about the current request, including\nthe client that is making the request the identity of the user the type of the request (access token, id token, or userinfo) the requested claim types, which are the claims types associated with requested scopes and resources Strategies for Emitting Claims You can use different strategies to determine which claims to emit based on the information in the profile context.\nemit claims based on the requested claim types emit claims based on user or client identity always emit certain claims Emit claims based on the client\u0026rsquo;s request You can filter the claims you emit to only include the claim types requested by the client. If your client requires consent, this will also give end users the opportunity to approve or deny sharing those claims with the client.\nClients can request claims in several ways:\nRequesting an IdentityResource by including the scope parameter for the IdentityResource requests the claims associated with the IdentityResource in its UserClaims collection. Requesting an ApiScope by including the scope parameter for the ApiScope requests the claims associated with the ApiScope in its UserClaims collection. Requesting an ApiResource by including the resource indicator parameter for the ApiResource requests the claims associated with the ApiResource in its UserClaims collection. The RequestedClaimTypes property of the ProfileDataRequestContext contains the collection of claims requested by the client.\nIf your profile service extends the DefaultProfileService, you can use its AddRequestedClaims method to add only requested and approved claims. The intent is that your profile service can retrieve claim data and then filter that claim data based on what was requested by the client. For example:\npublic class SampleProfileService : DefaultProfileService { public virtual async Task GetProfileDataAsync(ProfileDataRequestContext context) { var claims = await GetClaimsAsync(context); context.AddRequestedClaims(claims); } private async Task\u0026lt;Claim\u0026gt; GetClaimsAsync(ProfileDataRequestContext context) { // Your implementation that retrieves claims goes here } } Always emit claims We generally recommend emitting claims based on the requested claim types, as that respects the scopes and resources requested by the client and gives the end user an opportunity to consent to this sharing of information. However, if you have claims that don\u0026rsquo;t need to follow such rules, such as claims that are an integral part of the user\u0026rsquo;s identity and that are needed in most scenarios, they can be added by directly updating the context.IssuedClaims collection. For example:\npublic class SampleProfileService : DefaultProfileService { public virtual async Task GetProfileDataAsync(ProfileDataRequestContext context) { var claims = await GetClaimsAsync(context); context.IssuedClaims.AddRange(claims); } private async Task\u0026lt;Claim\u0026gt; GetClaimsAsync(ProfileDataRequestContext context) { // Your implementation that retrieves claims goes here } } Emit claims based on the user or client identity Finally, you might have claims that are only appropriate for certain users or clients. Your ProfileService can add whatever filtering or logic that you like.\nThe Subject of the ProfileDataRequestContext When the profile service is invoked to add claims to tokens, the Subject property on the ProfileDataRequestContext contains the principal that was issued during user sign-in. Typically, the profile service will source some claims from the Subject and others from databases or other data sources.\nWhen the profile service is called for requests to the userinfo endpoint, the Subject property will not contain the principal issued during user sign-in, since userinfo calls don\u0026rsquo;t happen as part of a session. Instead, the Subject property will contain a claims principal populated with the claims in the access token used to authorize the userinfo call. You can check the caller of the profile service by querying the Caller property on the context.\nClient claims Client claims are a set of pre-defined claims that are emitted in access tokens. They are defined on a per-client basis, meaning that each client can have its own unique set of client claims. The following shows an example of a client that is associated with a certain customer in your system:\nvar client = new Client { ClientId = \u0026#34;client\u0026#34;, // rest omitted Claims = { new ClientClaim(\u0026#34;customer_id\u0026#34;, \u0026#34;123\u0026#34;) } }; To avoid accidental collision with user claims, client claims are prefixed with client_. For example, the above ClientClaim would be emitted as the client_customer_id claim type in access tokens. You can change or remove this prefix by setting the ClientClaimsPrefix on the client definition.\nBy default, client claims are only sent in the client credentials flow. If you want to enable them for other flows, you need to set the AlwaysSendClientClaims property on the client definition.\nSetting client claims dynamically If you want to set client claims dynamically, you could either do that at client load time (via a client store implementation), or using a custom token request validator.\nClaim Serialization Claim values are serialized based on the ClaimValueType of the claim. Claims that don\u0026rsquo;t specify a ClaimValueType are simply serialized as strings. Claims that specify a ClaimValueType of System.Security.Claims.ClaimValueTypes.Integer, System.Security.Claims.ClaimValueTypes.Integer32, System.Security.Claims.ClaimValueTypes.Integer64, System.Security.Claims.ClaimValueTypes.Double, or System.Security.Claims.ClaimValueTypes.Boolean are parsed as the corresponding type, while those that specify IdentityServerConstants.ClaimValueTypes.Json are serialized to JSON using System.Text.Json.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/models/grant_validation_result/",
    "title": "Grant Validation Result",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Validation.GrantValidationResult The GrantValidationResult class models the outcome of grant validation for extensions grants and resource owner password grants.\nIt models either a successful validation result with claims (e.g. subject ID) or an invalid result with an error code and message, e.g.:\npublic class ExtensionGrantValidator : IExtensionGrantValidator { public Task ValidateAsync(ExtensionGrantValidationContext context) { // some validation steps if (success) { context.Result = new GrantValidationResult( subject: \u0026#34;818727\u0026#34;, authenticationMethod: \u0026#34;custom\u0026#34;, claims: extraClaims); } else { // custom error message context.Result = new GrantValidationResult( TokenRequestErrors.InvalidGrant, \u0026#34;invalid custom credential\u0026#34;); } return Task.CompletedTask; } } It also allows passing additional custom values that will be included in the token response, e.g.:\ncontext.Result = new GrantValidationResult( subject: \u0026#34;818727\u0026#34;, authenticationMethod: \u0026#34;custom\u0026#34;, customResponse: new Dictionary\u0026lt;string, object\u0026gt; { { \u0026#34;some_data\u0026#34;, \u0026#34;some_value\u0026#34; } }); This will result in the following token response:\n{ \u0026#34;access_token\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;Bearer\u0026#34;, \u0026#34;expires_in\u0026#34;: 360, \u0026#34;some_data\u0026#34;: \u0026#34;some_value\u0026#34; } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/samples/clients/",
    "title": "Clients",
    "tags": [],
    "description": "Samples",
    "content": "This section contains a collection of various client technologies connecting to IdentityServer.\n.NET 4.8 Clients This sample shows how to add OpenID Connect code flow with PKCE to a .NET 4.8 WebForms client and a .NET 4.8 MVC Client. Each client can login, logout, make API requests to a .NET 4.8 WebApi using OAuth, and refresh access tokens.\nlink to source code\n.NET MAUI client This sample shows how to use the IdentityModel.OidcClient FOSS library to connect a .NET MAUI app to IdentityServer\nlink to source code\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/extensibility/management/user/",
    "title": "BFF User Endpoint Extensibility",
    "tags": [],
    "description": "",
    "content": "The BFF user endpoint can be customized by implementing the IUserService or by extending DefaultUserService, its default implementation. In most cases, extending the default implementation is preferred, as it has several virtual methods that can be overridden to customize particular aspects of how the request is processed. The DefaultUserService\u0026rsquo;s virtual methods are ProcessRequestAsync, GetUserClaims, and GetManagementClaims.\nRequest Processing ProcessRequestAsync is the top level function called in the endpoint service and can be used to add arbitrary logic to the endpoint.\nFor example, you could take whatever actions you need before normal processing of the request like this:\npublic override Task ProcessRequestAsync(HttpContext context) { // Custom logic here return base.ProcessRequestAsync(context); } User Claims GetUserClaims produces the collection of claims that describe the user. The default implementation returns all the claims in the user\u0026rsquo;s session. Your override could add claims from some other source or manipulate the claims in arbitrary ways.\nFor example, you could add additional claims to the user endpoint that would not be part of the session like this:\nprotected override IEnumerable\u0026lt;ClaimRecord\u0026gt; GetUserClaims(AuthenticateResult authenticateResult) { var baseClaims = base.GetUserClaims(authenticateResult); var sub = authenticateResult.Principal.FindFirstValue(\u0026#34;sub\u0026#34;); var otherClaims = getAdditionalClaims(sub); // Retrieve claims from some data store return baseClaims.Append(otherClaims); } Management Claims GetManagementClaims is responsible for producing additional claims that are useful for user management. The default implementation creates bff:session_expires_in, bff:session_state, and bff:logout_url claims. Your implementation could change those claims or add additional custom claims.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/session/management/back-channel-logout/",
    "title": "BFF Back-Channel Logout Endpoint",
    "tags": [],
    "description": "",
    "content": "The /bff/backchannel endpoint is an implementation of the OpenID Connect Back-Channel Logout specification. The remote identity provider can use this endpoint to end the BFF\u0026rsquo;s session via a server to server call, without involving the user\u0026rsquo;s browser. This design avoids problems with 3rd party cookies associated with front-channel logout.\nTypical Usage The back-channel logout endpoint is invoked by the remote identity provider when it determines that sessions should be ended. IdentityServer will send back-channel logout requests if you configure your client\u0026rsquo;s BackChannelLogoutUri. When a session ends at IdentityServer, any client that was participating in that session that has a back-channel logout URI configured will be sent a back-channel logout request. This typically happens when another application signs out. Expiration of IdentityServer server side sessions can also be configured to send back-channel logout requests, though this is disabled by default.\nDependencies The back-channel logout endpoint depends on server-side sessions in the BFF, which must be enabled to use this endpoint. Note that such server-side sessions are distinct from server-side sessions in IdentityServer.\nRevoke all sessions Back-channel logout tokens include a sub (subject ID) and sid (session ID) claim to describe which session should be revoked. By default, the back-channel logout endpoint will only revoke the specific session for the given subject ID and session ID. Alternatively, you can configure the endpoint to revoke every session that belongs to the given subject ID by setting the BackchannelLogoutAllUserSessions option to true.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/fundamentals/keys/automatic_key_management/",
    "title": "Automatic Key Management",
    "tags": [],
    "description": "",
    "content": "Duende IdentityServer can manage signing keys for you using the Automatic Key Management feature.\nAutomatic Key Management follows best practices for handling signing key material, including\nautomatic rotation of keys secure storage of keys at rest using data protection announcement of upcoming new keys maintenance of retired keys Automatic Key Management is included in IdentityServer Business Edition or higher.\nConfiguration Automatic Key Management is configured by the options in the KeyManagement property on the IdentityServerOptions.\nManaged Key Lifecycle Keys created by Automatic Key Management move through several phases. First, new keys are announced, that is, they are added to the list of keys in discovery, but not yet used for signing. After a configurable amount of PropagationTime, keys are promoted to be signing credentials, and will be used by IdentityServer to sign tokens. Eventually, enough time will pass that the key is older than the configurable RotationTime, at which point the key is retired, but kept in discovery for a configurable RetentionDuration. After the RetentionDuration has passed, keys are removed from discovery, and optionally deleted.\nThe default is to rotate keys every 90 days, announce new keys with 14 days of propagation time, retain old keys for a duration of 14 days, and to delete keys when they are retired. All of these options are configurable in the KeyManagement options. For example:\nvar builder = services.AddIdentityServer(options =\u0026gt; { // new key every 30 days options.KeyManagement.RotationInterval = TimeSpan.FromDays(30); // announce new key 2 days in advance in discovery options.KeyManagement.PropagationTime = TimeSpan.FromDays(2); // keep old key for 7 days in discovery for validation of tokens options.KeyManagement.RetentionDuration = TimeSpan.FromDays(7); // don\u0026#39;t delete keys after their retention period is over options.KeyManagement.DeleteRetiredKeys = false; }); Key storage Automatic Key Management stores keys through the abstraction of the ISigningKeyStore. You can implement this extensibility point to customize the storage of your keys (perhaps using a key vault of some kind), or use one of the two implementations of the ISigningKeyStore that we provide:\nthe default FileSystemKeyStore, which writes keys to the file system. the EntityFramework operational store which writes keys to a database using EntityFramework. The default FileSystemKeyStore writes keys to the KeyPath directory configured in your IdentityServer host, which defaults to the directory ~/keys. This directory should be excluded from source control.\nIf you are deploying in a load balanced environment and wish to use the FileSystemKeyStore, all instances of IdentityServer will need read/write access to the KeyPath.\nvar builder = services.AddIdentityServer(options =\u0026gt; { // set path to store keys options.KeyManagement.KeyPath = \u0026#34;/home/shared/keys\u0026#34;; }); Encryption of Keys at Rest The keys created by Automatic Key Management are sensitive cryptographic secrets that should be encrypted at rest. By default, keys managed by Automatic Key Management are protected at rest using ASP.NET Core Data Protection. This is controlled with the DataProtectKeys flag, which is on by default. We recommend leaving this flag on unless you are using a custom ISigningKeyStore to store your keys in a secure location that will ensure keys are encrypted at rest. For example, if you implement the ISigningKeyStore to store your keys in Azure Key Vault, you could safely disabled DataProtectKeys, relying on Azure Key Vault to encrypt your signing keys at rest.\nSee the deployment section for more information about setting up data protection.\nManage multiple keys By default, Automatic Key Management will maintain a signing credential and validation keys for a single cryptographic algorithm (RS256). You can specify multiple keys, algorithms, and if those keys should additionally get wrapped in an X.509 certificate. Automatic key management will create and rotate keys for each signing algorithm you specify.\noptions.KeyManagement.SigningAlgorithms = new[] { // RS256 for older clients (with additional X.509 wrapping) new SigningAlgorithmOptions(SecurityAlgorithms.RsaSha256) { UseX509Certificate = true }, // PS256 new SigningAlgorithmOptions(SecurityAlgorithms.RsaSsaPssSha256), // ES256 new SigningAlgorithmOptions(SecurityAlgorithms.EcdsaSha256) }; When you register multiple signing algorithms, the first in the list will be the default used for signing tokens. Client and API resource definitions both have an AllowedTokenSigningAlgorithm property to override the default on a per resource and client basis.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/fundamentals/keys/static_key_management/",
    "title": "Manual Key Management",
    "tags": [],
    "description": "",
    "content": "Instead of using Automatic Key Management, IdentityServer\u0026rsquo;s signing keys can be set manually. Automatic Key Management is generally recommended, but if you want to explicitly control your keys statically, or you have a license that does not include the feature (e.g. the Starter Edition), you will need to manually manage your keys. With static configuration you are responsible for secure storage, loading and rotation of keys.\nDisabling Key Management The automatic key management feature can be disabled by setting the Enabled flag to false on the the KeyManagement property of IdentityServerOptions:\nvar builder = services.AddIdentityServer(options =\u0026gt; { options.KeyManagement.Enabled = false; }); Key Creation Without automatic key management, you are responsible for creating your own cryptographic keys. Such keys can be created with many tools. Some options include:\nUse the PowerShell commandlet New-SelfSignedCertificate to self-sign your own certificate Create certificates using Azure KeyVault Create certificates using your Public Key Infrastructure. Adding Keys Signing keys are added with the AddSigningCredential configuration method:\nvar builder = services.AddIdentityServer(); var key = LoadKeyFromVault(); // (Your code here) builder.AddSigningCredential(key, SecurityAlgorithms.RsaSha256); You can call AddSigningCredential multiple times if you want to register more than one signing key. When you register multiple signing algorithms, the first one added will be the default used for signing tokens. Client and API resource definitions both have an AllowedTokenSigningAlgorithm property to override the default on a per resource and client basis.\nAnother configuration method called AddValidationKey can be called to register public keys that should be accepted for token validation.\nKey Storage With automatic key management disabled, secure storage of the key material is left to you. This key material should be treated as highly sensitive. Key material should be encrypted at rest, and access to it should be restricted.\nManual Key Rotation With automatic key management disabled, you will need to rotate your keys manually. The rotation process must be done carefully for two reasons:\nClient applications and APIs cache key material. If you begin using a new key too quickly, new tokens will be signed with a key that is not yet in their caches. This will cause clients to not be able to validate the signatures of new id tokens which will prevent users from logging in, and APIs will not be able to validate signatures of access tokens, which will prevent authorization of calls to those APIs. Tokens signed with the old key material probably exist. If you tell APIs to stop using the old key too quickly, APIs will reject the signatures of old tokens, again causing authorization failures at your APIs. There are two solutions to these problems. Which one is right for you depends on the level of control you have over client applications, the amount of downtime that is acceptable, and the degree to which invalidating old tokens matters to you.\nSolution 1: Invalidate all caches when keys are rotated One solution to these problems is to invalidate the caches in all the client applications and APIs immediately after the key is rotated. In ASP.NET, the simplest way to do so is to restart the hosting process, which clears the cached signing keys of the authentication middleware.\nThis is only appropriate if all of the following are true:\nYou have control over the deployment of all of the client applications. You can tolerate a maintenance window in which your services are all restarted. You don\u0026rsquo;t mind that users will need to log in again after the key is rotated. Solution 2: Phased Rotation A more robust solution is to gradually transition from the old to the new key. This requires three phases.\nPhase 1: Announce the new key First, announce a new key that will be used for signing in the future. During this phase, continue to sign tokens with the old key. The idea is to allow for all the applications and APIs to update their caches without any interruption in service. Configure IdentityServer for phase 1 by registering the new key as a validation key.\nvar builder = services.AddIdentityServer(options =\u0026gt; { options.KeyManagement.Enabled = false; }); var oldKey = LoadOldKeyFromVault(); var newKey = LoadNewKeyFromVault(); builder.AddSigningCredential(oldKey, SecurityAlgorithms.RsaSha256); builder.AddValidationKey(newKey, SecurityAlgorithms.RsaSha256) Once IdentityServer is updated with the new key as a validation key, wait to proceed to phase 2 until all the applications and services have updated their signing key caches. The default cache duration in .NET is 24 hours, but this is customizable. You may also need to support clients or APIs built with other platforms or that were customized to use a different value. Ultimately you have to decide how long to wait to proceed to phase 2 in order to ensure that all clients and APIs have updated their caches.\nPhase 2: Start signing with the new key Next, start signing tokens with the new key, but continue to publish the public key of the old key so that tokens that were signed with that key can continue to be validated. The IdentityServer configuration change needed is simply to swap the signing credential and validation key.\nvar builder = services.AddIdentityServer(options =\u0026gt; { options.KeyManagement.Enabled = false; }); var oldKey = LoadOldKeyFromVault(); var newKey = LoadNewKeyFromVault(); builder.AddSigningCredential(newKey, SecurityAlgorithms.RsaSha256); builder.AddValidationKey(oldKey, SecurityAlgorithms.RsaSha256) Again, you need to wait to proceed to phase 3. The delay here is typically shorter, because the reason for the delay is to ensure that tokens signed with the old key remain valid until they expire. IdentityServer\u0026rsquo;s token lifetime defaults to 1 hour, though it is configurable.\nPhase 3: Remove the old key Once enough time has passed that there are no unexpired tokens signed with the old key, it is safe to completely remove the old key.\nvar builder = services.AddIdentityServer(options =\u0026gt; { options.KeyManagement.Enabled = false; }); var newKey = LoadNewKeyFromVault(); builder.AddSigningCredential(newKey, SecurityAlgorithms.RsaSha256); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/fundamentals/keys/migration/",
    "title": "Migrating from Static Keys to Automatic Key Management",
    "tags": [],
    "description": "",
    "content": "To migrate from static to automatic key management, you can set keys manually and enable automatic key management at the same time. This allows the automatic key management feature to begin creating keys and announce them in discovery, while you continue to use the old statically configured key. Eventually you can transition from the statically configured key to the automatically managed keys.\nA signing key registered with AddSigningCredential will take precedence over any keys created by the automatic key management feature. IdentityServer will sign tokens with the credential specified in AddSigningCredential, but also automatically create and manage validation keys.\nValidation keys registered manually with AddValidationKey are added to the collection of validation keys along with the keys produced by automatic key management. When automatic key management is enabled and there are keys statically specified with AddValidationkey, the set of validation keys will include:\nnew keys created by automatic key management that are not yet used for signing old keys created by automatic key management that are retired the keys added explicitly with calls to AddValidationKey. The migration path from manual to automatic keys is a three phase process, similar to the phased approach to manual key rotation. The difference here is that you are phasing out the old key and allowing the automatically generated keys to phase in.\nPhase 1: Announce new (automatic) key First, enable automatic key management while continuing to register your old key as the signing credential. In this phase, the new automatically managed key will be announced so that as client apps and APIs update their caches, they get the new key. IdentityServer will continue to sign keys with your old static key.\nvar builder = services.AddIdentityServer(options =\u0026gt; { options.KeyManagement.Enabled = true; }); var oldKey = LoadOldKeyFromVault(); builder.AddSigningCredential(oldKey, SecurityAlgorithms.RsaSha256); Wait until all APIs and applications have updated their signing key caches, and then proceed to phase 2.\nPhase 2: Start signing with the new (automatic) key Next, switch to using the new automatically managed keys for signing, but still keep the old key for validation purposes.\nvar builder = services.AddIdentityServer(options =\u0026gt; { options.KeyManagement.Enabled = true; }); var oldKey = LoadOldKeyFromVault(); builder.AddValidationKey(oldKey, SecurityAlgorithms.RsaSha256); Keep the old key as a validation key until all tokens signed with that key are expired, and then proceed to phase 3.\nPhase 3: Drop the old key Now the static key configuration can be removed entirely.\nvar builder = services.AddIdentityServer(options =\u0026gt; { options.KeyManagement.Enabled = true; }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/tokens/dynamic_validation/",
    "title": "Dynamic Request Validation and Customization",
    "tags": [],
    "description": "",
    "content": "You can hook into the token request pipeline by implementing the ICustomTokenRequestValidator interface.\nThis allows you to\nadd additional token request validation logic do custom per-client processing add custom response parameters return custom errors and error descriptions modify parameters on-the-fly access token lifetime and type client claims confirmation method The following example emits additional claims and changes the token lifetime on-the-fly based on a granted scope.\npublic class TransactionScopeTokenRequestValidator : ICustomTokenRequestValidator { public Task ValidateAsync(CustomTokenRequestValidationContext context) { var transaction = context .Result .ValidatedRequest .ValidatedResources .ParsedScopes.FirstOrDefault(x =\u0026gt; x.ParsedName == \u0026#34;transaction\u0026#34;); // transaction scope has been requested if (transaction?.ParsedParameter != null) { // emit transaction id as a claim context.Result.ValidatedRequest.ClientClaims.Add( new Claim(transaction.ParsedName, transaction.ParsedParameter)); // also shorten token lifetime context.Result.ValidatedRequest.AccessTokenLifetime = 10; } return Task.CompletedTask; } } You can register your implementation like this:\nbuilder.AddCustomTokenRequestValidator\u0026lt;TransactionScopeTokenRequestValidator\u0026gt;(); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/fundamentals/keys/",
    "title": "Key Management",
    "tags": [],
    "description": "",
    "content": "Duende IdentityServer issues several types of tokens that are cryptographically signed, including identity tokens, JWT access tokens, and logout tokens. To create those signatures, IdentityServer needs key material. That key material can be configured automatically, by using the Automatic Key Management feature, or manually, by loading the keys from a secured location with static configuration.\nIdentityServer supports signing tokens using the RS, PS and ES family of cryptographic signing algorithms.\nAutomatic Key Management Manual Key Management Migrating from Static Keys to Automatic Key Management "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/services/",
    "title": "Services",
    "tags": [],
    "description": "",
    "content": "Services Profile Service Persisted Grant Service Refresh Token Service User Session Service Session Management Service IdentityServer Interaction Service Device Flow Interaction Service Backchannel Authentication Interaction Service Backchannel Authentication User Notification Service "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/overview/support/",
    "title": "Support and Issues",
    "tags": [],
    "description": "",
    "content": "Source Code You can find all source code for IdentityServer and its supporting repos in our organization.\nIssue Tracker The IdentityServer issue tracker and pull requests allow you to follow the current work and submit questions or bug reports.\nMilestones / release notes\nSupport See here for our support policy.\nStandard support and feature requests are handled via our public developer community forum. Please start a discussion there if you need help.\nPriority support is part of our Enterprise Edition. It includes a private email alias, guaranteed two US business days response time.\nReporting a security vulnerability Security issues and bugs should be reported privately here. You should receive a response within two business days.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/tokens/",
    "title": "Token Management",
    "tags": [],
    "description": "BFF - Overview",
    "content": "Duende.BFF includes an automatic token management feature. This uses the access and refresh token stored in the authentication session to always provide a current access token for outgoing API calls.\nFor most scenarios, there is no additional configuration necessary. The token management will infer the configuration and token endpoint URL from the metadata of the OpenID Connect provider.\nThe easiest way to retrieve the current access token is to use an extension method on HttpContext:\nvar token = await HttpContext.GetUserAccessTokenAsync(); You can then use the token to set it on an HttpClient instance:\nvar client = new HttpClient(); client.SetBearerToken(token); We recommend to leverage the HttpClientFactory to fabricate HTTP clients that are already aware of the token management plumbing. For this you would register a named client in your startup e.g. like this:\n// registers HTTP client that uses the managed user access token services.AddUserAccessTokenHttpClient(\u0026#34;apiClient\u0026#34;, configureClient: client =\u0026gt; { client.BaseAddress = new Uri(\u0026#34;https://remoteServer/\u0026#34;); }); And then retrieve a client instance like this:\n[Route(\u0026#34;myApi\u0026#34;)] public class MyApiController : ControllerBase { private readonly IHttpClientFactory _httpClientFactory; public MyController(IHttpClientFactory httpClientFactory) { _httpClientFactory = httpClientFactory; } public async Task\u0026lt;IActionResult\u0026gt; Get(string id) { // create HTTP client with automatic token management var client = _httpClientFactory.CreateClient(\u0026#34;apiClient\u0026#34;); // call remote API var response = await client.GetAsync(\u0026#34;remoteApi\u0026#34;); // rest omitted } } If you prefer to use typed clients, you can do that as well:\n// registers a typed HTTP client with token management support services.AddHttpClient\u0026lt;MyTypedApiClient\u0026gt;(client =\u0026gt; { client.BaseAddress = new Uri(\u0026#34;https://remoteServer/\u0026#34;); }) .AddUserAccessTokenHandler(); And then use that client, for example like this on a controller\u0026rsquo;s action method:\npublic async Task\u0026lt;IActionResult\u0026gt; CallApiAsUserTyped( [FromServices] MyTypedClient client) { var response = await client.GetData(); // rest omitted } The client will internally always try to use a current and valid access token. If for any reason this is not possible, the 401 status code will be returned to the caller.\nReuse of Refresh Tokens We recommend that you configure IdentityServer to issue reusable refresh tokens to BFF clients. Because the BFF is a confidential client, it does not need one-time use refresh tokens. Re-useable refresh tokens are desirable because they avoid performance and user experience problems associated with one time use tokens. See the discussion on rotating refresh tokens and the OAuth 2.0 Security Best Current Practice for more details.\nManually revoking refresh tokens Duende.BFF revokes refresh tokens automatically at logout time. This behavior can be disabled with the RevokeRefreshTokenOnLogout option.\nIf you want to manually revoke the current refresh token, you can use the following code:\nawait HttpContext.RevokeUserRefreshTokenAsync(); This will invalidate the refresh token at the token service.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/tokens/",
    "title": "Requesting Tokens",
    "tags": [],
    "description": "index",
    "content": "Requesting Tokens At its very heart, Duende IdentityServer is a so-called Security Token Service (STS).\nOverview Requesting a Token Refreshing a Token Issuing Tokens based on User Passwords Extension Grants Dynamic Request Validation and Customization Issuing Internal Tokens Proof-of-Possession Access Tokens Reference Tokens Client Authentication Signed Authorize Requests Calling Endpoints from JavaScript "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/ui/login/local/",
    "title": "Accepting Local Credentials",
    "tags": [],
    "description": "",
    "content": "The steps for implementing a local login page are:\nValidate the user\u0026rsquo;s credentials Issue the authentication cookie Redirect the user to the return URL The code below shows a sample Razor Page that could act as a login page. This sample hard codes the logic for the credentials. In production code, use your custom user database or identity management library here.\nIf you are using ASP.NET Identity for user management, our Identity Server ASP.NET Identity (isaspid) template includes a login page that shows how you might use the abstractions of that library on your login page. Notably, it uses the SignInManager to start the session, rather than HttpContext.SignInAsync.\nThis is the cshtml for the login Razor Page:\n@page @model Sample.Pages.Account.LoginModel @addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers \u0026lt;div asp-validation-summary=\u0026#34;All\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;form method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; asp-for=\u0026#34;ReturnUrl\u0026#34; /\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label asp-for=\u0026#34;Username\u0026#34;\u0026gt;Username\u0026lt;/label\u0026gt; \u0026lt;input asp-for=\u0026#34;Username\u0026#34; autofocus\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label asp-for=\u0026#34;Password\u0026#34;\u0026gt;Password\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; asp-for=\u0026#34;Password\u0026#34; autocomplete=\u0026#34;off\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Login\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; And this is the code behind for the login Razor Page:\nnamespace Sample.Pages.Account { public class LoginModel : PageModel { [BindProperty(SupportsGet = true)] public string ReturnUrl { get; set; } [BindProperty] public string Username { get; set; } [BindProperty] public string Password { get; set; } public async Task\u0026lt;IActionResult\u0026gt; OnPost() { if (Username == \u0026#34;alice\u0026#34; \u0026amp;\u0026amp; Password == \u0026#34;password\u0026#34;) { var claims = new Claim[] { new Claim(\u0026#34;sub\u0026#34;, \u0026#34;unique_id_for_alice\u0026#34;) }; var identity = new ClaimsIdentity(claims, \u0026#34;pwd\u0026#34;); var user = new ClaimsPrincipal(identity); await HttpContext.SignInAsync(user); if (Url.IsLocalUrl(ReturnUrl)) { return Redirect(ReturnUrl); } } ModelState.AddModelError(\u0026#34;\u0026#34;, \u0026#34;Invalid username or password\u0026#34;); return Page(); } } } When IdentityServer redirects to the LoginUrl, the user should arrive at this page. If you\u0026rsquo;re using the default urls, then this page should be created at the path: ~/Pages/Account/Login.cshtml, which allows it to be loaded from the browser at the \u0026ldquo;/Account/Login\u0026rdquo; path.\nWhile you can use any custom user database or identity management library for your users, we provide first class integration support for ASP.NET Identity.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/ui/logout/notification/",
    "title": "Client Notifications",
    "tags": [],
    "description": "",
    "content": "Notifying clients that the user has signed-out As part of the logout process you will want to ensure client applications are informed that the user has signed out.\nThis is done by sending a notification to an endpoint provided by the each client application. Depending on your architecture, there are three supported techniques to call these endpoints:\nfront-channel notifications via the browser back-channel notifications via server-side call a PostMessage-based notification for JavaScript clients Regardless which technique you are using, Duende IdentityServer keeps track of the client applications involved with the current user session and provides helpers and automated ways of invoking the notification mechanisms.\nBoth the front-channel and JS-based notifications make use of cookies in iframes. If your architecture spans multiple sites, this will not work reliably. We recommend using back-channel notifications in this case. See the supported specifications page for links to the relevant documents.\nFront-channel server-side clients To sign the user out of the server-side client applications via the front-channel spec, the \u0026ldquo;logged out\u0026rdquo; page in IdentityServer must render an \u0026lt;iframe\u0026gt; for each client that points to the corresponding notification endpoint at the client.\nClients that wish to be notified must have the FrontChannelLogoutUri configuration value set. IdentityServer tracks which clients the user has signed into, and provides an API called GetLogoutContextAsync on the IIdentityServerInteractionService. This API returns a LogoutRequest object with a SignOutIFrameUrl property that your logged out page must render into an \u0026lt;iframe\u0026gt;.\nSee the Quickstart UI account controller and signout view for an example.\nBack-channel server-side clients To sign the user out of the server-side client applications via the back-channel the IBackChannelLogoutService service can be used. IdentityServer will automatically use this service when your logout page removes the user\u0026rsquo;s authentication cookie via a call to HttpContext.SignOutAsync.\nClients that wish to be notified must have the BackChannelLogoutUri configuration value set.\nImplementing Back-channel Logout in .NET Applications .NET does not have native support for back-channel logout notification. We do provide a sample, though. Alternatively, if you are using our BFF framework, back-channel logout is already implemented for you.\nBack-channel logout notifications are logout tokens as specified by OpenID Connect Back-Channel Logout 1.0. Beginning in v6.3, IdentityServer sets the typ header of the logout token to logout+jwt to comply with the final version of the specification. The LogoutTokenJwtType option can override this behavior.\nBrowser-based JavaScript clients There is nothing special you need to do to notify these clients that the user has signed out.\nThe clients, though, must perform monitoring on the check_session_iframe, and this is implemented by spec compliant client libraries, e.g. the oidc-client JavaScript library.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/ui/custom/",
    "title": "Custom Pages",
    "tags": [],
    "description": "",
    "content": "In addition to the pages your IdentityServer is expected to provide, you can add any other pages you wish. These could be pages needed during login (e.g. registration, password reset), self-service pages to allow the user to manage their profile (e.g. change password, change email), or even more specialized pages for various user workflows (e.g. password expired, or EULA).\nThese custom pages can be made available to the end user as links from the standard pages in your IdentityServer (i.e. login, consent), they can be rendered to the user during login page workflows, or they could be displayed as a result of requests into the authorize endpoint.\nAuthorize Endpoint Requests and Custom Pages As requests are made into the authorize endpoint, if a user already has an established authentication session then they will not be presented with a login page at your IdentityServer (as that is the normal expectation for single sign-on).\nDuende IdentityServer provides the authorize interaction response generator extensibility point to allow overriding or controlling the response from the authorize endpoint.\nBuilt-in AuthorizeInteractionResponseGenerator To provide custom logic for the authorize endpoint, the recommondation is to derive from the built-in AuthorizeInteractionResponseGenerator to inherit all the default logic pertaining to login and consent semantics. To augment the built-in logic, override ProcessLoginAsync and/or ProcessConsentAsync (depending on the nature of the custom logic). The pattern would be to invoke the base implementation and if the result did not cause a login, consent or error, then the custom logic could be tested to determine if it is desired to prevent SSO and instead force the user to interact in some way (e.g. re-login, trigger MFA, accept a EULA, etc). The sample below illustrates:\npublic class CustomAuthorizeInteractionResponseGenerator : AuthorizeInteractionResponseGenerator { public CustomAuthorizeInteractionResponseGenerator(IdentityServerOptions options, ISystemClock clock, ILogger\u0026lt;AuthorizeInteractionResponseGenerator\u0026gt; logger, IConsentService consent, IProfileService profile) : base(options, clock, logger, consent, profile) { } protected internal override async Task\u0026lt;InteractionResponse\u0026gt; ProcessLoginAsync(ValidatedAuthorizeRequest request) { var result = await base.ProcessLoginAsync(request); if (!result.IsLogin \u0026amp;\u0026amp; !result.IsError) { // check EULA database var mustShowEulaPage = HasUserAcceptedEula(request.Subject); if (!mustShowEulaPage) { result = new InteractionResponse { RedirectUrl = \u0026#34;/eula/accept\u0026#34; }; } } return result; } } Custom Redirects When using custom redirect pages by setting the RedirectUrl on the InteractionResponse, IdentityServer will provide a returnUrl query parameter with the request (much like on the login page). Once the custom logic is complete on the page, then the URL in the returnUrl query parameter should be used to return the user back into the IdentityServer authorize request workflow.\nBeware open-redirect attacks via the returnUrl parameter. You should validate that the returnUrl refers to a well-known location. Either use the Url.IsLocalUrl helper from ASP.NET Core, or use the interaction service from Duende IdentityServer for APIs to validate the returnUrl parameter.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/configuration/dcr/customization/",
    "title": "Customization",
    "tags": [],
    "description": "",
    "content": "The behavior of the Configuration API can be customized through the use of several extension points that control the steps that occur when a dynamic client registration request arrives.\nFirst, the incoming request is validated to ensure that it is syntactically valid and semantically correct. The result of the validation process is a model which will either contain error details or a validated Client model.\nWhen validation succeeds, the validated request is passed on to the request processor. The request processor is responsible for generating properties of the Client that are not specified in the request. For example, the client_id is not normally specified in the request and is instead generated by the processor.\nWhen the processor is finished generating values, it passes the final client object to the store and returns an IDynamicClientRegistrationResponse indicating success or failure. This response object is finally used by the response generator to generate an HTTP response.\nEach of the validation and processing steps might also encounter an error. When that occurs, errors are conveyed using the DynamicClientRegistrationError class.\nValidation To customize the validation process, you can either implement the IDynamicClientRegistrationValidator interface or extend from the default implementation of that interface, the DynamicClientRegistrationValidator. The default implementation includes many virtual methods, allowing you to use most of the base functionality and add your customization in a targeted manner.\nEach virtual method is responsible for validating a small number of parameters in the request and setting corresponding values on the client. The steps are passed a context object containing the client object that is being built up, the original request, the claims principal that made the request, and a dictionary of additional items that can be used to pass state between customized steps. Each step should update the client in the context and return an IStepResult to indicate success or failure.\nFor more details, see the reference section on validation\nProcessing In a similar way, the request processor can be customized by implementing an IDynamicClientRegistrationRequestProcessor or by extending from the default DynamicClientRegistrationRequestProcessor. Again, the default request processor contains virtual methods that allow you to override a part of its functionality.\nFor more details, see the reference section on request processing\nResponse Generation Finally, to customize the HTTP responses of the Configuration API, you can implement the IDynamicClientRegistrationResponseGenerator or extend from the default DynamicClientRegistrationResponseGenerator.\nFor more details, see the reference section on response generation\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/samples/diagnostics/",
    "title": "Diagnostics",
    "tags": [],
    "description": "Samples",
    "content": "OpenTelemetry support link to source code\nIdentityServer emits OpenTelemetry traces for input validators, stores and response generators (see here for more information).\nThe samples shows how to setup Otel for console tracing.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/upgrades/v6.1_to_v6.2/",
    "title": "Duende IdentityServer v6.1 to v6.2",
    "tags": [],
    "description": "",
    "content": "This upgrade guide covers upgrading from Duende IdentityServer v6.1 to v6.2 (release notes).\nWhat\u0026rsquo;s New Duende IdentityServer 6.2 adds:\nSupport for .NET 7.0 A new option that can help filter unhandled exceptions out of the logs Bug fixes and ongoing maintenance There are no changes to the data stores in this release.\nStep 1: Update NuGet package In your IdentityServer host project, update the version of the NuGet. For example in your project file:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;6.1.0\u0026#34; /\u0026gt; would change to:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;6.2.0\u0026#34; /\u0026gt; Step 2: Verify Data Protection Configuration IdentityServer depends on ASP.NET Data Protection. Data Protection encrypts and signs data using keys managed by ASP.NET. Those keys are isolated by application name, which by default is set to the content root path of the host. This prevents multiple applications from sharing encryption keys, which is necessary to protect your encryption against certain forms of attack. However, this means that if your content root path changes, the default settings for data protection will prevent you from using your old keys. Beginning in .NET 6, the content root path was normalized so that it ends with a directory separator. In .NET 7 that change was reverted. This means that your content root path might change if you upgrade from .NET 6 to .NET 7. This can be mitigated by explicitly setting the application name and removing the separator character. See Microsoft\u0026rsquo;s documentation for more information.\nStep 3: Done! That\u0026rsquo;s it. Of course, at this point you can and should test that your IdentityServer is updated and working properly.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/data/ef/",
    "title": "Entity Framework Integration",
    "tags": [],
    "description": "",
    "content": "An EntityFramework-based implementation is provided for the configuration and operational data extensibility points in IdentityServer. The use of EntityFramework allows any EF-supported database to be used with this library.\nThe features provided by this library are broken down into two main areas: configuration store and operational store support. These two different areas can be used independently or together, based upon the needs of the hosting application.\nTo use this library, ensure that you have the NuGet package for the ASP.NET Identity integration. It is called Duende.IdentityServer.EntityFramework. You can install it with:\ndotnet add package Duende.IdentityServer.EntityFramework Configuration Store Support For storing configuration data, then the configuration store can be used. This support provides implementations of the IClientStore, IResourceStore, IIdentityProviderStore, and the ICorsPolicyService extensibility points. These implementations use a DbContext-derived class called ConfigurationDbContext to model the tables in the database.\nTo use the configuration store support, use the AddConfigurationStore extension method after the call to AddIdentityServer:\npublic IServiceProvider ConfigureServices(IServiceCollection services) { const string connectionString = @\u0026#34;Data Source=(LocalDb)\\MSSQLLocalDB;database=YourIdentityServerDatabase;trusted_connection=yes;\u0026#34;; var migrationsAssembly = typeof(Startup).GetTypeInfo().Assembly.GetName().Name; services.AddIdentityServer() // this adds the config data from DB (clients, resources, CORS) .AddConfigurationStore(options =\u0026gt; { options.ConfigureDbContext = builder =\u0026gt; builder.UseSqlServer(connectionString, sql =\u0026gt; sql.MigrationsAssembly(migrationsAssembly)); }); } To configure the configuration store, use the ConfigurationStoreOptions options object passed to the configuration callback.\nConfigurationStoreOptions This options class contains properties to control the configuration store and ConfigurationDbContext.\nConfigureDbContext Delegate of type Action used as a callback to configure the underlying ConfigurationDbContext. The delegate can configure the ConfigurationDbContext in the same way if EF were being used directly with AddDbContext, which allows any EF-supported database to be used.\nDefaultSchema Allows setting the default database schema name for all the tables in the ConfigurationDbContext\noptions.DefaultSchema = \u0026#34;myConfigurationSchema\u0026#34;; If you need to change the schema for the Migration History Table, you can chain another action to the UseSqlServer:\noptions.ConfigureDbContext = b =\u0026gt; b.UseSqlServer(connectionString, sql =\u0026gt; sql.MigrationsAssembly(migrationsAssembly).MigrationsHistoryTable(\u0026#34;MyConfigurationMigrationTable\u0026#34;, \u0026#34;myConfigurationSchema\u0026#34;)); Enabling Caching for Configuration Store To enable caching for the EF configuration store implementation, use the AddConfigurationStoreCache extension method:\npublic IServiceProvider ConfigureServices(IServiceCollection services) { services.AddIdentityServer() .AddConfigurationStore(options =\u0026gt; { ... }) // this is something you will want in production to reduce load on and requests to the DB .AddConfigurationStoreCache(); } Operational Store For storing operational data then the operational store can be used. This support provides implementations of the IPersistedGrantStore, IDeviceFlowStore, IServerSideSessionStore, and ISigningKeyStore extensibility points. The implementation uses a DbContext-derived class called PersistedGrantDbContext to model the table in the database.\nTo use the operational store support, use the AddOperationalStore extension method after the call to AddIdentityServer:\npublic IServiceProvider ConfigureServices(IServiceCollection services) { const string connectionString = @\u0026#34;Data Source=(LocalDb)\\MSSQLLocalDB;database=YourIdentityServerDatabase;trusted_connection=yes;\u0026#34;; var migrationsAssembly = typeof(Startup).GetTypeInfo().Assembly.GetName().Name; services.AddIdentityServer() // this adds the operational data from DB (codes, tokens, consents) .AddOperationalStore(options =\u0026gt; { options.ConfigureDbContext = builder =\u0026gt; builder.UseSqlServer(connectionString, sql =\u0026gt; sql.MigrationsAssembly(migrationsAssembly)); // this enables automatic token cleanup. this is optional. options.EnableTokenCleanup = true; options.TokenCleanupInterval = 3600; // interval in seconds (default is 3600) }); } To configure the operational store, use the OperationalStoreOptions options object passed to the configuration callback.\nOperationalStoreOptions This options class contains properties to control the operational store and PersistedGrantDbContext.\nConfigureDbContext Delegate of type Action used as a callback to configure the underlying PersistedGrantDbContext. The delegate can configure the PersistedGrantDbContext in the same way if EF were being used directly with AddDbContext, which allows any EF-supported database to be used.\nDefaultSchema Allows setting the default database schema name for all the tables in the PersistedGrantDbContext.\nEnableTokenCleanup Indicates whether expired grants will be automatically cleaned up from the database. The default is false.\nRemoveConsumedTokens [added in 5.1] Indicates whether consumed grants will be automatically cleaned up from the database. The default is false.\nTokenCleanupInterval The token cleanup interval (in seconds). The default is 3600 (1 hour).\nConsumedTokenCleanupDelay [added in 6.3] The consumed token cleanup delay (in seconds). The default is 0. This delay is the amount of time that must elapse before tokens marked as consumed can be deleted. Note that only refresh tokens with OneTime usage can be marked as consumed.\nThe token cleanup feature does not remove persisted grants that are consumed (see persisted grants). It only removes persisted grants that are beyond their Expiration.\nDatabase creation and schema changes across different versions of IdentityServer It is very likely that across different versions of IdentityServer (and the EF support) that the database schema will change to accommodate new and changing features.\nWe do not provide any support for creating your database or migrating your data from one version to another. You are expected to manage the database creation, schema changes, and data migration in any way your organization sees fit.\nUsing EF migrations is one possible approach to this. If you do wish to use migrations, then see the EF quickstart for samples on how to get started, or consult the Microsoft documentation on EF migrations.\nWe publish a sample app that we use internally for creating databases to test the latest database schema (this is SQL Server specific).\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/deployment/health_checks/",
    "title": "Health Checks",
    "tags": [],
    "description": "",
    "content": "You can use ASP.NET\u0026rsquo;s health checks to monitor the health of your IdentityServer deployment. Health checks can contain arbitrary logic to test various conditions of a system. One common strategy for checking the health of IdentityServer is to make discovery requests. Successful discovery responses indicate not just that the IdentityServer host is running and able to receive requests and generate responses, but also that it was able to communicate with the configuration store.\nThe following example code creates a health check that makes requests to the discovery endpoint. It finds the discovery endpoint\u0026rsquo;s handler by name, which requires IdentityServer v6.3.\npublic class DiscoveryHealthCheck : IHealthCheck { private readonly IEnumerable\u0026lt;Hosting.Endpoint\u0026gt; _endpoints; private readonly IHttpContextAccessor _httpContextAccessor; public DiscoveryHealthCheck(IEnumerable\u0026lt;Hosting.Endpoint\u0026gt; endpoints, IHttpContextAccessor httpContextAccessor) { _endpoints = endpoints; _httpContextAccessor = httpContextAccessor; } public async Task\u0026lt;HealthCheckResult\u0026gt; CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default) { try { var endpoint = _endpoints.FirstOrDefault(x =\u0026gt; x.Name == IdentityServerConstants.EndpointNames.Discovery); if (endpoint != null) { var handler = _httpContextAccessor.HttpContext.RequestServices.GetRequiredService(endpoint.Handler) as IEndpointHandler; if (handler != null) { var result = await handler.ProcessAsync(_httpContextAccessor.HttpContext); if (result is DiscoveryDocumentResult) { return HealthCheckResult.Healthy(); } } } } catch { } return new HealthCheckResult(context.Registration.FailureStatus); } } Another health check that you can perform is to request the public keys that IdentityServer uses to sign tokens - the JWKS (JSON Web Key Set). Doing so demonstrates that IdentityServer is able to communicate with the signing key store, a critical dependency. The following example code creates such a health check. Just as with the previous health check, it finds the endpoint\u0026rsquo;s handler by name, which requires IdentityServer v6.3.\npublic class DiscoveryKeysHealthCheck : IHealthCheck { private readonly IEnumerable\u0026lt;Hosting.Endpoint\u0026gt; _endpoints; private readonly IHttpContextAccessor _httpContextAccessor; public DiscoveryKeysHealthCheck(IEnumerable\u0026lt;Hosting.Endpoint\u0026gt; endpoints, IHttpContextAccessor httpContextAccessor) { _endpoints = endpoints; _httpContextAccessor = httpContextAccessor; } public async Task\u0026lt;HealthCheckResult\u0026gt; CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default) { try { var endpoint = _endpoints.FirstOrDefault(x =\u0026gt; x.Name == IdentityServerConstants.EndpointNames.Jwks); if (endpoint != null) { var handler = _httpContextAccessor.HttpContext.RequestServices.GetRequiredService(endpoint.Handler) as IEndpointHandler; if (handler != null) { var result = await handler.ProcessAsync(_httpContextAccessor.HttpContext); if (result is JsonWebKeysResult) { return HealthCheckResult.Healthy(); } } } } catch { } return new HealthCheckResult(context.Registration.FailureStatus); } } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/configuration/dcr/reference/models/",
    "title": "Models",
    "tags": [],
    "description": "DCR Reference",
    "content": "DynamicClientRegistrationRequest Represents a dynamic client registration request. The parameters that are supported include a subset of the parameters defined by IANA, and custom properties needed by IdentityServer.\npublic class DynamicClientRegistrationRequest Public Members name description AbsoluteRefreshTokenLifetime { get; set; } The absolute lifetime of refresh tokens, in seconds. This property is an extension to the Dynamic Client Registration Protocol. AccessTokenLifetime { get; set; } The lifetime of access tokens, in seconds. This property is an extension to the Dynamic Client Registration Protocol. AccessTokenType { get; set; } The type of access tokens that this client will create. Either \u0026ldquo;Jwt\u0026rdquo; or \u0026ldquo;Reference\u0026rdquo;. This property is an extension to the Dynamic Client Registration Protocol. AllowedCorsOrigins { get; set; } List of allowed CORS origins for JavaScript clients. This property is an extension to the Dynamic Client Registration Protocol. AllowedIdentityTokenSigningAlgorithms { get; set; } List of signing algorithms to use when signing identity tokens. If not set, will use the server default signing algorithm. This property is an extension to the Dynamic Client Registration Protocol. AllowRememberConsent { get; set; } Boolean value specifying whether a user\u0026rsquo;s consent can be remembered in flows initiated by this client. This property is an extension to the Dynamic Client Registration Protocol. AuthorizationCodeLifetime { get; set; } The lifetime of authorization codes, in seconds. This property is an extension to the Dynamic Client Registration Protocol. BackChannelLogoutSessionRequired { get; set; } Boolean value specifying whether the RP requires that a sid (session ID) Claim be included in the Logout Token to identify the RP session with the OP when the backchannel_logout_uri is used. BackChannelLogoutUri { get; set; } RP URL that will cause the RP to log itself out when sent a Logout Token by the OP. ClientName { get; set; } Human-readable string name of the client to be presented to the end-user during authorization. ClientUri { get; set; } Web page providing information about the client. ConsentLifetime { get; set; } The lifetime of consent, in seconds. This property is an extension to the Dynamic Client Registration Protocol. CoordinateLifetimeWithUserSession { get; set; } When enabled, the client\u0026rsquo;s token lifetimes (e.g. refresh tokens) will be tied to the user\u0026rsquo;s session lifetime. This means when the user logs out, any revokable tokens will be removed. If using server-side sessions, expired sessions will also remove any revokable tokens, and backchannel logout will be triggered. This client\u0026rsquo;s setting overrides the global CoordinateTokensWithUserSession configuration setting. This property is an extension to the Dynamic Client Registration Protocol. DefaultMaxAge { get; set; } Default maximum authentication age. This is stored as the UserSsoLifetime property of the IdentityServer client model. EnableLocalLogin { get; set; } Boolean value specifying if local logins are enabled when this client uses interactive flows. This property is an extension to the Dynamic Client Registration Protocol. Extensions { get; set; } Custom client metadata fields to include in the serialization. FrontChannelLogoutSessionRequired { get; set; } Boolean value specifying whether the RP requires that a sid (session ID) query parameter be included to identify the RP session with the OP when the frontchannel_logout_uri is used. FrontChannelLogoutUri { get; set; } RP URL that will cause the RP to log itself out when rendered in an iframe by the OP. GrantTypes { get; set; } List of OAuth 2.0 grant type strings that the client can use at the token endpoint. Valid values are \u0026ldquo;authorization_code\u0026rdquo;, \u0026ldquo;client_credentials\u0026rdquo;, \u0026ldquo;refresh_token\u0026rdquo;. IdentityProviderRestrictions { get; set; } List of external IdPs that can be used with this client. If list is empty all IdPs are allowed. Defaults to empty. This property is an extension to the Dynamic Client Registration Protocol. IdentityTokenLifetime { get; set; } The lifetime of identity tokens, in seconds. This property is an extension to the Dynamic Client Registration Protocol. InitiateLoginUri { get; set; } URI using the https scheme that a third party can use to initiate a login by the relying party. Jwks { get; set; } JWK Set document which contains the client\u0026rsquo;s public keys. The JwksUri and Jwks parameters MUST NOT both be present in the same request or response. JwksUri { get; set; } URL to a JWK Set document which contains the client\u0026rsquo;s public keys. The JwksUri and Jwks parameters MUST NOT both be present in the same request or response. The default validator must be extended to make use of the JwksUri. The default implementation ignores this property. LogoUri { get; set; } Logo for the client. If present, the server should display this image to the end-user during approval. PostLogoutRedirectUris { get; set; } List of post-logout redirection URIs for use in the end session endpoint. RedirectUris { get; set; } List of redirection URI strings for use in redirect-based flows such as the authorization code flow. Clients using flows with redirection must register their redirection URI values. RefreshTokenExpiration { get; set; } The type of expiration for refresh tokens. Either \u0026ldquo;sliding\u0026rdquo; or \u0026ldquo;absolute\u0026rdquo;. This property is an extension to the Dynamic Client Registration Protocol. RefreshTokenUsage { get; set; } The usage type for refresh tokens. Either \u0026ldquo;OneTimeOnly\u0026rdquo; or \u0026ldquo;ReUse\u0026rdquo;. This property is an extension to the Dynamic Client Registration Protocol. RequireClientSecret { get; set; } Boolean value specifying if a client secret is needed to request tokens at the token endpoint. This property is an extension to the Dynamic Client Registration Protocol. RequireConsent { get; set; } Boolean value specifying whether consent is required in user-centric flows initiated by this client. This property is an extension to the Dynamic Client Registration Protocol. RequireSignedRequestObject { get; set; } Boolean value specifying whether authorization requests must be protected as signed request objects and provided through either the request or request_uri parameters. Scope { get; set; } String containing a space-separated list of scope values that the client can use when requesting access tokens. If omitted, the configuration API will register a client with the scopes set by the DynamicClientRegistrationValidator.SetDefaultScopes method, which defaults to no scopes. SlidingRefreshTokenLifetime { get; set; } The sliding lifetime of refresh tokens, in seconds. This property is an extension to the Dynamic Client Registration Protocol. SoftwareId { get; set; } A unique identifier string (e.g., a Universally Unique Identifier (UUID)) assigned by the client developer or software publisher used by registration endpoints to identify the client software to be dynamically registered. Unlike \u0026ldquo;client_id\u0026rdquo;, which is issued by the authorization server and SHOULD vary between instances, the \u0026ldquo;software_id\u0026rdquo; SHOULD remain the same for all instances of the client software. The \u0026ldquo;software_id\u0026rdquo; SHOULD remain the same across multiple updates or versions of the same piece of software. The value of this field is not intended to be human readable and is usually opaque to the client and authorization server. The default validator must be extended to make use of the SoftwareId. The default implementation ignores this property. SoftwareStatement { get; set; } A software statement containing client metadata values about the client software as claims. This is a string value containing the entire signed JWT. The default validator must be extended to make use of the software statement. The default implementation ignores this property. SoftwareVersion { get; set; } A version identifier string for the client software identified by \u0026ldquo;software_id\u0026rdquo;. The value of the \u0026ldquo;software_version\u0026rdquo; SHOULD change on any update to the client software identified by the same \u0026ldquo;software_id\u0026rdquo;. The value of this field is intended to be compared using string equality matching and no other comparison semantics are defined by this specification. The default validator must be extended to make use of the SoftwareVersion. The default implementation ignores this property. TokenEndpointAuthenticationMethod { get; set; } Requested Client Authentication method for the Token Endpoint. The supported options are client_secret_post, client_secret_basic, client_secret_jwt, private_key_jwt. UpdateAccessTokenClaimsOnRefresh { get; set; } Boolean value specifying whether access token claims are updated during token refresh. This property is an extension to the Dynamic Client Registration Protocol. Dynamic Client Registration Response Represents the response to a successful dynamic client registration request. This class extends the registration request by adding additional properties that are generated server side and not set by the client.\npublic class DynamicClientRegistrationResponse : DynamicClientRegistrationRequest, IDynamicClientRegistrationResponse Public Members name description ClientId { get; set; } Gets or sets the client ID. ClientSecret { get; set; } Gets or sets the client secret. ClientSecretExpiresAt { get; set; } Gets or sets the expiration time of the client secret. ResponseTypes { get; set; } List of the OAuth 2.0 response type strings that the client can use at the authorization endpoint. DynamicClientRegistrationContext Represents the context of a dynamic client registration request, including the original DCR request, the client model that is built up through validation and processing, the caller who made the DCR request, and other contextual information.\npublic class DynamicClientRegistrationContext Public Members name description Caller { get; set; } The ClaimsPrincipal that made the DCR request. Client { get; set; } The client model that is built up through validation and processing. Items { get; set; } A collection where additional contextual information may be stored. This is intended as a place to pass additional custom state between validation steps. Request { get; set; } The original dynamic client registration request. DynamicClientRegistrationError Represents an error that occurred during validation of a dynamic client registration request. This class implements the appropriate marker interfaces so that it can be returned from various points in the validator or processor.\npublic class DynamicClientRegistrationValidationError : IStepResult, IDynamicClientRegistrationResponse, IDynamicClientRegistrationValidationResult Public Members name description Error { get; set; } Gets or sets the error code for the error that occurred during validation. Error codes defined by RFC 7591 are defined as constants in the DynamicClientRegistrationErrors class. ErrorDescription { get; set; } Gets or sets a human-readable description of the error that occurred during validation. Marker Interfaces IDynamicClientRegistrationResponse Marker interface for the response to a dynamic client registration request. This interface has two implementations; DynamicClientRegistrationResponse indicates success, while DynamicClientRegistrationError indicates failure.\nIDynamicClientRegistrationValidationResult Marker interface for the result of validating a dynamic client registration request. This interface has two implementations; DynamicClientRegistrationValidatedRequest indicates success, while DynamicClientRegistrationError indicates failure. Note that the DynamicClientRegistrationError implements multiple interfaces and can be used throughout the pipeline to convey errors.\nIStepResult Marker interface for the result of a step in the dynamic client registration validator or processor. This interface has two implementations; SuccessfulStep indicates success, while DynamicClientRegistrationError indicates failure. Note that the DynamicClientRegistrationError implements multiple interfaces and can be used throughout the pipeline to convey errors.\nIStepResult Convenience Functions Your validation or processing steps can return a call to convenience functions in the static class StepResult to conveniently construct a success or failure from a step wrapped in a task.\nname description static Task\u0026lt;IStepResult\u0026gt; Success() Indicates that the validation step was completed was completed successfully static Task\u0026lt;IStepResult\u0026gt; Failure(string errorDescription) Indicates that the validation step failed with the specified error description and the default error code of invalid_client_metadata static Task\u0026lt;IStepResult\u0026gt; Failure(string errorDescription, string error) Indicates that the validation step failed with the specified error description and error code DynamicClientRegistrationValidatedRequest Represents a successfully validated dynamic client registration request.\npublic class DynamicClientRegistrationValidatedRequest : DynamicClientRegistrationValidationResult SuccessfulStep Represents a successful validation step.\npublic class SuccessfulStep : IStepResult "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/ui/login/mfa/",
    "title": "Multi Factor Authentication",
    "tags": [],
    "description": "",
    "content": "Duende IdentityServer itself doesn\u0026rsquo;t implement multi-factor authentication (MFA). MFA is part of the login process in the user interface which is the responsibility of the hosting application. Microsoft provides some general guidelines on how to enable MFA in ASP.NET Core.\nMFA hosted in IdentityServer An IdentityServer implementation can include MFA in its login page using anything that works with ASP.NET Core. One approach is to use ASP.NET Identity\u0026rsquo;s MFA support.\nMFA and external authentication When using IdentityServer as a federation gateway, interactive users authenticate at the upstream provider. Typically the upstream provider will perform the entire user authentication process, including any MFA required. There\u0026rsquo;s no special configuration or implementation needed in IdentityServer in this case, as the upstream provider handles everything.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/services/refresh_token_service/",
    "title": "Refresh Token Service",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Services.IRefreshTokenService All refresh token handling is implemented in the DefaultRefreshTokenService (which is the default implementation of the IRefreshTokenService interface):\npublic interface IRefreshTokenService { /// \u0026lt;summary\u0026gt; /// Validates a refresh token. /// \u0026lt;/summary\u0026gt; Task\u0026lt;TokenValidationResult\u0026gt; ValidateRefreshTokenAsync(string token, Client client); /// \u0026lt;summary\u0026gt; /// Creates the refresh token. /// \u0026lt;/summary\u0026gt; Task\u0026lt;string\u0026gt; CreateRefreshTokenAsync(ClaimsPrincipal subject, Token accessToken, Client client); /// \u0026lt;summary\u0026gt; /// Updates the refresh token. /// \u0026lt;/summary\u0026gt; Task\u0026lt;string\u0026gt; UpdateRefreshTokenAsync(string handle, RefreshToken refreshToken, Client client); } The behavior of the refresh token service is complex. We don\u0026rsquo;t recommend implementing the interface from scratch, unless you know exactly know what you are doing. If you want to customize how refresh tokens are handled, we recommended that you create a class that derives from the default implementation and override its virtual methods, calling the methods in the base class before adding your own custom logic.\nThe most common customizations to the refresh token service involve how to handle consumed tokens. In these situations, the token usage has been set to one-time only, but the same token gets sent more than once. This could either point to a replay attack of the refresh token, bugs in the client code, or transient network failures.\nWhen one-time use refresh tokens are used, they are not necessarily deleted from the database. The DeleteOneTimeOnlyRefreshTokensOnUse configuration flag, added in version 6.3, controls if such tokens are immediately deleted or consumed. If configured for consumption instead of deletion, then when the token is used, the ConsumedTime property will be set. If a token is received that has already been consumed, the default service will call the AcceptConsumedTokenAsync virtual method. The purpose of AcceptConsumedTokenAsync is to determine if a consumed token should be allowed to be used to produce new tokens. The default implementation of AcceptConsumedTokenAsync rejects all consumed tokens, causing the protocol request to fail with the \u0026ldquo;invalid_grant\u0026rdquo; error. Your customized implementation could instead add a grace period to allow recovery after network failures or could treat this as a replay attack and take steps to notify the user and/or revoke their access.\nSee also: Refreshing a token\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/data/operational/sessions/",
    "title": "Server-Side Sessions",
    "tags": [],
    "description": "Data Store",
    "content": "(added in 6.1)\nThe server-side sessions feature in Duende IdentityServer requires a store to persist a user\u0026rsquo;s session data.\nServer-Side Session Store The IServerSideSessionStore abstracts storing the server-side session data. ServerSideSession objects act as the storage entity, and provide several properties uses as metadata for the session. The Ticket property contains the actual serailized data used by the ASP.NET Cookie Authentication handler.\nThe methods on the IServerSideSessionStore are used to orchestrate the various management functions needed by the server-side sessions feature.\nRegistering a custom store To register a custom server-side session store in the DI container, there is a AddServerSideSessionStore helper on the IIdentityServerBuilder. It is still necessary to call AddServerSideSessions to enable the server-side session feature. For example:\npublic void ConfigureServices(IServiceCollection services) { services.AddIdentityServer() .AddServerSideSessions() .AddServerSideSessionStore\u0026lt;YourCustomStore\u0026gt;(); } There is also an overloaded version of a AddServerSideSessions that will perform both registration steps in one call. For example:\npublic void ConfigureServices(IServiceCollection services) { services.AddIdentityServer() .AddServerSideSessions\u0026lt;YourCustomStore\u0026gt;(); } EntityFramework store implementation An EntityFramework Core implementation of the server-side session store is included in the Entity Framework Integration operational store.\nWhen using the EntityFramework Core operational store, it will be necessary to indicate that server-side sessions need to be used with the call to the AddServerSideSessions fluent API. For example:\npublic void ConfigureServices(IServiceCollection services) { services.AddIdentityServer() .AddServerSideSessions() .AddOperationalStore(options =\u0026gt; { // ... }); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/overview/security/",
    "title": "Security best-practices",
    "tags": [],
    "description": "",
    "content": "This document describes how the integrity of software produced by Duende Software is maintained during the software development life cycle.\nData processing Our products are off-the shelf downloadable developer components. They are not managed services or SaaS - nor do we store, have access to, or process any of our customers\u0026rsquo; data or their customers\u0026rsquo; data.\nSystems access Multiple systems are used in the development life cycle, including GitHub, NuGet, and Microsoft Azure Key Vault. Multi-factor authentication is required for all services mentioned above. Only a limited subset of Duende Software employees act as administrators for each system. Software development All code is stored in GitHub. Any code added to a project must be added via pull request. At least one other staff member must review a pull request before it can be merged to a release branch. Static code security analysis is performed for every check-in (using GitHub CodeQL). Testing Automated test suites are run on code in every pull request branch. Pull requests cannot be merged if the automated test suite fails. Deployment Merging a pull request does not immediately release new features to users, this requires an additional release step. All compiled software packages with associated source are available as GitHub releases. Compiled software libraries (such as Duende IdentityServer) are published to NuGet. Packages must be pushed to NuGet by a Duende Software staff member only after additional validation by the staff member. All NuGet packages are signed with a code signing certificate The private key (RSA 4096 bits) is stored in Azure Key Vault. The private key never leaves Key Vault and the signature process is performed by Key Vault. NuGet will validate the package signature with Duende\u0026rsquo;s public key to verify they were legitimately built by Duende Software and have not been compromised or tampered with. NuGet client tooling can be configured to accept signed packages only. Once on NuGet, the package is available for end users to update their own solutions. End users still must take explicit action to upgrade after reviewing the package\u0026rsquo;s release notes. Vulnerability management process Potential security vulnerabilities can be responsibly disclosed via our contact form. We guarantee to reply within two US business days. All licenses includes a security notification service. Whenever a security vulnerability has been confirmed and fixed, customers will get a private update prior to public release. We will publish an official advisory Dependencies IdentityServer has two dependencies:\nMicrosoft .NET IdentityModel maintained by Duende Software using the same principles as outlined above Certification Duende IdentityServer is a certified implementation of OpenID Connect.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/response_handling/",
    "title": "Response Generators",
    "tags": [],
    "description": "",
    "content": "Response Generators Authorize Interaction Response Generator Token Response Generator "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/services/user_sesion_service/",
    "title": "User Session Service",
    "tags": [],
    "description": "",
    "content": "The IUserSession interface is the contract for a service that manages the user\u0026rsquo;s session and tracks the clients that are participating in the session.\nUser sessions are identified by the session identifier, which is a unique random number assigned when the user initially logs in. When client applications request tokens for a flow that involves a user, that client application\u0026rsquo;s id is recorded in the user\u0026rsquo;s session. Using that information, IdentityServer can determine which applications are participating in the current session. This can be useful for various purposes, but most notably, at signout time, IdentityServer sends logout notifications to the clients that are participating in the session that is ending.\nThe IUserSession interface also contains methods for manipulating the session cookie. The session cookie contains a copy of the session id value, and is used by IdentityServer\u0026rsquo;s implementation of OIDC session management. The session id cookie\u0026rsquo;s name is controlled by the IdentityServerOptions.Authentication.CheckSessionCookieName option, which defaults to \u0026ldquo;idsrv.session\u0026rdquo;.\nThe default implementation of the IUserSession is the DefaultUserSession class. It stores the session identifier and client list in the authentication properties.\nDuende.IdentityServer.Services.IUserSession Members name description Task CreateSessionIdAsync(ClaimsPrincipal principal, AuthenticationProperties properties) Creates a session id and issues the session id cookie. Task GetUserAsync() Gets the current authenticated user. Task\u0026lt;string?\u0026gt; GetSessionIdAsync() Gets the current session identifier. Task EnsureSessionIdCookieAsync() Ensures the session identifier cookie is synchronized with the current session identifier. Task RemoveSessionIdCookieAsync() Removes the session identifier cookie. Task AddClientIdAsync(string clientId) Adds a client to the list of clients the user has signed into during their session. Task\u0026lt;IEnumerable\u0026gt; GetClientListAsync() Gets the list of clients the user has signed into during their session. GetUserAsync Generally GetUserAsync should be preferred over IAuthenticationService.AuthenticateAsync for two reasons:\nIt does not cause claims transformation to run, which prevents issues where a claims transformation is run more than once. It has a cache of the authentication result which is updated whenever a new authentication cookie is issued. Calls to SignInAsync that issue an updated authentication ticket will be reflected immediately in GetUserAsync, while AuthenticateAsync\u0026rsquo;s results will reflect the incoming authentication cookie throughout the entire duration of an HTTP request. "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/services/session_management_service/",
    "title": "Session Management Service",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Services.ISessionManagementService When using server-side sessions, the ISessionManagementService provides an administrative feature to query those sessions and terminate those sessions (including associated tokens, consents, and triggering back-channel logout to the clients).\n/// \u0026lt;summary\u0026gt; /// Session management service /// \u0026lt;/summary\u0026gt; public interface ISessionManagementService { /// \u0026lt;summary\u0026gt; /// Queries all the session related data for a user. /// \u0026lt;/summary\u0026gt; Task\u0026lt;QueryResult\u0026lt;UserSession\u0026gt;\u0026gt; QuerySessionsAsync(SessionQuery filter = null, CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// Removes all the session related data for a user. /// \u0026lt;/summary\u0026gt; Task RemoveSessionsAsync(RemoveSessionsContext context, CancellationToken cancellationToken = default); } QuerySessionsAsync allows for returning paged results of UserSession data based on the optional SessionQuery filter.\n/// \u0026lt;summary\u0026gt; /// Results from querying user sessions from session management service. /// \u0026lt;/summary\u0026gt; public class UserSession { /// \u0026lt;summary\u0026gt; /// The subject ID /// \u0026lt;/summary\u0026gt; public string SubjectId { get; set; } = default!; /// \u0026lt;summary\u0026gt; /// The session ID /// \u0026lt;/summary\u0026gt; public string SessionId { get; set; } = default!; /// \u0026lt;summary\u0026gt; /// The display name for the user /// \u0026lt;/summary\u0026gt; public string DisplayName { get; set; } /// \u0026lt;summary\u0026gt; /// The creation time /// \u0026lt;/summary\u0026gt; public DateTime Created { get; set; } /// \u0026lt;summary\u0026gt; /// The renewal time /// \u0026lt;/summary\u0026gt; public DateTime Renewed { get; set; } /// \u0026lt;summary\u0026gt; /// The expiration time /// \u0026lt;/summary\u0026gt; public DateTime? Expires { get; set; } /// \u0026lt;summary\u0026gt; /// The client ids for the session /// \u0026lt;/summary\u0026gt; public IReadOnlyCollection\u0026lt;string\u0026gt; ClientIds { get; set; } = default!; /// \u0026lt;summary\u0026gt; /// The underlying AuthenticationTicket /// \u0026lt;/summary\u0026gt; public AuthenticationTicket AuthenticationTicket { get; set; } = default!; } RemoveSessionsAsync will terminate server-side sessions based on SubjectId and/or SessionId, and allow for fine-grained flags for what to revoke and/or notify.\n/// \u0026lt;summary\u0026gt; /// Models the information to remove a user\u0026#39;s session data. /// \u0026lt;/summary\u0026gt; public class RemoveSessionsContext { /// \u0026lt;summary\u0026gt; /// The subject ID /// \u0026lt;/summary\u0026gt; public string SubjectId { get; init; } /// \u0026lt;summary\u0026gt; /// The sesion ID /// \u0026lt;/summary\u0026gt; public string SessionId { get; init; } /// \u0026lt;summary\u0026gt; /// The client ids for which to trigger logout notification, or revoke tokens or consent. /// If not set, then all clients will be removed. /// \u0026lt;/summary\u0026gt; public IEnumerable\u0026lt;string\u0026gt; ClientIds { get; set; } = default!; /// \u0026lt;summary\u0026gt; /// Removes the server side session for the user\u0026#39;s session. /// \u0026lt;/summary\u0026gt; public bool RemoveServerSideSession { get; set; } = true; /// \u0026lt;summary\u0026gt; /// Sends a back channel logout notification (if clients are registered for one). /// \u0026lt;/summary\u0026gt; public bool SendBackchannelLogoutNotification { get; set; } = true; /// \u0026lt;summary\u0026gt; /// Revokes all tokens (e.g. refresh and reference) for the clients. /// \u0026lt;/summary\u0026gt; public bool RevokeTokens { get; set; } = true; /// \u0026lt;summary\u0026gt; /// Revokes all prior consent granted to the clients. /// \u0026lt;/summary\u0026gt; public bool RevokeConsents { get; set; } = true; } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/extensibility/management/back-channel-logout/",
    "title": "BFF Back-Channel Logout Endpoint Extensibility",
    "tags": [],
    "description": "",
    "content": "The back-channel logout endpoint has several extensibility points organized into two interfaces and their default implementations. The IBackchannelLogoutService is the top level abstraction that processes requests to the endpoint. This service can be used to add custom request processing logic or to change how it validates incoming requests. When the back-channel logout endpoint receives a valid request, it revokes sessions using the ISessionRevocationService.\nRequest Processing You can add custom logic to the endpoint by implementing the IBackchannelLogoutService or by extending its default implementation (Duende.Bff.DefaultBackchannelLogoutService). In most cases, extending the default implementation is preferred, as it has several virtual methods that can be overridden to customize particular aspects of how the request is processed.\nProcessRequestAsync is the top level function called in the endpoint service and can be used to add arbitrary logic to the endpoint.\npublic class CustomizedBackchannelLogoutService : DefaultBackchannelLogoutService { public override Task ProcessRequestAsync(HttpContext context) { // Custom logic here return base.ProcessRequestAsync(context); } Validation Validation of the incoming request can be customized by overriding one of several virtual methods in the DefaultBackchannelLogoutService. GetTokenValidationParameters allows you to specify the TokenValidationParameters used to validate the incoming logout token. The default implementation creates token validation parameters based on the authentication scheme\u0026rsquo;s configuration. Your override could begin by calling the base method and then make changes to those parameters or completely customize how token validation parameters are created. For example:\npublic class CustomizedBackchannelLogoutService : DefaultBackchannelLogoutService { protected override async Task\u0026lt;TokenValidationParameters\u0026gt; GetTokenValidationParameters() { var tokenValidationParams = await base.GetTokenValidationParameters(); // Set custom parameters here // For example, make clock skew more permissive than it is by default: tokenValidationParams.ClockSkew = TimeSpan.FromMinutes(15); return tokenValidationParams; } If you need more control over the validation of the logout token, you can override ValidateJwt. The default implementation of ValidateJwt validates the token and produces a ClaimsIdentity using a JsonWebTokenHandler and the token validation parameters returned from GetTokenValidationParameters. Your override could call the base method and then manipulate this ClaimsIdentity or add a completely custom method for producing the ClaimsIdentity from the logout token.\nValidateLogoutTokenAsync is the coarsest-grained validation method. It is is responsible for validating the incoming logout token and determining if logout should proceed, based on claims in the token. It returns a ClaimsIdentity if logout should proceed or null if it should not. Your override could prevent logout in certain circumstances by returning null. For example:\npublic class CustomizedBackchannelLogoutService : DefaultBackchannelLogoutService { protected override async Task\u0026lt;ClaimsIdentity?\u0026gt; ValidateLogoutTokenAsync(string logoutToken) { var identity = await base.ValidateLogoutTokenAsync(logoutToken); // Perform custom logic here // For example, prevent logout based on certain conditions if(identity?.FindFirst(\u0026#34;sub\u0026#34;)?.Value == \u0026#34;12345\u0026#34;) { return null; } else { return identity; } } Session Revocation The back-channel logout service will call the registered session revocation service to revoke the user session when it receives a valid logout token. To customize the revocation process, implement the ISessionRevocationService.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/overview/demo_server/",
    "title": "Demo Server",
    "tags": [],
    "description": "",
    "content": "You can try Duende IdentityServer with your favourite client library. We have a test instance at demo.duendesoftware.\nOn the main page you can find instructions on how to configure your client and how to call an API.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/services/interaction_service/",
    "title": "IdentityServer Interaction Service",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Services.IIdentityServerInteractionService The IIdentityServerInteractionService interface is intended to provide services to be used by the user interface to communicate with IdentityServer, mainly pertaining to user interaction. It is available from the dependency injection system and would normally be injected as a constructor parameter into your MVC controllers for the user interface of IdentityServer.\nIIdentityServerInteractionService APIs GetAuthorizationContextAsync\nReturns the AuthorizationRequest based on the returnUrl passed to the login or consent pages.\nIsValidReturnUrl\nIndicates if the returnUrl is a valid URL for redirect after login or consent.\nGetErrorContextAsync\nReturns the ErrorMessage based on the errorId passed to the error page.\nGetLogoutContextAsync\nReturns the LogoutRequest based on the logoutId passed to the logout page.\nCreateLogoutContextAsync\nUsed to create a logoutId if there is not one presently. This creates a cookie capturing all the current state needed for signout and the logoutId identifies that cookie. This is typically used when there is no current logoutId and the logout page must capture the current user\u0026rsquo;s state needed for sign-out prior to redirecting to an external identity provider for signout. The newly created logoutId would need to be roundtripped to the external identity provider at signout time, and then used on the signout callback page in the same way it would be on the normal logout page.\nGrantConsentAsync\nAccepts a ConsentResponse to inform IdentityServer of the user\u0026rsquo;s consent to a particular AuthorizationRequest.\nDenyAuthorizationAsync\nAccepts a AuthorizationError to inform IdentityServer of the error to return to the client for a particular AuthorizationRequest.\nGetAllUserGrantsAsync\nReturns a collection of Grant for the user. These represent a user\u0026rsquo;s consent or a clients access to a user\u0026rsquo;s resource.\nRevokeUserConsentAsync\nRevokes all of a user\u0026rsquo;s consents and grants for a client.\nRevokeTokensForCurrentSessionAsync\nRevokes all of a user\u0026rsquo;s consents and grants for clients the user has signed into during their current session.\nReturned models The above methods return various models.\nAuthorizationRequest Client\nThe client that initiated the request.\nRedirectUri\nThe URI to redirect the user to after successful authorization.\nDisplayMode\nThe display mode passed from the authorization request.\nUiLocales\nThe UI locales passed from the authorization request.\nIdP The external identity provider requested. This is used to bypass home realm discovery (HRD). This is provided via the \u0026ldquo;idp:\u0026rdquo; prefix to the acr_values parameter on the authorize request.\nTenant\nThe tenant requested. This is provided via the \u0026ldquo;tenant:\u0026rdquo; prefix to the acr_values parameter on the authorize request.\nLoginHint\nThe expected username the user will use to login. This is requested from the client via the login_hint parameter on the authorize request.\nPromptMode\nThe prompt mode requested from the authorization request.\nAcrValues\nThe acr values passed from the authorization request.\nValidatedResources\nThe ResourceValidationResult which represents the validated resources from the authorization request.\nParameters\nThe entire parameter collection passed to the authorization request.\nRequestObjectValues\nThe validated contents of the request object (if present).\nResourceValidationResult Resources\nThe resources of the result.\nParsedScopes\nThe parsed scopes represented by the result.\nRawScopeValues\nThe original (raw) scope values represented by the validated result.\nErrorMessage Error\nThe error code.\nErrorDescription\nThe error description.\nDisplayMode\nThe display mode passed from the authorization request.\nUiLocales\nThe UI locales passed from the authorization request.\nRequestId\nThe per-request identifier. This can be used to display to the end user and can be used in diagnostics.\nClientId\nThe client id making the request (if available).\nRedirectUri\nThe redirect URI back to the client (if available).\nLogoutRequest ClientId\nThe client identifier that initiated the request.\nPostLogoutRedirectUri\nThe URL to redirect the user to after they have logged out.\nSessionId\nThe user\u0026rsquo;s current session id.\nSignOutIFrameUrl\nThe URL to render in an \u0026lt;iframe\u0026gt; on the logged out page to enable single sign-out.\nParameters\nThe entire parameter collection passed to the end session endpoint.\nShowSignoutPrompt\nIndicates if the user should be prompted for signout based upon the parameters passed to the end session endpoint.\nConsentResponse ScopesValuesConsented\nThe collection of scopes the user consented to.\nRememberConsent\nFlag indicating if the user\u0026rsquo;s consent is to be persisted.\nDescription\nOptional description the user can set for the grant (e.g. the name of the device being used when consent is given). This can be presented back to the user from the persisted grant service.\nError\nError, if any, for the consent response. This will be returned to the client in the authorization response.\nErrorDescription\nError description. This will be returned to the client in the authorization response.\nGrant SubjectId\nThe subject id that allowed the grant.\nClientId\nThe client identifier for the grant.\nDescription\nThe description the user assigned to the client or device being authorized.\nScopes\nThe collection of scopes granted.\nCreationTime\nThe date and time when the grant was granted.\nExpiration\nThe date and time when the grant will expire.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/tokens/internal/",
    "title": "Issuing Internal Tokens",
    "tags": [],
    "description": "",
    "content": "Sometimes, extensibility code running on your IdentityServer needs access tokens to call other APIs. In this case it is not necessary to use the protocol endpoints. The tokens can be issued internally.\nThe IdentityServerTools class is a collection of useful internal tools that you might need when writing extensibility code for IdentityServer. To use it, inject it into your code, e.g. a controller::\npublic MyController(IdentityServerTools tools) { _tools = tools; } The IssueJwtAsync method allows creating JWT tokens using the IdentityServer token creation engine. The IssueClientJwtAsync is an easier version of that for creating tokens for server-to-server communication (e.g. when you have to call an IdentityServer protected API from your code):\npublic async Task\u0026lt;IActionResult\u0026gt; MyAction() { var token = await _tools.IssueClientJwtAsync( clientId: \u0026#34;client_id\u0026#34;, lifetime: 3600, audiences: new[] { \u0026#34;backend.api\u0026#34; }); // more code } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/apis/",
    "title": "Protecting APIs",
    "tags": [],
    "description": "",
    "content": "Protecting APIs Duende IdentityServer issues tokens for accessing resources.\nThese resources are very often HTTP-based APIs, but could be also other \u0026ldquo;invocable\u0026rdquo; functionality like messaging endpoints, gRPC services or even good old XML Web Services. See the issuing tokens section on more information on access tokens and how to request them.\nProtecting APIs using ASP.NET Core Adding API Endpoints to your IdentityServer "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/samples/configuration/",
    "title": "Configuration API",
    "tags": [],
    "description": "Samples",
    "content": "Dynamic Client Registration Sample This sample of the IdentityServer.Configuration API shows how to make simple Dynamic Client Registration (DCR) requests. link to source code\nPermissions Sample This sample of the IdentityServer.Configuration API shows how you might make authorization decisions during Dynamic Client Registration (DCR). link to source code\nCI/CD Pipeline Sample using a Personal Access Token This sample of the IdentityServer.Configuration API shows how you might use Personal Access Tokens to authorize access to the configuration API in a CI/CD pipeline. link to source code\nSoftware Statement Sample This sample of the IdentityServer.Configuration API shows how you might use a software statement to pass client metadata values used in Dynamic Client Registration. link to source code\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/upgrades/v6.0_to_v6.1/",
    "title": "Duende IdentityServer v6.0 to v6.1",
    "tags": [],
    "description": "",
    "content": "This upgrade guide covers upgrading from Duende IdentityServer v6.0 to v6.1 (release notes).\nStep 1: Update NuGet package In your IdentityServer host project, update the version of the NuGet. For example in your project file:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;6.0.0\u0026#34; /\u0026gt; would change to:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;6.1.0\u0026#34; /\u0026gt; Step 2: Update Database Schema (if needed) If you are using a database for your configuration or operational data, then there is a database schema update. This includes:\nServer-side sessions feature, which requires a new table (more details). Session coordination feature, which adds a column to the Clients table (more details). Improve primary key on the persisted grants table (more details). IdentityServer is abstracted from the data store on multiple levels, so the exact steps involved in updating your data store will depend on your implementation details.\nCustom Store Implementations The core of IdentityServer is written against the store interfaces, which abstract all the implementation details of actually storing data. If your IdentityServer implementation includes a custom implementation of those stores, then you will have to determine how best to include the changes in the model in the underlying data store and make any necessary changes to schemas, if your data store requires that.\nDuende.IdentityServer.EntityFramework We also provide a default implementation of the stores in the Duende.IdentityServer.EntityFramework package, but this implementation is still highly abstracted because it is usable with any database that has an EF provider. Different database vendors have very different dialects of sql that have different syntax and type systems, so we don\u0026rsquo;t provide schema changes directly. Instead, we provide the Entity Framework entities and mappings which can be used with Entity Framework\u0026rsquo;s migrations feature to generate the schema updates that are needed in your database.\nTo generate migrations, run the commands below. Note that you might need to adjust paths based on your specific organization of the migration files.\ndotnet ef migrations add Update_DuendeIdentityServer_v6_1 -c ConfigurationDbContext -o Data/Migrations/IdentityServer/ConfigurationDb dotnet ef migrations add Update_DuendeIdentityServer_v6_1 -c PersistedGrantDbContext -o Data/Migrations/IdentityServer/PersistedGrantDb Then to apply those changes to your database:\ndotnet ef database update -c ConfigurationDbContext dotnet ef database update -c PersistedGrantDbContext Some organizations prefer to use other tools for managing schema changes. You\u0026rsquo;re free to manage your schema however you see fit, as long as the entities can be successfully mapped. Even if you\u0026rsquo;re not going to ultimately use Entity Framework migrations to manage your database changes, generating a migration can be a useful development step to get an idea of what needs to be done.\nStep 3: Done! That\u0026rsquo;s it. Of course, at this point you can and should test that your IdentityServer is updated and working properly.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/ui/login/external/",
    "title": "Integrating with External Providers",
    "tags": [],
    "description": "",
    "content": "External Identity Providers One option for allowing your users to login is by using an external identity provider. These external providers can be a social login for your users (e.g. Google), a corporate login system (e.g. Azure AD for employees), or some other login system your users use.\nThe workflow using an external provider is much like the workflow from one of your client applications using your IdentityServer. Your login page must redirect the user to the identity provider for login, and the identity provider will redirect the user to a callback endpoint in your IdentityServer to process the results. This means the external provider should implement a standard protocol (e.g. Open ID Connect, SAML2-P, or WS-Federation) to allow such an integration.\nIt is possible to use a custom protocol to allow logins from an external provider, but you are taking on risk using something that is not as widely validated and scrutinized as one of the standard authentication protocols (e.g. Open ID Connect, SAML2-P, or WS-Federation).\nTo ease integration with external providers, it is recommended to use an authentication handler for ASP.NET Core that implements the corresponding protocol used by the provider. Many are available as part of ASP.NET Core, but you might need to find others (both commercial and free) for things like SAML2-P and other social login systems not provided by ASP.NET Core.\nRegistering Authentication Handlers for External Providers Supporting an external provider is achieved by simply registering the handler in your IdentityServer\u0026rsquo;s startup. For example, to use employee logins from Azure AD (AAD):\npublic void ConfigureServices(IServiceCollection services) { services.AddIdentityServer(); services.AddAuthentication() .AddOpenIdConnect(\u0026#34;AAD\u0026#34;, \u0026#34;Employee Login\u0026#34;, options =\u0026gt; { // options omitted }); } The above snippet registers a scheme called AAD in the ASP.NET Core authentication system, and uses a human-friendly display name of \u0026ldquo;Employee Login\u0026rdquo;. The options necessary will be different based on the protocol and identity provider used, and are beyond the scope of this documentation.\nTriggering the Authentication Handler To allow the user to be redirected to the external provider, there must be some code in your login page that triggers the handler. This can be done because you have provided the user with a button to click, or it could be due to inspecting some property of the authorization context, or it could be based on any other aspect of the request (e.g. such as the user entering their email).\nThe process of determining which identity provider to use is called Home Realm Discovery, or HRD for short.\nTo invoke an external authentication handler use the ChallengeAsync extension method on the HttpContext (or using the MVC ChallengeResult). When triggering challenge, it\u0026rsquo;s common to pass some properties to indicate the callback URL where you intend to process the external login results and any other state you need to maintain across the workflow (e.g. such as the return URL passed to the login page):\nvar callbackUrl = Url.Action(\u0026#34;MyCallback\u0026#34;); var props = new AuthenticationProperties { RedirectUri = callbackUrl, Items = { { \u0026#34;scheme\u0026#34;, \u0026#34;AAD\u0026#34; }, { \u0026#34;returnUrl\u0026#34;, returnUrl } } }; return Challenge(\u0026#34;AAD\u0026#34;, props); The Role of Cookies in External Logins ASP.NET Core needs a way to manage the state produced from the result of the external login. This state is managed (by default) with another cookie using ASP.NET Core\u0026rsquo;s cookie authentication handler.\nThis extra cookie is necessary since there are typically several redirects involved until you are done with the external authentication process.\nIf you are using ASP.NET Identity, many of these technical details are hidden from you. It is recommended that you also read the Microsoft docs and do the ASP.NET Identity quickstart.\nOne option on an external authentication handlers is called SignInScheme. This specifies the cookie handler to manage the state:\nservices.AddAuthentication() .AddOpenIdConnect(\u0026#34;AAD\u0026#34;, \u0026#34;Employee Login\u0026#34;, options =\u0026gt; { options.SignInScheme = \u0026#34;scheme of cookie handler to use\u0026#34;; // other options omitted }); Given that this is such a common practice, IdentityServer registers a cookie handler specifically for this external provider workflow. The scheme is represented via the IdentityServerConstants.ExternalCookieAuthenticationScheme constant. If you were to use our external cookie handler, then for the SignInScheme above you\u0026rsquo;d assign the value to be the IdentityServerConstants.ExternalCookieAuthenticationScheme constant:\nservices.AddAuthentication() .AddOpenIdConnect(\u0026#34;AAD\u0026#34;, \u0026#34;Employee Login\u0026#34;, options =\u0026gt; { options.SignInScheme = IdentityServerConstants.ExternalCookieAuthenticationScheme; // other options omitted }); Alternatively, you can also register your own custom cookie handler instead. For example:\nservices.AddAuthentication() .AddCookie(\u0026#34;MyTempHandler\u0026#34;) .AddOpenIdConnect(\u0026#34;AAD\u0026#34;, \u0026#34;Employee Login\u0026#34;, options =\u0026gt; { options.SignInScheme = \u0026#34;MyTempHandler\u0026#34;; // other options omitted }); For specialized scenarios, you can also short-circuit the external cookie mechanism and forward the external user directly to the main cookie handler. This typically involves handling events on the external handler to make sure you do the correct claims transformation from the external identity source.\nHandling the Callback On the callback page your typical tasks are:\nInspect the identity returned by the external provider. Make a decision how you want to deal with that user. This might be different based on if this is a new user or a returning user. New users might need additional steps and UI before they are allowed in. Typically this involves creating a new internal user account that is linked to the user from the external provider. Store the external claims that you want to keep. Delete the temporary cookie. Establish the user\u0026rsquo;s authentication session. Complete the login workflow. Inspecting the External Identity To access the result of the external login, invoke the AuthenticateAsync method. This will read the external cookie to retrieve the claims issued by the external provider and any other state you previously stored when calling ChallengeAsync:\n// read external identity from the temporary cookie var result = await HttpContext.AuthenticateAsync(IdentityServerConstants.ExternalCookieAuthenticationScheme); if (result?.Succeeded != true) { throw new Exception(\u0026#34;External authentication error\u0026#34;); } // retrieve claims of the external user var externalUser = result.Principal; if (externalUser == null) { throw new Exception(\u0026#34;External authentication error\u0026#34;); } // retrieve claims of the external user var userId = externalUser.FindFirst(\u0026#34;sub\u0026#34;).Value; var scheme = result.Properties.Items[\u0026#34;scheme\u0026#34;]; // retrieve returnUrl var returnUrl = result.Properties.Items[\u0026#34;returnUrl\u0026#34;] ?? \u0026#34;~/\u0026#34;; // use the user information to find your user in your database, or provision a new user The sub claim from the external cookie is the external provider\u0026rsquo;s unique id for the user. This value should be used to locate your local user record for the user.\nEstablish Session, Clean Up, and Resume Workflow Once your callback page logic has identified the user based on the external identity provider, it will log the user in and complete the original login workflow:\nvar user = FindUserFromExternalProvider(scheme, userId); // issue authentication cookie for user await HttpContext.SignInAsync(new IdentityServerUser(user.SubjectId) { DisplayName = user.DisplayName, IdentityProvider = scheme }); // delete temporary cookie used during external authentication await HttpContext.SignOutAsync(IdentityServerConstants.ExternalCookieAuthenticationScheme); // return back to protocol processing return Redirect(returnUrl); Typically, the sub value used to log the user in would be the user\u0026rsquo;s unique id from your local user database.\nState, URL length, and ISecureDataFormat When redirecting to an external provider for sign-in, frequently state from the client application must be roundtripped. This means that state is captured prior to leaving the client and preserved until the user has returned to the client application. Many protocols, including OpenID Connect, allow passing some sort of state as a parameter as part of the request, and the identity provider will return that state in the response. The OpenID Connect authentication handler provided by ASP.NET Core utilizes this feature of the protocol, and that is how it implements the returnUrl feature mentioned above.\nThe problem with storing state in a request parameter is that the request URL can get too large (over the common limit of 2000 characters). The OpenID Connect authentication handler does provide an extensibility point to store the state in your server, rather than in the request URL. You can implement this yourself by implementing ISecureDataFormat and configuring it on the OpenIdConnectOptions.\nFortunately, IdentityServer provides an implementation of this for you, backed by the IDistributedCache implementation registered in the DI container (e.g. the standard MemoryDistributedCache). To use the IdentityServer provided secure data format implementation, simply call the AddOidcStateDataFormatterCache extension method on the IServiceCollection when configuring DI.\nIf no parameters are passed, then all OpenID Connect handlers configured will use the IdentityServer provided secure data format implementation:\npublic void ConfigureServices(IServiceCollection services) { // configures the OpenIdConnect handlers to persist the state parameter into the server-side IDistributedCache. services.AddOidcStateDataFormatterCache(); services.AddAuthentication() .AddOpenIdConnect(\u0026#34;demoidsrv\u0026#34;, \u0026#34;IdentityServer\u0026#34;, options =\u0026gt; { // ... }) .AddOpenIdConnect(\u0026#34;aad\u0026#34;, \u0026#34;Azure AD\u0026#34;, options =\u0026gt; { // ... }) .AddOpenIdConnect(\u0026#34;adfs\u0026#34;, \u0026#34;ADFS\u0026#34;, options =\u0026gt; { // ... }); } If only particular schemes are to be configured, then pass those schemes as parameters:\npublic void ConfigureServices(IServiceCollection services) { // configures the OpenIdConnect handlers to persist the state parameter into the server-side IDistributedCache. services.AddOidcStateDataFormatterCache(\u0026#34;aad\u0026#34;, \u0026#34;demoidsrv\u0026#34;); // rest omitted } See this quickstart for step-by-step instructions for adding external authentication and configuring it.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/fundamentals/license_key/",
    "title": "License Key",
    "tags": [],
    "description": "",
    "content": "When deploying your IdentityServer to production, you will need to configure your license key. This can be configured in one of two ways:\nVia a well-known file on the file system Programmatically in your startup code File System Duende IdentityServer will look for a file called Duende_License.key in the same directory as your hosting application. If present, the contents of the file will be loaded as the license key.\nStartup If you prefer to load the license key dynamically (e.g. from an API or environment variable), you can in your startup code. When calling AddIdentityServer from ConfigureServices, you can pass a lambda expression to configure various options in your IdentityServer. The LicenseKey is one such setting.\nThe contents of the license key file is text, and so that is the value to assign to the LicenseKey property. For example:\npublic void ConfigureServices(IServiceCollection services) { services.AddIdentityServer(options =\u0026gt; { options.LicenseKey = \u0026#34;eyJhbG...\u0026#34;; // the contents of the license key file }); } License Validation and Logging All license validation is self-contained and does not leave the host (meaning there are no outbound calls related to license validation). Any messages from the license validation layer will be emitted to the logging system. The level of the log entry depends on the nature of the message and the type of license.\nType of Message Standard License Redistribution License (development*) Redistribution License (production*) Startup, missing license Warning Warning Warning Startup, license details Debug Debug Trace Startup, valid license notice Informational Informational Trace Startup, violations Error Error Trace Runtime, violations Error Error Trace * as determined by IHostEnvironment.IsDevelopment()\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/configuration/dcr/reference/options/",
    "title": "Options",
    "tags": [],
    "description": "",
    "content": "IdentityServerConfigurationOptions Top level options for IdentityServer.Configuration.\npublic class IdentityServerConfigurationOptions Public Members name description DynamicClientRegistration { get; set; } Options for Dynamic Client Registration DynamicClientRegistrationOptions Options for dynamic client registration.\npublic class DynamicClientRegistrationOptions Public Members name description SecretLifetime { get; set; } Gets or sets the lifetime of secrets generated for clients. If unset, generated secrets will have no expiration. Defaults to null (secrets never expire). "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/ui/logout/client_redirect/",
    "title": "Returning to the Client",
    "tags": [],
    "description": "",
    "content": "If sign-out was initiated by a client application, then the client first redirected the user to the end session endpoint. This can be determined if a logoutId is passed to the login page and the returned LogoutRequest\u0026rsquo;s PostLogoutRedirectUri is set.\nHow to Redirect If there is a PostLogoutRedirectUri value, then it\u0026rsquo;s important how this URL is used to redirect the user. The logout page typically should not directly redirect the user to this URL. Doing so would skip the necessary front-channel notifications to clients.\nInstead, the typical approach is to render the PostLogoutRedirectUri as a link on the \u0026ldquo;logged out\u0026rdquo; page. This will allow the page to render, the front-channel iframes will load and perform their duty. It\u0026rsquo;s possible to add JavaScript to the page to enhance this experience even more.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/stores/",
    "title": "Stores",
    "tags": [],
    "description": "Reference",
    "content": "Stores Resource Store Client Store CORS Policy Service Identity Provider Store Persisted Grant Store Device Flow Store Backchannel Authentication Request Store Signing Key Store Server-Side Session Store "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/services/device_flow_interaction_service/",
    "title": "Device Flow Interaction Service",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Services.IDeviceFlowInteractionService The IDeviceFlowInteractionService interface is intended to provide services to be used by the user interface to communicate with Duende IdentityServer during device flow authorization. It is available from the dependency injection system and would normally be injected as a constructor parameter into your MVC controllers for the user interface of IdentityServer.\nIDeviceFlowInteractionService APIs GetAuthorizationContextAsync\nReturns the DeviceFlowAuthorizationRequest based on the userCode passed to the login or consent pages.\nDeviceFlowInteractionResult\nCompletes device authorization for the given userCode.\nDeviceFlowAuthorizationRequest ClientId\nThe client identifier that initiated the request.\nScopesRequested\nThe scopes requested from the authorization request.\nDeviceFlowInteractionResult IsError\nSpecifies if the authorization request errored.\nErrorDescription\nError description upon failure.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/ui/login/dynamicproviders/",
    "title": "Dynamic Providers",
    "tags": [],
    "description": "",
    "content": "Dynamic Identity Providers Normally authentication handlers for external providers are added into your IdentityServer using AddAuthentication() and AddOpenIdConnect(). This is fine for a handful of schemes, but the authentication handler architecture in ASP.NET Core was not designed for dozens or more statically registered in the DI system. At some point you will incur a performance penalty for having too many. Also, as you need to add or change this configuration you will need to re-compile and re-run your startup code for those changes to take effect.\nDuende IdentityServer provides support for dynamic configuration of OpenID Connect providers loaded from a store. This is designed to address the performance concern as well as allowing changes to the configuration to a running server.\nSupport for Dynamic Identity Providers is included in IdentityServer Enterprise Edition.\nListing and displaying the dynamic providers on the login page The identity provider store can be used to query the database containing the dynamic providers.\n/// \u0026lt;summary\u0026gt; /// Interface to model storage of identity providers. /// \u0026lt;/summary\u0026gt; public interface IIdentityProviderStore { /// \u0026lt;summary\u0026gt; /// Gets all identity providers name. /// \u0026lt;/summary\u0026gt; Task\u0026lt;IEnumerable\u0026lt;IdentityProviderName\u0026gt;\u0026gt; GetAllSchemeNamesAsync(); // other APIs omitted } These results can then be used to populate the list of options presented to the user on the login page.\nThis API is deliberately separate than the IAuthenticationSchemeProvider provided by ASP.NET Core, which returns the list of statically configured providers (from Startup.cs). This allows the developer to have more control over the customization on the login page (e.g. there might be hundreds or thousands on dynamic providers, and therefore you would not want them displayed on the login page, but you might have a few social providers statically configured that you would want to display).\nHere is an example of how the IdentityServer Quickstart UI uses both interfaces to then present a merged and unified list to the end user:\nvar schemes = await _schemeProvider.GetAllSchemesAsync(); var providers = schemes .Where(x =\u0026gt; x.DisplayName != null) .Select(x =\u0026gt; new ExternalProvider { DisplayName = x.DisplayName ?? x.Name, AuthenticationScheme = x.Name }).ToList(); var dynamicSchemes = (await _identityProviderStore.GetAllSchemeNamesAsync()) .Where(x =\u0026gt; x.Enabled) .Select(x =\u0026gt; new ExternalProvider { AuthenticationScheme = x.Scheme, DisplayName = x.DisplayName }); providers.AddRange(dynamicSchemes); Store and Configuration Data To use the dynamic providers feature an identity provider store must be provided that will load model data for the OIDC identity provider to be used. If you\u0026rsquo;re using the Entity Framework Integration then this is implemented for you.\nLike other configuration data in IdentityServer, by default the dynamic provider configuration is loaded from the store on every request unless caching is enabled. If you use a custom store, there is an extension method to enable caching. If you use the EF stores, there is general helper to enable caching for all configuration data.\nThe configuration data for the OIDC provider is used to assign the configuration on the ASP.NET Core OpenID Connect Options class, much like you would if you were to statically configure the options when using AddOpenIdConnect(). The identity provider model documentation provides details for the model properties and how they are mapped to the options.\nCustomizing OpenIdConnectOptions If it is needed to further customize the OpenIdConnectOptions, you can register in the DI system an instance of IConfigureNamedOptions\u0026lt;OpenIdConnectOptions\u0026gt;. For example:\npublic class CustomConfig : IConfigureNamedOptions\u0026lt;OpenIdConnectOptions\u0026gt; { public void Configure(string name, OpenIdConnectOptions options) { if (name == \u0026#34;MyScheme\u0026#34;) { options.ClaimActions.MapAll(); } } public void Configure(OpenIdConnectOptions options) { } } And to register this in the DI system:\npublic void ConfigureServices(IServiceCollection services) { services.ConfigureOptions\u0026lt;CustomConfig\u0026gt;(); } Accessing OidcProvider data in IConfigureNamedOptions If your customization of the OpenIdConnectOptions requires per-provider data that you are storing on the OidcProvider, then we provide an abstraction for the IConfigureNamedOptions\u0026lt;OpenIdConnectOptions\u0026gt;. This abstraction requires your code to derive from ConfigureAuthenticationOptions\u0026lt;OpenIdConnectOptions, OidcProvider\u0026gt; (rather than IConfigureNamedOptions\u0026lt;OpenIdConnectOptions\u0026gt;). For example:\nclass CustomOidcConfigureOptions : ConfigureAuthenticationOptions\u0026lt;OpenIdConnectOptions, OidcProvider\u0026gt; { public CustomOidcConfigureOptions(IHttpContextAccessor httpContextAccessor, ILogger\u0026lt;CustomOidcConfigureOptions\u0026gt; logger) : base(httpContextAccessor, logger) { } protected override void Configure(ConfigureAuthenticationContext\u0026lt;OpenIdConnectOptions, OidcProvider\u0026gt; context) { var oidcProvider = context.IdentityProvider; var oidcOptions = context.AuthenticationOptions; // TODO: configure oidcOptions with values from oidcProvider } } The above class would need to be configured in DI (as before):\npublic void ConfigureServices(IServiceCollection services) { services.ConfigureOptions\u0026lt;CustomOidcConfigureOptions\u0026gt;(); } Callback Paths As part of the architecture of the dynamic providers feature, the various callback paths are required and are automatically set to follow a convention. The convention of these paths follows the form of ~/federation/{scheme}/{suffix}.\nThese are three paths that are set on the OpenIdConnectOptions:\nCallbackPath. This is the OIDC redirect URI protocol value. The suffix \u0026ldquo;/signin\u0026rdquo; is used for this path. SignedOutCallbackPath. This is the OIDC post logout redirect URI protocol value. The suffix \u0026ldquo;/signout-callback\u0026rdquo; is used for this path. RemoteSignOutPath. This is the OIDC front channel logout URI protocol value. The suffix \u0026ldquo;/signout\u0026rdquo; is used for this path. This means for your IdentityServer running at \u0026ldquo;https://sample.duendesoftware.com\u0026rdquo; and an OIDC identity provider whose scheme is \u0026ldquo;idp1\u0026rdquo;, your client configuration with the external OIDC identity provider would be:\nThe redirect URI would be \u0026ldquo;https://sample.duendesoftware.com/federation/idp1/signin\u0026quot; The post logout redirect URI would be \u0026ldquo;https://sample.duendesoftware.com/federation/idp1/signout-callback\u0026quot; The front channel logout URI would be \u0026ldquo;https://sample.duendesoftware.com/federation/idp1/signout\u0026quot; DynamicProviderOptions The DynamicProviderOptions is a new options class in the IdentityServer options object model. It provides shared settings for the dynamic identity providers feature.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/extensibility/management/diagnostics/",
    "title": "BFF Diagnostics Endpoint Extensibility",
    "tags": [],
    "description": "",
    "content": "The BFF diagnostics endpoint can be customized by implementing the IDiagnosticsService or by extending DefaultDiagnosticsService, its default implementation.\nRequest Processing ProcessRequestAsync is the top level function called in the endpoint service and can be used to add arbitrary logic to the endpoint.\nFor example, you could take whatever actions you need before normal processing of the request like this:\npublic override Task ProcessRequestAsync(HttpContext context) { // Custom logic here return base.ProcessRequestAsync(context); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/overview/glossary/",
    "title": "Glossary",
    "tags": [],
    "description": "",
    "content": "Client A client is a piece of software that requests tokens from your IdentityServer - either for authenticating a user (requesting an identity token) or for accessing a resource (requesting an access token). A client must be first registered with your IdentityServer before it can request tokens and is identified by a unique client ID.\nThere are many different client types, e.g. web applications, native mobile or desktop applications, SPAs, server processes, etc.\nMore details\nAutomatic key management (Business Edition)\nThe automatic key management feature creates and manages key material for signing tokens and follows best practices for handling this key material, including storage and rotation.\nMore details\nDocumentation\nServer-side Session Management (Business Edition)\nThe server-side session management feature extends the ASP.NET Core cookie authentication handler to maintain a user\u0026rsquo;s authentication session state in a server-side store, rather than putting it all into a self-contained cookie. Using server-side sessions enables more architectural features in your IdentityServer, such as:\nquery and manage active user sessions (e.g. from an administrative app). detect session expiration and perform cleanup both in IdentityServer as well as in client apps. centralize and monitor session activity in order to achieve a system-wide inactivity timeout. More details\nDocumentation\nBFF Security Framework (Business Edition)\nThe Duende BFF (Backend for Frontend) security framework packages up guidance and the necessary components to secure browser-based frontends (e.g. SPAs or Blazor WASM applications) with ASP.NET Core backends.\nMore details\nDocumentation\nDynamic Client Registration (Business Edition)\nImplementation of RFC 8707. Provides a standards-based endpoint to register clients and their configuration.\nDocumentation\nDynamic Authentication Providers (Enterprise Edition)\nThe dynamic configuration feature allows dynamic loading of configuration for OpenID Connect providers from a store. This is designed to address the performance concern as well as allowing changes to the configuration to a running server.\nMore details\nDocumentation\nResource Isolation (Enterprise Edition)\nThe resource isolation feature allows a client to request access tokens for an individual resource server. This allows API-specific features such as access token encryption and isolation of APIs that are not in the same trust boundary.\nMore details\nDocumentation\nCIBA (Enterprise Edition)\nDuende IdentityServer supports the Client-Initiated Backchannel Authentication Flow (also known as CIBA). This allows a user to login with a higher security device (e.g. their mobile phone) than the device on which they are using an application (e.g. a public kiosk). CIBA is one of the requirements to support the Financal-grade API compliance.\nMore details\nDocumentation\nProof-of-Possession at the Application Layer / DPoP (Enterprise Edition)\nA mechanism for sender-constraining OAuth 2.0 tokens via a proof-of-possession mechanism on the application level. This mechanism allows for the detection of replay attacks with access and refresh tokens.\nDocumentation\nSingle Deployment A single deployment acts as a single OpenID Connect / OAuth authority hosted at a single URL. It can consist of multiple physical or virtual nodes for load-balancing or fail-over purposes.\nMultiple Deployment Can be either completely independent single deployments, or a single deployment that acts as multiple authorities.\nMultiple Authorities A single logical deployment that acts as multiple logical token services on multiple URLs or host names (e.g. for branding, isolation or multi-tenancy reasons).\nStandard Developer Support Online developer community forum for Duende Software product issues and bugs.\nPriority Developer Support (Enterprise Edition)\nHelpdesk system with guaranteed response time for Duende Software product issues and bugs.\nMore details\nSecurity Notification System Notification system for security bugs and/or reported vulnerabilities.\nMore details\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/models/secrets/",
    "title": "Secrets",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Validation.ISecretParser Parses a secret from the raw HTTP request.\npublic interface ISecretParser { /// \u0026lt;summary\u0026gt; /// Tries to find a secret on the context that can be used for authentication /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;context\u0026#34;\u0026gt;The HTTP context.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;A parsed secret\u0026lt;/returns\u0026gt; Task\u0026lt;ParsedSecret\u0026gt; ParseAsync(HttpContext context); /// \u0026lt;summary\u0026gt; /// Returns the authentication method name that this parser implements /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;The authentication method.\u0026lt;/value\u0026gt; string AuthenticationMethod { get; } } AuthenticationMethod\nThe name of the authentication method that this parser registers for. This value must be unique and will be displayed in the discovery document.\nParseAsync\nThe job of this method is to extract the secret from the HTTP request and parse it into a ParsedSecret\nDuende.IdentityServer.Model.ParsedSecret Represents a parsed secret.\n/// \u0026lt;summary\u0026gt; /// Represents a secret extracted from the HttpContext /// \u0026lt;/summary\u0026gt; public class ParsedSecret { /// \u0026lt;summary\u0026gt; /// Gets or sets the identifier associated with this secret /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The identifier. /// \u0026lt;/value\u0026gt; public string Id { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the credential to verify the secret /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The credential. /// \u0026lt;/value\u0026gt; public object Credential { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the type of the secret /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The type. /// \u0026lt;/value\u0026gt; public string Type { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets additional properties. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The properties. /// \u0026lt;/value\u0026gt; public Dictionary\u0026lt;string, string\u0026gt; Properties { get; set; } = new Dictionary\u0026lt;string, string\u0026gt;(); } The parsed secret is forwarded to the registered secret validator. The validator will typically inspect the Type property to determine if this secret is something that can be validated by that validator instance. If yes, it will know how to cast the Credential object into a format that is understood.\nDuende.IdentityServer.Validation.ISecretParser Validates a parsed secret.\npublic interface ISecretValidator { /// \u0026lt;summary\u0026gt;Validates a secret\u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;secrets\u0026#34;\u0026gt;The stored secrets.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;parsedSecret\u0026#34;\u0026gt;The received secret.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;A validation result\u0026lt;/returns\u0026gt; Task\u0026lt;SecretValidationResult\u0026gt; ValidateAsync( IEnumerable\u0026lt;Secret\u0026gt; secrets, ParsedSecret parsedSecret); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/upgrades/v5.2_to_v6.0/",
    "title": "Duende IdentityServer v5.2 to v6.0",
    "tags": [],
    "description": "",
    "content": "This upgrade guide covers upgrading from Duende IdentityServer v5.2 to v6.0 (release notes). The most significant aspect of this upgrade is that Duende IdentityServer v6.0 targets .NET 6, and CIBA support was added.\nWith any major release, there is always the possibility of some breaking changes. This issue tracks the list of updates where a breaking change might affect your use of IdentityServer. It would be useful to review it to understand if any of these changes affect you.\nStep 1: Update to .NET 6 In your IdentityServer host project, update the version of the .NET framework. For example in your project file:\n\u0026lt;TargetFramework\u0026gt;netcoreapp3.1\u0026lt;/TargetFramework\u0026gt; would change to:\n\u0026lt;TargetFramework\u0026gt;net6.0\u0026lt;/TargetFramework\u0026gt; Also, any other NuGets that you were previously using that targeted an older version of .NET should be updated. For example, Microsoft.EntityFrameworkCore.SqlServer or Microsoft.AspNetCore.Authentication.Google. Depending on what your application was using, there may or may not be code changes based on those updated NuGet packages.\nStep 2: Update the IdentityServer NuGet package In your IdentityServer host project, update the version of the Duende IdentityServer NuGet. For example in your project file:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;5.2.0\u0026#34; /\u0026gt; would change to:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;6.0.0\u0026#34; /\u0026gt; Step 3: Update Database Schema (if needed) If you are using a database for your configuration data, then there is a small database schema update. This includes:\nAdd missing columns for created, updated, etc to EF entities (more details). Add unique constraints to EF tables where duplicate records not allowed (more details). IdentityServer is abstracted from the data store on multiple levels, so the exact steps involved in updating your data store will depend on your implementation details. Custom Store Implementations The core of IdentityServer is written against the store interfaces, which abstract all the implementation details of actually storing data. If your IdentityServer implementation includes a custom implementation of those stores, then you will have to determine how best to include the changes in the model in the underlying data store and make any necessary changes to schemas, if your data store requires that.\nDuende.IdentityServer.EntityFramework We also provide a default implementation of the stores in the Duende.IdentityServer.EntityFramework package, but this implementation is still highly abstracted because it is usable with any database that has an EF provider. Different database vendors have very different dialects of sql that have different syntax and type systems, so we don\u0026rsquo;t provide schema changes directly. Instead, we provide the Entity Framework entities and mappings which can be used with Entity Framework\u0026rsquo;s migrations feature to generate the schema updates that are needed in your database.\nTo generate a migration, run the command below. Note that you might need to adjust paths based on your specific organization of the migration files.\ndotnet ef migrations add Update_DuendeIdentityServer_v6_0 -c ConfigurationDbContext -o Data/Migrations/IdentityServer/ConfigurationDb You will likely get the warning \u0026ldquo;An operation was scaffolded that may result in the loss of data. Please review the migration for accuracy.\u0026rdquo;. This is due to the fact that in this release the column length for redirect URIs (for both login and logout) was reduced from 2000 to 400. This was needed because some database providers have limits on index size. This should not affect you unless you are using redirect URIs greater than 400 characters.\nThen to apply those changes to your database:\ndotnet ef database update -c ConfigurationDbContext Some organizations prefer to use other tools for managing schema changes. You\u0026rsquo;re free to manage your schema however you see fit, as long as the entities can be successfully mapped. Even if you\u0026rsquo;re not going to ultimately use Entity Framework migrations to manage your database changes, generating a migration can be a useful development step to get an idea of what needs to be done.\nStep 4: Verify Data Protection Configuration IdentityServer depends on ASP.NET Data Protection. Data Protection encrypts and signs data using keys managed by ASP.NET. Those keys are isolated by application name, which by default is set to the content root path of the host. This prevents multiple applications from sharing encryption keys, which is necessary to protect your encryption against certain forms of attack. However, this means that if your content root path changes, the default settings for data protection will prevent you from using your old keys. Beginning in .NET 6, the content root path is now normalized so that it ends with a directory separator. This means that your content root path might change when you upgrade to .NET 6. This can be mitigated by explicitly setting the application name and removing the separator character. See Microsoft\u0026rsquo;s documentation for more information.\nStep 5: Done! That\u0026rsquo;s it. Of course, at this point you can and should test that your IdentityServer is updated and working properly.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/ui/logout/external/",
    "title": "External Logout",
    "tags": [],
    "description": "",
    "content": "When a user is logging out, and they have used an external identity provider to sign-in then it is likely that they should be redirected to also sign-out of the external provider. Not all external providers support sign-out, as it depends on the protocol and features they support.\nDon\u0026rsquo;t forget that your logout page still needs to complete all the other steps to properly sign the user out. This is complicated if the logout page must redirect to an external provider to sign out. To achieve both, it is necessary to have the external provider to redirect the user back to your IdentityServer after signing out of the external provider. Across this redirect exchange, there will be state that must be maintained so the complete sign out workflow can complete successfully.\nDetermining the Identity Provider To detect that a user must be redirected to an external identity provider for sign-out is typically done by using an idp claim issued into the cookie at IdentityServer. The value is either local for a local sign-in or the scheme of the corresponding authentication handler used for an external provider. At sign-out time this claim should be consulted to determine if an external sign-out is required.\nThe constant IdentityServerConstants.LocalIdentityProvider can be used instead of hard coding the value local for the local login provider identifier.\nRedirecting to the External Provider To trigger logout at an external provider, use the SignOutAsync extension method on the HttpContext (or the SignOutResult action result in MVC or Razor Pages). You must pass the scheme of the provider as configured in your startup (which should also match the idp claim mentioned above).\npublic IActionResult Logout(string logoutId) { // other code elided var idp = User.FindFirst(\u0026#34;idp\u0026#34;).Value; if (idp != IdentityServerConstants.LocalIdentityProvider) { return SignOut(idp); } // other code elided } Redirecting back from the External Provider and State Management To redirect back to your IdentityServer after the external provider sign-out, the RedirectUri should be used on the AuthenticationProperties when using ASP.NET Core\u0026rsquo;s SignOutAsync API.\nRecall that after we return, we must perform the other steps to complete the logout workflow. These steps require the context passed as the logoutId parameter, so this state needs to be roundtripped to the external provider. We can do so by incorporating the logoutId value into the RedirectUri.\nIf there is no logoutId parameter on the original logout page request, we still might have context that needs to be round tripped. We can obtain a logoutId to use by calling CreateLogoutContextAsync API on the interaction service.\nFor example:\npublic async Task\u0026lt;IActionResult\u0026gt; Logout(string logoutId) { // other code elided var idp = User.FindFirst(\u0026#34;idp\u0026#34;).Value; if (idp != IdentityServerConstants.LocalIdentityProvider) { logoutId = logoutId ?? await _interaction.CreateLogoutContextAsync(); string url = Url.Action(\u0026#34;Logout\u0026#34;, new { logoutId = logoutId }); return SignOut(new AuthenticationProperties { RedirectUri = url }, idp); } // other code elided } Once the user is signed-out of the external provider and then redirected back, the normal sign-out processing at your IdentityServer should execute which involves processing the logoutId and doing all necessary cleanup.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/validators/",
    "title": "Validators",
    "tags": [],
    "description": "Reference",
    "content": "Validators Custom Authorize Request Validator Custom Token Request Validator Backchannel Authentication User Validator DPoP Proof Validator Extension Grant Validator "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/ui/login/windows/",
    "title": "Windows Authentication",
    "tags": [],
    "description": "",
    "content": "There are several ways how you can enable Windows authentication in ASP.NET Core (and thus in your IdentityServer).\nOn Windows using IIS hosting (both in- and out-of process) On Windows using HTTP.SYS hosting On any platform using the Negotiate authentication handler (added in ASP.NET Core 3.0) See the Microsoft documentation for additional information.\nOn Windows using IIS hosting The typical ASP.NET Core CreateDefaultBuilder host setup enables support for IIS-based Windows authentication when hosting in IIS. Make sure that Windows authentication is enabled in launchSettings.json or your IIS configuration.\nThe IIS integration layer will configure a Windows authentication handler into DI that can be invoked via the authentication service. Typically in your IdentityServer it is advisable to disable the automatic behavior.\nThis is done in ConfigureServices (details vary depending on in-proc vs out-of-proc hosting)::\n// configures IIS out-of-proc settings (see https://github.com/aspnet/AspNetCore/issues/14882) services.Configure\u0026lt;IISOptions\u0026gt;(iis =\u0026gt; { iis.AuthenticationDisplayName = \u0026#34;Windows\u0026#34;; iis.AutomaticAuthentication = false; }); // ..or configures IIS in-proc settings services.Configure\u0026lt;IISServerOptions\u0026gt;(iis =\u0026gt; { iis.AuthenticationDisplayName = \u0026#34;Windows\u0026#34;; iis.AutomaticAuthentication = false; }); You trigger Windows authentication by calling ChallengeAsync using the Windows scheme (or if you want to use a constant: Microsoft.AspNetCore.Server.IISIntegration.IISDefaults.AuthenticationScheme).\nThis will send the Www-Authenticate header back to the browser which will then re-load the current URL including the Windows identity. You can tell that Windows authentication was successful, when you call AuthenticateAsync on the Windows scheme and the principal returned is of type WindowsPrincipal.\nThe principal will have information like user and group SID and the Windows account name. The following snippet shows how to trigger authentication, and if successful convert the information into a standard ClaimsPrincipal for the temp-Cookie approach::\nprivate async Task\u0026lt;IActionResult\u0026gt; ChallengeWindowsAsync(string returnUrl) { // see if windows auth has already been requested and succeeded var result = await HttpContext.AuthenticateAsync(\u0026#34;Windows\u0026#34;); if (result?.Principal is WindowsPrincipal wp) { // we will issue the external cookie and then redirect the // user back to the external callback, in essence, treating windows // auth the same as any other external authentication mechanism var props = new AuthenticationProperties() { RedirectUri = Url.Action(\u0026#34;Callback\u0026#34;), Items = { { \u0026#34;returnUrl\u0026#34;, returnUrl }, { \u0026#34;scheme\u0026#34;, \u0026#34;Windows\u0026#34; }, } }; var id = new ClaimsIdentity(\u0026#34;Windows\u0026#34;); // the sid is a good sub value id.AddClaim(new Claim(JwtClaimTypes.Subject, wp.FindFirst(ClaimTypes.PrimarySid).Value)); // the account name is the closest we have to a display name id.AddClaim(new Claim(JwtClaimTypes.Name, wp.Identity.Name)); // add the groups as claims -- be careful if the number of groups is too large var wi = wp.Identity as WindowsIdentity; // translate group SIDs to display names var groups = wi.Groups.Translate(typeof(NTAccount)); var roles = groups.Select(x =\u0026gt; new Claim(JwtClaimTypes.Role, x.Value)); id.AddClaims(roles); await HttpContext.SignInAsync( IdentityServerConstants.ExternalCookieAuthenticationScheme, new ClaimsPrincipal(id), props); return Redirect(props.RedirectUri); } else { // trigger windows auth // since windows auth don\u0026#39;t support the redirect uri, // this URL is re-triggered when we call challenge return Challenge(\u0026#34;Windows\u0026#34;); } } A sample is provided here.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/services/ciba_interaction_service/",
    "title": "Backchannel Authentication Interaction Service",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Services.IBackchannelAuthenticationInteractionService The IBackchannelAuthenticationInteractionService interface provides services for a user to access or complete a login requests for CIBA. It is available from the dependency injection system and would normally be injected as a constructor parameter into your MVC controllers for the user interface of IdentityServer.\nIBackchannelAuthenticationInteractionService APIs GetPendingLoginRequestsForCurrentUserAsync\nReturns a collection of BackchannelUserLoginRequest objects which represent pending login requests for the current user.\nGetLoginRequestByInternalIdAsync\nReturns the BackchannelUserLoginRequest object for the id.\nCompleteLoginRequestAsync\nCompletes the login request with the provided CompleteBackchannelLoginRequest response for the current user or the subject passed.\nCompleteBackchannelLoginRequest Models the data needed for a user to complete a backchannel authentication request.\nInternalId\nThe internal store id for the request.\nScopesValuesConsented\nGets or sets the scope values consented to. Setting any scopes grants the login request. Leaving the scopes null or empty denies the request.\nDescription\nGets or sets the optional description to associate with the consent.\nSubject\nThe subject for which the completion is being made. This allows more claims to be associated with the request that was identified on the backchannel authentication request. If not provided, then the IUserSession service will be consulting to obtain the current subject.\nSessionId\nThe session id to associate with the completion request if the Subject is provided. If the Subject is not provided, then this property is ignored in favor of the session id provided by the IUserSession service.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/stores/backchannel_auth_request_store/",
    "title": "Backchannel Authentication Request Store",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Stores.IBackChannelAuthenticationRequestStore Used to store backchannel login requests (for CIBA).\n/// \u0026lt;summary\u0026gt; /// Interface for the backchannel authentication request store /// \u0026lt;/summary\u0026gt; public interface IBackChannelAuthenticationRequestStore { /// \u0026lt;summary\u0026gt; /// Creates the request. /// \u0026lt;/summary\u0026gt; Task\u0026lt;string\u0026gt; CreateRequestAsync(BackChannelAuthenticationRequest request); /// \u0026lt;summary\u0026gt; /// Gets the requests. /// \u0026lt;/summary\u0026gt; Task\u0026lt;IEnumerable\u0026lt;BackChannelAuthenticationRequest\u0026gt;\u0026gt; GetLoginsForUserAsync(string subjectId, string clientId = null); /// \u0026lt;summary\u0026gt; /// Gets the request. /// \u0026lt;/summary\u0026gt; Task\u0026lt;BackChannelAuthenticationRequest\u0026gt; GetByAuthenticationRequestIdAsync(string requestId); /// \u0026lt;summary\u0026gt; /// Gets the request. /// \u0026lt;/summary\u0026gt; Task\u0026lt;BackChannelAuthenticationRequest\u0026gt; GetByInternalIdAsync(string id); /// \u0026lt;summary\u0026gt; /// Removes the request. /// \u0026lt;/summary\u0026gt; Task RemoveByInternalIdAsync(string id); /// \u0026lt;summary\u0026gt; /// Updates the request. /// \u0026lt;/summary\u0026gt; Task UpdateByInternalIdAsync(string id, BackChannelAuthenticationRequest request); } BackChannelAuthenticationRequest /// \u0026lt;summary\u0026gt; /// Models a backchannel authentication request. /// \u0026lt;/summary\u0026gt; public class BackChannelAuthenticationRequest { /// \u0026lt;summary\u0026gt; /// The identifier for this request in the store. /// \u0026lt;/summary\u0026gt; public string InternalId { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the creation time. /// \u0026lt;/summary\u0026gt; public DateTime CreationTime { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the life time in seconds. /// \u0026lt;/summary\u0026gt; public int Lifetime { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the ID of the client. /// \u0026lt;/summary\u0026gt; public string ClientId { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the subject. /// \u0026lt;/summary\u0026gt; public ClaimsPrincipal Subject { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the requested scopes. /// \u0026lt;/summary\u0026gt; public IEnumerable\u0026lt;string\u0026gt; RequestedScopes { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the requested resource indicators. /// \u0026lt;/summary\u0026gt; public IEnumerable\u0026lt;string\u0026gt; RequestedResourceIndicators { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the authentication context reference classes. /// \u0026lt;/summary\u0026gt; public ICollection\u0026lt;string\u0026gt; AuthenticationContextReferenceClasses { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the tenant. /// \u0026lt;/summary\u0026gt; public string Tenant { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the idp. /// \u0026lt;/summary\u0026gt; public string IdP { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the binding message. /// \u0026lt;/summary\u0026gt; public string BindingMessage { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets a value indicating whether this instance has been completed. /// \u0026lt;/summary\u0026gt; public bool IsComplete { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the authorized scopes. /// \u0026lt;/summary\u0026gt; public IEnumerable\u0026lt;string\u0026gt; AuthorizedScopes { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the session identifier from which the user approved the request. /// \u0026lt;/summary\u0026gt; public string SessionId { get; set; } /// \u0026lt;summary\u0026gt; /// Gets the description the user assigned to the client being authorized. /// \u0026lt;/summary\u0026gt; public string Description { get; set; } } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/models/ciba_login_request/",
    "title": "Backchannel User Login Request",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Models.BackchannelUserLoginRequest Models the information to initiate a user login request for CIBA.\nInternalId\nIhe identifier of the request in the store.\nSubject\nThe subject for whom the login request is intended.\nBindingMessage\nThe binding message used in the request.\nAuthenticationContextReferenceClasses\nThe acr_values used in the request.\nTenant\nThe tenant value from the acr_values used the request.\nIdP\nThe idp value from the acr_values used in the request.\nRequestedResourceIndicators\nThe resource indicator values used in the request.\nClient\nThe client that initiated the request.\nValidatedResources\nThe validated resources (i.e. scopes) used in the request.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/data/",
    "title": "Data Stores and Persistence",
    "tags": [],
    "description": "",
    "content": "Data Stores and Persistence Duende IdentityServer is backed by two kinds of data:\nConfiguration Data Operational Data Data access is abstracted by store interfaces that are registered in the DI system. These store interfaces allow IdentityServer to access the data it needs at runtime when processing requests. You can implement these interfaces yourself and thus can use any database you wish. If you prefer a relational database for this data, then we provide EntityFramework Core implementations.\nGiven that data stores abstract the details of the data stored, strictly speaking, IdentityServer does not know or understand where the data is actually being stored. As such, there is no built-in administrative tool to populate or manage this data. There are third-party options (both commercial and FOSS) that provide an administrative UI for managing the data when using the EntityFramework Core implementations.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/upgrades/v5.1_to_v5.2/",
    "title": "Duende IdentityServer v5.1 to v5.2",
    "tags": [],
    "description": "",
    "content": "This upgrade guide covers upgrading from Duende IdentityServer v5.1 to v5.2 (release notes).\nStep 1: Update NuGet package In your IdentityServer host project, update the version of the NuGet. For example in your project file:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;5.1.0\u0026#34; /\u0026gt; would change to:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;5.2.0\u0026#34; /\u0026gt; Step 2: Update Database Schema (if needed) If you are using a database for your configuration data, then there is a database schema update for the new Dynamic Providers feature (more details). This includes:\nA new table called IdentityProviders for storing the OIDC provider details. Its TSQL schema would look like this: CREATE TABLE [IdentityProviders] ( [Id] int NOT NULL IDENTITY, [Scheme] nvarchar(200) NOT NULL, [DisplayName] nvarchar(200) NULL, [Enabled] bit NOT NULL, [Type] nvarchar(20) NOT NULL, [Properties] nvarchar(max) NULL, CONSTRAINT [PK_IdentityProviders] PRIMARY KEY ([Id]) ); IdentityServer is abstracted from the data store on multiple levels, so the exact steps involved in updating your data store will depend on your implementation details.\nCustom Store Implementations The core of IdentityServer is written against the store interfaces, which abstract all the implementation details of actually storing data. If your IdentityServer implementation includes a custom implementation of those stores, then you will have to determine how best to include the changes in the model in the underlying data store and make any necessary changes to schemas, if your data store requires that.\nDuende.IdentityServer.EntityFramework We also provide a default implementation of the stores in the Duende.IdentityServer.EntityFramework package, but this implementation is still highly abstracted because it is usable with any database that has an EF provider. Different database vendors have very different dialects of sql that have different syntax and type systems, so we don\u0026rsquo;t provide schema changes directly. Instead, we provide the Entity Framework entities and mappings which can be used with Entity Framework\u0026rsquo;s migrations feature to generate the schema updates that are needed in your database.\nTo generate a migration, run the command below. Note that you might need to adjust paths based on your specific organization of the migration files.\ndotnet ef migrations add Update_DuendeIdentityServer_v5_2 -c ConfigurationDbContext -o Data/Migrations/IdentityServer/ConfigurationDb Then to apply those changes to your database:\ndotnet ef database update -c ConfigurationDbContext Some organizations prefer to use other tools for managing schema changes. You\u0026rsquo;re free to manage your schema however you see fit, as long as the entities can be successfully mapped. Even if you\u0026rsquo;re not going to ultimately use Entity Framework migrations to manage your database changes, generating a migration can be a useful development step to get an idea of what needs to be done.\nStep 4: Update custom AuthorizeInteractionResponseGenerator (if needed) If you have created a custom, derived implementation of the AuthorizeInteractionResponseGenerator, then the constructor must accept an additional parameter of type IdentityServerOptions. This is needed for the new tenant validation in authorize endpoint requests.\nStep 5: Done! That\u0026rsquo;s it. Of course, at this point you can and should test that your IdentityServer is updated and working properly.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/validators/extension_grant_validator/",
    "title": "Extension Grant Validator",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Validation.IExtensionGrantValidator Use an implementation of this interface to handle extension grants.\npublic interface IExtensionGrantValidator { /// \u0026lt;summary\u0026gt; /// Handles the custom grant request. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;request\u0026#34;\u0026gt;The validation context.\u0026lt;/param\u0026gt; Task ValidateAsync(ExtensionGrantValidationContext context); /// \u0026lt;summary\u0026gt; /// Returns the grant type this validator can deal with /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The type of the grant. /// \u0026lt;/value\u0026gt; string GrantType { get; } } GrantType\nSpecifies the name of the extension grant that the implementation wants to register for.\nValidateAsync\nThis methods gets called at runtime, when a request comes in that is using the registered extension grant. The job of this method is to validate the request and to populate ExtensionGrantValidationContext.Result with a grant validation result\nThe instance of the extension grant validator gets registered with:\nbuilder.AddExtensionGrantValidator\u0026lt;MyValidator\u0026gt;(); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/ui/logout/external_notification/",
    "title": "External Logout Notification",
    "tags": [],
    "description": "",
    "content": "Federated sign-out is the situation where a user has used an external identity provider to log into IdentityServer, and then the user logs out of that external identity provider via a workflow unknown to IdentityServer. When the user signs out, it will be useful for IdentityServer to be notified so that it can sign the user out of IdentityServer and all of the applications that use IdentityServer.\nNot all external identity providers support federated sign-out, but those that do will provide a mechanism to notify clients that the user has signed out. This notification usually comes in the form of a request in an \u0026lt;iframe\u0026gt; from the external identity provider\u0026rsquo;s \u0026ldquo;logged out\u0026rdquo; page. IdentityServer must then notify all of its clients (as discussed here), also typically in the form of a request in an \u0026lt;iframe\u0026gt; from within the external identity provider\u0026rsquo;s \u0026lt;iframe\u0026gt;.\nWhat makes federated sign-out a special case (when compared to a normal logout) is that the federated sign-out request is not to the normal sign-out endpoint in IdentityServer. In fact, each external IdentityProvider will have a different endpoint into your IdentityServer host. This is due to that fact that each external identity provider might use a different protocol, and each middleware listens on different endpoints.\nThe net effect of all of these factors is that there is no \u0026ldquo;logged out\u0026rdquo; page being rendered as we would on the normal sign-out workflow, which means we are missing the sign-out notifications to IdentityServer\u0026rsquo;s clients. We must add code for each of these federated sign-out endpoints to render the necessary notifications to achieve federated sign-out.\nFortunately IdentityServer already contains this code. When requests come into IdentityServer and invoke the handlers for external authentication providers, IdentityServer detects if these are federated signout requests and if they are it will automatically render the same \u0026lt;iframe\u0026gt; as described here for logout.\nIn short, federated signout is automatically supported.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/overview/resources/",
    "title": "Resources",
    "tags": [],
    "description": "External Links",
    "content": "Below are links to relevant topics:\nOAuth and OIDC Fundamentals OAuth the good Parts (video from NDC Porto 2022) Securing SPAs and Blazor Applications using the BFF (video from NDC Porto 2022) Automated OAuth Access Token Management for .NET Workers and ASP.NET Web Applications ASP.NET Security Introduction to ASP.NET Core Authentication and Authorization ASP.NET Cookie Authentication Documentation Supporting External Authentication Providers Part 1 Supporting External Authentication Providers Part 2 End-User Authorization Authorization for Modern Applications (video from DevConf 2018) "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/options/",
    "title": "Configuration Options",
    "tags": [],
    "description": "BFF",
    "content": "The Duende.BFF.BffOptions allows to configure several aspects of the BFF framework.\nYou set the options at startup time in your ConfigureServices method:\nservices.AddBff(options =\u0026gt; { // configure options here.. }) General EnforceBffMiddleware\nEnables checks in the user management endpoints that ensure that the BFF middleware has been added to the pipeline. Since the middleware performs important security checks, this protects from accidental configuration errors. You can disable this check if it interferes with some custom logic you might have. Defaults to true.\nLicenseKey\nThis sets the license key for Duende.BFF. A business edition or higher license key is required for production deployments. The same license key is used in IdentityServer and the BFF. Just as in the IdentityServer host, you can either set the license key using this option in code or include Duende_License.key in the same directory as your BFF host.\nAnonymousSessionResponse (added in 2.0)\nThis sets the response status code behavior on the user endpoint to either return 401 or 200 with a null payload when the user is anonymous.\nDiagnosticsEnvironments\nThe ASP.NET environment names that enable the diagnostics endpoint. Defaults to \u0026ldquo;Development\u0026rdquo;.\nPaths LoginPath\nSets the path to the login endpoint. Defaults to /bff/login.\nSilentLoginPath\nSets the path to the silent login endpoint. Defaults to /bff/silent-login.\nSilentLoginCallbackPath\nSets the path to the silent login callback endpoint. Defaults to /bff/silent-login-callback.\nLogoutPath\nSets the path to the logout endpoint. Defaults to /bff/logout.\nUserPath\nSets the path to the user endpoint. Defaults to /bff/user.\nBackChannelLogoutPath\nSets the path to the backchannel logout endpoint. Defaults to /bff/backchannel.\nDiagnosticsPath\nSets the path to the diagnostics endpoint. Defaults to /bff/diagnostics.\nSession Management ManagementBasePath\nBase path for management endpoints. Defaults to /bff.\nRequireLogoutSessionId\nFlag that specifies if the sid claim needs to be present in the logout request as query string parameter. Used to prevent cross site request forgery. Defaults to true.\nRevokeRefreshTokenOnLogout\nSpecifies if the user\u0026rsquo;s refresh token is automatically revoked at logout time. Defaults to true.\nBackchannelLogoutAllUserSessions\nSpecifies if during backchannel logout all matching user sessions are logged out. If true, all sessions for the subject will be revoked. If false, just the specific session will be revoked. Defaults to false.\nEnableSessionCleanup\nIndicates if expired server side sessions should be cleaned up. This requires an implementation of IUserSessionStoreCleanup to be registered in the DI system. Defaults to false.\nSessionCleanupInterval\nInterval at which expired sessions are cleaned up. Defaults to 10 minutes.\nAPIs AntiForgeryHeaderName\nSpecifies the name of the header used for anti-forgery header protection. Defaults to X-CSRF.\nAntiForgeryHeaderValue\nSpecifies the expected value of Anti-forgery header. Defaults to 1.\nDPoPJsonWebKey\nSpecifies the Json Web Key to use when creating DPoP proof tokens. Defaults to null, which is appropriate when not using DPoP.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/diagnostics/",
    "title": "Diagnostics",
    "tags": [],
    "description": "Overview",
    "content": "Diagnostics Logging Events OpenTelemetry "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/aspnet_identity/",
    "title": "ASP.NET Identity Integration",
    "tags": [],
    "description": "Overview",
    "content": "ASP.NET Identity Integration An ASP.NET Identity-based implementation is provided for managing the identity database for users of IdentityServer. This implementation implements the extensibility points in IdentityServer needed to load identity data for your users to emit claims into tokens.\nTo use this library, ensure that you have the NuGet package for the ASP.NET Identity integration. It is called Duende.IdentityServer.AspNetIdentity. You can install it with:\ndotnet add package Duende.IdentityServer.AspNetIdentity Next, configure ASP.NET Identity normally in your IdentityServer host with the standard calls to AddIdentity and any other related configuration.\nThen in your Startup.cs, use the AddAspNetIdentity extension method after the call to AddIdentityServer:\npublic void ConfigureServices(IServiceCollection services) { services.AddIdentity\u0026lt;ApplicationUser, IdentityRole\u0026gt;() .AddEntityFrameworkStores\u0026lt;ApplicationDbContext\u0026gt;() .AddDefaultTokenProviders(); services.AddIdentityServer() .AddAspNetIdentity\u0026lt;ApplicationUser\u0026gt;(); } AddAspNetIdentity requires as a generic parameter the class that models your user for ASP.NET Identity (and the same one passed to AddIdentity to configure ASP.NET Identity). This configures IdentityServer to use the ASP.NET Identity implementations of IUserClaimsPrincipalFactory to convert the user data into claims, IResourceOwnerPasswordValidator to support the password grant type, and IProfileService which uses the IUserClaimsPrincipalFactory to add claims to tokens. It also configures some of ASP.NET Identity\u0026rsquo;s options for use with IdentityServer (such as claim types to use and authentication cookie settings).\nIf you need to use your own implementation of IUserClaimsPrincipalFactory, then that is supported. Our implementation of the IUserClaimsPrincipalFactory will use the decorator pattern to encapsulate yours. For this to work properly, ensure that your implementation is registered in the DI system prior to calling the IdentityServer AddAspNetIdentity extension method.\nTemplate Alternatively, you can use the isaspid template to create a starter IdentityServer host project configured to use ASP.NET Identity. See the Quickstart Documentation for a detailed walkthrough.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/services/ciba_user_notification/",
    "title": "Backchannel Authentication User Notification Service",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Services.IBackchannelAuthenticationUserNotificationService The IBackchannelAuthenticationUserNotificationService interface is used to contact users when a CIBA login request has been made. To use CIBA, you are expected to implement this interface and register it in the DI system.\nIBackchannelAuthenticationUserNotificationService APIs SendLoginRequestAsync\nSends a notification for the user to login via the BackchannelUserLoginRequest parameter.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/upgrades/v5.0_to_v5.1/",
    "title": "Duende IdentityServer v5.0 to v5.1",
    "tags": [],
    "description": "",
    "content": "This upgrade guide covers upgrading from Duende IdentityServer v5.0 to v5.1 (release notes). Fortunately there\u0026rsquo;s not much to do :)\nStep 1: Update NuGet package In your IdentityServer host project, update the version of the NuGet. For example in your project file:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;5.0.0\u0026#34; /\u0026gt; would change to:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;5.1.0\u0026#34; /\u0026gt; Step 2: Update Database Schema (if needed) If you are using the Duende.IdentityServer.EntityFramework package as the implementation for the database for your operational data, then there is a small database schema update. This includes:\nA new index on the ConsumedTime column in the PersistedGrants table (more details). If you\u0026rsquo;re using EntityFramework Core migrations as the mechanism for managing schema changes over time, the commands below will update those migrations with the new changes. Note that you might need to adjust based on your specific organization of the migration files.\ndotnet ef migrations add Update_DuendeIdentityServer_v5_1 -c PersistedGrantDbContext -o Data/Migrations/IdentityServer/PersistedGrantDb Then to apply those changes to your database:\ndotnet ef database update -c PersistedGrantDbContext Some organizations prefer to use other tools for managing schema changes. You\u0026rsquo;re free to manage your schema however you see fit, as long as the entities can be successfully mapped. Even if you\u0026rsquo;re not going to ultimately use Entity Framework migrations to manage your database changes, generating a migration can be a useful development step to get an idea of what needs to be done.\nStep 3: Done! That\u0026rsquo;s it. Of course, at this point you can and should test that your IdentityServer is updated and working properly.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/stores/signing_key_store/",
    "title": "Signing Key Store",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Stores.ISigningKeyStore Used to dynamically load client configuration.\n/// \u0026lt;summary\u0026gt; /// Interface to model storage of serialized keys. /// \u0026lt;/summary\u0026gt; public interface ISigningKeyStore { /// \u0026lt;summary\u0026gt; /// Returns all the keys in storage. /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task\u0026lt;IEnumerable\u0026lt;SerializedKey\u0026gt;\u0026gt; LoadKeysAsync(); /// \u0026lt;summary\u0026gt; /// Persists new key in storage. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task StoreKeyAsync(SerializedKey key); /// \u0026lt;summary\u0026gt; /// Deletes key from storage. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;id\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task DeleteKeyAsync(string id); } SerializedKey /// \u0026lt;summary\u0026gt; /// Serialized key. /// \u0026lt;/summary\u0026gt; public class SerializedKey { /// \u0026lt;summary\u0026gt; /// Version number of serialized key. /// \u0026lt;/summary\u0026gt; public int Version { get; set; } /// \u0026lt;summary\u0026gt; /// Key identifier. /// \u0026lt;/summary\u0026gt; public string Id { get; set; } /// \u0026lt;summary\u0026gt; /// Date key was created. /// \u0026lt;/summary\u0026gt; public DateTime Created { get; set; } /// \u0026lt;summary\u0026gt; /// The algorithm. /// \u0026lt;/summary\u0026gt; public string Algorithm { get; set; } /// \u0026lt;summary\u0026gt; /// Contains X509 certificate. /// \u0026lt;/summary\u0026gt; public bool IsX509Certificate { get; set; } /// \u0026lt;summary\u0026gt; /// Serialized data for key. /// \u0026lt;/summary\u0026gt; public string Data { get; set; } /// \u0026lt;summary\u0026gt; /// Indicates if data is protected. /// \u0026lt;/summary\u0026gt; public bool DataProtected { get; set; } } The Data property contains a copy of all of the values (and more) and is considered authoritative by IdentityServer, thus most of the other property values are considered informational and read-only.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/",
    "title": "BFF Security Framework",
    "tags": [],
    "description": "",
    "content": "BFF Security Framework The Duende.BFF (Backend for Frontend) security framework packages the necessary components to secure browser-based frontends (e.g. SPAs or Blazor WASM applications) with ASP.NET Core backends.\nDuende.BFF is included in IdentityServer Business Edition or higher. The same license and special offers apply.\nThe source code for the BFF framework can be found here. Builds are distributed through NuGet here, and samples are available here.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/configuration/dcr/",
    "title": "Dynamic Client Registration",
    "tags": [],
    "description": "",
    "content": "Dynamic Client Registration Dynamic Client Registration (DCR) is the process of registering OAuth clients dynamically. The client provides information about itself and specifies its desired configuration in an HTTP request to the configuration endpoint. The endpoint will then create the necessary client configuration and return an HTTP response describing the new client, if the request is authorized and valid.\nDCR eliminates the need for a manual registration process, making it more efficient and less time-consuming to register new clients.\nInstallation and Hosting Authorization Calling the Registration Endpoint Customization Reference "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/upgrades/is4_v4_to_dis_v6/",
    "title": "IdentityServer4 v4.1 to Duende IdentityServer v6",
    "tags": [],
    "description": "",
    "content": "This upgrade guide covers upgrading from IdentityServer4 v4.1.x to Duende IdentityServer v6.\nWith any major release, there is always the possibility of some breaking changes. This issue tracks the list of updates where a breaking change might affect your use of IdentityServer. It would be useful to review it to understand if any of these changes affect you.\nStep 1: Update to .NET 6 In your IdentityServer host project, update the version of the .NET framework. For example in your project file:\n\u0026lt;TargetFramework\u0026gt;netcoreapp3.1\u0026lt;/TargetFramework\u0026gt; would change to:\n\u0026lt;TargetFramework\u0026gt;net6.0\u0026lt;/TargetFramework\u0026gt; Also, any other NuGets that you were previously using that targeted an older version of .NET should be updated. For example, Microsoft.EntityFrameworkCore.SqlServer or Microsoft.AspNetCore.Authentication.Google. Depending on what your application was using, there may or may not be code changes based on those updated NuGet packages.\nStep 2: Update the IdentityServer NuGet package In your IdentityServer host project, update the IdentityServer NuGet being used from IdentityServer4 to Duende IdentityServer. For example in your project file:\n\u0026lt;PackageReference Include=\u0026#34;IdentityServer4\u0026#34; Version=\u0026#34;4.1.1\u0026#34; /\u0026gt; would change to the latest version of Duende IdentityServer:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;6.0.0\u0026#34; /\u0026gt; If you\u0026rsquo;re using any of the other IdentityServer4 packages, such as IdentityServer4.EntityFramework or IdentityServer4.AspNetIdentity, then there are Duende equivalents such as Duende.IdentityServer.EntityFramework and Duende.IdentityServer.AspNetIdentity, respectively.\nStep 3: Update Namespaces Anywhere IdentityServer4 was used as a namespace, replace it with Duende.IdentityServer. For example:\nusing IdentityServer4; using IdentityServer4.Models; would change to:\nusing Duende.IdentityServer; using Duende.IdentityServer.Models; Step 4: Remove AddDeveloperSigningCredential If in ConfigureServices in your Startup.cs you were previously using AddDeveloperSigningCredential, that can be removed. Automatic key management is now a built-in feature.\nStep 5: Update Database Schema (if needed) If you are using a database for your configuration and operational data, then there are database schema updates. These include:\nA new Keys table for the automatic key management feature in the operational database. A new RequireResourceIndicator boolean column on the ApiResources table in the configuration database. A new index on the ConsumedTime column in the PersistedGrants table (more details). A new table called IdentityProviders for storing the OIDC provider details (more details). Add missing columns for created, updated, etc to EF entities (more details). Add unique constraints to EF tables where duplicate records not allowed (more details). IdentityServer is abstracted from the data store on multiple levels, so the exact steps involved in updating your data store will depend on your implementation details.\nCustom Store Implementations The core of IdentityServer is written against the store interfaces, which abstract all the implementation details of actually storing data. If your IdentityServer implementation includes a custom implementation of those stores, then you will have to determine how best to include the changes in the model in the underlying data store and make any necessary changes to schemas, if your data store requires that.\nDuende.IdentityServer.EntityFramework We also provide a default implementation of the stores in the Duende.IdentityServer.EntityFramework package, but this implementation is still highly abstracted because it is usable with any database that has an EF provider. Different database vendors have very different dialects of sql that have different syntax and type systems, so we don\u0026rsquo;t provide schema changes directly. Instead, we provide the Entity Framework entities and mappings which can be used with Entity Framework\u0026rsquo;s migrations feature to generate the schema updates that are needed in your database.\nTo generate migrations, run the commands below. Note that you might need to adjust paths based on your specific organization of the migration files.\ndotnet ef migrations add UpdateToDuende_v6_0 -c PersistedGrantDbContext -o Data/Migrations/IdentityServer/PersistedGrantDb dotnet ef migrations add UpdateToDuende_v6_0 -c ConfigurationDbContext -o Data/Migrations/IdentityServer/ConfigurationDb You will likely get the warning \u0026ldquo;An operation was scaffolded that may result in the loss of data. Please review the migration for accuracy.\u0026rdquo;. This is due to the fact that in this release the column length for redirect URIs (for both login and logout) was reduced from 2000 to 400. This was needed because some database providers have limits on index size. This should not affect you unless you are using redirect URIs greater than 400 characters.\nThen to apply those changes to your database:\ndotnet ef database update -c PersistedGrantDbContext dotnet ef database update -c ConfigurationDbContext Some organizations prefer to use other tools for managing schema changes. You\u0026rsquo;re free to manage your schema however you see fit, as long as the entities can be successfully mapped. Even if you\u0026rsquo;re not going to ultimately use Entity Framework migrations to manage your database changes, generating a migration can be a useful development step to get an idea of what needs to be done.\nStep 6: Migrating signing keys (optional) In IdentityServer4, the common way to configure a signing key in Startup was to use AddSigningCredential() and provide key material (such as an X509Certificate2). In Duende IdentityServer the automatic key management feature can manage those keys for you.\nSince client apps and APIs commonly cache the key material published from the discovery document then when upgrading you need to consider how those applications will handle an upgraded token server with a new and different signing key.\nIf while upgrading you can simply restart all of the client apps and APIs that depend on those signing keys, then you can remove the old signing key and start to use the new automatic key management. When they are restarted they will reload the discovery document and thus be aware of the new signing key.\nBut if you can\u0026rsquo;t restart all the client apps and APIs then you will need to maintain the prior signing key while still publishing the new keys produced from the automatic key management feature. This can be achieved by still using AddSigningCredential(). A signing key registered with AddSigningCredential() will take precedence over any keys created by the automatic key management feature. Once the client apps and APIs have updated their caches (typically after 24 hours) then you can remove the prior signing key by removing the call to AddSigningCredential() and redeploy your IdentityServer.\nStep 7: Verify Data Protection Configuration IdentityServer depends on ASP.NET Data Protection. Data Protection encrypts and signs data using keys managed by ASP.NET. Those keys are isolated by application name, which by default is set to the content root path of the host. This prevents multiple applications from sharing encryption keys, which is necessary to protect your encryption against certain forms of attack. However, this means that if your content root path changes, the default settings for data protection will prevent you from using your old keys. Beginning in .NET 6, the content root path is now normalized so that it ends with a directory separator. This means that your content root path might change when you upgrade to .NET 6. This can be mitigated by explicitly setting the application name and removing the separator character. See Microsoft\u0026rsquo;s documentation for more information.\nStep 8: Done! That\u0026rsquo;s it. Of course, at this point you can and should test that your IdentityServer is updated and working properly.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/configuration/",
    "title": "Configuration API",
    "tags": [],
    "description": "Overview",
    "content": "(Added in 6.3)\nThe Configuration API is a collection of endpoints that allow for management and configuration of an IdentityServer implementation. The Configuration API can be hosted either separately or within the IdentityServer implementation, and is distributed through the separate Duende.IdentityServer.Configuration NuGet package.\nIn this initial release, the Configuration API supports the Dynamic Client Registration protocol.\nThe Configuration API is part of the IdentityServer Business Edition or higher. The same license and special offers apply.\nThe Configuration API\u0026rsquo;s source code is available on github.\nSamples of the Configuration API are available here.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/bff/extensibility/",
    "title": "Extensibility",
    "tags": [],
    "description": "",
    "content": "Extensibility Duende.BFF can be extended in the following areas\ncustom logic at the session management endpoints custom logic and configuration for HTTP forwarding custom data storage for server-side sessions and access/refresh tokens "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/ui/federation/",
    "title": "Federation Gateway",
    "tags": [],
    "description": "",
    "content": "Federation means that your IdentityServer offers authentication methods that use external authentication providers.\nIf you offer a number of these external authentication methods, often the term Federation Gateway is used to describe this architectural approach.\nGenerally, this architecture allows shielding your client applications from the complexities of your authentication workflows and business requirements that go along with them.\nYour clients only need to trust the gateway, and the gateway coordinates all the communication and trust relationships with the external providers. This might involve switching between different protocols, token types, claim types etc. Also the gateway can make sure that all claims and identities that ultimately arrive at the client applications are trustworthy and in a format that the client expects.\nThere are a number of scenarios where this approach is commonly used.\nMultiple authentication methods for users Maybe your users should have multiple options how they can sign-in/up, e.g.\nusername/password or a commercial provider like Google or Microsoft Account username/password or a commercial provider for customers, and Active Directory or Azure AD for employees Integration of on-premise products with customer identity systems If you are building on-premise products, you have to integrate with a multitude of customer authentication systems. Maintaining variations of your business software for each product you have to integrate with, makes your software hard to maintain.\nWith a federation gateway, you only need to adapt to these external systems at the gateway level, all of your business applications are shielded from the technical details.\nSoftware-as-a-Service It\u0026rsquo;s very common to offer federation with your customers\u0026rsquo; authentication systems in SaaS scenarios. This way your customers get single-sign-on to your applications without having to explicitly create accounts in your identity system.\nSupport for external authentication methods IdentityServer leverages the ASP.NET Core authentication infrastructure for communicating with external providers. This means that every authentication system that is supported by ASP.NET Core, can also be used in the context of IdentityServer. This includes support for commercial providers like Google, GitHub or LinkedIn (and many more) as well as any OpenID Connect, SAML2p or WS-Federation based systems.\nSee the Integrating with External Providers section for more details.\nHome Realm Discovery The process of selecting the \u0026ldquo;best\u0026rdquo; authentication workflow for a user (especially when you have multiple authentication methods) is called Home Realm Discovery (or HRD for short).\nSince users are typically anonymous when they arrive at the gateway, you need some sort of hint to optimize the login workflow, e.g.\nyou present a list of available authentication methods to the user. This might work for simpler scenarios, but probably not if you have a lot of choices or if this would reveal your customers\u0026rsquo; authentication systems you ask the user for an identifier (e.g. email address) and have a way to infer the right external authentication method from that id. This is a common technique for SaaS systems. the client application can give a hint to the gateway via a custom protocol parameter of IdentityServer\u0026rsquo;s built-in support for the idp parameter on acr_values. In some case the client already knows the right authentication method, e.g. when your customers access your software via a customer-specific URL (see here). you restrict the available authentication methods per client in the client configuration using the IdentityProviderRestrictions property (see here) Every system is slightly different. Always start with the desired user experience, and then choose from the above options (or combinations) to implement the required flow.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/tokens/pop/",
    "title": "Proof-of-Possession Access Tokens",
    "tags": [],
    "description": "",
    "content": "Proof-of-Possession Access Tokens By default, OAuth access tokens are so called bearer tokens. This means they are not bound to a client and anybody who possesses the token can use it. The security concern here is that a leaked token could be used by a (malicious) third party to impersonate the client and/or user.\nOn the other hand, Proof-of-Possession (PoP) tokens are bound to the client that requested the token. This is also often called sender constraining. This is done by using cryptography to prove that the sender of the token knows an additional secret only known to the client.\nThis proof is called the confirmation method and is expressed via the standard cnf claim,e.g.:\n{ \u0026#34;iss\u0026#34;: \u0026#34;https://localhost:5001\u0026#34;, \u0026#34;iat\u0026#34;: 1609932801, \u0026#34;exp\u0026#34;: 1609936401, \u0026#34;aud\u0026#34;: \u0026#34;urn:resource1\u0026#34;, \u0026#34;client_id\u0026#34;: \u0026#34;web_app\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;88421113\u0026#34;, \u0026#34;cnf\u0026#34;: \u0026#34;confirmation_method\u0026#34; } When using reference tokens, the cnf claim will be returned from the introspection endpoint.\nProof-of-Possession Styles IdentityServer supports two styles of proof of possession tokens:\nMutual TLS DPoP "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/tokens/reference/",
    "title": "Reference Tokens",
    "tags": [],
    "description": "",
    "content": "When using reference tokens, Duende IdentityServer stores the contents of the token in the persisted grant store and issues a unique identifier for this token back to the client.\nThe consumer of the token must use the introspection endpoint to validate the token.\nYou can set the token type of a client using the following client setting:\nclient.AccessTokenType = AccessTokenType.Reference; Enabling an API to consume reference tokens The introspection endpoint requires authentication - since the client of an introspection endpoint is typically an API, you configure the secret on the ApiResource:\nvar api = new ApiResource(\u0026#34;api1\u0026#34;) { ApiSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) } Scopes = { \u0026#34;read\u0026#34;, \u0026#34;write\u0026#34; } } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/tokens/authentication/",
    "title": "Client Authentication",
    "tags": [],
    "description": "",
    "content": "Client Authentication Overview Shared Secrets Private Key JWTs TLS Client Certificates "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/deployment/",
    "title": "Deployment",
    "tags": [],
    "description": "",
    "content": "Deployment Because IdentityServer is made up of middleware and services that you use within an ASP.NET Core application, it can be hosted and deployed with the same diversity of technology as any other ASP.NET Core application. You have the choice about\nwhere to host your IdentityServer (on-prem or in the cloud, and if in the cloud, which one?) which web server to use (IIS, Kestrel, Nginx, Apache, etc) how you\u0026rsquo;ll scale and load-balance the deployment what kind of deployment artifacts you\u0026rsquo;ll publish (files in a folder, containers, etc) how you\u0026rsquo;ll manage the environment (a managed app service in the cloud, a Kubernetes cluster, etc) While this is a lot of decisions to make, this also means that your IdentityServer implementation can be built, deployed, hosted, and managed with the same technology that you\u0026rsquo;re using for any other ASP.NET applications that you have.\nMicrosoft publishes extensive advice and documentation about deploying ASP.NET Core applications, and it is applicable to IdentityServer implementations. We\u0026rsquo;re not attempting to replace that documentation - or the documentation for other tools that you might be using in your environment. Rather, this section of our documentation focuses on IdentityServer-specific deployment and hosting considerations.\nOur experience has been that these topics are very important. Some of our most common support requests are related to Data Protection and Load Balancing, so we strongly encourage you to review those pages, along with the rest of this chapter before deploying IdentityServer to production.\nProxy Servers and Load Balancers ASP.NET Core Data Protection IdentityServer Data Stores Distributed Caching Health Checks "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/stores/server_side_sessions/",
    "title": "Server-Side Session Store",
    "tags": [],
    "description": "Reference",
    "content": "Duende.IdentityServer.Stores.IServerSideSessionStore Used to persist users\u0026rsquo; authentication session data when using the server-side sessions feature.\n/// \u0026lt;summary\u0026gt; /// User session store /// \u0026lt;/summary\u0026gt; public interface IServerSideSessionStore { /// \u0026lt;summary\u0026gt; /// Retrieves a session /// \u0026lt;/summary\u0026gt; Task\u0026lt;ServerSideSession\u0026gt; GetSessionAsync(string key, CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// Creates a session /// \u0026lt;/summary\u0026gt; Task CreateSessionAsync(ServerSideSession session, CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// Updates a session /// \u0026lt;/summary\u0026gt; Task UpdateSessionAsync(ServerSideSession session, CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// Deletes a session /// \u0026lt;/summary\u0026gt; Task DeleteSessionAsync(string key, CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// Gets sessions for a specific subject id and/or session id /// \u0026lt;/summary\u0026gt; Task\u0026lt;IReadOnlyCollection\u0026lt;ServerSideSession\u0026gt;\u0026gt; GetSessionsAsync(SessionFilter filter, CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// Deletes sessions for a specific subject id and/or session id /// \u0026lt;/summary\u0026gt; Task DeleteSessionsAsync(SessionFilter filter, CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// Queries sessions based on filter /// \u0026lt;/summary\u0026gt; Task\u0026lt;QueryResult\u0026lt;ServerSideSession\u0026gt;\u0026gt; QuerySessionsAsync(SessionQuery filter = null, CancellationToken cancellationToken = default); } ServerSideSession /// \u0026lt;summary\u0026gt; /// A user session /// \u0026lt;/summary\u0026gt; public class ServerSideSession { /// \u0026lt;summary\u0026gt; /// The key /// \u0026lt;/summary\u0026gt; public string Key { get; set; } = default!; /// \u0026lt;summary\u0026gt; /// The cookie handler scheme /// \u0026lt;/summary\u0026gt; public string Scheme { get; set; } = default!; /// \u0026lt;summary\u0026gt; /// The subject ID /// \u0026lt;/summary\u0026gt; public string SubjectId { get; set; } = default!; /// \u0026lt;summary\u0026gt; /// The session ID /// \u0026lt;/summary\u0026gt; public string SessionId { get; set; } = default!; /// \u0026lt;summary\u0026gt; /// The display name for the user /// \u0026lt;/summary\u0026gt; public string DisplayName { get; set; } /// \u0026lt;summary\u0026gt; /// The creation time /// \u0026lt;/summary\u0026gt; public DateTime Created { get; set; } /// \u0026lt;summary\u0026gt; /// The renewal time /// \u0026lt;/summary\u0026gt; public DateTime Renewed { get; set; } /// \u0026lt;summary\u0026gt; /// The expiration time /// \u0026lt;/summary\u0026gt; public DateTime? Expires { get; set; } /// \u0026lt;summary\u0026gt; /// The serialized ticket /// \u0026lt;/summary\u0026gt; public string Ticket { get; set; } = default!; } The Ticket property contains a copy of all of the values (and more) and is considered authoritative by IdentityServer, thus most of the other property values are considered informational and read-only.\nSessionFilter /// \u0026lt;summary\u0026gt; /// Filter to query user sessions /// \u0026lt;/summary\u0026gt; public class SessionFilter { /// \u0026lt;summary\u0026gt; /// The subject ID /// \u0026lt;/summary\u0026gt; public string SubjectId { get; init; } /// \u0026lt;summary\u0026gt; /// The sesion ID /// \u0026lt;/summary\u0026gt; public string SessionId { get; init; } } SessionQuery /// \u0026lt;summary\u0026gt; /// Filter to query all user sessions /// \u0026lt;/summary\u0026gt; public class SessionQuery { /// \u0026lt;summary\u0026gt; /// The token indicating the prior results. /// \u0026lt;/summary\u0026gt; public string ResultsToken { get; set; } /// \u0026lt;summary\u0026gt; /// If true, requests the previous set of results relative to the ResultsToken, otherwise requests the next set of results relative to the ResultsToken. /// \u0026lt;/summary\u0026gt; public bool RequestPriorResults { get; set; } /// \u0026lt;summary\u0026gt; /// The number requested to return /// \u0026lt;/summary\u0026gt; public int CountRequested { get; set; } /// \u0026lt;summary\u0026gt; /// The subject ID used to filter the results. /// \u0026lt;/summary\u0026gt; public string SubjectId { get; init; } /// \u0026lt;summary\u0026gt; /// The sesion ID used to filter the results. /// \u0026lt;/summary\u0026gt; public string SessionId { get; init; } /// \u0026lt;summary\u0026gt; /// The user display name used to filter the results. /// \u0026lt;/summary\u0026gt; public string DisplayName { get; init; } } QueryResult /// \u0026lt;summary\u0026gt; /// Query result for paged data /// \u0026lt;/summary\u0026gt; public class QueryResult\u0026lt;T\u0026gt; { /// \u0026lt;summary\u0026gt; /// The token that indicates these results. This is used for more results in subsequent queries. /// If null, then there were no more results. /// \u0026lt;/summary\u0026gt; public string ResultsToken { get; init; } /// \u0026lt;summary\u0026gt; /// True if there is a previous set of results. /// \u0026lt;/summary\u0026gt; public bool HasPrevResults { get; set; } /// \u0026lt;summary\u0026gt; /// True if there is another set of results. /// \u0026lt;/summary\u0026gt; public bool HasNextResults { get; set; } /// \u0026lt;summary\u0026gt; /// The total count (if available). /// \u0026lt;/summary\u0026gt; public int? TotalCount { get; init; } /// \u0026lt;summary\u0026gt; /// The total pages (if available). /// \u0026lt;/summary\u0026gt; public int? TotalPages { get; init; } /// \u0026lt;summary\u0026gt; /// The current (if available). /// \u0026lt;/summary\u0026gt; public int? CurrentPage { get; init; } /// \u0026lt;summary\u0026gt; /// The results. /// \u0026lt;/summary\u0026gt; public IReadOnlyCollection\u0026lt;T\u0026gt; Results { get; init; } = default!; } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/ui/ciba/",
    "title": "Client Initiated Backchannel Authentication (CIBA)",
    "tags": [],
    "description": "",
    "content": "Duende IdentityServer supports the Client-Initiated Backchannel Authentication Flow (also known as CIBA). CIBA is one of the requirements to support the Financal-grade API compliance.\nCIBA is included in IdentityServer Enterprise Edition.\nDuende IdentityServer supports the poll mode to allow a client to obtain the results of a backchannel login request.\nOverview Normally when using OpenID Connect, a user accesses a client application on the same device they use to login to the OpenID Connect provider. For example, a user (via the browser) uses a web app (the client) and that same browser is redirected for the user to login at IdentityServer (the OpenID Connect provider), and this all takes place on the user\u0026rsquo;s device (e.g. their computer). Another example would be that a user uses a mobile app (the client), and it launches the browser for the user to login at IdentityServer (the OpenID Connect provider), and this all takes place on the user\u0026rsquo;s device (e.g. their mobile phone).\nCIBA allow the user to interact with the client application on a different device than the user uses to login. For example, the user can use a kiosk at the public library to access their data, but they perform the actual login on their mobile phone. Another example would be a user is at the bank and the bank teller wishes to access the user\u0026rsquo;s account, so the user logs into mobile phone to grant that access.\nA nice feature of this workflow is that the user does not enter their credentials into the device the client application is accessed from, and instead a higher trust device can be used for the login step.\nCIBA Workflow in IdentityServer Below is a diagram that shows the high level steps involved with the CIBA workflow and the supporting services involved.\nStep 1: IdentityServer exposes a backchannel authentication request endpoint that the client uses to initiate the CIBA workflow.\nStep 2: Once client authentication and basic request parameter validation is performed, the user for which the request is being made must be identified. This is done by using the IBackchannelAuthenticationUserValidator service in DI, which you are required to implement and register in the DI system. The ValidateRequestAsync method will validate the request parameters and return a result which will contain the user\u0026rsquo;s sub (subject identifier) claim.\nStep 3: Once a user has successfully been identified, then a record representing the pending login request is created in the Backchannel Authentication Request Store.\nStep 4: Next, the user needs to be notified of the login request. This is done by using the IBackchannelAuthenticationUserNotificationService service in DI, which you are required to implement and register in the DI system. The SendLoginRequestAsync method should contact the user with whatever mechanism is appropriate (e.g. email, text message, push notification, etc.), and presumably provide the user with instructions (perhaps via a link, but other approaches are conceivable) to start the login and consent process. This method is passed a BackchannelUserLoginRequest which will contain all the contextual information needed to send to the user (the InternalId being the identifier for this login request which is needed when completing the request \u0026ndash; see below).\nStep 5: Next, the user should be presented with the information for the login request (e.g. via a web page at IdentityServer, or via any other means appropriate). The IBackchannelAuthenticationInteractionService can be used to access an indivdual BackchannelUserLoginRequest by its InternalId. Once the user has consented and allows the login, then the CompleteLoginRequestAsync method should be used to record the result (including which scopes the user has granted).\nStep 6: Finally, the client, after polling for the result, will finally be issued the tokens it\u0026rsquo;s requested (or a suitable error if the user has denied the request or it has timed out).\nWe provide a sample for the interactive pages a user might be presented with for the CIBA workflow.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/upgrades/",
    "title": "Upgrading",
    "tags": [],
    "description": "",
    "content": "Upgrading Here is a list of upgrade guides.\nDuende IdentityServer v6.x to v7.0 Duende IdentityServer v6.2 to v6.3 Duende IdentityServer v6.1 to v6.2 Duende IdentityServer v6.0 to v6.1 Duende IdentityServer v5.2 to v6.0 Duende IdentityServer v5.1 to v5.2 Duende IdentityServer v5.0 to v5.1 IdentityServer4 v4.1 to Duende IdentityServer v6 IdentityServer4 v3.1 to Duende IdentityServer v6 Microsoft SPA and Blazor Templates "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/upgrades/is4_v3_to_dis_v6/",
    "title": "IdentityServer4 v3.1 to Duende IdentityServer v6",
    "tags": [],
    "description": "",
    "content": "This upgrade guide covers upgrading from IdentityServer4 v3.1.x to Duende IdentityServer v6. This upgrade is a complex one because the configuration object model had some non-trivial changes from IdentityServer4 v3 to IdentityServer4 v4.\nIn short, in IdentityServer4 v3 there was a parent-child relationship between the ApiResources and the ApiScopes. Then in IdentityServer4 v4 the ApiScopes was promoted to be its own top-level configuration. This meant that the child collection under the ApiResources was renamed to ApiResourcesScopes and it contained a reference to the new top-level ApiScopes.\nIf you were using a database for this configuration, then this means that configuration changed from a parent-child, to two top-level tables with a join table between them (to put it loosely). The new ApiResourcesScopes table was created to act as that join table.\nAlso, all the prior tables that were associated with the ApiResources were prefixed with \u0026ldquo;Api\u0026rdquo; and that prefix became \u0026ldquo;ApiResource\u0026rdquo; to better indicate the association. Then any new tables associated with the new top-level ApiScopes have the \u0026ldquo;ApiScope\u0026rdquo; prefix to indicate that association.\nIn order to properly update the database, the easiest approach is to first update to the latest of IdentityServer4 v4. Once that\u0026rsquo;s complete, then it\u0026rsquo;s very simple to move to Duende IdentityServer v5.\nThere is a sample project for this migration exercise. It is located here.\nStep 1: Update NuGet package to IdentityServer4 v4.x In your IdentityServer host project, update the IdentityServer NuGet being used from IdentityServer4 v3 to IdentityServer4 v4. For example in your project file:\n\u0026lt;PackageReference Include=\u0026#34;IdentityServer4\u0026#34; Version=\u0026#34;3.1.4\u0026#34; /\u0026gt; would change to the latest version of IdentityServer4:\n\u0026lt;PackageReference Include=\u0026#34;IdentityServer4\u0026#34; Version=\u0026#34;4.1.2\u0026#34; /\u0026gt; If you\u0026rsquo;re using any of the other IdentityServer4 packages, such as IdentityServer4.EntityFramework or IdentityServer4.AspNetIdentity, then update those as well.\nStep 2: Update Database Schema with EF Core Migrations If you are using a database for your configuration and operational data, then there is a bit of work. The reason is that for this type of schema restructuring EntityFramework Core\u0026rsquo;s migrations can lose existing data. To handle this, the conversation from the old schema to the new will be performed by custom SQL. This is only needed for the configuration database, not the operational one so normal migrations will suffice for the operational database.\nFirst for the operational database, we can simply apply EF Core migrations. Note that you might need to adjust based on your specific organization of the migration files.\ndotnet ef migrations add Grants_v4 -c PersistedGrantDbContext -o Migrations/PersistedGrantDb Then to apply those changes to your database:\ndotnet ef database update -c PersistedGrantDbContext Next for the configuration database, we\u0026rsquo;ll also add an EF Migration with:\ndotnet ef migrations add Config_v4 -c ConfigurationDbContext -o Migrations/ConfigurationDb When you run this, you should see the warnings from EF Core about this migration possibly losing data:\nBuild started... Build succeeded. info: Microsoft.EntityFrameworkCore.Infrastructure[10403] Entity Framework Core 3.1.15 initialized \u0026#39;ConfigurationDbContext\u0026#39; using provider \u0026#39;Microsoft.EntityFrameworkCore.SqlServer\u0026#39; with options: MigrationsAssembly=IdentityServerMigrationSample, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null An operation was scaffolded that may result in the loss of data. Please review the migration for accuracy. Done. To undo this action, use \u0026#39;ef migrations remove\u0026#39; To ensure we don\u0026rsquo;t lose data, we will add a custom SQL script to run instead of the generated migration. To ensure the script is available to the migration we will include the script into the project as an embedded resource. You could devise other approaches (like simply loading the SQL script from the filesystem) based on your preferences.\nThe SQL script to include is located here. Copy it into your project folder and then configure it as an embedded resource in the csproj file:\n\u0026lt;ItemGroup\u0026gt; \u0026lt;EmbeddedResource Include=\u0026#34;ConfigurationDb_v4_delta.sql\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; Then modify the migration that was just created. Remove all of the code in the Up and Down methods are replace the Up with this code, which will execute the custom SQL script:\nusing System.IO; using Microsoft.EntityFrameworkCore.Migrations; namespace IdentityServerMigrationSample.Migrations.ConfigurationDb { public partial class Config_v4 : Migration { protected override void Up(MigrationBuilder migrationBuilder) { var assembly = typeof(Program).Assembly; using (var s = assembly.GetManifestResourceStream(\u0026#34;IdentityServerMigrationSample.ConfigurationDb_v4_delta.sql\u0026#34;)) { using (StreamReader sr = new StreamReader(s)) { var sql = sr.ReadToEnd(); migrationBuilder.Sql(sql); } } } protected override void Down(MigrationBuilder migrationBuilder) { } } } Note that given that there is no Down implementation, this is a one-way update.\nAnd now run the migration:\ndotnet ef database update -c ConfigurationDbContext And your database should now be updated.\nStep 3: Verify your configuration database data At this point, you should be able to query your migrated database and see your data in tact. This script allows you to query the new restructured tables.\nStep 4: Move onto the upgrade guide for Duende IdentityServer v6 Once your project has been updated to IdentityServer4 v4, then you can work through the guide to update from IdentityServer4 v4 to Duende IdentityServer v6 (which should be far easier). Here is the link to the next upgrade guide.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/ui/server_side_sessions/",
    "title": "Server-Side Sessions",
    "tags": [],
    "description": "Overview",
    "content": "(added in 6.1)\nOverview When a user logs in interactively, their authentication session is managed by the ASP.NET Core authentication system, and more specifically the cookie authentication handler. IdentityServer uses the state in the cookie to track the user\u0026rsquo;s subject and session identifiers (i.e. the sub and sid claims), and the list of clients the user has logged into (which is used at logout time for OIDC logout notification).\nBy default, this cookie is self-contained which means it contains all the state needed to track a user\u0026rsquo;s session. While this does allow for a stateless server for session management, cookie size could be a problem, and it makes it difficult to know how many active user sessions there are in your system or revoke those sessions from an administrative standpoint.\nIdentityServer provides a server-side session feature, which extends the ASP.NET Core cookie authentication handler to maintain this state in a server-side store, rather than putting it all into the cookie itself. This implementation is specifically designed for IdentityServer to allow for more protocol related features, such as querying for active sessions based on subject id or session id, and revoking artifacts from protocol workflows as part of that session.\nSupport for Server Side Sessions is included in IdentityServer Business Edition or higher.\nSession Management With the addition and use of server-side sessions, more interesting architectural features are possible:\nthe ability to query and manage sessions from outside the browser that a user is logged into. the ability to detect session expiration and perform cleanup both in IdentityServer as well as in the client. the ability to centralize and monitor session activity in order to achieve a system-wide inactivity timeout. Enabling server-side sessions To enable server-side sessions, use the AddServerSideSessions extension method after adding IdentityServer to the DI system:\npublic void ConfigureServices(IServiceCollection services) { services.AddIdentityServer() .AddServerSideSessions(); } By default, the store for the server-side sessions will just be kept in-memory. For production scenarios you will want to configure a durable store either by using our EntityFramework Core implementation, or you can implement the store yourself.\nOrder is important in the DI system. When using AddServerSideSessions, this call needs to come after any custom IRefreshTokenService implementation that has been registered.\nData stored server-side The data stored for the user session is the data contained in the ASP.NET Core AuthenticationTicket class. This data will be serialized and protected using ASP.NET Core\u0026rsquo;s data protection feature so as to protect any user PII. Some of the values from the user\u0026rsquo;s session are extracted and used as indices in the store so that specific sessions can be queried. These values are the user\u0026rsquo;s:\nsubject identifier (the sub claim value) session identifier (the sid claim value) display name (an optional and configurable claim value) If you would like to query this data based on a user\u0026rsquo;s display name, then the claim type used is configurable with the ServerSideSessions.UserDisplayNameClaimType property on the IdentityServerOptions. This claim must be included in the claims when the user\u0026rsquo;s authentication session is established.\nFor example:\npublic void ConfigureServices(IServiceCollection services) { services.AddIdentityServer(options =\u0026gt; { options.ServerSideSessions.UserDisplayNameClaimType = \u0026#34;name\u0026#34;; // or \u0026#34;email\u0026#34; perhaps }) .AddServerSideSessions(); } IServerSideSessionStore The IServerSideSessionStore is the abstraction for storing the server-side session.\nA EntityFramework Core implementation is already provided as part of our operational store, but you can implement the interface yourself for other backing implementations.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/samples/",
    "title": "Samples",
    "tags": [],
    "description": "",
    "content": "Samples We have a collection of runnable samples that show how to use IdentityServer and configure client applications in a variety of scenarios. Most of the samples include both their own IdentityServer implementation and the clients and APIs needed to demonstrate the illustrated functionality. The \u0026ldquo;Basics\u0026rdquo; samples use a shared IdentityServer implementation, and some of the BFF samples use our public demo instance of IdentityServer.\nBasics User Interaction ASP.NET Identity Integration Requesting tokens Backend for Frontend Pattern Clients Diagnostics Configuration API Miscellaneous The source code for the samples is in our samples repository.\nFeel free to ask the developer community if you are looking for a particular sample and can\u0026rsquo;t find it here.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/upgrades/spa_to_duende/",
    "title": "Microsoft SPA and Blazor Templates",
    "tags": [],
    "description": "",
    "content": "Microsoft publishes templates for securing an API with token based security backed by the ASP.NET Identity identity management library. There are several templates; a couple for JavaScript-based SPA applications using React and Angular, and one for Blazor WASM style SPA applications. All of these use Duende IdentityServer as the token server to issue tokens to the client-side code in the browser for securing calls to an API.\nThis upgrade guide discusses the design pattern of these templates and how you would migrate them to a more recommended architecture. This guide describes the high level architecture, and doesn\u0026rsquo;t go into the specifics of any code, and as such should suffice for the SPA/JavaScript templates, as well as the Blazor WASM template.\nTemplate Architecture with a Single Host Below is a picture showing the important moving parts of the template. The most important detail is that there is a single host for many different conceptual items, and this affects the security of the overall design. The one host serves up:\nSPA Assets (HTML, CSS, and JS (React, Angular) or WASM (Blazor)) ASP.NET Identity UI Pages (for login, logout, registration, etc) Duende IdentityServer (middleware for OIDC/OAuth protocol endpoints) The API In terms of workflow for ultimately securing calls to the API, the logical steps taken are:\n1: The SPA Assets are loaded from the host into the browser.\n2: The UI logic must then navigate the user to the login page. The login session is fundamentally tracked with a cookie managed by the ASP.NET cookie authentication handler. This authentication handler is configured by ASP.NET Identity.\n3: Once the user is logged in, the SPA must make OIDC/OAuth protocol requests to the endpoints managed by Duende IdentityServer. The authentication cookie from the prior step is what is used to identify the user. The result of this step is an access token that is maintained by the code running in the browser.\n4: Finally, the UI logic can securely invoke the API by passing the access token as the Authorization HTTP header. The code on the server will validate that the access token was issued by the instance of Duende IdentityServer that is hosted from this project.\nThe picture below shows these logical steps.\nArchitecture with Separate Hosts While the above architecture works, there are some disadvantages to the design presented in the template. There is an obvious complexity in using two different credential types in the single host (cookies and tokens). There are great pains taken in the template (hidden away in various extension methods and clever configuration in the DI system) to accept the access token for the API calls, but only accept the authentication cookie to the ASP.NET Identity Pages and the Duende IdentityServer endpoints.\nRelated to this, co-hosting your token server (i.e. Duende IdentityServer) with the application and API is simply not the recommended pattern. The intent of using a token server is to enable centralization of user authentication, which enables single sign-on for users. Co-hosting the token server with the client application (and API) is counter to that goal. Thus, the recommended approach is to host Duende IdentityServer (and then also the ASP.NET Identity Pages) in its own host separate from the app and API. Doing so would produce an architectural picture as such:\nThe steps in the logical workflow would remain the same, but now the token server is independent from any one app or API. Also, each host now only has one credential type to be concerned with, which simplifies the security model. Once you decide to add a new app or API into your architecture, it\u0026rsquo;s very little effort to integrate them with the existing token server. And of course, your users would get single sign-on across all of those applications. Finally, from a deployment standpoint, each of the various hosts is separate and can be updated/versioned/patched separately, as needed.\nBFF Architecture with a Remote API There is another point about the security of the SPA invoking the API that requires discussion.\nThe design of the template utilizes an access token to secure calls to the API. It makes sense to secure APIs with access tokens when those APIs need to be accessed by a variety of applications, including those not even running in a browser. This would be an example of a shared API. But very often, an API that is co-hosted with a SPA front end really only exists to support the UI and won\u0026rsquo;t expect to be invoked by any other application. In this case, it might be overkill to design this \u0026ldquo;local\u0026rdquo; API to require an access token. Also, there are a variety of factors that make is undesirable (and sometimes impossible) for code running in the browser to fully manage tokens obtained from the OIDC/OAuth protocol.\nThus, one additional improvement to the architecture presented so far would be to introduce the BFF pattern.\nThe BFF pattern changes the credential used from the SPA to the backend to instead use a cookie (much like the cookie used in IdentityServer). This would allow securing calls to a \u0026ldquo;local\u0026rdquo; API that is co-hosted in the backend. And then if there is a \u0026ldquo;remote\u0026rdquo; API (e.g. a shared API) hosted elsewhere that accepts access tokens, it is accessible from the code running in the application.\nThe picture below illustrates:\nStep 3: This step from the prior diagrams now results in an authentication session cookie in the SPA application, and an optional access token (depending if a remote API needs to be invoked). This access token is associated with the user\u0026rsquo;s session and would only ever be available on the server-side of the SPA host (i.e. the backend, or BFF).\nStep 4a: All calls from the SPA to the backend now use the authentication cookie to authenticate the call. If a local API is the only API needed, then there is no need for an access token anywhere in the app. The benefit is that the code client-side does not have to manage anything with the OIDC/OAuth protocol or sending tokens on API calls, and thus is simpler.\nStep 4b: If a remote API needs to be invoked, then the access token associated with the user\u0026rsquo;s authentication session can be used. This access token is only available on the server. It can be used from the local API invoking a remote API, or a reverse proxy can be setup in the SPA host (e.g. using Microsoft\u0026rsquo;s YARP) to allow more of a pass-through style so the SPA code can invoke the remote API without manual coding to pass along the access token.\nThe Duende BFF Security Framework makes this architecture easy to implement.\nMigrating The last aspect of the template which requires discussion is that there is configuration required when using OIDC/OAuth. This configuration models the client application (the SPA) as well as the API being secured. Typically, all the players (the app, the API, and the token server) require their own store for their relevant configuration data. Given that the template co-hosts all three of these, more great pains were taken to hide all of this configuration from the developer. The various extension methods that are provided for the template that sets up Duende IdentityServer, that performs the automatic configuration, and the client-side code that bootstraps the security in the browser all assume this co-hosting model. While this might be convenient when co-hosting, when you split the hosts into the recommended architecture then the configuration must be more explicit.\nUnfortunately what this means is that is it non-trivial to migrate a project from the template to the recommended architecture. Rather, it makes more sense to follow the quickstart guides to setup a properly designed architecture. Once that\u0026rsquo;s in place, then it will be more obvious how to take any existing application created with the template and preserve the relevant application assets to use the token server you have setup in its own host.\nIt is recommended you start with the first quickstart (if you haven\u0026rsquo;t already), and follow through the progression. This will allow you to understand the configuration needed when using OIDC/OAuth. If you\u0026rsquo;re already familiar with hosting and configuring IdentityServer, then you can jump right to the JavaScript quickstart or the Blazor quickstart.\nIt is worth noting why the template is designed the way it is. First, at the time the template was created, the templating system from Microsoft could only support a single project. This explains why all the different logical pieces are lumped into a single host. Second, why was a token based design chosen to secure the API co-hosted with the login page. The assumption is that as projects grow and more and more applications are added to the architecture, the design would eventually require a token based architecture (presumably hosted separately). Thus, rather than require rework later on, starting with a token based design makes sense and acclimates developers to those fundamentals from the beginning. Third, it\u0026rsquo;s assumed that the automatic self-configuration done in the template would avoid 1) the hassle of explicit configuration needed for the OIDC/OAuth protocols when the template is deployed, and 2) the need to explain the mechanics of the protocols.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/tokens/jar/",
    "title": "Signed Authorize Requests",
    "tags": [],
    "description": "",
    "content": "Instead of providing the parameters for an authorize request as individual query string key/value pairs, you can package them up in signed JWTs. This makes the parameters tamper proof and you can authenticate the client already on the front-channel.\nSee here for a sample for using signed authorize requests (and JWT-based authentication) in ASP.NET Core.\nYou can either transmit them by value or by reference to the authorize endpoint - see the spec for more details.\nDuende IdentityServer requires the request JWTs to be signed. We support X509 certificates and JSON web keys, e.g.:\nvar client = new Client { ClientId = \u0026#34;foo\u0026#34;, // set this to true to accept signed requests only RequireRequestObject = true, ClientSecrets = { new Secret { // X509 cert base64-encoded Type = IdentityServerConstants.SecretTypes.X509CertificateBase64, Value = Convert.ToBase64String(cert.Export(X509ContentType.Cert)) }, new Secret { // RSA key as JWK Type = IdentityServerConstants.SecretTypes.JsonWebKey, Value = \u0026#34;{\u0026#39;e\u0026#39;:\u0026#39;AQAB\u0026#39;,\u0026#39;kid\u0026#39;:\u0026#39;...\u0026#39;,\u0026#39;kty\u0026#39;:\u0026#39;RSA\u0026#39;,\u0026#39;n\u0026#39;:\u0026#39;...\u0026#39;}\u0026#34; } } } Passing request JWTs by reference If the request_uri parameter is used, IdentityServer will make an outgoing HTTP call to fetch the JWT from the specified URL.\nYou can customize the HTTP client used for this outgoing connection, e.g. to add caching or retry logic (e.g. via the Polly library):\nbuilder.AddJwtRequestUriHttpClient(client =\u0026gt; { client.Timeout = TimeSpan.FromSeconds(30); }) .AddTransientHttpErrorPolicy(policy =\u0026gt; policy.WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(3) })); Request URI processing is disabled by default. Enable on the Endpoints on the IdentityServerOptions. Also see the security considerations from the JAR specification.\nAccessing the request object data You can access the validated data from the request object in two ways:\nWherever you have access to the ValidatedAuthorizeRequest, the RequestObjectValues dictionary holds the values. In the UI code you can call IIdentityServerInteractionService.GetAuthorizationContextAsync, the resulting AuthorizationRequest object contains the RequestObjectValues dictionary as well. "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/ui/portal/",
    "title": "Client Application Portal",
    "tags": [],
    "description": "",
    "content": "(Added in 6.3)\nYou can create a client application portal within your IdentityServer host that contains links to client applications that are configured with an InitiateLoginUri. InitiateLoginUri is an optional URI that can be used to initiate login. Your IdentityServer host can check for clients with this property and render links to those applications.\nThose links are just links to pages within your client applications that will start an OIDC challenge when the user follows them. This creates a curious pattern, where the user follows a link from the portal page in the IdentityServer host to an external application only to have that application immediately redirect back to the IdentityServer host\u0026rsquo;s /connect/authorize endpoint. However, if the user has logged in and created a session at the IdentityServer host, they will get a single sign on experience as they navigate to the various applications in the portal.\nThe quickstart UI contains an example of such a portal in the ~/portal razor page.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/tokens/cors/",
    "title": "Calling Endpoints from JavaScript",
    "tags": [],
    "description": "",
    "content": "In JavaScript-based clients, some endpoints like the token endpoint (but also discovery) will be accessed via Ajax calls.\nGiven that your IdentityServer will most likely be hosted on a different origin than these clients, this implies that Cross-Origin Resource Sharing (CORS) will need to be configured.\nClient-based CORS Configuration One approach to configuring CORS is to use the AllowedCorsOrigins collection on the client configuration. Simply add the origin of the client to the collection and the default configuration in IdentityServer will consult these values to allow cross-origin calls from the origins.\nBe sure to use an origin (not a URL) when configuring CORS. For example: https://foo:123/ is a URL, whereas https://foo:123 is an origin.\nThis default CORS implementation will be in use if you are using either the \u0026ldquo;in-memory\u0026rdquo; or EF-based client configuration that we provide. If you define your own IClientStore, then you will need to implement your own custom CORS policy service (see below).\nCustom Cors Policy Service Duende IdentityServer allows the hosting application to implement the ICorsPolicyService to completely control the CORS policy.\nThe single method to implement is: Task IsOriginAllowedAsync(string origin). Return true if the origin is allowed, false otherwise.\nOnce implemented, simply register the implementation in DI and IdentityServer will then use your custom implementation.\nDefaultCorsPolicyService If you simply wish to hard-code a set of allowed origins, then there is a pre-built ICorsPolicyService implementation you can use called DefaultCorsPolicyService.\nThis would be configured as a singleton in DI, and hard-coded with its AllowedOrigins collection, or setting the flag AllowAll to true to allow all origins.\nFor example, in ConfigureServices:\nservices.AddSingleton\u0026lt;ICorsPolicyService\u0026gt;((container) =\u0026gt; { var logger = container.GetRequiredService\u0026lt;ILogger\u0026lt;DefaultCorsPolicyService\u0026gt;\u0026gt;(); return new DefaultCorsPolicyService(logger) { AllowedOrigins = { \u0026#34;https://foo\u0026#34;, \u0026#34;https://bar\u0026#34; } }; }); Use AllowAll with caution.\nMixing IdentityServer\u0026rsquo;s CORS policy with ASP.NET Core\u0026rsquo;s CORS policies IdentityServer uses the CORS middleware from ASP.NET Core to provide its CORS implementation. It is possible that your application that hosts IdentityServer might also require CORS for its own custom endpoints. In general, both should work together in the same application, providing the call to app.UseCors(\u0026ldquo;mypolicy\u0026rdquo;); is called after the call to app.UseIdentityServer();.\nYour code should use the documented CORS features from ASP.NET Core without regard to IdentityServer. This means you should define policies and register the middleware as normal. If your application defines policies in ConfigureServices, then those should continue to work in the same places you are using them (either where you configure the CORS middleware or where you use the MVC EnableCors attributes in your controller code). If instead you define an inline policy in the use of the CORS middleware (via the policy builder callback), then that too should continue to work normally.\nThe one scenario where there might be a conflict between your use of the ASP.NET Core CORS services and IdentityServer is if you decide to create a custom ICorsPolicyProvider. Given the design of the ASP.NET Core\u0026rsquo;s CORS services and middleware, IdentityServer implements its own custom ICorsPolicyProvider and registers it in the DI system. Fortunately, the IdentityServer implementation is designed to use the decorator pattern to wrap any existing ICorsPolicyProvider that is already registered in DI. What this means is that you can also implement the ICorsPolicyProvider, but it simply needs to be registered prior to IdentityServer in DI (e.g. in ConfigureServices).\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/reference/",
    "title": "Reference",
    "tags": [],
    "description": "Index",
    "content": "Reference IdentityServer Options EF Options DI Extension Methods Endpoints Models Services Response Generators Stores Validators "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/configuration/dcr/reference/",
    "title": "Reference",
    "tags": [],
    "description": "Dynamic Client Registration",
    "content": "Reference Validation Request Processing Store Response Generation Models Options "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v6/samples/misc/",
    "title": "Miscellaneous",
    "tags": [],
    "description": "",
    "content": "Securing Azure Functions This sample shows how to parse and validate a JWT token issued by IdentityServer inside an Azure Function.\nlink to source code\nMutual TLS using Kestrel This sample shows how to use Kestrel using MTLS for client authentication and proof of possession API access. Using Kestrel will not likely be how MTLS is configured in a production environment, but it is convenient for local testing. This approach requires DNS entries for mtls.localhost and api.localhost to resolve to 127.0.0.1, and is easily configured by modifying your local hosts file.\nlink to source code\nDPoP This sample shows how to access APIs using DPoP for proof of possession. It contains two different clients; one that uses client credentials and DPoP tokens, and another that is an interactive ASP.NET Core app using code flow to obtain the DPoP bound tokens. Both clients demonstrate the use of the Duende.AccessTokenManagement library with DPoP. The sample also contains an API with the necessary helper code to accept and validate DPoP bound access tokens.\nlink to source code\nSession Management This sample shows how to enable server-side sessions and configure the basic settings. The sample requires all three projects to be run at once.\nThings of note:\nIn the IdentityServerHost project in Startup.cs, server-side sessions are enabled with a call to AddServerSideSessions. This only uses in-memory server-side sessions by default, so restarting the host will lose session data. Also in Startup.cs with the call to AddIdentityServer various settings are configured on the ServerSideSessions options object to control the behavior. The client application configured in Clients.cs has CoordinateLifetimeWithUserSession enabled, which causes its refresh token to slide the server-side session for the user. When launching the IdentityServerHost project, you should visit the ~/serversidesessions page to see the active sessions. Note that there is no authorization on this page (so consider adding it based on your requirements). Once you login, you should see a user\u0026rsquo;s session in the list. As the client app refreshes its access token, you should see the user\u0026rsquo;s session expiration being extended. When you revoke the user\u0026rsquo;s session, the user should be logged out of the client app. link to source code\nSession Migration This sample shows how to do seamless migration of existing cookie-based session when enabling server side sessions. Normally when server side sesssions are enabled all existing logged in sessions are invalidated and the users are forced to log in again. If the application has sessions with long lifetimes where it would be a problem to have all users log in again the sessions can be migrated. Instructions for running the sample are in the HostingExtensions.cs file.\nlink to source code\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/",
    "title": "IdentityServer (v7)",
    "tags": [],
    "description": "",
    "content": "Duende IdentityServer v7 Documentation The most flexible \u0026amp; standards-compliant OpenID Connect and OAuth 2.0 framework for ASP.NET Core.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/endpoints/discovery/",
    "title": "Discovery Endpoint",
    "tags": [],
    "description": "",
    "content": "The discovery endpoint can be used to retrieve metadata about your IdentityServer - it returns information like the issuer name, key material, supported scopes etc.\nThe discovery endpoint is available via /.well-known/openid-configuration relative to the base address, e.g.:\nhttps://demo.duendesoftware.com/.well-known/openid-configuration .NET client library You can use the IdentityModel client library to programmatically interact with the protocol endpoint from .NET code.\nvar client = new HttpClient(); var disco = await client.GetDiscoveryDocumentAsync(\u0026#34;https://demo.duendesoftware.com\u0026#34;); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/quickstarts/0_overview/",
    "title": "Overview",
    "tags": [],
    "description": "Quickstarts",
    "content": "The quickstarts provide step-by-step instructions for various common Duende IdentityServer scenarios. They start with the absolute basics and become more complex - it is recommended you do them in order.\nadding Duende IdentityServer to an ASP.NET Core application configuring Duende IdentityServer issuing tokens for various clients securing web applications and APIs adding support for EntityFramework based configuration adding support for ASP.NET Identity Every quickstart has a reference solution - you can find the code in the samples folder.\nPreparation The first thing you should do is install our templates:\ndotnet new install Duende.Templates You may have a previous version of Duende templates (Duende.IdentityServer.Templates) installed on your machine. Please uninstall the template package and install the latest version.\nThey will be used as a starting point for the various tutorials.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/tokens/authentication/overview/",
    "title": "Overview",
    "tags": [],
    "description": "Client Authentication",
    "content": "Confidential and credentialed clients need to authenticate with your IdentityServer before they can request tokens.\nDuende IdentityServer has built-in support for various client credential types and authentication methods, and an extensible infrastructure to customize the authentication system.\nAll information in this section also applies to API secrets for introspection.\nWe recommend using asymmetric client credentials like the private key jwt or Mutual TLS authentication method over shared secrets.\nAssigning secrets A client secret is abstracted by the Secret class. It provides properties for setting the value and type as well as a description and expiration date.\nvar secret = new Secret { Value = \u0026#34;foo\u0026#34;, Type = \u0026#34;bar\u0026#34;, Description = \u0026#34;my custom secret\u0026#34;, Expiration = new DateTime(2021,12,31) } You can assign multiple secrets to a client to enable roll-over scenarios, e.g.:\nvar primary = new Secret(\u0026#34;foo\u0026#34;); var secondary = new Secret(\u0026#34;bar\u0026#34;); client.ClientSecrets = new[] { primary, secondary }; Secret parsing During request processing, the secret must be somehow extracted from the incoming request. The various specs describe a couple of options, e.g. as part of the authorization header or the body payload.\nIt is the job of implementations of the ISecretParser interface to accomplish this. You can add secret parsers by calling the AddSecretParser() DI extension method.\nThe following secret parsers are part of Duende IdentityServer:\nDuende.IdentityServer.Validation.BasicAuthenticationSecretParser\nparses an OAuth basic authentication formatted Authorization header. Enabled by default.\nDuende.IdentityServer.Validation.PostBodySecretParser\nParses from the client_id and client_secret body fields. Enabled by default.\nDuende.IdentityServer.Validation.JwtBearerClientAssertionSecretParser\nParses a JWT on the client_assertion body field. Can be enabled by calling the AddJwtBearerClientAuthentication DI extension method.\nDuende.IdentityServer.Validation.MutualTlsSecretParser\nParses the client_id body field and TLS client certificate. Can be enabled by calling the AddMutualTlsSecretValidators DI extension method.\nSecret validation It is the job of implementations of the ISecretValidator interface to validate the extracted credentials.\nYou can add secret validators by calling the AddSecretValidator() DI extension method.\nThe following secret validators are part of Duende IdentityServer:\nDuende.IdentityServer.Validation.HashedSharedSecretValidator\nValidates shared secrets that are stored hashed. Enabled by default.\nDuende.IdentityServer.Validation.PlainTextSharedSecretValidator\nValidates shared secrets that are stored in plaintext.\nDuende.IdentityServer.Validation.PrivateKeyJwtSecretValidator\nValidates JWTs that are signed with either X.509 certificates or keys wrapped in a JWK. Can be enabled by calling the AddJwtBearerClientAuthentication DI extension method.\nDuende.IdentityServer.Validation.X509ThumbprintSecretValidator\nValidates X.509 client certificates based on a thumbprint. Can be enabled by calling the AddMutualTlsSecretValidators DI extension method.\nDuende.IdentityServer.Validation.X509NameSecretValidator\nValidates X.509 client certificates based on a common name. Can be enabled by calling the AddMutualTlsSecretValidators DI extension method.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/tokens/overview/",
    "title": "Overview",
    "tags": [],
    "description": "Tokens",
    "content": "Duende IdentityServer is a token service engine based on OAuth 2.x and OpenID Connect.\nHow to request tokens OIDC and OAuth contain two endpoints that can issue tokens - the authorize endpoint and the token endpoint.\nWhile the authorize endpoint can be used for some special cases, you typically use the token endpoint for issuing tokens.\nToken Types The following token types are supported.\nIdentity Token During user authentication, your IdentityServer collects data about the user, e.g. authentication method, authentication time, some protocol information and a unique identifier for the user that was authenticated, to communicate back to the client application “what happened at the token service”.\nThis data must be sent in a format that is both tamper proof and that allows the client to authenticate the issuer. In OIDC this format is JSON – and the way to add the above security properties to a JSON object is by wrapping it in a JWT (along with JWS, JWA and JWK) – hence the name identity token.\nThe data includes token lifetime information (exp, iat, nbf), the authentication method (amr) and time (auth_time), the authentication source (idp), the session ID (sid) and information about the user (sub and name).\n{ \u0026#34;iss\u0026#34;: \u0026#34;https://localhost:5001\u0026#34;, \u0026#34;nbf\u0026#34;: 1609932802, \u0026#34;iat\u0026#34;: 1609932802, \u0026#34;exp\u0026#34;: 1609933102, \u0026#34;aud\u0026#34;: \u0026#34;web_app\u0026#34;, \u0026#34;amr\u0026#34;: [ \u0026#34;pwd\u0026#34; ], \u0026#34;nonce\u0026#34;: \u0026#34;63745529591...I3ZTIyOTZmZTNj\u0026#34;, \u0026#34;sid\u0026#34;: \u0026#34;F6E6F2EDE86EB8731EF609A4FE40ED89\u0026#34;, \u0026#34;auth_time\u0026#34;: 1609932794, \u0026#34;idp\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;88421113\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Bob\u0026#34;, } This data is solely for the client application (the aud claim) that initiated the authentication request, and you never send it to an API to consume. The identity token also contains a nonce (a number used once) to make sure it is only consumed once at the client.\nSee the OpenID Connect specification for more information on identity tokens.\nAccess Token An access token is a data structure that allows a client to access a resource (e.g. an API - see the protecting APIs section for more details).\nThe data associated with an access token typically includes the client ID, the requested scopes, an expiration time, and user information in case of an interactive application. Access tokens come in two flavours: JSON Web Tokens (JWT) or reference tokens.\nIn the case of JWTs, all claims are embedded into the token itself, e.g.:\n{ \u0026#34;iss\u0026#34;: \u0026#34;https://localhost:5001\u0026#34;, \u0026#34;nbf\u0026#34;: 1609932801, \u0026#34;iat\u0026#34;: 1609932801, \u0026#34;exp\u0026#34;: 1609936401, \u0026#34;aud\u0026#34;: \u0026#34;urn:resource1\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;openid resource1.scope1 offline_access\u0026#34;, \u0026#34;amr\u0026#34;: [ \u0026#34;pwd\u0026#34; ], \u0026#34;client_id\u0026#34;: \u0026#34;web_app\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;88421113\u0026#34;, \u0026#34;auth_time\u0026#34;: 1609932794, \u0026#34;idp\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;sid\u0026#34;: \u0026#34;F6E6F2EDE86EB8731EF609A4FE40ED89\u0026#34;, \u0026#34;jti\u0026#34;: \u0026#34;2C56A356A306E64AFC7D2C6399E23A17\u0026#34; } A reference token does not contain any data, but is a pointer to the token data stored in the token service. Reference tokens allow for immediate revocation (by deleting the token data from your IdentityServer data store), whereas a JWT can only be invalidated via expiration.\nYou can control the access token format on a per-client basis using the AccessTokenType setting.\nSee the OAuth specification for more information on access tokens.\nRefresh Token Refresh tokens allow for token lifetime management of access tokens. Since an access token has a finite lifetime, the refresh token (usually with a significantly longer lifetime) can be used to request new access tokens. This mechanism serves three purposes\nit allows similar semantics as sliding expiration for cookies - just with access tokens lifetime management does not need to involve the end-user and thus provides a good UX refresh tokens can be revoked and thus provide a way to revoke long-lived API access (while allowing the above two features) See the OAuth specification for more information on refresh tokens.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/overview/big_picture/",
    "title": "The big Picture",
    "tags": [],
    "description": "",
    "content": "Most modern applications look more or less like this:\nThe most common interactions are:\nBrowsers communicate with web applications Web applications communicate with web APIs (sometimes on their own, sometimes on behalf of a user) Browser-based applications communicate with web APIs Native applications communicate with web APIs Server-based applications communicate with web APIs Web APIs communicate with web APIs (sometimes on their own, sometimes on behalf of a user) Typically each and every layer (front-end, middle-tier and back-end) has to protect resources and implement authentication and/or authorization – often against the same user store.\nOutsourcing these fundamental security functions to a security token service prevents duplicating that functionality across those applications and endpoints.\nRestructuring the application to support a security token service leads to the following architecture and protocols:\nSuch a design divides security concerns into two parts:\nAuthentication Authentication is needed when an application needs to know the identity of the current user. Typically these applications manage data on behalf of that user and need to make sure that this user can only access the data for which they are allowed. The most common example for that is (classic) web applications – but native and JS-based applications also have a need for authentication.\nThe most common authentication protocols are SAML2p, WS-Federation and OpenID Connect – SAML2p being the most popular and the most widely deployed.\nOpenID Connect is the newest of the three, but is considered to be the future because it has the most potential for modern applications. It was built for mobile application scenarios right from the start and is designed to be API friendly.\nAPI Access Applications have two fundamental ways with which they communicate with APIs – using the application identity, or delegating the user’s identity. Sometimes both methods need to be combined.\nOAuth2 is a protocol that allows applications to request access tokens from a security token service and use them to communicate with APIs. This delegation reduces complexity in both the client applications as well as the APIs since authentication and authorization can be centralized.\nOpenID Connect and OAuth 2.0 – better together OpenID Connect and OAuth 2.0 are very similar – in fact OpenID Connect is an extension on top of OAuth 2.0. The two fundamental security concerns, authentication and API access, are combined into a single protocol - often with a single round trip to the security token service.\nWe believe that the combination of OpenID Connect and OAuth 2.0 is the best approach to secure modern applications for the foreseeable future. Duende IdentityServer is an implementation of these two protocols and is highly optimized to solve the typical security problems of today’s mobile, native and web applications.\nHow Duende IdentityServer can help Duende IdentityServer is middleware that adds spec-compliant OpenID Connect and OAuth 2.0 endpoints to an arbitrary ASP.NET Core host.\nTypically, you build (or re-use) an application that contains login and logout pages (and optionally a consent page, depending on your needs) and add the IdentityServer middleware to that application. The middleware adds the necessary protocol heads to the application so that clients can talk to it using those standard protocols.\nThe hosting application can be as complex as you want, but we typically recommend to keep the attack surface as small as possible by including authentication/federation related UI only.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/overview/",
    "title": "Overview",
    "tags": [],
    "description": "IdentityServer",
    "content": "Overview The big Picture Terminology Supported Specifications Packaging and Builds Support and Issues Security best-practices Demo Server Glossary Resources "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/endpoints/authorize/",
    "title": "Authorize Endpoint",
    "tags": [],
    "description": "",
    "content": "The authorize endpoint can be used to request tokens or authorization codes via the browser. This process typically involves authentication of the end-user and optionally consent.\nIdentityServer supports a subset of the OpenID Connect and OAuth 2.0 authorize request parameters. For a full list, see here.\nRequired parameters client_id\nidentifier of the client\nscope\none or more registered scopes\nredirect_uri\nmust exactly match one of the allowed redirect URIs for that client\nresponse_type\nspecifies the response type\nid_token\ntoken\nid_token token\ncode\ncode id_token\ncode id_token token\nOptional parameters response_mode\nspecifies the response mode\nquery\nfragment\nform_post\nstate\nechos back the state value on the token response, this is for round tripping state between client and provider, correlating request and response and CSRF/replay protection. (recommended)\nnonce\nechos back the nonce value in the identity token (for replay protection)\nRequired when identity tokens is transmitted via the browser channel\nprompt\nnone\nno UI will be shown during the request. If this is not possible (e.g. because the user has to sign in or consent) an error is returned\nlogin\nthe login UI will be shown, even if the user is already signed-in and has a valid session\ncreate\nthe user registration UI will be shown, if the UserInteraction.CreateAccountUrl option is set (the option is null by default, which disables support for this prompt value)\ncode_challenge\nsends the code challenge for PKCE\ncode_challenge_method\nplain\nindicates that the challenge is using plain text (not recommended)\nS256\nindicates the challenge is hashed with SHA256\nlogin_hint\ncan be used to pre-fill the username field on the login page\nui_locales\ngives a hint about the desired display language of the login UI\nmax_age\nif the user\u0026rsquo;s logon session exceeds the max age (in seconds), the login UI will be shown\nacr_values\nallows passing in additional authentication related information - IdentityServer special cases the following proprietary acr_values:\nidp:name_of_idp\nbypasses the login/home realm screen and forwards the user directly to the selected identity provider (if allowed per client configuration)\ntenant:name_of_tenant\ncan be used to pass a tenant name to the login UI\nrequest\ninstead of providing all parameters as individual query string parameters, you can provide a subset or all of them as a JWT\nrequest_uri\nURL of a pre-packaged JWT containing request parameters\nGET /connect/authorize? client_id=client1\u0026amp; scope=openid email api1\u0026amp; response_type=id_token token\u0026amp; redirect_uri=https://myapp/callback\u0026amp; state=abc\u0026amp; nonce=xyz .NET client library You can use the IdentityModel client library to programmatically create authorize request URLs from .NET code.\nvar ru = new RequestUrl(\u0026#34;https://demo.duendesoftware.com/connect/authorize\u0026#34;); var url = ru.CreateAuthorizeUrl( clientId: \u0026#34;client\u0026#34;, responseType: \u0026#34;code\u0026#34;, redirectUri: \u0026#34;https://app.com/callback\u0026#34;, scope: \u0026#34;openid\u0026#34;); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/quickstarts/1_client_credentials/",
    "title": "Protecting an API using Client Credentials",
    "tags": [],
    "description": "",
    "content": "Welcome to the first quickstart for IdentityServer! To see the full list of quickstarts, please see Quickstarts Overview.\nThis first quickstart provides step-by-step instructions to set up IdentityServer in the most basic scenario: protecting APIs for server-to-server communication. You will create a solution containing three projects:\nAn Identity Server An API that requires authentication A client that accesses that API The client will request an access token from IdentityServer using its client ID and secret and then use the token to gain access to the API.\nSource Code Finished source code for each quickstart in this series is available in the Samples repository, and a reference implementation of this quickstart is available here.\nVideo In addition to the written steps below there\u0026rsquo;s also a YouTube video available:\nPreparation The IdentityServer templates for the dotnet CLI are a good starting point for the quickstarts. To install the templates open a console window and type the following command:\ndotnet new install Duende.Templates You may have a previous version of Duende templates (Duende.IdentityServer.Templates) installed on your machine. Please uninstall the template package and install the latest version.\nCreate the Solution and IdentityServer Project In this section, you will create a directory for the solution and use the isempty (IdentityServer Empty) template to create an ASP.NET Core application that includes a basic IdentityServer setup.\nBack in the console, run the following commands to create the directory structure for the solution.\nmkdir quickstart cd quickstart mkdir src dotnet new sln -n Quickstart This will create a quickstart directory that will serve as the root of the solution, a src subdirectory to hold your source code, and a solution file to organize your projects. Throughout the rest of the quickstart series, paths will be written relative to to the quickstart directory.\nFrom the new quickstart directory, run the following commands to use the isempty template to create a new project. The template creates a web project named IdentityServer with the IdentityServer package installed and minimal configuration added for it.\ncd src dotnet new isempty -n IdentityServer This will create the following files within a new src/IdentityServer directory:\nProperties/launchSettings.json file - launch profile appsettings.json - run time settings Config.cs - definitions for resources and clients used by IdentityServer HostingExtensions.cs - configuration for ASP.NET pipeline and services Notably, the IdentityServer services are configured here and the IdentityServer middleware is added to the pipeline here. IdentityServer.csproj - project file with the IdentityServer NuGet package added Program.cs - main application entry point The src/IdentityServer/Properties/launchSettings.json file created by the isempty template sets the applicationUrl to https://localhost:5001. You can change the port that your IdentityServer host listens on by changing the port in this url. This url also sets the protocol (http or https) that the IdentityServer host will use. In production scenarios you should always use https.\nNext, add the IdentityServer project to the solution. Back in the console, navigate up to the quickstart directory and add the IdentityServer project to the solution.\ncd .. dotnet sln add ./src/IdentityServer Defining an API Scope Scope is a core feature of OAuth that allows you to express the extent or scope of access. Clients request scopes when they initiate the protocol, declaring what scope of access they want. IdentityServer then has to decide which scopes to include in the token. Just because the client has asked for something doesn\u0026rsquo;t mean they should get it! There are built-in abstractions as well as extensibility points that you can use to make this decision. Ultimately, IdentityServer issues a token to the client, which then uses the token to access APIs. APIs can check the scopes that were included in the token to make authorization decisions.\nScopes don\u0026rsquo;t have structure imposed by the protocols - they are just space-separated strings. This allows for flexibility when designing the scopes used by a system. In this quickstart, you will create a scope that represents complete access to an API that will be created later in this quickstart.\nScope definitions can be loaded in many ways. This quickstart shows how to use a \u0026ldquo;code as configuration\u0026rdquo; approach. A minimal Config.cs was created by the template at src/IdentityServer/Config.cs. Open it and add an ApiScope to the ApiScopes property:\npublic static IEnumerable\u0026lt;ApiScope\u0026gt; ApiScopes =\u0026gt; new ApiScope[] { new ApiScope(name: \u0026#34;api1\u0026#34;, displayName: \u0026#34;My API\u0026#34;) }; See the full file here.\nIn production it is important to give your API a useful name and display name. Use these names to describe your API in simple terms to both developers and users. Developers will use the name to connect to your API, and end users will see the display name on consent screens, etc.\nDefining the client The next step is to configure a client application that you will use to access the API. You\u0026rsquo;ll create the client application project later in this quickstart. First, you\u0026rsquo;ll add configuration for it to your IdentityServer project.\nIn this quickstart, the client will not have an interactive user and will authenticate with IdentityServer using a client secret.\nAdd this client definition to Config.cs:\npublic static IEnumerable\u0026lt;Client\u0026gt; Clients =\u0026gt; new Client[] { new Client { ClientId = \u0026#34;client\u0026#34;, // no interactive user, use the clientid/secret for authentication AllowedGrantTypes = GrantTypes.ClientCredentials, // secret for authentication ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, // scopes that client has access to AllowedScopes = { \u0026#34;api1\u0026#34; } } }; Again, see the full file here.\nClients can be configured with many options. Your minimal machine-to-machine client here contains:\nA ClientId, which identifies the application to IdentityServer so that it knows which client is trying to connect to it. A Secret, which you can think of as the password for the client. The list of scopes that the client is allowed to ask for. Notice that the allowed scope here matches the name of the ApiScope above. Configuring IdentityServer The scope and client definitions are loaded in HostingExtensions.cs. The template created a ConfigureServices method there that is already loading the scopes and clients. You can take a look to see how it is done. Note that the template adds a few things that are not used in this quickstart. Here\u0026rsquo;s the minimal ConfigureServices method that is needed:\npublic static WebApplication ConfigureServices(this WebApplicationBuilder builder) { builder.Services.AddIdentityServer() .AddInMemoryApiScopes(Config.ApiScopes) .AddInMemoryClients(Config.Clients); return builder.Build(); } That\u0026rsquo;s it - your IdentityServer is now configured. If you run the project and then navigate to https://localhost:5001/.well-known/openid-configuration in your browser, you should see the discovery document. The discovery document is a standard endpoint in OpenID Connect and OAuth. It is used by your clients and APIs to retrieve configuration data needed to request and validate tokens, login and logout, etc.\nOn first startup, IdentityServer will use its automatic key management feature to create a signing key and store it in the src/IdentityServer/keys directory. To avoid accidentally disclosing cryptographic secrets, the entire keys directory should be excluded from source control. It will be recreated if it is not present.\nCreate an API Project Next, add an API project to your solution. This API will serve protected resources that will be secured by IdentityServer.\nYou can either use the ASP.NET Core Web API template from Visual Studio or use the .NET CLI to create the API project. To use the CLI, run the following commands:\ncd src dotnet new webapi -n Api --no-openapi Then navigate back up to the root quickstart directory and add it to the solution by running the following commands:\ncd .. dotnet sln add ./src/Api Add JWT Bearer Authentication Now you will add JWT Bearer Authentication to the API\u0026rsquo;s ASP.NET pipeline. The goal is to authorize calls to your API using tokens issued by the IdentityServer project. To that end, you will add authentication middleware to the pipeline from the Microsoft.AspNetCore.Authentication.JwtBearer NuGet package. This middleware will:\nFind and parse a JWT sent with incoming requests as an Authorization: Bearer header. Validate the JWT\u0026rsquo;s signature to ensure that it was issued by IdentityServer. Validate that the JWT is not expired. Run this command to add the middleware package to the API:\ndotnet add ./src/Api package Microsoft.AspNetCore.Authentication.JwtBearer Now add the authentication and authorization services to the Service Collection, and configure the JWT Bearer authentication provider as the default Authentication Scheme.\nbuilder.Services.AddAuthentication() .AddJwtBearer(options =\u0026gt; { options.Authority = \u0026#34;https://localhost:5001\u0026#34;; options.TokenValidationParameters.ValidateAudience = false; }); builder.Services.AddAuthorization(); Audience validation is disabled here because access to the api is modeled with ApiScopes only. By default, no audience will be emitted unless the api is modeled with ApiResources instead. See here for a more in-depth discussion.\nAdd an endpoint Replace the templated weather forecast endpoint with a new endpoint:\napp.MapGet(\u0026#34;identity\u0026#34;, (ClaimsPrincipal user) =\u0026gt; user.Claims.Select(c =\u0026gt; new { c.Type, c.Value })) .RequireAuthorization(); This endpoint will be used to test authorization and to display the claims identity through the eyes of the API.\nConfigure API to listen on Port 6001 Configure the API to run on https://localhost:6001 only. You can do this by editing the launchSettings.json file in the src/Api/Properties directory. Change these settings for the https profile:\n\u0026#34;launchUrl\u0026#34;: \u0026#34;identity\u0026#34;, \u0026#34;applicationUrl\u0026#34;: \u0026#34;https://localhost:6001\u0026#34;, Test the identity endpoint Run the API project using the https profile and then navigate to the identity controller at https://localhost:6001/identity in a browser. This should return a 401 status code, which means your API requires a credential and is now protected by IdentityServer.\nCreate the client project The last step is to create a client that requests an access token and then uses that token to access the API. Your client will be a console project in your solution. Run the following commands:\ncd src dotnet new console -n Client Then as before, add it to your solution using:\ncd .. dotnet sln add ./src/Client Add the IdentityModel NuGet package The token endpoint at IdentityServer implements the OAuth protocol, and you could use raw HTTP to access it. However, we have a client library called IdentityModel that encapsulates the protocol interaction in an easy to use API.\nAdd the *Duende.IdentityModel * NuGet package to your client by running the following command:\ndotnet add ./src/Client package Duende.IdentityModel Retrieve the discovery document IdentityModel includes a client library to use with the discovery endpoint. This way you only need to know the base address of IdentityServer - the actual endpoint addresses can be read from the metadata. Add the following to the client\u0026rsquo;s Program.cs in the src/Client/Program.cs directory:\nusing IdentityModel.Client; // discover endpoints from metadata var client = new HttpClient(); var disco = await client.GetDiscoveryDocumentAsync(\u0026#34;https://localhost:5001\u0026#34;); if (disco.IsError) { Console.WriteLine(disco.Error); Console.WriteLine(disco.Exception); return 1; } If you get an error connecting, it may be that the development certificate for localhost is not trusted. You can run dotnet dev-certs https \u0026ndash;trust in order to trust the development certificate. This only needs to be done once.\nRequest a token from IdentityServer Next you can use the information from the discovery document to request a token from IdentityServer to access api1:\n// request token var tokenResponse = await client.RequestClientCredentialsTokenAsync(new ClientCredentialsTokenRequest { Address = disco.TokenEndpoint, ClientId = \u0026#34;client\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Scope = \u0026#34;api1\u0026#34; }); if (tokenResponse.IsError) { Console.WriteLine(tokenResponse.Error); Console.WriteLine(tokenResponse.ErrorDescription); return 1; } Console.WriteLine(tokenResponse.AccessToken); Copy and paste the access token from the console to jwt.ms to inspect the raw token.\nCalling the API To send the access token to the API you typically use the HTTP Authorization header. This is done using the SetBearerToken extension method:\n// call api var apiClient = new HttpClient(); apiClient.SetBearerToken(tokenResponse.AccessToken!); // AccessToken is always non-null when IsError is false var response = await apiClient.GetAsync(\u0026#34;https://localhost:6001/identity\u0026#34;); if (!response.IsSuccessStatusCode) { Console.WriteLine(response.StatusCode); return 1; } var doc = JsonDocument.Parse(await response.Content.ReadAsStringAsync()).RootElement; Console.WriteLine(JsonSerializer.Serialize(doc, new JsonSerializerOptions { WriteIndented = true })); return 0; The completed Program.cs file can be found here.\nTo test the flow, start the IdentityServer and API projects. Once they are running, run the Client project.\nThe output should look like this:\nIf you\u0026rsquo;re using Visual Studio, here\u0026rsquo;s how to start everything up:\nRight click the solution and select Configure Startup Projects\u0026hellip; Choose Multiple Startup Projects and set the action for Api and IdentityServer to Start Run the solution and wait a moment for both the API and and IdentityServer to start Right click the Client project and select Debug -\u0026gt; Start Without Debugging. By default an access token will contain claims about the scope, lifetime (nbf and exp), the client ID (client_id) and the issuer name (iss).\nAuthorization at the API Right now, the API accepts any access token issued by your IdentityServer. In this section, you will add an Authorization Policy to the API that will check for the presence of the \u0026ldquo;api1\u0026rdquo; scope in the access token. The protocol ensures that this scope will only be in the token if the client requests it and IdentityServer allows the client to have that scope. You configured IdentityServer to allow this access by including it in the allowedScopes property. Add the following to the Program.cs file of the API:\nbuilder.Services.AddAuthorization(options =\u0026gt; { options.AddPolicy(\u0026#34;ApiScope\u0026#34;, policy =\u0026gt; { policy.RequireAuthenticatedUser(); policy.RequireClaim(\u0026#34;scope\u0026#34;, \u0026#34;api1\u0026#34;); }); }); You can now enforce this policy at various levels, e.g.:\nglobally for all endpoints for specific controllers, actions, or endpoints Add the policy to the identity endpoint in src/Api/Program.cs:\napp.MapGet(\u0026#34;identity\u0026#34;, (ClaimsPrincipal user) =\u0026gt; user.Claims.Select(c =\u0026gt; new { c.Type, c.Value })) .RequireAuthorization(\u0026#34;ApiScope\u0026#34;); Now you can run the API again and it will enforce that the api1 scope is present in the access token.\nFurther experiments This quickstart focused on the success path:\nThe client was able to request a token. The client could use the token to access the API. You can now try to provoke errors to learn how the system behaves, e.g.:\nTry to connect to IdentityServer when it is not running (unavailable). Try to use an invalid client id or secret to request the token. Try to ask for an invalid scope during the token request. Try to call the API when it is not running (unavailable). Don\u0026rsquo;t send the token to the API. Configure the API to require a different scope than the one in the token. "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/quickstarts/2_interactive/",
    "title": "Interactive Applications with ASP.NET Core",
    "tags": [],
    "description": "",
    "content": "Welcome to Quickstart 2 for Duende IdentityServer!\nIn this quickstart, you will add support for interactive user authentication via the OpenID Connect protocol to the IdentityServer you built in Quickstart 1. Once that is in place, you will create an ASP.NET Razor Pages application that will use IdentityServer for authentication.\nWe recommend you do the quickstarts in order. If you\u0026rsquo;d like to start here, begin from a copy of the reference implementation of Quickstart 1. Throughout this quickstart, paths are written relative to the base quickstart directory created in part 1, which is the root directory of the reference implementation. You will also need to install the IdentityServer templates.\nVideo In addition to the written steps below there\u0026rsquo;s also a YouTube video available:\nEnable OIDC in IdentityServer To enable OIDC in IdentityServer you need:\nAn interactive UI Configuration for OIDC scopes Configuration for an OIDC client Users to log in with Add the UI Support for the OpenID Connect protocol is already built into IdentityServer. You need to provide the User Interface for login, logout, consent and error.\nWhile the look \u0026amp; feel and workflows will differ in each implementation, we provide a Razor Pages-based UI that you can use as a starting point. You can use the .NET CLI to add the quickstart UI to a project. Run the following command from the src/IdentityServer directory:\ndotnet new isui Enable the UI Once you have added the UI, you will need to register its services and enable it in the pipeline. In src/IdentityServer/HostingExtensions.cs you will find commented out code in the ConfigureServices and ConfigurePipeline methods that enable the UI. Note that there are three places to comment in - two in ConfigurePipeline and one in ConfigureServices.\nThere is also a template called isinmem which combines the basic IdentityServer from the isempty template with the quickstart UI from the isui template.\nComment in the service registration and pipeline configuration, run the IdentityServer project, and navigate to https://localhost:5001. You should now see a home page.\nSpend some time reading the pages and models, especially those in the src/IdentityServer/Pages/Account directory. These pages are the main UI entry points for login and logout. The better you understand them, the easier it will be to make future modifications.\nConfigure OIDC Scopes Similar to OAuth, OpenID Connect uses scopes to represent something you want to protect and that clients want to access. In contrast to OAuth, scopes in OIDC represent identity data like user id, name or email address rather than APIs.\nAdd support for the standard openid (subject id) and profile (first name, last name, etc) scopes by declaring them in src/IdentityServer/Config.cs:\npublic static IEnumerable\u0026lt;IdentityResource\u0026gt; IdentityResources =\u0026gt; new IdentityResource[] { new IdentityResources.OpenId(), new IdentityResources.Profile(), }; Then register the identity resources in src/IdentityServer/HostingExtensions.cs:\nbuilder.Services.AddIdentityServer() .AddInMemoryIdentityResources(Config.IdentityResources) .AddInMemoryApiScopes(Config.ApiScopes) .AddInMemoryClients(Config.Clients); All standard scopes and their corresponding claims can be found in the OpenID Connect specification.\nAdd Test Users The sample UI also comes with an in-memory \u0026ldquo;user database\u0026rdquo;. You can enable this by calling AddTestUsers in src/IdentityServer/HostingExtensions.cs:\nbuilder.Services.AddIdentityServer() .AddInMemoryIdentityResources(Config.IdentityResources) .AddInMemoryApiScopes(Config.ApiScopes) .AddInMemoryClients(Config.Clients) .AddTestUsers(TestUsers.Users); In the TestUsers class, you can see that two users called alice and bob are defined with some identity claims. You can use those users to login. Note that the test users\u0026rsquo; passwords match their usernames.\nRegister an OIDC client The last step in the IdentityServer project is to add a new configuration entry for a client that will use OIDC to log in. You will create the application code for this client in the next section. For now, you will register its configuration.\nOpenID Connect-based clients are very similar to the OAuth clients we added in Quickstart 1. But since the flows in OIDC are always interactive, we need to add some redirect URLs to our configuration.\nThe Clients list in src/IdentityServer/Config.cs should look like this:\npublic static IEnumerable\u0026lt;Client\u0026gt; Clients =\u0026gt; new List\u0026lt;Client\u0026gt; { // machine to machine client (from quickstart 1) new Client { ClientId = \u0026#34;client\u0026#34;, ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, AllowedGrantTypes = GrantTypes.ClientCredentials, // scopes that client has access to AllowedScopes = { \u0026#34;api1\u0026#34; } }, // interactive ASP.NET Core Web App new Client { ClientId = \u0026#34;web\u0026#34;, ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, AllowedGrantTypes = GrantTypes.Code, // where to redirect to after login RedirectUris = { \u0026#34;https://localhost:5002/signin-oidc\u0026#34; }, // where to redirect to after logout PostLogoutRedirectUris = { \u0026#34;https://localhost:5002/signout-callback-oidc\u0026#34; }, AllowedScopes = { IdentityServerConstants.StandardScopes.OpenId, IdentityServerConstants.StandardScopes.Profile } } }; Create the OIDC client Next you will create an ASP.NET web application that will allow interactive users to log in using OIDC. Use the webapp template to create the project. Run the following commands from the src directory:\ndotnet new webapp -n WebClient cd .. dotnet sln add ./src/WebClient This version of the quickstarts uses Razor Pages for the web client. If you prefer MVC, the conversion is straightforward. See the quickstart for IdentityServer 5 that uses it.\nInstall the OIDC NuGet Package To add support for OpenID Connect authentication to the WebClient project, you need to add the NuGet package containing the OpenID Connect handler. From the src/WebClient directory, run the following command:\ndotnet add package Microsoft.AspNetCore.Authentication.OpenIdConnect Configure Authentication Services Then add the authentication service and register the cookie and OpenIdConnect authentication providers in src/WebClient/Program.cs:\nbuilder.Services.AddAuthentication(options =\u0026gt; { options.DefaultScheme = \u0026#34;Cookies\u0026#34;; options.DefaultChallengeScheme = \u0026#34;oidc\u0026#34;; }) .AddCookie(\u0026#34;Cookies\u0026#34;) .AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { options.Authority = \u0026#34;https://localhost:5001\u0026#34;; options.ClientId = \u0026#34;web\u0026#34;; options.ClientSecret = \u0026#34;secret\u0026#34;; options.ResponseType = \u0026#34;code\u0026#34;; options.Scope.Clear(); options.Scope.Add(\u0026#34;openid\u0026#34;); options.Scope.Add(\u0026#34;profile\u0026#34;); options.MapInboundClaims = false; // Don\u0026#39;t rename claim types options.SaveTokens = true; }); If you are unfamiliar with the fundamentals of how the ASP.NET Core authentication system works, then we recommend this recording of an Introduction to ASP.NET Core Authentication and Authorization.\nAddAuthentication registers the authentication services. Notice that in its options, the DefaultChallengeScheme is set to \u0026ldquo;oidc\u0026rdquo;, and the DefaultScheme is set to \u0026ldquo;Cookies\u0026rdquo;. The DefaultChallengeScheme is used when an unauthenticated user must log in. This begins the OpenID Connect protocol, redirecting the user to IdentityServer. After the user has logged in and been redirected back to the client, the client creates its own local cookie. Subsequent requests to the client will include this cookie and be authenticated with the default Cookie scheme.\nAfter the call to AddAuthentication, AddCookie adds the handler that can process the local cookie.\nFinally, AddOpenIdConnect is used to configure the handler that performs the OpenID Connect protocol. The Authority indicates where the trusted token service is located. The ClientId and the ClientSecret identify this client. The Scope is the collection of scopes that the client will request. By default it includes the openid and profile scopes, but clear the collection and add them back for explicit clarity. SaveTokens is used to persist the tokens in the cookie (as they will be needed later).\nThis uses the authorization code flow with PKCE to connect to the OpenID Connect provider. See here for more information on protocol flows.\nConfigure the Pipeline Now add UseAuthentication to the ASP.NET pipeline in src/WebClient/Program.cs. Also chain a call to RequireAuthorization onto MapRazorPages to disable anonymous access for the entire application.\napp.UseRouting(); app.UseAuthentication(); app.UseAuthorization(); app.MapRazorPages().RequireAuthorization(); See the ASP.NET Core documentation on Razor Pages authorization conventions for more options that allow you to specify authorization on a per page or directory basis.\nDisplay the Auth Cookie Modify src/WebClient/Pages/Index.cshtml to display the claims of the user and the cookie properties:\n@page @model IndexModel @using Microsoft.AspNetCore.Authentication \u0026lt;h2\u0026gt;Claims\u0026lt;/h2\u0026gt; \u0026lt;dl\u0026gt; @foreach (var claim in User.Claims) { \u0026lt;dt\u0026gt;@claim.Type\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;@claim.Value\u0026lt;/dd\u0026gt; } \u0026lt;/dl\u0026gt; \u0026lt;h2\u0026gt;Properties\u0026lt;/h2\u0026gt; \u0026lt;dl\u0026gt; @foreach (var prop in (await HttpContext.AuthenticateAsync()).Properties!.Items) { \u0026lt;dt\u0026gt;@prop.Key\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;@prop.Value\u0026lt;/dd\u0026gt; } \u0026lt;/dl\u0026gt; Configure WebClient\u0026rsquo;s Port Update the client\u0026rsquo;s applicationUrl in src/WebClient/Properties/launchSettings.json to use port 5002.\n{ \u0026#34;$schema\u0026#34;: \u0026#34;http://json.schemastore.org/launchsettings.json\u0026#34;, \u0026#34;profiles\u0026#34;: { \u0026#34;WebClient\u0026#34;: { \u0026#34;commandName\u0026#34;: \u0026#34;Project\u0026#34;, \u0026#34;dotnetRunMessages\u0026#34;: true, \u0026#34;launchBrowser\u0026#34;: true, \u0026#34;applicationUrl\u0026#34;: \u0026#34;https://localhost:5002\u0026#34;, \u0026#34;environmentVariables\u0026#34;: { \u0026#34;ASPNETCORE_ENVIRONMENT\u0026#34;: \u0026#34;Development\u0026#34; } } } } Test the client Now everything should be in place to log in to WebClient using OIDC. Run IdentityServer and WebClient and then trigger the authentication handshake by navigating to the protected home page. You should see a redirect to the login page in IdentityServer.\nAfter you log in, IdentityServer will redirect back to WebClient, where the OpenID Connect authentication handler will process the response and sign-in the user locally by setting a cookie. Finally the WebClient\u0026rsquo;s page will show the contents of the cookie.\nAs you can see, the cookie has two parts: the claims of the user and some metadata in the properties. This metadata also contains the original access and id tokens issued by IdentityServer. Feel free to copy these tokens to jwt.ms to inspect their content.\nAdding sign-out Next you will add sign-out to WebClient.\nTo sign out, you need to\nClear local application cookies Make a roundtrip to IdentityServer using the OIDC protocol to clear its session The cookie auth handler will clear the local cookie when you sign out from its authentication scheme. The OpenId Connect handler will perform the protocol steps for the roundtrip to IdentityServer when you sign out of its scheme.\nCreate a page to trigger sign-out of both schemes by running the following command from the src/WebClient/Pages directory:\ndotnet new page -n Signout Update the new page\u0026rsquo;s model (src/WebClient/Pages/Signout.cshtml.cs) with the following code:\npublic class SignoutModel : PageModel { public IActionResult OnGet() { return SignOut(\u0026#34;Cookies\u0026#34;, \u0026#34;oidc\u0026#34;); } } This will clear the local cookie and then redirect to the IdentityServer. The IdentityServer will clear its cookies and then give the user a link to return back to the web application.\nCreate a link to the logout page in src/WebClient/Pages/Shared/_Layout.cshtml within the navbar-nav list:\n\u0026lt;!-- Existing navbar generated by template --\u0026gt; \u0026lt;ul class=\u0026#34;navbar-nav flex-grow-1\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link text-dark\u0026#34; asp-area=\u0026#34;\u0026#34; asp-page=\u0026#34;/Index\u0026#34;\u0026gt;Home\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link text-dark\u0026#34; asp-area=\u0026#34;\u0026#34; asp-page=\u0026#34;/Privacy\u0026#34;\u0026gt;Privacy\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;!-- Add this item to the list --\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link text-dark\u0026#34; asp-area=\u0026#34;\u0026#34; asp-page=\u0026#34;/Signout\u0026#34;\u0026gt;Signout\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; Run the application again, and try logging out. Observe that you get redirected to the end session endpoint, and that both session cookies are cleared.\nGetting claims from the UserInfo endpoint You might have noticed that even though you\u0026rsquo;ve configured the client to be allowed to retrieve the profile identity scope, the claims associated with that scope (such as name, given_name, family_name, etc.) don\u0026rsquo;t appear in the returned token. You need to tell the client to retrieve those claims from the userinfo endpoint by specifying scopes that the client application needs to access and setting the GetClaimsFromUserInfoEndpoint option. Add the following to ConfigureServices in src/WebClient/Program.cs:\n.AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { // ... options.Scope.Clear(); options.Scope.Add(\u0026#34;openid\u0026#34;); options.Scope.Add(\u0026#34;profile\u0026#34;); options.GetClaimsFromUserInfoEndpoint = true; // ... }); After restarting the client app and logging back in, you should see additional user claims associated with the profile identity scope displayed on the page.\nFurther Experiments This quickstart created a client with interactive login using OIDC. To experiment further you can\nAdd additional claims to the identity Add support for external authentication Add More Claims To add more claims to the identity:\nAdd a new identity resource to the list in src/IdentityServer/Config.cs. Name it and specify which claims should be returned when it is requested. The Name property of the resource is the scope value that clients can request to get the associated UserClaims. For example, you could add an IdentityResource named \u0026ldquo;verification\u0026rdquo; which would include the email and email_verified claims.\npublic static IEnumerable\u0026lt;IdentityResource\u0026gt; IdentityResources =\u0026gt; new List\u0026lt;IdentityResource\u0026gt; { new IdentityResources.OpenId(), new IdentityResources.Profile(), new IdentityResource() { Name = \u0026#34;verification\u0026#34;, UserClaims = new List\u0026lt;string\u0026gt; { JwtClaimTypes.Email, JwtClaimTypes.EmailVerified } } }; Give the client access to the resource via the AllowedScopes property on the client configuration in src/IdentityServer/Config.cs. The string value in AllowedScopes must match the Name property of the resource.\nnew Client { ClientId = \u0026#34;web\u0026#34;, //... AllowedScopes = { IdentityServerConstants.StandardScopes.OpenId, IdentityServerConstants.StandardScopes.Profile, \u0026#34;verification\u0026#34; } } Request the resource by adding it to the Scopes collection on the OpenID Connect handler configuration in src/WebClient/Program.cs, and add a ClaimAction to map the new claim returned from the userinfo endpoint onto a user claim.\n.AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { // ... options.Scope.Add(\u0026#34;verification\u0026#34;); options.ClaimActions.MapJsonKey(\u0026#34;email_verified\u0026#34;, \u0026#34;email_verified\u0026#34;); // ... } IdentityServer uses the IProfileService to retrieve claims for tokens and the userinfo endpoint. You can provide your own implementation of IProfileService to customize this process with custom logic, data access, etc. Since you are using AddTestUsers, the TestUserProfileService is used automatically. It will automatically include requested claims from the test users added in src/IdentityServer/TestUsers.cs.\nAdd Support for External Authentication Adding support for external authentication to your IdentityServer can be done with very little code; all that is needed is an authentication handler.\nASP.NET Core ships with handlers for Google, Facebook, Twitter, Microsoft Account and OpenID Connect. In addition, you can find handlers for many other authentication providers here.\nAdd Google support To use Google for authentication, you need to:\nAdd the Microsoft.AspNetCore.Authentication.Google NuGet package to the IdentityServer project. Register with Google and set up a client. Store the client id and secret securely with dotnet user-secrets. Add the Google authentication handler to the middleware pipeline and configure it. See Microsoft\u0026rsquo;s guide for details on how to register with Google, create the client, and store the secrets in user-secrets. Stop before adding the authentication middleware and Google authentication handler to the pipeline. You will need an IdentityServer specific option.\nAdd the following to ConfigureServices in src/IdentityServer/HostingExtensions.cs:\nbuilder.Services.AddAuthentication() .AddGoogle(\u0026#34;Google\u0026#34;, options =\u0026gt; { options.SignInScheme = IdentityServerConstants.ExternalCookieAuthenticationScheme; options.ClientId = builder.Configuration[\u0026#34;Authentication:Google:ClientId\u0026#34;]; options.ClientSecret = builder.Configuration[\u0026#34;Authentication:Google:ClientSecret\u0026#34;]; }); When authenticating with Google, there are again two authentication schemes. AddGoogle adds the Google scheme, which handles the protocol flow back and forth with Google. After successful login, the application needs to sign in to an additional scheme that can authenticate future requests without needing a roundtrip to Google - typically by issuing a local cookie. The SignInScheme tells the Google handler to use the scheme named IdentityServerConstants.ExternalCookieAuthenticationScheme, which is a cookie authentication handler automatically created by IdentityServer that is intended for external logins.\nNow run IdentityServer and WebClient and try to authenticate (you may need to log out and log back in). You will see a Google button on the login page.\nClick on Google and authenticate with a Google account. You should land back on the WebClient home page, showing that the user is now coming from Google with claims sourced from Google\u0026rsquo;s data.\nThe Google button is rendered by the login page automatically when there are external providers registered as authentication schemes. See the BuildModelAsync method in src/IdentityServer/Pages/Account/Login/Index.cshtml.cs and the corresponding Razor template for more details.\nAdding an additional OpenID Connect-based external provider A cloud-hosted demo version of Duende IdentityServer can be added as an additional external provider.\nRegister and configure the services for the OpenId Connect handler in src/IdentityServer/HostingExtensions.cs:\nbuilder.Services.AddAuthentication() .AddGoogle(\u0026#34;Google\u0026#34;, options =\u0026gt; { /* ... */ }) .AddOpenIdConnect(\u0026#34;oidc\u0026#34;, \u0026#34;Demo IdentityServer\u0026#34;, options =\u0026gt; { options.SignInScheme = IdentityServerConstants.ExternalCookieAuthenticationScheme; options.SignOutScheme = IdentityServerConstants.SignoutScheme; options.SaveTokens = true; options.Authority = \u0026#34;https://demo.duendesoftware.com\u0026#34;; options.ClientId = \u0026#34;interactive.confidential\u0026#34;; options.ClientSecret = \u0026#34;secret\u0026#34;; options.ResponseType = \u0026#34;code\u0026#34;; options.TokenValidationParameters = new TokenValidationParameters { NameClaimType = \u0026#34;name\u0026#34;, RoleClaimType = \u0026#34;role\u0026#34; }; }); Now if you try to authenticate, you should see an additional button to log in to the cloud-hosted Demo IdentityServer. If you click that button, you will be redirected to https://demo.duendesoftware.com/. Note that the demo site is using the same UI as your site, so there will not be very much that changes visually when you\u0026rsquo;re redirected. Check that the page\u0026rsquo;s location has changed and then log in using the alice or bob users (their passwords are their usernames, just as they are for the local test users). You should land back at WebClient, authenticated with a demo user.\nThe demo users are logically distinct entities from the local test users, even though they happen to have identical usernames. Inspect their claims in WebClient and note the differences between them, such as the distinct sub claims.\nThe quickstart UI auto-provisions external users. When an external user logs in for the first time, a new local user is created with a copy of all the external user\u0026rsquo;s claims. This auto-provisioning process occurs in the OnGet method of src/IdentityServer/Pages/ExternalLogin/Callback.cshtml.cs, and is completely customizable. For example, you could modify Callback so that it will require registration before provisioning the external user.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/endpoints/token/",
    "title": "Token Endpoint",
    "tags": [],
    "description": "",
    "content": "The token endpoint can be used to programmatically request tokens.\nDuende IdentityServer supports a subset of the OpenID Connect and OAuth 2.0 token request parameters. For a full list, see here.\nRequired parameters client_id\nclient identifier; not necessary in body if it is present in the authorization header\ngrant_type\nauthorization_code\nclient_credentials\npassword\nrefresh_token\nurn:ietf:params:oauth:grant-type:device_code\nextension grant\nOptional parameters client_secret\nclient secret for confidential/credentials clients - either in the post body, or as a basic authentication header.\nscope\none or more registered scopes. If not specified, a token for all explicitly allowed scopes will be issued.\nredirect_uri\nrequired for the authorization_code grant type\ncode\nthe authorization code (required for authorization_code grant type)\ncode_verifier\nPKCE proof key\nusername\nresource owner username (required for password grant type)\npassword\nresource owner password (required for password grant type)\nacr_values\nallows passing in additional authentication related information. Duende IdentityServer special cases the following proprietary acr_values\ntenant:name_of_tenant\ncan be used to pass a tenant name to the token endpoint\nrefresh_token\nthe refresh token (required for refresh_token grant type)\ndevice_code\nthe device code (required for urn:ietf:params:oauth:grant-type:device_code grant type)\nauth_req_id\nthe backchannel authentication request id (required for urn:openid:params:grant-type:ciba grant type)\nPOST /connect/token CONTENT-TYPE application/x-www-form-urlencoded client_id=client1\u0026amp; client_secret=secret\u0026amp; grant_type=authorization_code\u0026amp; code=hdh922\u0026amp; redirect_uri=https://myapp.com/callback .NET client library You can use the IdentityModel client library to programmatically interact with the protocol endpoint from .NET code.\nusing IdentityModel.Client; var client = new HttpClient(); var response = await client.RequestAuthorizationCodeTokenAsync(new AuthorizationCodeTokenRequest { Address = TokenEndpoint, ClientId = \u0026#34;client\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Code = \u0026#34;...\u0026#34;, CodeVerifier = \u0026#34;...\u0026#34;, RedirectUri = \u0026#34;https://app.com/callback\u0026#34; }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/quickstarts/3_api_access/",
    "title": "ASP.NET Core and API access",
    "tags": [],
    "description": "",
    "content": "Welcome to Quickstart 3 for Duende IdentityServer!\nThe previous quickstarts introduced API access and user authentication. This quickstart will bring the two together.\nIn addition to the written steps below a YouTube video is available:\nOpenID Connect and OAuth combine elegantly; you can achieve both user authentication and api access in a single exchange with the token service.\nIn Quickstart 2, the token request in the login process asked for only identity resources, that is, only scopes such as profile and openid. In this quickstart, you will add scopes for API resources to that request. IdentityServer will respond with two tokens:\nthe identity token, containing information about the authentication process and session, and the access token, allowing access to APIs on behalf of the logged on user We recommend you do the quickstarts in order. If you\u0026rsquo;d like to start here, begin from a copy of the reference implementation of Quickstart 2. Throughout this quickstart, paths are written relative to the base _quickstart* directory created in part 1, which is the root directory of the reference implementation. You will also need to install the IdentityServer templates.\nModifying the client configuration The client configuration in IdentityServer requires one straightforward update. We should add the api1 resource to the allowed scopes list so that the client will have permission to access it.\nUpdate the Client in src/IdentityServer/Config.cs as follows:\nnew Client { ClientId = \u0026#34;web\u0026#34;, ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, AllowedGrantTypes = GrantTypes.Code, // where to redirect to after login RedirectUris = { \u0026#34;https://localhost:5002/signin-oidc\u0026#34; }, // where to redirect to after logout PostLogoutRedirectUris = { \u0026#34;https://localhost:5002/signout-callback-oidc\u0026#34; }, AllowedScopes = { IdentityServerConstants.StandardScopes.OpenId, IdentityServerConstants.StandardScopes.Profile, \u0026#34;verification\u0026#34;, \u0026#34;api1\u0026#34; } } Modifying the Web client Now configure the client to ask for access to api1 by requesting the api1 scope. This is done in the OpenID Connect handler configuration in src/WebClient/Program.cs:\nbuilder.Services.AddAuthentication(options =\u0026gt; { options.DefaultScheme = \u0026#34;Cookies\u0026#34;; options.DefaultChallengeScheme = \u0026#34;oidc\u0026#34;; }) .AddCookie(\u0026#34;Cookies\u0026#34;) .AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { options.Authority = \u0026#34;https://localhost:5001\u0026#34;; options.ClientId = \u0026#34;web\u0026#34;; options.ClientSecret = \u0026#34;secret\u0026#34;; options.ResponseType = \u0026#34;code\u0026#34;; options.Scope.Clear(); options.Scope.Add(\u0026#34;openid\u0026#34;); options.Scope.Add(\u0026#34;profile\u0026#34;); options.Scope.Add(\u0026#34;api1\u0026#34;); options.Scope.Add(\u0026#34;verification\u0026#34;); options.ClaimActions.MapJsonKey(\u0026#34;email_verified\u0026#34;, \u0026#34;email_verified\u0026#34;); options.GetClaimsFromUserInfoEndpoint = true; options.MapInboundClaims = false; // Don\u0026#39;t rename claim types options.SaveTokens = true; }); Since SaveTokens is enabled, ASP.NET Core will automatically store the id and access tokens in the properties of the authentication cookie. If you run the solution and authenticate, you will see the tokens on the page that displays the cookie claims and properties created in quickstart 2.\nUsing the access token Now you will use the access token to authorize requests from the WebClient to the Api.\nCreate a page that will\nRetrieve the access token from the session using the GetTokenAsync method from Microsoft.AspNetCore.Authentication Set the token in an Authentication: Bearer HTTP header Make an HTTP request to the API Display the results Create the Page by running the following command from the src/WebClient/Pages directory:\ndotnet new page -n CallApi Update src/WebClient/Pages/CallApi.cshtml.cs as follows:\npublic class CallApiModel : PageModel { public string Json = string.Empty; public async Task OnGet() { var accessToken = await HttpContext.GetTokenAsync(\u0026#34;access_token\u0026#34;); var client = new HttpClient(); client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\u0026#34;Bearer\u0026#34;, accessToken); var content = await client.GetStringAsync(\u0026#34;https://localhost:6001/identity\u0026#34;); var parsed = JsonDocument.Parse(content); var formatted = JsonSerializer.Serialize(parsed, new JsonSerializerOptions { WriteIndented = true }); Json = formatted; } } And update src/WebClient/Pages/CallApi.cshtml as follows:\n@page @model MyApp.Namespace.CallApiModel \u0026lt;pre\u0026gt;@Model.Json\u0026lt;/pre\u0026gt; Also add a link to the new page in src/WebClient/Shared/_Layout.cshtml with the following:\n\u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link text-dark\u0026#34; asp-area=\u0026#34;\u0026#34; asp-page=\u0026#34;/CallApi\u0026#34;\u0026gt;CallApi\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; Make sure the IdentityServer and Api projects are running, start the WebClient and request /CallApi after authentication.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/endpoints/userinfo/",
    "title": "UserInfo Endpoint",
    "tags": [],
    "description": "",
    "content": "The UserInfo endpoint can be used to retrieve claims about a user (see spec).\nThe caller needs to send a valid access token. Depending on the granted scopes, the UserInfo endpoint will return the mapped claims (at least the openid scope is required).\nGET /connect/userinfo Authorization: Bearer \u0026lt;access_token\u0026gt; HTTP/1.1 200 OK Content-Type: application/json { \u0026#34;sub\u0026#34;: \u0026#34;248289761001\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Bob Smith\u0026#34;, \u0026#34;given_name\u0026#34;: \u0026#34;Bob\u0026#34;, \u0026#34;family_name\u0026#34;: \u0026#34;Smith\u0026#34; } .NET client library You can use the IdentityModel client library to programmatically interact with the protocol endpoint from .NET code.\nusing IdentityModel.Client; var client = new HttpClient(); var response = await client.GetUserInfoAsync(new UserInfoRequest { Address = disco.UserInfoEndpoint, Token = token }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/quickstarts/3a_token_management/",
    "title": "Token Management",
    "tags": [],
    "description": "",
    "content": "Welcome to this Quickstart for Duende IdentityServer!\nThe previous quickstart introduced API access with interactive applications, but by far the most complex task for a typical client is to manage the access token.\nIn addition to the written steps below a YouTube video is available:\nGiven that the access token has a finite lifetime, you typically want to\nrequest a refresh token in addition to the access token at login time cache those tokens use the access token to call APIs until it expires use the refresh token to get a new access token repeat the process of caching and refreshing with the new token ASP.NET Core has built-in facilities that can help you with some of those tasks (like caching or sessions), but there is still quite some work left to do. Duende.AccessTokenManagement can help. It provides abstractions for storing tokens, automatic refresh of expired tokens, etc.\nRequesting a refresh token To allow the web client to request a refresh token set the AllowOfflineAccess property to true in the client configuration.\nUpdate the Client in src/IdentityServer/Config.cs as follows:\nnew Client { ClientId = \u0026#34;web\u0026#34;, ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, AllowedGrantTypes = GrantTypes.Code, // where to redirect to after login RedirectUris = { \u0026#34;https://localhost:5002/signin-oidc\u0026#34; }, // where to redirect to after logout PostLogoutRedirectUris = { \u0026#34;https://localhost:5002/signout-callback-oidc\u0026#34; }, AllowOfflineAccess = true, AllowedScopes = { IdentityServerConstants.StandardScopes.OpenId, IdentityServerConstants.StandardScopes.Profile, \u0026#34;verification\u0026#34;, \u0026#34;api1\u0026#34; } } To get the refresh token the offline_access scope has to be requested by the client.\nIn src/WebClient/Program.cs add the scope to the scope list:\noptions.Scope.Add(\u0026#34;offline_access\u0026#34;); When running the solution the refresh token should now be visible under Properties on the landing page of the client.\nAutomatically refreshing an access token In the WebClient project add a reference to the NuGet package Duende.AccessTokenManagement.OpenIdConnect and in Program.cs add the needed types to dependency injection:\nbuilder.Services.AddOpenIdConnectAccessTokenManagement(); In CallApi.cshtml.cs update the method body of OnGet as follows:\npublic async Task OnGet() { var tokenInfo = await HttpContext.GetUserAccessTokenAsync(); var client = new HttpClient(); client.SetBearerToken(tokenInfo.AccessToken!); var content = await client.GetStringAsync(\u0026#34;https://localhost:6001/identity\u0026#34;); var parsed = JsonDocument.Parse(content); var formatted = JsonSerializer.Serialize(parsed, new JsonSerializerOptions { WriteIndented = true }); Json = formatted; } There are two changes here that utilize the AccessTokenManagement NuGet package:\nAn object called tokenInfo containing all stored tokens is returned by the GetUserAccessTokenAsync extension method. This will make sure the access token is automatically refreshed using the refresh token if needed. The SetBearerToken extension method on HttpClient is used for convenience to place the access token in the needed HTTP header. Using a Named HttpClient On each call to OnGet in CallApi.cshtml.cs a new HttpClient is created in the code above. Recommended however is to use the HttpClientFactory pattern so that instances can be reused.\nDuende.AccessTokenManagement.OpenIdConnect builds on top of HttpClientFactory to create HttpClient instances that automatically retrieve the needed access token and refresh if needed.\nIn the client in Program.cs under the call to AddOpenIdConnectAccessTokenManagement register the HttpClient:\nbuilder.Services.AddUserAccessTokenHttpClient(\u0026#34;apiClient\u0026#34;, configureClient: client =\u0026gt; { client.BaseAddress = new Uri(\u0026#34;https://localhost:6001\u0026#34;); }); Now the OnGet method in CallApi.cshtml.cs can be even more straightforward:\npublic class CallApiModel(IHttpClientFactory httpClientFactory) : PageModel { public string Json = string.Empty; public async Task OnGet() { var client = httpClientFactory.CreateClient(\u0026#34;apiClient\u0026#34;); var content = await client.GetStringAsync(\u0026#34;https://localhost:6001/identity\u0026#34;); var parsed = JsonDocument.Parse(content); var formatted = JsonSerializer.Serialize(parsed, new JsonSerializerOptions { WriteIndented = true }); Json = formatted; } } Note that:\nThe httpClientFactory is injected using a primary constructor. The type was registered when AddOpenIdConnectAccessTokenManagement was called in Program.cs. The client is created using the factory passing in the name of the client that was registered in program.cs. No additional code is needed. The client will automatically retrieve the access token and refresh it if needed. "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/endpoints/introspection/",
    "title": "Introspection Endpoint",
    "tags": [],
    "description": "",
    "content": "The introspection endpoint is an implementation of RFC 7662.\nIt can be used to validate reference tokens, JWTs (if the consumer does not have support for appropriate JWT or cryptographic libraries) and refresh tokens. Refresh tokens can only be introspected by the client that requested them.\nThe introspection endpoint requires authentication - since the client of an introspection endpoint is an API, you configure the secret on the ApiResource.\nPOST /connect/introspect Authorization: Basic xxxyyy token=\u0026lt;token\u0026gt; A successful response will return a status code of 200, the token claims, the token type and a flag indicating the token is active:\n{ \u0026#34;iss\u0026#34;: \u0026#34;https://localhost:5001\u0026#34;, \u0026#34;nbf\u0026#34;: 1729599599, \u0026#34;iat\u0026#34;: 1729599599, \u0026#34;exp\u0026#34;: 1729603199, \u0026#34;client_id\u0026#34;: \u0026#34;client\u0026#34;, \u0026#34;jti\u0026#34;: \u0026#34;44FD2DE9E9F8E9F4DDD141CD7C244BE9\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;api1\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;access_token\u0026#34;, \u0026#34;active\u0026#34;: true, } Unknown or expired tokens will be marked as inactive:\n{ \u0026#34;active\u0026#34;: false, } An invalid request will return a 400, an unauthorized request 401.\n.NET client library You can use the IdentityModel client library to programmatically interact with the protocol endpoint from .NET code.\nusing IdentityModel.Client; var client = new HttpClient(); var response = await client.IntrospectTokenAsync(new TokenIntrospectionRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/introspect\u0026#34;, ClientId = \u0026#34;api1\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Token = accessToken }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/endpoints/revocation/",
    "title": "Revocation Endpoint",
    "tags": [],
    "description": "",
    "content": "This endpoint allows revoking access tokens (reference tokens only) and refresh token. It implements the token revocation specification (RFC 7009).\ntoken\nthe token to revoke (required)\ntoken_type_hint\neither access_token or refresh_token (optional)\nPOST /connect/revocation HTTP/1.1 Host: server.example.com Content-Type: application/x-www-form-urlencoded Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW token=...\u0026amp;token_type_hint=refresh_token .NET client library You can use the IdentityModel client library to programmatically interact with the protocol endpoint from .NET code.\nusing IdentityModel.Client; var client = new HttpClient(); var result = await client.RevokeTokenAsync(new TokenRevocationRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/revocation\u0026#34;, ClientId = \u0026#34;client\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Token = token }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/quickstarts/4_ef/",
    "title": "Using EntityFramework Core for configuration and operational data",
    "tags": [],
    "description": "",
    "content": "Welcome to Quickstart 4 for Duende IdentityServer! In this quickstart you will move configuration and other temporary data into a database using Entity Framework.\nIn addition to the written steps below a YouTube video is available:\nWe recommend you do the quickstarts in order. If you\u0026rsquo;d like to start here, begin from a copy of the reference implementation of Quickstart 3. Throughout this quickstart, paths are written relative to the base quickstart directory created in part 1, which is the root directory of the reference implementation. You will also need to install the IdentityServer templates.\nIn the previous quickstarts, you configured clients and scopes with code. IdentityServer loaded this configuration data into memory on startup. Modifying the configuration required a restart. IdentityServer also generates temporary data, such as authorization codes, consent choices, and refresh tokens. Up to this point in the quickstarts, this data was also stored in memory.\nTo move this data into a database that is persistent between restarts and across multiple IdentityServer instances, you will use the Duende.IdentityServer.EntityFramework library.\nThis quickstart shows how to add Entity Framework support to IdentityServer manually. There is also a template that will create a new IdentityServer project with the EntityFramework integration already added: dotnet new isef.\nConfigure IdentityServer Install Duende.IdentityServer.EntityFramework IdentityServer\u0026rsquo;s Entity Framework integration is provided by the Duende.IdentityServer.EntityFramework NuGet package. Run the following commands from the src/IdentityServer directory to replace the Duende.IdentityServer package with it. Replacing packages prevents any dependency issues with version mismatches.\ndotnet remove package Duende.IdentityServer dotnet add package Duende.IdentityServer.EntityFramework Install Microsoft.EntityFrameworkCore.Sqlite Duende.IdentityServer.EntityFramework can be used with any Entity Framework database provider. In this quickstart, you will use Sqlite. To add Sqlite support to your IdentityServer project, install the Entity framework Sqlite NuGet package by running the following command from the src/IdentityServer directory:\ndotnet add package Microsoft.EntityFrameworkCore.Sqlite Configuring the Stores Duende.IdentityServer.EntityFramework stores configuration and operational data in separate stores, each with their own DbContext.\nConfigurationDbContext: used for configuration data such as clients, resources, and scopes PersistedGrantDbContext: used for dynamic operational data such as authorization codes and refresh tokens To use these stores, replace the existing calls to AddInMemoryClients, AddInMemoryIdentityResources, and AddInMemoryApiScopes in your ConfigureServices method in src/IdentityServer/HostingExtensions.cs with AddConfigurationStore and AddOperationalStore, like this:\npublic static WebApplication ConfigureServices(this WebApplicationBuilder builder) { builder.Services.AddRazorPages(); var migrationsAssembly = typeof(Program).Assembly.GetName().Name; const string connectionString = @\u0026#34;Data Source=Duende.IdentityServer.Quickstart.EntityFramework.db\u0026#34;; builder.Services.AddIdentityServer() .AddConfigurationStore(options =\u0026gt; { options.ConfigureDbContext = b =\u0026gt; b.UseSqlite(connectionString, sql =\u0026gt; sql.MigrationsAssembly(migrationsAssembly)); }) .AddOperationalStore(options =\u0026gt; { options.ConfigureDbContext = b =\u0026gt; b.UseSqlite(connectionString, sql =\u0026gt; sql.MigrationsAssembly(migrationsAssembly)); }) .AddTestUsers(TestUsers.Users); //... } You will use Entity Framework migrations later on in this quickstart to manage the database schema. The call to MigrationsAssembly(\u0026hellip;) tells Entity Framework that the host project will contain the migrations. This is necessary since the host project is in a different assembly than the one that contains the DbContext classes.\nManaging the Database Schema The Duende.IdentityServer.EntityFramework.Storage NuGet package (installed as a dependency of Duende.IdentityServer.EntityFramework) contains entity classes that map onto IdentityServer\u0026rsquo;s models. These entities are maintained in sync with IdentityServer\u0026rsquo;s models - when the models are changed in a new release, corresponding changes are made to the entities. As you use IdentityServer and upgrade over time, you are responsible for your database schema and changes necessary to that schema.\nOne approach for managing those changes is to use EF migrations, which is what this quickstart will use. If migrations are not your preference, then you can manage the schema changes in any way you see fit.\nAdding Migrations To create migrations, you will need to install the Entity Framework Core CLI tool on your machine and the Microsoft.EntityFrameworkCore.Design NuGet package in IdentityServer. Run the following commands from the src/IdentityServer directory:\ndotnet tool install --global dotnet-ef dotnet add package Microsoft.EntityFrameworkCore.Design Handle Expected Exception The Entity Framework CLI internally starts up IdentityServer for a short time in order to read your database configuration. After it has read the configuration, it shuts IdentityServer down by throwing a HostAbortedException exception. We expect this exception to be unhandled and therefore stop IdentityServer. Since it is expected, you do not need to log it as a fatal error. Update the error logging code in src/IdentityServer/Program.cs as follows:\n// See https://github.com/dotnet/runtime/issues/60600 re StopTheHostException catch (Exception ex) when (ex.GetType().Name is not \u0026#34;StopTheHostException\u0026#34;) { Log.Fatal(ex, \u0026#34;Unhandled exception\u0026#34;); } Now run the following two commands from the src/IdentityServer directory to create the migrations:\ndotnet ef migrations add InitialIdentityServerPersistedGrantDbMigration -c PersistedGrantDbContext -o Data/Migrations/IdentityServer/PersistedGrantDb dotnet ef migrations add InitialIdentityServerConfigurationDbMigration -c ConfigurationDbContext -o Data/Migrations/IdentityServer/ConfigurationDb You should now see a src/IdentityServer/Data/Migrations/IdentityServer directory in your project containing the code for your newly created migrations.\nInitializing the Database Now that you have the migrations, you can write code to create the database from them and seed the database with the same configuration data used in the previous quickstarts.\nThe approach used in this quickstart is used to make it easy to get IdentityServer up and running. You should devise your own database creation and maintenance strategy that is appropriate for your architecture.\nIn src/IdentityServer/HostingExtensions.cs, add this method to initialize the database:\nprivate static void InitializeDatabase(IApplicationBuilder app) { using (var serviceScope = app.ApplicationServices.GetService\u0026lt;IServiceScopeFactory\u0026gt;()!.CreateScope()) { serviceScope.ServiceProvider.GetRequiredService\u0026lt;PersistedGrantDbContext\u0026gt;().Database.Migrate(); var context = serviceScope.ServiceProvider.GetRequiredService\u0026lt;ConfigurationDbContext\u0026gt;(); context.Database.Migrate(); if (!context.Clients.Any()) { foreach (var client in Config.Clients) { context.Clients.Add(client.ToEntity()); } context.SaveChanges(); } if (!context.IdentityResources.Any()) { foreach (var resource in Config.IdentityResources) { context.IdentityResources.Add(resource.ToEntity()); } context.SaveChanges(); } if (!context.ApiScopes.Any()) { foreach (var resource in Config.ApiScopes) { context.ApiScopes.Add(resource.ToEntity()); } context.SaveChanges(); } } } Call InitializeDatabase from the ConfigurePipeline method:\npublic static WebApplication ConfigurePipeline(this WebApplication app) { app.UseSerilogRequestLogging(); if (app.Environment.IsDevelopment()) { app.UseDeveloperExceptionPage(); } InitializeDatabase(app); //... } Now if you run the IdentityServer project, the database should be created and seeded with the quickstart configuration data. You should be able to use a tool like SQL Lite Studio to connect and inspect the data.\nThe InitializeDatabase method is convenient way to seed the database, but this approach is not ideal to leave in to execute each time the application runs. Once your database is populated, consider removing the call to the API.\nRun the client applications You should now be able to run any of the existing client applications and sign-in, get tokens, and call the API \u0026ndash; all based upon the database configuration.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/endpoints/end_session/",
    "title": "End Session Endpoint",
    "tags": [],
    "description": "",
    "content": "The end session endpoint can be used to trigger single sign-out in the browser (see spec).\nTo use the end session endpoint a client application will redirect the user\u0026rsquo;s browser to the end session URL. All applications that the user has logged into via the browser during the user\u0026rsquo;s session can participate in the sign-out.\nThe URL for the end session endpoint is available via discovery.\nid_token_hint\nWhen the user is redirected to the endpoint, they will be prompted if they really want to sign-out. This prompt can be bypassed by a client sending the original id_token received from authentication. This is passed as a query string parameter called id_token_hint.\npost_logout_redirect_uri\nIf a valid id_token_hint is passed, then the client may also send a post_logout_redirect_uri parameter. This can be used to allow the user to redirect back to the client after sign-out. The value must match one of the client\u0026rsquo;s pre-configured PostLogoutRedirectUris.\nstate\nIf a valid post_logout_redirect_uri is passed, then the client may also send a state parameter. This will be returned back to the client as a query string parameter after the user redirects back to the client. This is typically used by clients to roundtrip state across the redirect.\nGET /connect/endsession?id_token_hint=...\u0026amp;post_logout_redirect_uri=http%3A%2F%2Flocalhost%3A7017%2Findex.html .NET client library You can use the IdentityModel client library to programmatically create end sessions request URLs from .NET code.\nvar ru = new RequestUrl(\u0026#34;https://demo.duendesoftware.com/connect/end_session\u0026#34;); var url = ru.CreateEndSessionUrl( idTokenHint: \u0026#34;...\u0026#34;, postLogoutRedirectUri: \u0026#34;...\u0026#34;); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/quickstarts/5_aspnetid/",
    "title": "Using ASP.NET Core Identity",
    "tags": [],
    "description": "",
    "content": "Welcome to Quickstart 5 for Duende IdentityServer! In this quickstart you will integrate IdentityServer with ASP.NET Core Identity.\nWe recommend you do the quickstarts in order. If you\u0026rsquo;d like to start here, begin from a copy of the reference implementation of Quickstart 4. Throughout this quickstart, paths are written relative to the base quickstart directory created in part 1, which is the root directory of the reference implementation. You will also need to install the IdentityServer templates.\nIdentityServer\u0026rsquo;s flexible design allows you to use any database you want to store users and their data, including password hashes, multi-factor authentication details, roles, claims, profile data, etc. If you are starting with a new user database, then ASP.NET Core Identity is one option you could choose. This quickstart shows how to use ASP.NET Core Identity with IdentityServer.\nThe approach this quickstart takes to using ASP.NET Core Identity is to create a new project for the IdentityServer host. This new project will replace the IdentityServer project you built up in the previous quickstarts. You will create a new project because it is a convenient way to get the UI assets that are needed to login and logout with ASP.NET Core Identity. All the other projects in this solution (for the clients and the API) will remain the same.\nThis quickstart assumes you are familiar with how ASP.NET Core Identity works. If you are not, it is recommended that you first learn about it.\nIn addition to the written steps below a YouTube video is available:\nNew Project for ASP.NET Core Identity The first step is to add a new project for ASP.NET Core Identity to your solution. We provide a template that contains the minimal UI assets needed to use ASP.NET Core Identity with IdentityServer. You will eventually delete the old project for IdentityServer, but there are some items that you will need to migrate over.\nStart by creating a new IdentityServer project that will use ASP.NET Core Identity. Run the following commands from the src directory:\ndotnet new isaspid -n IdentityServerAspNetIdentity cd .. dotnet sln add ./src/IdentityServerAspNetIdentity When prompted to \u0026ldquo;seed\u0026rdquo; the user database, choose \u0026ldquo;Y\u0026rdquo; for \u0026ldquo;yes\u0026rdquo;. This populates the user database with our \u0026ldquo;alice\u0026rdquo; and \u0026ldquo;bob\u0026rdquo; users. Their passwords are \u0026ldquo;Pass123$\u0026rdquo;.\nThe template uses Sqlite as the database for the users, and EF migrations are pre-created in the template. If you wish to use a different database provider, you will need to change the provider used in the code and re-create the EF migrations.\nInspect the new project Open the new project in the editor of your choice, and inspect the generated code. Much of it is the same from the prior quickstarts and templates. The following sections will describe some key differences and guide you through migrating configuration from the old IdentityServer Project, including:\nThe project file (IdentityServerAspNetIdentity.csproj) Pipeline and service configuration (HostingExtensions.cs) Resource and client configuration (Config.cs) Entry point and seed data (Program.cs and SeedData.cs) Login and logout pages (Pages in Pages/Account) IdentityServerAspNetIdentity.csproj Notice the reference to Duende.IdentityServer.AspNetIdentity. This NuGet package contains the ASP.NET Core Identity integration components for IdentityServer.\nHostingExtensions.cs In ConfigureServices notice the necessary AddDbContext() and AddIdentity\u0026lt;ApplicationUser, IdentityRole\u0026gt;() calls are done to configure ASP.NET Core Identity.\nAlso notice that much of the same IdentityServer configuration you did in the previous quickstarts is already done. The template uses the in-memory style for clients and resources, which are defined in Config.cs.\nFinally, notice the addition of the new call to AddAspNetIdentity(). AddAspNetIdentity() adds the integration layer to allow IdentityServer to access the user data for the ASP.NET Core Identity user database. This is needed when IdentityServer must add claims for the users into tokens.\nNote that AddIdentity\u0026lt;ApplicationUser, IdentityRole\u0026gt;() must be invoked before AddIdentityServer().\nConfig.cs Config.cs contains the hard-coded in-memory clients and resource definitions. To keep the same clients and API working as the prior quickstarts, we need to copy over the configuration data from the old IdentityServer project into this one. Do that now, and afterwards Config.cs should look like this:\npublic static class Config { public static IEnumerable\u0026lt;IdentityResource\u0026gt; IdentityResources =\u0026gt; new IdentityResource[] { new IdentityResources.OpenId(), new IdentityResources.Profile(), new IdentityResource() { Name = \u0026#34;verification\u0026#34;, UserClaims = new List\u0026lt;string\u0026gt; { JwtClaimTypes.Email, JwtClaimTypes.EmailVerified } } }; public static IEnumerable\u0026lt;ApiScope\u0026gt; ApiScopes =\u0026gt; new ApiScope[] { new ApiScope(name: \u0026#34;api1\u0026#34;, displayName: \u0026#34;My API\u0026#34;) }; public static IEnumerable\u0026lt;Client\u0026gt; Clients =\u0026gt; new Client[] { new Client { ClientId = \u0026#34;client\u0026#34;, // no interactive user, use the clientid/secret for authentication AllowedGrantTypes = GrantTypes.ClientCredentials, // secret for authentication ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, // scopes that client has access to AllowedScopes = { \u0026#34;api1\u0026#34; } }, // interactive ASP.NET Core Web App new Client { ClientId = \u0026#34;web\u0026#34;, ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, AllowedGrantTypes = GrantTypes.Code, // where to redirect to after login RedirectUris = { \u0026#34;https://localhost:5002/signin-oidc\u0026#34; }, // where to redirect to after logout PostLogoutRedirectUris = { \u0026#34;https://localhost:5002/signout-callback-oidc\u0026#34; }, AllowOfflineAccess = true, AllowedScopes = { IdentityServerConstants.StandardScopes.OpenId, IdentityServerConstants.StandardScopes.Profile, \u0026#34;verification\u0026#34;, \u0026#34;api1\u0026#34; } } }; } At this point, you no longer need the old IdentityServer project and can remove it from the solution. From the quickstart directory, run the following commands:\ndotnet sln remove ./src/IdentityServer rm -r ./src/IdentityServer Program.cs and SeedData.cs The application entry point in Program.cs is a little different than most ASP.NET Core projects. Notice that it looks for a command line argument called /seed which is used as a flag to seed the users in the ASP.NET Core Identity database. This seed process is invoked during template creation and already ran when you were prompted to seed the database.\nLook at the SeedData class\u0026rsquo; code to see how the database is created and the first users are created.\nAccount Pages Finally, take a look at the the pages in the src/IdentityServerAspNetIdentity/Pages/Account directory. These pages contain slightly different login and logout code than the prior quickstart and templates because the login and logout processes now rely on ASP.NET Core Identity. Notice the use of the SignInManager and UserManager types from ASP.NET Core Identity to validate credentials and manage the authentication session.\nMuch of the rest of the code is the same from the prior quickstarts and templates.\nLogging in with the Web client At this point, you should be able to run all of the existing clients and samples. Launch the Web client application, and you should be redirected to IdentityServer to log in. Login with one of the users created by the seed process (e.g., alice/Pass123$), and after that you will be redirected back to the Web client application where your user\u0026rsquo;s claims should be listed.\nYou should also be able to go to the call api page to invoke the API on behalf of the user:\nCongratulations, you\u0026rsquo;re using users from ASP.NET Core Identity in IdentityServer!\nAdding Custom Profile Data Next you will add a custom property to your user model and include it as a claim when the appropriate Identity Resource is requested.\nFirst, add a FavoriteColor property in src/IdentityServerAspNetIdentity/ApplicationUser.cs.\npublic class ApplicationUser : IdentityUser { public string FavoriteColor { get; set; } } Then, set the FavoriteColor of one of your test users in SeedData.cs\nalice = new ApplicationUser { UserName = \u0026#34;alice\u0026#34;, Email = \u0026#34;AliceSmith@email.com\u0026#34;, EmailConfirmed = true, FavoriteColor = \u0026#34;red\u0026#34;, }; In the same file, add code to recreate the database when you re-seed the data, by calling EnsureDeleted just before Migrate:\nvar context = scope.ServiceProvider.GetService\u0026lt;ApplicationDbContext\u0026gt;(); context.Database.EnsureDeleted(); context.Database.Migrate(); Caution: this will destroy your test users when you make changes to them. While that is convenient for this quickstart, it is not recommended in production!\nNext, create an ef migration for the CustomProfileData and reseed your user database. Run the following commands from the src/IdentityServerAspNetIdentity directory:\ndotnet ef migrations add CustomProfileData dotnet run /seed Now that you have more data in the database, you can use it to set claims. IdentityServer contains an extensibility point called the IProfileService that is responsible for retrieval of user claims. The ASP.NET Identity Integration includes an implementation of IProfileService that retrieves claims from ASP.NET Identity. You can extend that implementation to use the custom profile data as a source of claims data. See here for more details on the profile service.\nCreate a new file called src/IdentityServerAspNetIdentity/CustomProfileService.cs and add the following code to it:\nusing Duende.IdentityServer.AspNetIdentity; using Duende.IdentityServer.Models; using IdentityServerAspNetIdentity.Models; using Microsoft.AspNetCore.Identity; using System.Security.Claims; namespace IdentityServerAspNetIdentity { public class CustomProfileService : ProfileService\u0026lt;ApplicationUser\u0026gt; { public CustomProfileService(UserManager\u0026lt;ApplicationUser\u0026gt; userManager, IUserClaimsPrincipalFactory\u0026lt;ApplicationUser\u0026gt; claimsFactory) : base(userManager, claimsFactory) { } protected override async Task GetProfileDataAsync(ProfileDataRequestContext context, ApplicationUser user) { var principal = await GetUserClaimsAsync(user); var id = (ClaimsIdentity)principal.Identity; if (!string.IsNullOrEmpty(user.FavoriteColor)) { id.AddClaim(new Claim(\u0026#34;favorite_color\u0026#34;, user.FavoriteColor)); } context.AddRequestedClaims(principal.Claims); } } } Register the CustomProfileService in HostingExtensions.cs:\nbuilder.Services .AddIdentityServer(options =\u0026gt; { // ... }) .AddInMemoryIdentityResources(Config.IdentityResources) .AddInMemoryApiScopes(Config.ApiScopes) .AddInMemoryClients(Config.Clients) .AddAspNetIdentity\u0026lt;ApplicationUser\u0026gt;() .AddProfileService\u0026lt;CustomProfileService\u0026gt;(); Finally, you need to configure your application to make a request for the favorite_color, and include that claim in your client\u0026rsquo;s configuration.\nAdd a new IdentityResource in src/IdentityServerAspNetIdentity/Config.cs that will map the color scope onto the favorite_color claim type:\npublic static IEnumerable\u0026lt;IdentityResource\u0026gt; IdentityResources =\u0026gt; new IdentityResource[] { // ... new IdentityResource(\u0026#34;color\u0026#34;, new [] { \u0026#34;favorite_color\u0026#34; }) }; Allow the web client to request the color scope (also in Config.cs):\nnew Client { ClientId = \u0026#34;web\u0026#34;, // ... AllowedScopes = new List\u0026lt;string\u0026gt; { IdentityServerConstants.StandardScopes.OpenId, IdentityServerConstants.StandardScopes.Profile, \u0026#34;api1\u0026#34;, \u0026#34;color\u0026#34; } } Finally, update the WebClient project so that it will request the color scope. In its src/WebClient/Program.cs file, add the color scope to the requested scopes, and add a claim action to map the favorite_color into the principal:\n.AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { // ... options.Scope.Clear(); options.Scope.Add(\u0026#34;openid\u0026#34;); options.Scope.Add(\u0026#34;profile\u0026#34;); options.Scope.Add(\u0026#34;offline_access\u0026#34;); options.Scope.Add(\u0026#34;api1\u0026#34;); options.Scope.Add(\u0026#34;color\u0026#34;); options.GetClaimsFromUserInfoEndpoint = true; options.ClaimActions.MapUniqueJsonKey(\u0026#34;favorite_color\u0026#34;, \u0026#34;favorite_color\u0026#34;); }); Now restart the IdentityServerAspNetIdentity and WebClient projects, sign out and sign back in as alice, and you should see the favorite color claim.\nWhat\u0026rsquo;s Missing? The rest of the code in this template is similar to the other quickstarts and templates we provide. You will notice that this template does not include UI code for user registration, password reset, and other things you might expect from Microsoft\u0026rsquo;s templates that include ASP.NET Core Identity.\nGiven the variety of requirements and different approaches to using ASP.NET Core Identity, our template deliberately does not provide those features. The intent of this template is to be a starting point to which you can add the features you need from ASP.NET Core Identity, customized according to your requirements. Alternatively, you can create a new project based on the ASP.NET Core Identity template and add the IdentityServer features you have learned about in these quickstarts to that project. With that approach, you may need to configure IdentityServer so that it knows the paths to pages for user interactions. Set the LoginUrl, LogoutUrl, ConsentUrl, ErrorUrl, and DeviceVerificationUrl as needed in your IdentityServerOptions.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/endpoints/device_authorization/",
    "title": "Device Authorization Endpoint",
    "tags": [],
    "description": "",
    "content": "The device authorization endpoint can be used to request device and user codes. This endpoint is used to start the device flow authorization process.\nclient_id\nclient identifier (required)\nclient_secret\nclient secret either in the post body, or as a basic authentication header. Optional.\nscope\none or more registered scopes. If not specified, a token for all explicitly allowed scopes will be issued\nPOST /connect/deviceauthorization client_id=client1\u0026amp; client_secret=secret\u0026amp; scope=openid api1 .NET client library You can use the IdentityModel client library to programmatically interact with the protocol endpoint from .NET code.\nusing IdentityModel.Client; var client = new HttpClient(); var response = await client.RequestDeviceAuthorizationAsync(new DeviceAuthorizationRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/device_authorize\u0026#34;, ClientId = \u0026#34;device\u0026#34; }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/endpoints/ciba/",
    "title": "Backchannel Authentication Endpoint",
    "tags": [],
    "description": "",
    "content": "The backchannel authentication endpoint is used by a client to initiate a CIBA request.\nClients must be configured with the \u0026ldquo;urn:openid:params:grant-type:ciba\u0026rdquo; grant type to use this endpoint. You can use the OidcConstants.GrantTypes.Ciba constant rather than hard coding the value for the CIBA grant type.\nRequired parameters scope\none or more registered scopes\nThe client id and a client credential is required to authenticate to the endpoint using any valid form of authentication that has been configured for it (much like the token endpoint).\nExactly one of these values is required login_hint\nhint for the end user to be authenticated. the value used is implementation specific.\nid_token_hint\na previously issued id_token for the end user to be authenticated\nlogin_hint_token\na token containing information for the end user to be authenticated. the details are implementation specific.\nTo validate these implementation specific values and use them to identity the user that is to be authenticated, you are required to implement the IBackchannelAuthenticationUserValidator interface.\nOptional parameters binding_message\nidentifier or message intended to be displayed on both the consumption device and the authentication device\nuser_code\na secret code, such as a password or pin, that is known only to the user but verifiable by the OP\nrequested_expiry\na positive integer allowing the client to request the expires_in value for the auth_req_id the server will return. if not present, then the optional CibaLifetime property on the Client is used, and if that is not present, then the DefaultLifetime on the CibaOptions will be used.\nacr_values\nallows passing in additional authentication related information - IdentityServer special cases the following proprietary acr_values:\nidp:name_of_idp\nbypasses the login/home realm screen and forwards the user directly to the selected identity provider (if allowed per client configuration)\ntenant:name_of_tenant\ncan be used to pass a tenant name to the login UI\nresource\nresource indicator identifying the ApiResource for which the access token should be restricted to\nrequest\ninstead of providing all parameters as individual parameters, you can provide all of them as a JWT\nPOST /connect/ciba client_id=client1\u0026amp; client_secret=secret\u0026amp; scope=openid api1\u0026amp; login_hint=alice And a successful response will look something like:\nHTTP/1.1 200 OK Content-Type: application/json Cache-Control: no-store { \u0026#34;auth_req_id\u0026#34;: \u0026#34;1C266114A1BE42528AD104986C5B9AC1\u0026#34;, \u0026#34;expires_in\u0026#34;: 600, \u0026#34;interval\u0026#34;: 5 } .NET client library You can use the IdentityModel client library to programmatically interact with the protocol endpoint from .NET code.\nusing IdentityModel.Client; var client = new HttpClient(); var cibaResponse = await client.RequestBackchannelAuthenticationAsync(new BackchannelAuthenticationRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/ciba\u0026#34;, ClientId = \u0026#34;client1\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Scope = \u0026#34;openid api1\u0026#34;, LoginHint = \u0026#34;alice\u0026#34;, }); And with a successful response, it can be used to poll the token endpoint:\nwhile (true) { var response = await client.RequestBackchannelAuthenticationTokenAsync(new BackchannelAuthenticationTokenRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/token\u0026#34;, ClientId = \u0026#34;client1\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, AuthenticationRequestId = cibaResponse.AuthenticationRequestId }); if (response.IsError) { if (response.Error == OidcConstants.TokenErrors.AuthorizationPending || response.Error == OidcConstants.TokenErrors.SlowDown) { await Task.Delay(cibaResponse.Interval.Value * 1000); } else { throw new Exception(response.Error); } } else { // success! use response.IdentityToken, response.AccessToken, and response.RefreshToken (if requested) } } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/samples/basics/",
    "title": "Basics",
    "tags": [],
    "description": "",
    "content": "This solution contains a collection of common scenarios.\nClient Credentials This sample shows how to use the client_credentials grant type. This is typically used for machine to machine communication.\nKey takeaways:\nhow to request a token using client credentials how to use a shared secret how to use access token link to source code\nJWT-based Client Authentication This sample shows how to use the client_credentials grant type with JWT-based client authentication. This authentication method is more recommended than shared secrets.\nKey takeaways:\ncreate a JWT for client authentication use a JWT as a client secret replacement configure IdentityServer to accept a JWT as a client secret link to source code\nIntrospection \u0026amp; Reference Tokens This sample shows how to use the reference tokens instead of JWTs.\nThings of interest:\nthe client registration uses AccessTokenType of value Reference the client requests scope2 - this scope is part of an API resource. API resources allow defining API secrets, which can then be used to access the introspection endpoint The API supports both JWT and reference tokens, this is achieved by forwarding the token to the right handler at runtime Key takeaways:\nconfiguring a client to receive reference tokens setup an API resource with an API secret configure an API to accept and validate reference tokens link to source code\nMVC Client Sample This sample shows how to use the authorization_code grant type. This is typically used for interactive applications like web applications.\nKey takeaways:\nconfigure an MVC client to use IdentityServer access tokens in ASP.NET Core\u0026rsquo;s authentication session call an API manually refresh tokens link to source code\nMVC Client with automatic Access Token Management This sample shows how to use Duende.AccessTokenManagement to automatically manage access tokens.\nThe sample uses a special client in the sample IdentityServer with a short token lifetime (75 seconds). When repeating the API call, make sure you inspect the returned iat and exp claims to observer how the token is slides.\nYou can also turn on debug tracing to get more insights in the token management library.\nKey takeaways:\nuse Duende.AccessTokenManagement to automate refreshing tokens link to source code\nMVC Client with JAR and JWT-based Authentication This sample shows how to use signed authorize requests, and JWT-based authentication for clients in MVC. It also show how to integrate that technique with automatic token management.\nKey takeaways:\nuse the ASP.NET Core extensibility points to add signed authorize requests and JWT-based authentication use JWT-based authentication for automatic token management configure a client in IdentityServer to share key material for both front- and back-channel link to source code\nMVC Client with Back-Channel Logout Notifications This sample shows how to use back-channel logout notifications.\nKey takeaways:\nhow to implement the back-channel notification endpoint how to leverage events on the cookie handler to invalidate the user session link to source code\nMVC Client with Pushed Authorization Requests This sample shows how to use Pushed Authorization Requests (PAR).\nKey takeaways:\nhow to enable PAR in the client configuration how to add support for PAR to the ASP.NET OIDC authentication handler. The main idea is to use the events in the handler to push the parameters before redirecting to the authorize endpoint, and then replace the parameters that would normally be sent in that redirect with the resulting request uri. See the ParOidcEvents.cs file for more details. link to source code\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/fundamentals/resources/identity/",
    "title": "Identity Resources",
    "tags": [],
    "description": "",
    "content": "An identity resource is a named group of claims about a user that can be requested using the scope parameter.\nThe OpenID Connect specification suggests a couple of standard scope name to claim type mappings that might be useful to you for inspiration, but you can freely design them yourself.\nOne of them is actually mandatory, the openid scope, which tells the provider to return the sub (subject id) claim in the identity token.\nThis is how you could define the openid scope in code:\npublic static IEnumerable\u0026lt;IdentityResource\u0026gt; GetIdentityResources() { return new List\u0026lt;IdentityResource\u0026gt; { new IdentityResource( name: \u0026#34;openid\u0026#34;, userClaims: new[] { \u0026#34;sub\u0026#34; }, displayName: \u0026#34;Your user identifier\u0026#34;) }; } But since this is one of the standard scopes from the spec you can shorten that to:\npublic static IEnumerable\u0026lt;IdentityResource\u0026gt; GetIdentityResources() { return new List\u0026lt;IdentityResource\u0026gt; { new IdentityResources.OpenId() }; } See the reference section for more information on IdentityResource.\nThe following example shows a custom identity resource called profile that represents the display name, email address and website claim:\npublic static IEnumerable\u0026lt;IdentityResource\u0026gt; GetIdentityResources() { return new List\u0026lt;IdentityResource\u0026gt; { new IdentityResource( name: \u0026#34;profile\u0026#34;, userClaims: new[] { \u0026#34;name\u0026#34;, \u0026#34;email\u0026#34;, \u0026#34;website\u0026#34; }, displayName: \u0026#34;Your profile data\u0026#34;) }; } Once the resource is defined, you can give access to it to a client via the AllowedScopes option (other properties omitted):\nvar client = new Client { ClientId = \u0026#34;client\u0026#34;, AllowedScopes = { \u0026#34;openid\u0026#34;, \u0026#34;profile\u0026#34; } }; See the reference section for more information on the Client class.\nThe client can then request the resource using the scope parameter (other parameters omitted):\nhttps://demo.duendesoftware.com/connect/authorize?client_id=client\u0026amp;scope=openid profile IdentityServer will then use the scope names to create a list of requested claim types, and present that to your implementation of the profile service.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/diagnostics/logging/",
    "title": "Logging",
    "tags": [],
    "description": "",
    "content": "Duende IdentityServer uses the standard logging facilities provided by ASP.NET Core. You don\u0026rsquo;t need to do any extra configuration.\nThe Microsoft documentation has a good intro and a description of the built-in logging providers.\nWe are roughly following the Microsoft guidelines for usage of log levels:\nTrace\nFor information that is valuable only to a developer troubleshooting an issue. These messages may contain sensitive application data like tokens and should not be enabled in a production environment.\nDebug\nFor following the internal flow and understanding why certain decisions are made. Has short-term usefulness during development and debugging.\nInformation\nFor tracking the general flow of the application. These logs typically have some long-term value.\nWarning\nFor abnormal or unexpected events in the application flow. These may include errors or other conditions that do not cause the application to stop, but which may need to be investigated.\nError\nFor errors and exceptions that cannot be handled. Examples: failed validation of a protocol request.\nCritical\nFor failures that require immediate attention. Examples: missing store implementation, invalid key material\u0026hellip;\nIn production, logging might produce too much data. It is recommended you either turn it off, or default to the Warning level. Have a look at events for more high-level production instrumentation.\nSetup for Serilog We personally like Serilog and the Serilog.AspNetCore package a lot. Give it a try:\n//Program.cs Activity.DefaultIdFormat = ActivityIdFormat.W3C; Log.Logger = new LoggerConfiguration() .MinimumLevel.Debug() .MinimumLevel.Override(\u0026#34;Microsoft\u0026#34;, LogEventLevel.Warning) .MinimumLevel.Override(\u0026#34;Microsoft.Hosting.Lifetime\u0026#34;, LogEventLevel.Information) .MinimumLevel.Override(\u0026#34;System\u0026#34;, LogEventLevel.Warning) .MinimumLevel.Override(\u0026#34;Microsoft.AspNetCore.Authentication\u0026#34;, LogEventLevel.Information) .Enrich.FromLogContext() .WriteTo.Console(outputTemplate: \u0026#34;[{Timestamp:HH:mm:ss} {Level}] {SourceContext}{NewLine}{Message:lj}{NewLine}{Exception}{NewLine}\u0026#34;, theme: AnsiConsoleTheme.Code) .CreateLogger(); builder.Logging.AddSeriLog(); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/diagnostics/otel/metrics/",
    "title": "Metrics",
    "tags": [],
    "description": "",
    "content": "(added in v7.0)\nOpenTelemetry metrics are run-time measurements that are are intended to provide an indication of overall health and are typically used to show graphs on a dashboard or to set up monitoring rules. When that monitoring reveals issues, traces and logs are used to investigate further. Open Telemetry monitoring tools often provide features to find the traces and logs corresponding to certain metrics.\nIdentityServer emits metrics from the IdentityServer middleware and services. Our quick start for the UI also contains metrics that can be used as a starting point for monitoring UI events. The metric counters that IdentityServer emits are designed to not contain any sensitive information. They often are tagged to indicate the source of the events.\nHigh level Metrics These metrics are instrumented by the IdentityServer middleware and services and are intended to describe the overall usage and health of the system. They could provide the starting point for building a metrics dashboard. The high level metrics are created by the the meter named \u0026ldquo;Duende.IdentityServer\u0026rdquo;, which is the value of the Duende.IdentityServer.Telemetry.ServiceName constant.\nTelemetry.Metrics.Counters.Operation Counter name: tokenservice.operation\nAggregated counter of failed and successful operations. The result tag indicates if an operation succeeded, failed, or caused an internal error. It is expected to have some failures during normal operations. In contrast, operations tagged with a result of internal_error are abnormal and indicate an unhandled exception. The error/success ratio can be used as a very high level health metric.\nTag Description error Error label on errors result Success, error or internal_error client Id of client requesting the operation. May be empty. Telemetry.Metrics.Counters.ActiveRequests Counter name: active_requests\nGauge/up-down counter that shows current active requests that are processed by any IdentityServer endpoint. Note that the pages in the user interface are not IdentityServer endpoints and are not included in this count.\nTag Description endpoint The type name for the endpoint processor path The path of the request Detailed Metrics - Experimental These detailed metrics are instrumented by the IdentityServer middleware and services and track usage of specific flows and features. These metrics are created by the meter named \u0026ldquo;Duende.IdentityServer.Experimental\u0026rdquo;, which is the value of the Duende.IdentityServer.Telemetry.ServiceName.Experimental constant. The definition and tags of these counters may be changed between releases. Once the counters and tags are considered stable they will be moved to the Duende.IdentityServer.Telemetry.ServiceName meter.\nTelemetry.Metrics.Counters.ApiSecretValidation Counter name: tokenservice.api.secret_validation\nNumber of successful/failed validations of API Secrets.\nTag Description api The Api Id auth_method Authentication method used error Error label on errors Telemetry.Metrics.Counters.BackchannelAuthentication Counter name: tokenservice.backchannel_authentication\nNumber of successful/failed back channel authentications (CIBA).\nTag Description client The client Id error Error label on errors Telemetry.Metrics.Counters.ClientConfigValidation Counter name: tokenservice.client.config_validation\nNumber of successful/failed client validations.\nTag Description client The client Id error Error label on errors Telemetry.Metrics.Counters.ClientSecretValidation Counter name: tokenservice.client.secret_validation\nNumber of successful/failed client secret validations.\nTag Description client The client Id auth_method The authentication method on success error Error label on errors Telemetry.Metrics.Counters.DeviceAuthentication Counter name: tokenservice.device_authentication\nNumber of successful/failed device authentications.\nTag Description client The client Id error Error label on errors Telemetry.Metrics.Counters.DynamicIdentityProviderValidation Counter name: tokenservice.dynamic_identityprovider.validation\nNumber of successful/failed validations of dynamic identity providers.\nTag Description scheme The scheme name of the provider error Error label on errors Telemetry.Metrics.Counters.Introspection Counter name: tokenservice.introspection\nNumber of successful/failed token introspections.\nTag Description caller The caller of the endpoint, a client id or api id. active Was the token active? Only sent on success error Error label on errors Telemetry.Metrics.Counters.PushedAuthorizationRequest Counter name: tokenservice.pushed_authorization_request\nNumber of successful/failed pushed authorization requests.\nTag Description client The client Id error Error label on errors Telemetry.Metrics.Counters.ResourceOwnerAuthentication Counter name: tokenservice.resourceowner_authentication\nNumber of successful/failed resource owner authentications.\nTag Description client The client Id error Error label on errors Telemetry.Metrics.Counters.Revocation Counter name: tokenservice.revocation\nNumber of successful/failed token revocations.\nTag Description client The client Id error Error label on errors Telemetry.Metrics.Counters.TokenIssued Counter name: tokenservice.token_issued\nNumber of successful/failed token issuance attempts. Note that a token issuance might include multiple actual tokens (id_token, access token, refresh token).\nTag Description client The client Id grant_type The grant type used authorize_request_type The authorize request type, if information about it is available error Error label on errors Metrics in the UI The UI in your IdentityServer host can instrument these events to measure activities that occur during interactive flows, such as user login and logout. These events are not instrumented by the IdentityServer middleware or services because they are the responsibility of the UI. Our templated UI does instrument these events, and you can alter and add metrics as needed to the UI in your context.\nTelemetry.Metrics.Counters.Consent Counter name: tokenservice.consent\nConsent requests granted or denied. The counters are per scope, so if a user consents to multiple scopes, the counter is increased multiple times, one for each scope. This allows the scope name to be included as a tag without causing an explosion of combination of tags.\nTag Description client The client Id scope The scope names consent granted or denied Telemetry.Metrics.Counters.GrantsRevoked Counter name: tokenservice.grants_revoked\nRevocation of grants.\nTag Description client The client Id, if grants are revoked only for one client. If not set, the revocation was for all clients. Telemetry.Metrics.Counters.UserLogin Counter names: tokenservice.user_login\nSuccessful and failed user logins.\nTag Description client The client Id, if the login was caused by a request from a client idp The idp (Asp.Net Core Scheme name) used to log in error Error label on errors Telemetry.Metrics.Counters.UserLogout Counter name: user_logout\nUser logout. Note that this is only raised on explicit user logout, not if the session times out. The number of logouts will typically be lower than the number of logins.\nTag Description idp The idp (ASP.NET scheme name) logging out from "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/deployment/proxies/",
    "title": "Proxy Servers and Load Balancers",
    "tags": [],
    "description": "",
    "content": "In typical deployments, your IdentityServer will be hosted behind a load balancer or reverse proxy. These and other network appliances often obscure information about the request before it reaches the host. Some of the behavior of IdentityServer and the ASP.NET authentication handlers depend on that information, most notably the scheme (HTTP vs HTTPS) of the request and the originating client IP address.\nRequests to your IdentityServer that come through a proxy will appear to come from that proxy instead of its true source on the Internet or corporate network. If the proxy performs TLS termination (that is, HTTPS requests are proxied over HTTP), the original HTTPS scheme will also no longer be present in the proxied request. Then, when the IdentityServer middleware and the ASP.NET authentication middleware process these requests, they will have incorrect values for the scheme and originating IP address.\nCommon symptoms of this problem are\nHTTPS requests get downgraded to HTTP Host names are incorrect in the discovery document or on redirect Cookies are not sent with the secure attribute, which can especially cause problems with the samesite cookie attribute. In almost all cases, these problems can be solved by adding the ASP.NET ForwardedHeaders middleware to your pipeline. Most network infrastructure that proxies requests will set the X-Forwarded-For and X-Forwarded-Proto HTTP headers to describe the original request\u0026rsquo;s IP address and scheme.\nThe ForwardedHeaders middleware reads the information in these headers on incoming requests and makes it available to the rest of the ASP.NET pipeline by updating the HttpContext.HttpRequest. This transformation should be done early in the pipeline, certainly before the IdentityServer middleware and ASP.NET authentication middleware process requests, so that the presence of a proxy is abstracted away first.\nThe appropriate configuration for the forwarded headers middleware depends on your environment. In general, you need to configure which headers it should respect, the IP address or IP address range of your proxy, and the number of proxies you expect (when there are multiple proxies, each one is captured in the X-Forwarded-* headers).\nThere are two ways to configure this middleware:\nEnable the environment variable ASPNETCORE_FORWARDEDHEADERS_ENABLED. This is the simplest option, but doesn\u0026rsquo;t give you as much control. It automatically adds the forwarded headers middleware to the pipeline, and configures it to accept forwarded headers from any single proxy, respecting the X-Forwarded-For and X-Forwarded-Proto headers. This is often the right choice for cloud hosted environments and Kubernetes clusters. Configure the ForwardedHeadersOptions in DI, and use the ForwardedHeaders middleware explicitly in your pipeline. The advantage of configuring the middleware explicitly is that you can configure it in a way that is appropriate for your environment, if the defaults used by ASPNETCORE_FORWARDEDHEADERS_ENABLED are not what you need. Most notably, you can use the KnownNetworks or KnownProxies options to only accept headers sent by a known proxy, and you can set the ForwardLimit to allow for multiple proxies in front of your IdentityServer. This is often the right choice when you have more complex proxying going on, or if your proxy has a stable IP address. In a client codebase operating behind a proxy, you\u0026rsquo;ll need to configure the ForwardedHeadersOptions. Be sure to correctly set values for KnownNetworks and KnownProxies for your production environments. By default, KnownNetworks and KnownProxies support localhost with values of 127.0.0.1 and ::1 respectively. This is useful (and secure!) for local development environments and for solutions where the reverse proxy and the .NET web host runs on the same machine.\nbuilder.Services.Configure\u0026lt;ForwardedHeadersOptions\u0026gt;(options =\u0026gt; { // you may need to change these ForwardedHeaders // values based on your network architecture options.ForwardedHeaders = ForwardedHeaders.XForwardedHost | ForwardedHeaders.XForwardedProto; // exact Addresses of known proxies to accept forwarded headers from. options.KnownProxies.Add(IPAddress.Parse(\u0026#34;203.0.113.42\u0026#34;); // \u0026lt;-- change this value to the IP Address of the proxy // if the proxies could use any address from a block, that can be configured too: // var network = new IPNetwork(IPAddress.Parse(\u0026#34;198.51.100.0\u0026#34;), 24); // options.KnownNetworks.Add(network); // default is 1 options.ForwardLimit = 1; }); Please consult the Microsoft documentation for more details.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/tokens/requesting/",
    "title": "Requesting a Token",
    "tags": [],
    "description": "Overview",
    "content": "A typical architecture is composed of two application (aka client) types - machine to machine calls and interactive applications.\nMachine to Machine communication In this scenario a headless application with no interactive user (e.g. a server daemon, batch job etc.) wants to call an API.\nPrerequisites are:\ndefine a client for the client credentials grant type define an API scope (and optionally a resource) grant the client access to the scope via the AllowedScopes property According to the OAuth specification, you request a token by posting to the token endpoint:\nPOST /connect/token CONTENT-TYPE application/x-www-form-urlencoded client_id=client1\u0026amp; client_secret=secret\u0026amp; grant_type=client_credentials\u0026amp; scope=scope1 In the success case, this will return a JSON response containing the access token:\nHTTP/1.1 200 OK Content-Type: application/json;charset=UTF-8 Cache-Control: no-store Pragma: no-cache { \u0026#34;access_token\u0026#34;: \u0026#34;2YotnFZFEjr1zCsicMWpAA\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;bearer\u0026#34;, \u0026#34;expires_in\u0026#34;: 3600, } .NET client library In .NET you can leverage the IdentityModel client library to request tokens.\nThe above token request would look like this in C#:\nusing IdentityModel.Client; var client = new HttpClient(); var response = await client.RequestClientCredentialsTokenAsync(new ClientCredentialsTokenRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/token\u0026#34;, ClientId = \u0026#34;m2m\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Scope = \u0026#34;api\u0026#34; }); Automating token requests in ASP.NET Core and Worker applications The Duende.AccessTokenManagement library can automate client credential request and token lifetime management for you.\nUsing this library, you only need to register the token client in DI:\nbuilder.Services.AddAccessTokenManagement(options =\u0026gt; { options.Client.Clients.Add(\u0026#34;client\u0026#34;, new ClientCredentialsTokenRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/token\u0026#34;, ClientId = \u0026#34;m2m\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Scope = \u0026#34;api\u0026#34; }); }); You can then add token management to an HTTP-factory provided client:\nbuilder.Services.AddClientAccessTokenClient(\u0026#34;client\u0026#34;, configureClient: client =\u0026gt; { client.BaseAddress = new Uri(\u0026#34;https://demo.duendesoftware.com/api/\u0026#34;); }); \u0026hellip;and finally use the client with automatic token management in your application code:\npublic class DataController : Controller { IHttpClientFactory _factory; public DataController(IHttpClientFactory factory) { _factory = factory; } public IActionResult Index() { var client = _factory.CreateClient(\u0026#34;client\u0026#34;); // rest omitted } } Interactive applications In this scenario, an interactive application like a web application or mobile/desktop app wants to call an API in the context of an authenticated user (see spec here).\nYou will receive three tokens - an identity token containing details about the end-user authentication, the access token to call the API, and a refresh token for access token lifetime management. The access token will also contain some information about the end-user (e.g. the user ID), so that the API can do authorization based on the user\u0026rsquo;s identity.\nIn this scenario you typically use the authorization code flow which first involves a call to the authorize endpoint for all human interactions (e.g. login and/or consent). This returns a code, which you then redeem at the token endpoint to retrieve identity and access tokens.\nPrerequisites are:\ndefine a client for the authorization code grant type define an identity resource, e.g. openid define an API scope (and optionally a resource) grant the client access to both scopes via the AllowedScopes property Front-channel The call to the authorize endpoint is done using a redirect in the browser:\nGET /connect/authorize? client_id=client1\u0026amp; scope=openid api1\u0026amp; response_type=code\u0026amp; redirect_uri=https://myapp/callback\u0026amp; On success, the browser will ultimately redirect to the callback endpoint transmitting the authorization code (and other parameters like the granted scopes):\nGET /callback? code=abc\u0026amp; scope=openid api1 Back-channel The client then opens a back-channel communication to the token service to retrieve the tokens:\nPOST /connect/token CONTENT-TYPE application/x-www-form-urlencoded client_id=client1\u0026amp; client_secret=secret\u0026amp; grant_type=authorization_code\u0026amp; code=abc\u0026amp; redirect_uri=https://myapp/callback In this scenario, the token response will contain three tokens:\nHTTP/1.1 200 OK Content-Type: application/json;charset=UTF-8 Cache-Control: no-store Pragma: no-cache { \u0026#34;id_token\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;access_token\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;refresh_token\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;bearer\u0026#34;, \u0026#34;expires_in\u0026#34;: 3600, } See the refresh token section for more information on how to deal with refresh tokens.\n.NET client library The most common client library for .NET is the OpenID Connect authentication handler for ASP.NET Core. This library handles the complete front- and back-channel interaction and coordination.\nYou only need to configure it in your startup code:\nbuilder.Services.AddAuthentication(options =\u0026gt; { options.DefaultScheme = \u0026#34;cookie\u0026#34;; options.DefaultChallengeScheme = \u0026#34;duende\u0026#34;; }) .AddCookie(\u0026#34;cookie\u0026#34;) .AddOpenIdConnect(\u0026#34;duende\u0026#34;, \u0026#34;IdentityServer\u0026#34;, options =\u0026gt; { options.Authority = \u0026#34;https://demo.duendesoftware.com\u0026#34;; options.ClientId = \u0026#34;interactive.confidential\u0026#34;; options.ResponseType = \u0026#34;code\u0026#34;; options.ResponseMode = \u0026#34;query\u0026#34;; options.SaveTokens = true; options.Scope.Clear(); options.Scope.Add(\u0026#34;openid\u0026#34;); options.Scope.Add(\u0026#34;api\u0026#34;); options.Scope.Add(\u0026#34;offline_access\u0026#34;); options.TokenValidationParameters = new TokenValidationParameters { NameClaimType = \u0026#34;name\u0026#34;, RoleClaimType = \u0026#34;role\u0026#34; }; // Disable x-client-SKU and x-client-ver headers options.DisableTelemetry = true; }); Automating token management in ASP.NET Core The Duende.AccessTokenManagement library can also be used to automate token lifetime management in ASP.NET Core applications for you.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/tokens/authentication/shared_secret/",
    "title": "Shared Secrets",
    "tags": [],
    "description": "",
    "content": "Shared secrets is by far the most common technique for authenticating clients.\nFrom a security point of view they have some shortcomings\nthe shared secrets must be transmitted over the network during authentication they should not be persisted in clear text to reduce the risk of leaking them they should have high entropy to avoid brute-force attacks The following creates a shared secret:\n// loadSecret is responsible for loading a SHA256 or SHA512 hash of a good, // high-entropy secret from a secure storage location var hash = loadSecretHash(); var secret = new Secret(hash); IdentityServer\u0026rsquo;s Secrets are designed to operate on either a SHA256 or SHA512 hash of the shared secret. The shared secret is not stored in IdentityServer - only the hash. The client on the hand needs access to the clear text of the secret. It must send the clear text to authenticate itself.\nIdentityServer provides the Sha256 and Sha512 extension methods on strings as a convenience to produce their hashes. These extension methods can be used when prototyping or during demos to get started quickly. However, the clear text of secrets used in production should never be written down in your source code. Anyone with access to the repository can see the secret.\nvar compromisedSecret = new Secret(\u0026#34;just for demos, not prod!\u0026#34;.Sha256()); Authentication using a shared secret You can either send the client id/secret combination as part of the POST body::\nPOST /connect/token Content-type: application/x-www-form-urlencoded client_id=client\u0026amp; client_secret=secret\u0026amp; grant_type=authorization_code\u0026amp; code=hdh922\u0026amp; redirect_uri=https://myapp.com/callback ..or as a basic authentication header::\nPOST /connect/token Content-type: application/x-www-form-urlencoded Authorization: Basic xxxxx grant_type=authorization_code\u0026amp; code=hdh922\u0026amp; redirect_uri=https://myapp.com/callback .NET client library You can use the IdentityModel client library to programmatically interact with the protocol endpoint from .NET code.\nusing IdentityModel.Client; var client = new HttpClient(); var response = await client.RequestAuthorizationCodeTokenAsync(new AuthorizationCodeTokenRequest { Address = TokenEndpoint, ClientId = \u0026#34;client\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Code = \u0026#34;...\u0026#34;, CodeVerifier = \u0026#34;...\u0026#34;, RedirectUri = \u0026#34;https://app.com/callback\u0026#34; }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/overview/terminology/",
    "title": "Terminology",
    "tags": [],
    "description": "",
    "content": "The specs, documentation and object model use a certain terminology that you should be aware of.\nDuende IdentityServer Duende IdentityServer is an OpenID Connect \u0026amp; OAuth engine - it implements the OpenID Connect and OAuth 2.0 family of protocols.\nDifferent literature uses different terms for the same role - you probably also find the terms security token service, identity provider, authorization server, IP-STS and more.\nBut they are in a nutshell all the same: a piece of software that issues security tokens to clients.\nA typical implementation of Duende IdentityServer has a number of jobs and features - including:\nmanage access to resources authenticate users using a local account store or via an external identity provider provide session management and single sign-on manage and authenticate clients issue identity and access tokens to clients User A user is a human that is using a registered client to access resources.\nClient A client is a piece of software that requests tokens from your IdentityServer - either for authenticating a user (requesting an identity token) or for accessing a resource (requesting an access token). A client must be first registered with your IdentityServer before it can request tokens.\nWhile there are many different client types, e.g. web applications, native mobile or desktop applications, SPAs, server processes etc., they can all be put into two high-level categories.\nMachine to Machine Communication In this scenario two machines talk to each other (e.g. background processes, batch jobs, server daemons), and there is no interactive user present. To authorize this communication, your IdentityServer issues a token to the caller.\nIn protocol terms, this scenario is called Client Credentials Flow and you can learn more about it in the issuing tokens section as well as in our Quickstart.\nInteractive Applications This is the most common type of client scenario: web applications, SPAs or native/mobile apps with interactive users. This scenario typically involves a browser for user interaction (e.g. for authentication or consent).\nIn protocol terms, this scenario is called Authorization Code Flow and you can learn more about it in the issuing tokens section as well as in our Quickstart.\nA client application can potentially have many instances - e.g. your web application might be physically deployed on multiple servers for load-balancing purposes, or your mobile application might be deployed to thousands of different phones. Logically these instances are still a single client.\nResources Resources are something you want to protect with your IdentityServer - either identity data of your users, or APIs.\nEvery resource has a unique name - and clients use this name to specify to which resources they want to get access to.\nIdentity data Identity information (aka claims) about a user, e.g. name or email address.\nAPIs APIs resources represent functionality a client wants to invoke - typically modelled as Web APIs, but not necessarily.\nIdentity Token An identity token represents the outcome of an authentication process. It contains at a bare minimum an identifier for the user (called the sub aka subject claim) and information about how and when the user authenticated. It can contain additional identity data.\nAccess Token An access token allows access to an API resource. Clients request access tokens and forward them to the API. Access tokens contain information about the client and the user (if present). APIs use that information to authorize access to their data and functionality.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/tokens/extension_grants/token_exchange/",
    "title": "Token Exchange",
    "tags": [],
    "description": "",
    "content": "The OAuth Token Exchange specification (RFC 8693) describes a general purpose mechanism for translating between token types. Common use cases are creating tokens for impersonation and delegation purposes - but it is not limited to that.\nYou can leverage the extension grant feature to implement your preferred token exchange logic.\nSome of the logic is boilerplate:\nread and validate incoming protocol parameters validate incoming token using the built-in token validator if the token was issued by the same token service using a token type specific library if the token is coming from a trusted (but different) token service read contents of token to apply custom logic/authorization if needed create response Here\u0026rsquo;s a simple implementation of the above steps:\npublic class TokenExchangeGrantValidator : IExtensionGrantValidator { private readonly ITokenValidator _validator; public TokenExchangeGrantValidator(ITokenValidator validator) { _validator = validator; } // register for urn:ietf:params:oauth:grant-type:token-exchange public string GrantType =\u0026gt; OidcConstants.GrantTypes.TokenExchange; public async Task ValidateAsync(ExtensionGrantValidationContext context) { // default response is error context.Result = new GrantValidationResult(TokenRequestErrors.InvalidRequest); // the spec allows for various token types, most commonly you return an access token var customResponse = new Dictionary\u0026lt;string, object\u0026gt; { { OidcConstants.TokenResponse.IssuedTokenType, OidcConstants.TokenTypeIdentifiers.AccessToken } }; // read the incoming token var subjectToken = context.Request.Raw.Get(OidcConstants.TokenRequest.SubjectToken); // and the token type var subjectTokenType = context.Request.Raw.Get(OidcConstants.TokenRequest.SubjectTokenType); // mandatory parameters if (string.IsNullOrWhiteSpace(subjectToken)) { return; } // for our impersonation/delegation scenario we require an access token if (!string.Equals(subjectTokenType, OidcConstants.TokenTypeIdentifiers.AccessToken)) { return; } // validate the incoming access token with the built-in token validator var validationResult = await _validator.ValidateAccessTokenAsync(subjectToken); if (validationResult.IsError) { return; } // these are two values you typically care about var sub = validationResult.Claims.First(c =\u0026gt; c.Type == JwtClaimTypes.Subject).Value; var clientId = validationResult.Claims.First(c =\u0026gt; c.Type == JwtClaimTypes.ClientId).Value; // add any custom logic here (if needed) // create response } } You then register your grant validator with DI:\nidsvrBuilder.AddExtensionGrantValidator\u0026lt;TokenExchangeGrantValidator\u0026gt;(); And configure your client to be able to use it:\nclient.AllowedGrantTypes = { OidcConstants.GrantTypes.TokenExchange }; Values sent to the token endpoint are logged, except well-known sensitive values that IdentityServer processes by default. Any sensitive values you use as input to your extension grant validator that you do not want included in the logs should be filtered. This can be done by adding those parameter names on the Logging.TokenRequestSensitiveValuesFilter collection on the IdentityServerOptions.\nToken Exchange for impersonation and delegation One of the primary use cases of the token exchange specification is creating tokens for identity delegation and impersonation scenarios. In these scenarios you want to forward certain token and identity information over multiple hops in a call chain.\nImpersonation In the impersonation use case, API 1 doing the token exchange becomes \u0026ldquo;invisible\u0026rdquo;. For API 2 it looks like as if the front end is doing a direct call. The token would look like this (simplified):\n{ \u0026#34;client_id\u0026#34;: \u0026#34;front_end\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;scope\u0026#34;: [ \u0026#34;api2\u0026#34; ] } Add the following code to the above validator to create an impersonation response:\n// set token client_id to original id context.Request.ClientId = clientId; // create impersonation response context.Result = new GrantValidationResult( subject: sub, authenticationMethod: GrantType, customResponse: customResponse); Delegation In the delegation use case, the call chain is preserved using the act claim, e.g.:\n{ \u0026#34;client_id\u0026#34;: \u0026#34;front-end\u0026#34;, \u0026#34;act\u0026#34;: { \u0026#34;client_id\u0026#34;: \u0026#34;api1\u0026#34; }, \u0026#34;sub\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;scope\u0026#34;: [ \u0026#34;api2\u0026#34; ] } For API 2 it still looks like that the front-end is making the call, but by inspecting the act claim, the API can learn about the traversed call chain.\nThe following code adds the act claim to the response:\n// set token client_id to original id context.Request.ClientId = clientId; // create actor data structure var actor = new { client_id = context.Request.Client.ClientId }; // create act claim var actClaim = new Claim(JwtClaimTypes.Actor, JsonSerializer.Serialize(actor), IdentityServerConstants.ClaimValueTypes.Json); context.Result = new GrantValidationResult( subject: sub, authenticationMethod: GrantType, claims: new[] { actClaim }, customResponse: customResponse); To emit the act claim into outgoing tokens, your profile service must know about it. The following simple profile service emits the act claim if the token request is in the context of a token exchange operation:\npublic class ProfileService : IProfileService { public override async Task GetProfileDataAsync(ProfileDataRequestContext context) { // add actor claim if needed if (context.Subject.GetAuthenticationMethod() == OidcConstants.GrantTypes.TokenExchange) { var act = context.Subject.FindFirst(JwtClaimTypes.Actor); if (act != null) { context.IssuedClaims.Add(act); } } // rest omitted } // rest omitted } See here for the full source code.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/apis/aspnetcore/jwt/",
    "title": "Using JWTs",
    "tags": [],
    "description": "",
    "content": "On ASP.NET Core, you typically use the JWT authentication handler for validating JWT bearer tokens.\nValidating a JWT token First you need to add a reference to the authentication handler in your API project:\n\u0026lt;PackageReference Include=\u0026#34;Microsoft.AspNetCore.Authentication.JwtBearer\u0026#34; /\u0026gt; If all you care about is making sure that an access token comes from your trusted IdentityServer, the following snippet shows the typical JWT validation configuration for ASP.NET Core:\nbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) .AddJwtBearer(options =\u0026gt; { // base-address of your identityserver options.Authority = \u0026#34;https://demo.duendesoftware.com\u0026#34;; // audience is optional, make sure you read the following paragraphs // to understand your options options.TokenValidationParameters.ValidateAudience = false; // it\u0026#39;s recommended to check the type header to avoid \u0026#34;JWT confusion\u0026#34; attacks options.TokenValidationParameters.ValidTypes = new[] { \u0026#34;at+jwt\u0026#34; }; }); Adding audience validation Simply making sure that the token is coming from a trusted issuer is not good enough for most cases. In more complex systems, you will have multiple resources and multiple clients. Not every client might be authorized to access every resource.\nIn OAuth there are two complementary mechanisms to embed more information about the \u0026ldquo;functionality\u0026rdquo; that the token is for - audience and scope (see defining resources for more information).\nIf you designed your APIs around the concept of API resources, your IdentityServer will emit the aud claim by default (api1 in this example):\n{ \u0026#34;typ\u0026#34;: \u0026#34;at+jwt\u0026#34;, \u0026#34;kid\u0026#34;: \u0026#34;123\u0026#34; }. { \u0026#34;aud\u0026#34;: \u0026#34;api1\u0026#34;, \u0026#34;client_id\u0026#34;: \u0026#34;mobile_app\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;read write delete\u0026#34; } If you want to express in your API, that only access tokens for the api1 audience (aka API resource name) are accepted, change the above code snippet to:\nbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) .AddJwtBearer(options =\u0026gt; { options.Authority = \u0026#34;https://demo.duendesoftware.com\u0026#34;; options.Audience = \u0026#34;api1\u0026#34;; options.TokenValidationParameters.ValidTypes = new[] { \u0026#34;at+jwt\u0026#34; }; }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/apis/aspnetcore/",
    "title": "Protecting APIs using ASP.NET Core",
    "tags": [],
    "description": "",
    "content": "Protecting APIs using ASP.NET Core Using JWTs Using Reference Tokens Authorization based on Scopes and other Claims Validating Proof-of-Possession "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/response_handling/authorize_interaction_response_generator/",
    "title": "Authorize Interaction Response Generator",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.ResponseHandling.IAuthorizeInteractionResponseGenerator The IAuthorizeInteractionResponseGenerator interface models the logic for determining if user must login or consent when making requests to the authorization endpoint.\nIf a custom implementation of IAuthorizeInteractionResponseGenerator is desired, then it\u0026rsquo;s recommended to derive from the built-in AuthorizeInteractionResponseGenerator to inherit all the default logic pertaining to login and consent semantics.\nIAuthorizeInteractionResponseGenerator APIs ProcessInteractionAsync\nReturns the InteractionResponse based on the ValidatedAuthorizeRequest an and optional ConsentResponse if the user was shown a consent page.\nInteractionResponse IsLogin\nSpecifies if the user must login.\nIsConsent\nSpecifies if the user must consent.\nIsCreateAccount\nAdded in v6.3.\nSpecifies if the user must create an account.\nIsError\nSpecifies if the user must be shown an error page.\nError\nThe error to display on the error page.\nErrorDescription\nThe description of the error to display on the error page.\nIsRedirect\nSpecifies if the user must be redirected to a custom page for custom processing.\nRedirectUrl\nThe URL for the redirect to the page for custom processing.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/quickstarts/js_clients/js_with_backend/",
    "title": "Browser-Based Applications with a BFF",
    "tags": [],
    "description": "",
    "content": " We recommend you do the quickstarts in order. If you\u0026rsquo;d like to start here, begin from a copy of the reference implementation of Quickstart 3. Throughout this quickstart, paths are written relative to the base quickstart directory created in part 1, which is the root directory of the reference implementation. You will also need to install the IdentityServer templates.\nIn this quickstart, you will build a browser-based JavaScript client application with a backend. This means your application will have server-side code that supports the frontend application code. This is known as the Backend For Frontend (BFF) pattern.\nYou will implement the BFF pattern with the help of the Duende.BFF library. The backend will implement all of the security protocol interactions with the token server and will be responsible for management of the tokens. The client-side JavaScript authenticates with the BFF using traditional cookie authentication. This simplifies the JavaScript in the client-side, and reduces the attack surface of the application.\nThe features that will be shown in this quickstart will allow the user to login with IdentityServer, invoke a local API hosted in the backend (secured with cookie authentication), invoke a remote API running in a different host (secured with an access token), and logout of IdentityServer.\nNew Project for the JavaScript client and BFF Begin by creating a new project to host the JavaScript application and its BFF. A single project containing the front-end and its BFF facilitates cookie authentication - the front end and BFF need to be on the same host so that cookies will be sent from the front end to the BFF.\nCreate a new ASP.NET Core web application and add it to the solution by running the following commands from the src directory:\ndotnet new web -n JavaScriptClient cd .. dotnet sln add ./src/JavaScriptClient Add additional NuGet packages Install NuGet packages to add BFF and OIDC support to the new project by running the following commands from the src/JavaScriptClient directory:\ndotnet add package Microsoft.AspNetCore.Authentication.OpenIdConnect dotnet add package Duende.BFF dotnet add package Duende.BFF.Yarp Modify hosting Modify the JavaScriptClient project to run on https://localhost:5003. Its Properties/launchSettings.json should look like this:\n{ \u0026#34;$schema\u0026#34;: \u0026#34;http://json.schemastore.org/launchsettings.json\u0026#34;, \u0026#34;profiles\u0026#34;: { \u0026#34;JavaScriptClient\u0026#34;: { \u0026#34;commandName\u0026#34;: \u0026#34;Project\u0026#34;, \u0026#34;dotnetRunMessages\u0026#34;: true, \u0026#34;launchBrowser\u0026#34;: true, \u0026#34;applicationUrl\u0026#34;: \u0026#34;https://localhost:5003\u0026#34;, \u0026#34;environmentVariables\u0026#34;: { \u0026#34;ASPNETCORE_ENVIRONMENT\u0026#34;: \u0026#34;Development\u0026#34; } } } } Add services In the BFF pattern, the server-side code triggers and receives OpenID Connect requests and responses. To do that, it needs the same services configured as the WebClient did in the prior web application quickstart. Additionally, the BFF services need to be added with AddBff(). In addition the offline_access scope is requested that will result in a refresh token that will be used by the BFF library to automatically refresh the access token for the remote API if needed.\nAdd the following to src/JavaScriptClient/Program.cs:\nusing System.IdentityModel.Tokens.Jwt; using System.Security.Claims; using Duende.Bff.Yarp; using Microsoft.AspNetCore.Authorization; var builder = WebApplication.CreateBuilder(args); builder.Services.AddAuthorization(); builder.Services .AddBff() .AddRemoteApis(); builder.Services .AddAuthentication(options =\u0026gt; { options.DefaultScheme = \u0026#34;Cookies\u0026#34;; options.DefaultChallengeScheme = \u0026#34;oidc\u0026#34;; options.DefaultSignOutScheme = \u0026#34;oidc\u0026#34;; }) .AddCookie(\u0026#34;Cookies\u0026#34;) .AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { options.Authority = \u0026#34;https://localhost:5001\u0026#34;; options.ClientId = \u0026#34;bff\u0026#34;; options.ClientSecret = \u0026#34;secret\u0026#34;; options.ResponseType = \u0026#34;code\u0026#34;; options.Scope.Add(\u0026#34;api1\u0026#34;); options.Scope.Add(\u0026#34;offline_access\u0026#34;); options.SaveTokens = true; options.GetClaimsFromUserInfoEndpoint = true; options.MapInboundClaims = false; }); var app = builder.Build(); Add middleware Similarly, the middleware pipeline for this application will resemble the WebClient, with the addition of the BFF middleware and the BFF endpoints. Continue by adding the following to src/JavaScriptClient/Program.cs:\nvar app = builder.Build(); if (app.Environment.IsDevelopment()) { app.UseDeveloperExceptionPage(); } app.UseDefaultFiles(); app.UseStaticFiles(); app.UseRouting(); app.UseAuthentication(); app.UseBff(); app.UseAuthorization(); app.MapBffManagementEndpoints(); app.Run(); Add your HTML and JavaScript files Next, add HTML and JavaScript files for your client-side application to the wwwroot directory in the JavaScriptClient project. Create that directory (src/JavaScriptClient/wwwroot) and add an index.html and an app.js file to it.\nindex.html\nThe index.html file will be the main page in your application. It contains\nbuttons for the user to login, logout, and call the APIs a \u0026lt;pre\u0026gt; container used to show messages to the user a \u0026lt;script\u0026gt; tag to include our JavaScript file It should look like this:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=\u0026#34;login\u0026#34;\u0026gt;Login\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;local\u0026#34;\u0026gt;Call Local API\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;remote\u0026#34;\u0026gt;Call Remote API\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;logout\u0026#34;\u0026gt;Logout\u0026lt;/button\u0026gt; \u0026lt;pre id=\u0026#34;results\u0026#34;\u0026gt;\u0026lt;/pre\u0026gt; \u0026lt;script src=\u0026#34;app.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; app.js\nThe app.js file will contain the client-side code for your application.\nFirst, add a helper function to display messages in the \u0026lt;pre\u0026gt;:\nfunction log() { document.getElementById(\u0026#34;results\u0026#34;).innerText = \u0026#34;\u0026#34;; Array.prototype.forEach.call(arguments, function (msg) { if (typeof msg !== \u0026#34;undefined\u0026#34;) { if (msg instanceof Error) { msg = \u0026#34;Error: \u0026#34; + msg.message; } else if (typeof msg !== \u0026#34;string\u0026#34;) { msg = JSON.stringify(msg, null, 2); } document.getElementById(\u0026#34;results\u0026#34;).innerText += msg + \u0026#34;\\r\\n\u0026#34;; } }); } Next, you can use the BFF user management endpoint to query if the user is logged in or not. Notice the userClaims variable is global; it will be needed elsewhere.\nlet userClaims = null; (async function () { var req = new Request(\u0026#34;/bff/user\u0026#34;, { headers: new Headers({ \u0026#34;X-CSRF\u0026#34;: \u0026#34;1\u0026#34;, }), }); try { var resp = await fetch(req); if (resp.ok) { userClaims = await resp.json(); log(\u0026#34;user logged in\u0026#34;, userClaims); } else if (resp.status === 401) { log(\u0026#34;user not logged in\u0026#34;); } } catch (e) { log(\u0026#34;error checking user status\u0026#34;); } })(); Next, register click event handlers on the buttons:\ndocument.getElementById(\u0026#34;login\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, login, false); document.getElementById(\u0026#34;local\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, localApi, false); document.getElementById(\u0026#34;remote\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, remoteApi, false); document.getElementById(\u0026#34;logout\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, logout, false); Next, implement the login and logout functions.\nLogin is simple - just redirect the user to the BFF login endpoint.\nfunction login() { window.location = \u0026#34;/bff/login\u0026#34;; } Logout is more involved, as you need to redirect the user to the BFF logout endpoint, which requires an anti-forgery token to prevent cross site request forgery attacks. The userClaims that you populated earlier contain that token and the full logout URL in its bff:logout_url claim, so redirect to that url:\nfunction logout() { if (userClaims) { var logoutUrl = userClaims.find( (claim) =\u0026gt; claim.type === \u0026#34;bff:logout_url\u0026#34; ).value; window.location = logoutUrl; } else { window.location = \u0026#34;/bff/logout\u0026#34;; } } Finally, add empty stubs for the other button event handler functions. You will implement those after you get login and logout working.\nasync function localApi() { } async function remoteApi() { } Add a client registration to IdentityServer for the JavaScript client Now that the client application is ready to go, you need to define a configuration entry in IdentityServer for the new JavaScript client.\nIn the IdentityServer project locate the client configuration in src/IdentityServer/Config.cs. Add a new Client to the list for your new JavaScript application. Because this client uses the BFF pattern, the configuration will be very similar to the Web client. In addition requesting the offline_access scope should be allowed for this client. It should have the configuration listed below:\n// JavaScript BFF client new Client { ClientId = \u0026#34;bff\u0026#34;, ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, AllowedGrantTypes = GrantTypes.Code, // where to redirect to after login RedirectUris = { \u0026#34;https://localhost:5003/signin-oidc\u0026#34; }, // where to redirect to after logout PostLogoutRedirectUris = { \u0026#34;https://localhost:5003/signout-callback-oidc\u0026#34; }, AllowOfflineAccess = true, AllowedScopes = new List\u0026lt;string\u0026gt; { IdentityServerConstants.StandardScopes.OpenId, IdentityServerConstants.StandardScopes.Profile, \u0026#34;api1\u0026#34; } } Run and test login and logout At this point, you should be able to run the JavaScriptClient application. You should see that the user is not logged in initially.\nWhen you click the login button, you\u0026rsquo;ll be redirected to IdentityServer to login. After you login, you\u0026rsquo;ll be redirected back to the JavaScriptClient application, where you\u0026rsquo;ll be signed into the Cookies authentication scheme with your tokens saved in the session.\nThe app loads again, but this time it has a session cookie. So, when it makes the HTTP request to get userClaims, that cookie is included in the request. This allows the BFF middleware to authenticate the user and return user info. Once the JavaScriptClient application receives the response, the user should appear logged in and their claims should be displayed.\nFinally, the logout button should successfully get the user logged out.\nAdd API support Now that you have login and logout working, you will add support to invoke both local and remote APIs.\nA local API is an endpoint that is hosted in the same backend as the JavaScriptClient application. Local APIs are intended to be APIs that only exist to support the JavaScript frontend, typically by providing UI specific data or aggregating data from other sources. Local APIs are authenticated with the user\u0026rsquo;s session cookie.\nA remote API is an API running in some other host than the JavaScriptClient application. This is useful for APIs that are shared by many different applications (e.g. mobile app, other web apps, etc). Remote APIs are authenticated with an access token. Fortunately, the JavaScriptClient application has an access token stored in the user\u0026rsquo;s session. You will use the BFF proxy feature to accept a call from the JavaScript running in the browser authenticated with the user\u0026rsquo;s session cookie, retrieve the access token for the user from the user\u0026rsquo;s session, and then proxy the call to the remote API, sending the access token for authentication.\nDefine a local API Local APIs can be defined using controllers or with Minimal API Route Handlers. For simplicity, this quickstart uses a minimal API with its handler defined directly in Program.cs, but you can organize your Local APIs however you like.\nAdd a handler to src/JavaScriptClient/Program.cs for the the local API:\n[Authorize] static IResult LocalIdentityHandler(ClaimsPrincipal user) { var name = user.FindFirst(\u0026#34;name\u0026#34;)?.Value ?? user.FindFirst(\u0026#34;sub\u0026#34;)?.Value; return Results.Json(new { message = \u0026#34;Local API Success!\u0026#34;, user = name }); } Local APIs often make requests to remote APIs that are authorized with the user\u0026rsquo;s access token. To get the access token, call the GetUserAccessTokenAsync extension method on the HttpContext. For example: var token = await HttpContext.GetUserAccessTokenAsync();\nUpdate routing to accept local and remote API calls Next, you need to register both the local API and the BFF proxy for the remote API in the ASP.NET Core routing system. Add the code below to the endpoint configuration code in src/JavaScriptClient/Program.cs.\napp.MapBffManagementEndpoints(); // Uncomment this for Controller support // app.MapControllers() // .AsBffApiEndpoint(); app.MapGet(\u0026#34;/local/identity\u0026#34;, LocalIdentityHandler) .AsBffApiEndpoint(); app.MapRemoteBffApiEndpoint(\u0026#34;/remote\u0026#34;, \u0026#34;https://localhost:6001\u0026#34;) .RequireAccessToken(Duende.Bff.TokenType.User); The call to the AsBffApiEndpoint() fluent helper method adds BFF support to the local APIs. This includes anti-forgery protection as well as suppressing login redirects on authentication failures and instead returning 401 and 403 status codes under the appropriate circumstances.\nMapRemoteBffApiEndpoint() registers the BFF proxy for the remote API and configures it to pass the user\u0026rsquo;s access token.\nCall the APIs from JavaScript Back in src/JavaScriptClient/wwwroot/app.js, implement the two API button event handlers like this:\nasync function localApi() { var req = new Request(\u0026#34;/local/identity\u0026#34;, { headers: new Headers({ \u0026#34;X-CSRF\u0026#34;: \u0026#34;1\u0026#34;, }), }); try { var resp = await fetch(req); let data; if (resp.ok) { data = await resp.json(); } log(\u0026#34;Local API Result: \u0026#34; + resp.status, data); } catch (e) { log(\u0026#34;error calling local API\u0026#34;); } } async function remoteApi() { var req = new Request(\u0026#34;/remote/identity\u0026#34;, { headers: new Headers({ \u0026#34;X-CSRF\u0026#34;: \u0026#34;1\u0026#34;, }), }); try { var resp = await fetch(req); let data; if (resp.ok) { data = await resp.json(); } log(\u0026#34;Remote API Result: \u0026#34; + resp.status, data); } catch (e) { log(\u0026#34;error calling remote API\u0026#34;); } } The path for the local API is exactly what you set in the the call to MapGet in src/JavaScriptClient/Program.cs.\nThe path for the remote API uses a \u0026ldquo;/remote\u0026rdquo; prefix to indicate that the BFF proxy should be used, and the remaining path is what\u0026rsquo;s then passed when invoking the remote API (\u0026quot;/identity\u0026quot; in this case).\nNotice both API calls require a \u0026lsquo;X-CSRF\u0026rsquo;: \u0026lsquo;1\u0026rsquo; header, which acts as the anti-forgery token.\nSee the client credentials quickstart for information on how to create the remote API used in the code above.\nRun and test the API calls At this point, you should be able to run the JavaScriptClient application and invoke the APIs. The local API should return something like this:\nAnd the remote API should return something like this:\nYou now have the start of a JavaScript client application that uses IdentityServer for sign-in, sign-out, and authenticating calls to local and remote APIs, using Duende.BFF.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/quickstarts/js_clients/",
    "title": "Building Browser-Based Client Applications",
    "tags": [],
    "description": "",
    "content": "Building Browser-Based Client Applications When building browser-based or SPA applications using javascript, there are two main styles: those with a backend and those without.\nBrowser-based applications with a backend are more secure, making it the recommended style. This style uses the \u0026ldquo;Backend For Frontend\u0026rdquo; pattern, or \u0026ldquo;BFF\u0026rdquo; for short, which relies on the backend host to implement all of the security protocol interactions with the token server. The Duende.BFF library is used in this quickstart to easily support the BFF pattern.\nBrowser-based applications without a backend need to do all the security protocol interactions on the client-side, including driving user authentication and token requests, session and token management, and token storage. This leads to more complex JavaScript, cross-browser incompatibilities, and a considerably higher attack surface. Since this style inherently needs to store security sensitive artifacts (like tokens) in JavaScript reachable locations, this style is not recommended. Consequently we don\u0026rsquo;t offer a quickstart for this style.\nAs the \u0026ldquo;OAuth 2.0 for Browser-Based Apps\u0026rdquo; IETF/OAuth working group BCP document says:\nthere is no browser API that allows to store tokens in a completely secure way.\nAdditionally, modern browsers have recently added or are planning to add privacy features that can break some front-channel protocol interactions. See here for more details.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/data/configuration/",
    "title": "Configuration Data",
    "tags": [],
    "description": "",
    "content": "Configuration data models the information for Clients and Resources.\nStores Store interfaces are designed to abstract accessing the configuration data. The stores used in Duende IdentityServer are:\nClient store for Client data. CORS policy service for CORS support. Given that this is so closely tied to the Client configuration data, the CORS policy service is considered one of the configuration stores. Resource store for IdentityResource, ApiResource, and ApiScope data. Identity Provider store for IdentityProvider data. Registering Custom Stores Custom implementations of the stores must be registered in the DI system. There are convenience methods for registering these. For example:\nbuilder.Services.AddIdentityServer() .AddClientStore\u0026lt;YourCustomClientStore\u0026gt;() .AddCorsPolicyService\u0026lt;YourCustomCorsPolicyService\u0026gt;() .AddResourceStore\u0026lt;YourCustomResourceStore\u0026gt;() .AddIdentityProviderStore\u0026lt;YourCustomAddIdentityProviderStore\u0026gt;(); Caching Configuration Data Configuration data is used frequently during request processing. If this data is loaded from a database or other external store, then it might be expensive to frequently re-load the same data.\nDuende IdentityServer provides convenience methods to enable caching data from the various stores. The caching implementation relies upon an ICache\u0026lt;T\u0026gt; service and must also be added to DI. For example:\nbuilder.Services.AddIdentityServer() .AddClientStore\u0026lt;YourCustomClientStore\u0026gt;() .AddCorsPolicyService\u0026lt;YourCustomCorsPolicyService\u0026gt;() .AddResourceStore\u0026lt;YourCustomResourceStore\u0026gt;() .AddInMemoryCaching() .AddClientStoreCache\u0026lt;YourCustomClientStore\u0026gt;() .AddCorsPolicyCache\u0026lt;YourCustomCorsPolicyService\u0026gt;() .AddResourceStoreCache\u0026lt;YourCustomResourceStore\u0026gt;() .AddIdentityProviderStoreCache\u0026lt;YourCustomAddIdentityProviderStore\u0026gt;(); The duration of the data in the default cache is configurable on the IdentityServerOptions. For example:\nbuilder.Services.AddIdentityServer(options =\u0026gt; { options.Caching.ClientStoreExpiration = TimeSpan.FromMinutes(5); options.Caching.ResourceStoreExpiration = TimeSpan.FromMinutes(5); }) .AddClientStore\u0026lt;YourCustomClientStore\u0026gt;() .AddCorsPolicyService\u0026lt;YourCustomCorsPolicyService\u0026gt;() .AddResourceStore\u0026lt;YourCustomResourceStore\u0026gt;() .AddInMemoryCaching() .AddClientStoreCache\u0026lt;YourCustomClientStore\u0026gt;() .AddCorsPolicyCache\u0026lt;YourCustomCorsPolicyService\u0026gt;() .AddResourceStoreCache\u0026lt;YourCustomResourceStore\u0026gt;(); Further customization of the cache is possible:\nIf you wish to customize the caching behavior for the specific configuration objects, you can replace the ICache\u0026lt;T\u0026gt; service implementation in the dependency injection system. The default implementation of the ICache\u0026lt;T\u0026gt; itself relies upon the IMemoryCache interface (and MemoryCache implementation) provided by .NET. If you wish to customize the in-memory caching behavior, you can replace the IMemoryCache implementation in the dependency injection system. In-Memory Stores The various in-memory configuration APIs allow for configuring IdentityServer from an in-memory list of the various configuration objects. These in-memory collections can be hard-coded in the hosting application, or could be loaded dynamically from a configuration file or a database. By design, though, these collections are only created when the hosting application is starting up.\nUse of these configuration APIs are designed for use when prototyping, developing, and/or testing where it is not necessary to dynamically consult database at runtime for the configuration data. This style of configuration might also be appropriate for production scenarios if the configuration rarely changes, or it is not inconvenient to require restarting the application if the value must be changed.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/validators/custom_authorize_request_validator/",
    "title": "Custom Authorize Request Validator",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Validation.ICustomAuthorizeRequestValidator Allows running custom code as part of the authorization issuance pipeline at the authorization endpoint.\n/// \u0026lt;summary\u0026gt; /// Allows inserting custom validation logic into authorize requests /// \u0026lt;/summary\u0026gt; public interface ICustomAuthorizeRequestValidator { /// \u0026lt;summary\u0026gt; /// Custom validation logic for the authorize request. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;context\u0026#34;\u0026gt;The context.\u0026lt;/param\u0026gt; Task ValidateAsync(CustomAuthorizeRequestValidationContext context); } ValidateAsync\nThis method gets called during authorize request processing. The context gives you access to request and response parameters.\nTo fail the request, set the the IsError, the Error, and optionally the ErrorDescription properties on the Result object on the CustomAuthorizeRequestValidationContext.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/fundamentals/hosting/",
    "title": "Hosting",
    "tags": [],
    "description": "",
    "content": "You add the Duende IdentityServer engine to any ASP.NET Core application by adding the relevant services to the dependency injection (DI) system and adding the middleware to the processing pipeline.\nWhile technically you could share the ASP.NET Core host between Duende IdentityServer, clients or APIs. We recommend putting your IdentityServer into a separate application.\nDI system You add the necessary services to the DI system by calling AddIdentityServer at application startup:\nvar idsvrBuilder = builder.Services.AddIdentityServer(options =\u0026gt; { ... }); Many of the fundamental configuration settings can be set on the options. See the IdentityServerOptions reference for more details.\nThe builder object has a number of extension methods to add additional services to DI. You can see the full list in the reference section, but very commonly you start by adding the configuration stores for clients and resources, e.g.:\nvar idsvrBuilder = builder.Services.AddIdentityServer() .AddInMemoryClients(Config.Clients) .AddInMemoryIdentityResources(Config.IdentityResources) .AddInMemoryApiScopes(Config.ApiScopes) The above is using the in-memory stores, but we also support EntityFramework-based implementations and custom stores. See here for more information.\nPipeline You need to add the Duende IdentityServer middleware to the pipeline by calling UseIdentityServer.\nSince ordering is important in the pipeline, you typically want to put the IdentityServer middleware after the static files, but before the UI framework like MVC.\nThis would be a very typical minimal pipeline:\napp.UseStaticFiles(); app.UseRouting(); app.UseIdentityServer(); app.UseAuthorization(); app.MapDefaultControllerRoute(); UseIdentityServer includes a call to UseAuthentication, so it’s not necessary to have both.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/options/",
    "title": "IdentityServer Options",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Configuration.IdentityServerOptions The IdentityServerOptions is the central place to configure fundamental settings in Duende IdentityServer.\nYou set the options when registering IdentityServer at startup time, using a lambda expression in the AddIdentityServer method:\nvar idsvrBuilder = builder.Services.AddIdentityServer(options =\u0026gt; { // configure options here.. }) Main Top-level settings. Available directly on the IdentityServerOptions object.\nIssuerUri\nThe name of the token server, used in the discovery document as the issuer claim and in JWT tokens and introspection responses as the iss claim.\nIt is not recommended to set this option. If it is not set (the default), the issuer is inferred from the URL used by clients. This better conforms to the OpenID Connect specification, which requires that issuer values be \u0026ldquo;identical to the Issuer URL that was directly used to retrieve the configuration information\u0026rdquo;. It is also more convenient for clients to validate the issuer of tokens, because they will not need additional configuration or customization to know the expected issuer.\nLowerCaseIssuerUri\nControls the casing of inferred IssuerUris. When set to false, the original casing of the IssuerUri in requests is preserved. When set to true, the IssuerUri is converted to lowercase. Defaults to true.\nAccessTokenJwtType\nThe value used for the typ header in JWT access tokens. Defaults to at+jwt, as specified by the RFC 9068. If AccessTokenJwtType is set to null or the empty string, the typ header will not be emitted in JWT access tokens.\nLogoutTokenJwtType\nThe value for the typ header in back-channel logout tokens. Defaults to \u0026ldquo;logout+jwt\u0026rdquo;, as specified by OpenID Connect Back-Channel Logout 1.0.\nEmitScopesAsSpaceDelimitedStringInJwt\nControls the format of scope claims in JWTs and introspection responses. Historically scopes values were emitted as an array in JWT access tokens. RFC 9068 now specifies a space delimited string instead. Defaults to false for backwards compatibility.\nEmitStaticAudienceClaim\nEmits a static aud (audience) claim in all access tokens with the format {issuer}/resources. For example, if IdentityServer was running at https://identity.example.com, the static aud claim\u0026rsquo;s value would be https://identity.example.com/resources. Historically, older versions of IdentityServer produced tokens with a static audience claim in this format. This flag is intended for use when you need to produce backwards-compatible access tokens. Also note that multiple audience claims are possible. If you enable this flag and also configure ApiResources you can have both the static audience and audiences from the API resources. Defaults to false.\nEmitIssuerIdentificationResponseParameter\nEmits the iss response parameter on authorize responses, as specified by RFC 9207. Defaults to true.\nEmitStateHash\nEmits the s_hash claim in identity tokens. The s_hash claim is a hash of the state parameter that is specified in the OpenID Connect Financial-grade API Security Profile. Defaults to false.\nStrictJarValidation\nStrictly validate JWT-secured authorization requests according to RFC 9101. When enabled, JWTs used to secure authorization requests must have the typ header value oauth-authz-req+jwt and JWT-secured authorization requests must have the HTTP content-type header value application/oauth-authz-req+jwt. This might break older OIDC conformant request objects. Defaults to false.\nValidateTenantOnAuthorization\nSpecifies if a user\u0026rsquo;s tenant claim is compared to the tenant acr_values parameter value to determine if the login page is displayed. Defaults to false.\nKey management Automatic key management settings. Available on the KeyManagement property of the IdentityServerOptions object.\nEnabled\nEnables automatic key management. Defaults to true.\nSigningAlgorithms\nThe signing algorithms for which automatic key management will manage keys.\nThis option is configured with a list of objects containing a Name property, which is the name of a supported signing algorithm, and a UseX509Certificate property, which is a flag indicating if the signing key should be wrapped in an X.509 certificate.\nThe first algorithm in the collection will be used as the default for clients that do not specify AllowedIdentityTokenSigningAlgorithms.\nThe supported signing algorithm names are RS256, RS384, RS512, PS256, PS384, PS512, ES256, ES384, and ES512.\nX.509 certificates are not supported for ES256, ES384, and ES512 keys.\nDefaults to RS256 without an X.509 certificate.\nX.509 certificates have an expiration date, but IdentityServer does not use this data to validate the certificate and throw an exception. If a certificate has expired then you must decide whether to continue using it or replace it with a new certificate.\nRsaKeySize\nKey size (in bits) of RSA keys. The signing algorithms that use RSA keys (RS256, RS384, RS512, PS256, PS384, and PS512) will generate an RSA key of this length. Defaults to 2048.\nRotationInterval\nAge at which keys will no longer be used for signing, but will still be used in discovery for validation. Defaults to 90 days.\nPropagationTime\nTime expected to propagate new keys to all servers, and time expected all clients to refresh discovery. Defaults to 14 days.\nRetentionDuration\nDuration for keys to remain in discovery after rotation. Defaults to 14 days.\nDeleteRetiredKeys\nAutomatically delete retired keys. Defaults to true.\nKeyPath\nPath for storing keys when using the default file system store. Defaults to the \u0026ldquo;keys\u0026rdquo; directory relative to the hosting application.\nDataProtectKeys\nAutomatically protect keys in the storage using data protection. Defaults to true.\nKeyCacheDuration\nWhen in normal operation, duration to cache keys from store. Defaults to 24 hours.\nInitializationDuration\nWhen no keys have been created yet, this is the window of time considered to be an initialization period to allow all servers to synchronize if the keys are being created for the first time. Defaults to 5 minutes.\nInitializationSynchronizationDelay\nDelay used when re-loading from the store when the initialization period. It allows other servers more time to write new keys so other servers can include them. Defaults to 5 seconds.\nInitializationKeyCacheDuration\nCache duration when within the initialization period. Defaults to 1 minute.\nEndpoints Endpoint settings, including flags to disable individual endpoints and support for the request_uri JAR parameter. Available on the Endpoints property of the IdentityServerOptions object.\nEnableAuthorizeEndpoint\nEnables the authorize endpoint. Defaults to true.\nEnableTokenEndpoint\nEnables the token endpoint. Defaults to true.\nEnableDiscoveryEndpoint\nEnables the discovery endpoint. Defaults to true.\nEnableUserInfoEndpoint\nEnables the user info endpoint. Defaults to true.\nEnableEndSessionEndpoint\nEnables the end session endpoint. Defaults to true.\nEnableCheckSessionEndpoint\nEnables the check session endpoint. Defaults to true.\nEnableTokenRevocationEndpoint\nEnables the token revocation endpoint. Defaults to true.\nEnableIntrospectionEndpoint\nEnables the introspection endpoint. Defaults to true.\nEnableDeviceAuthorizationEndpoint\nEnables the device authorization endpoint. Defaults to true.\nEnableBackchannelAuthenticationEndpoint\nEnables the backchannel authentication endpoint. Defaults to true.\nEnablePushedAuthorizationEndpoint\nEnables the pushed authorization endpoint. Defaults to true.\nEnableJwtRequestUri Enables the request_uri parameter for JWT-Secured Authorization Requests. This allows the JWT to be passed by reference. Disabled by default, due to the security implications of enabling the request_uri parameter (see RFC 9101 section 10.4).\nDiscovery Discovery settings, including flags to toggle sections of the discovery document and settings to add custom entries to it. Available on the Discovery property of the IdentityServerOptions object.\nIf you want to take full control over the rendering of the discovery and jwks documents, you can implement the IDiscoveryResponseGenerator interface (or derive from our default implementation).\nShowEndpoints\nShows endpoints (authorization_endpoint, token_endpoint, etc) in the discovery document. Defaults to true.\nShowKeySet\nShows the jwks_uri in the discovery document and enables the jwks endpoint. Defaults to true.\nShowIdentityScopes\nIncludes IdentityResources in the supported_scopes of the discovery document. Defaults to true.\nShowApiScopes\nIncludes ApiScopes in the supported_scopes of the discovery document. Defaults to true.\nShowClaims\nShows claims_supported in the discovery document. Defaults to true.\nShowResponseTypes\nShows response_types_supported in the discovery document. Defaults to true.\nShowResponseModes\nShows response_modes_supported in the discovery document. Defaults to true.\nShowGrantTypes\nShows grant_types_supported in the discovery document. Defaults to true.\nShowExtensionGrantTypes\nIncludes extension grant types in the grant_types_supported of the discovery document. Defaults to true.\nShowTokenEndpointAuthenticationMethods\nShows token_endpoint_auth_methods_supported in the discovery document. Defaults to true.\nCustomEntries Adds custom elements to the discovery document. For example:\nvar idsvrBuilder = builder.Services.AddIdentityServer(options =\u0026gt; { options.Discovery.CustomEntries.Add(\u0026#34;my_setting\u0026#34;, \u0026#34;foo\u0026#34;); options.Discovery.CustomEntries.Add(\u0026#34;my_complex_setting\u0026#34;, new { foo = \u0026#34;foo\u0026#34;, bar = \u0026#34;bar\u0026#34; }); }); ExpandRelativePathsInCustomEntries Expands paths in custom entries that begin with \u0026ldquo;~/\u0026rdquo; into absolute paths below the IdentityServer base address. Defaults to true. In the following example, if IdentityServer\u0026rsquo;s base address is https://localhost:5001, then my_custom_endpoint\u0026rsquo;s value will be expanded to https://localhost:5001/custom. options.Discovery.CustomEntries.Add(\u0026#34;my_custom_endpoint\u0026#34;, \u0026#34;~/custom\u0026#34;); Authentication Login/logout related settings. Available on the Authentication property of the IdentityServerOptions\nCookieAuthenticationScheme\nSets the cookie authentication scheme configured by the host used for interactive users. If not set, the scheme will be inferred from the host\u0026rsquo;s default authentication scheme. This setting is typically used when AddPolicyScheme is used in the host as the default scheme.\nCookieLifetime\nThe authentication cookie lifetime (only effective if the IdentityServer-provided cookie handler is used). Defaults to 10 hours.\nCookieSlidingExpiration\nSpecifies if the cookie should be sliding or not (only effective if the IdentityServer-provided cookie handler is used). Defaults to false.\nCookieSameSiteMode\nSpecifies the SameSite mode for the internal cookies. Defaults to None.\nRequireAuthenticatedUserForSignOutMessage\nIndicates if user must be authenticated to accept parameters to end session endpoint. Defaults to false.\nCheckSessionCookieName\nThe name of the cookie used for the check session endpoint. Defaults to the constant IdentityServerConstants.DefaultCheckSessionCookieName, which has the value \u0026ldquo;idsrv.session\u0026rdquo;.\nCheckSessionCookieDomain\nThe domain of the cookie used for the check session endpoint. Defaults to null.\nCheckSessionCookieSameSiteMode\nThe SameSite mode of the cookie used for the check session endpoint. Defaults to None.\nRequireCspFrameSrcForSignout\nEnables all content security policy headers on the end session endpoint. For historical reasons, this option\u0026rsquo;s name mentions frame-src, but the content security policy headers on the end session endpoint also include other fetch directives, including a default-src \u0026rsquo;none\u0026rsquo; directive, which prevents most resources from being loaded by the end session endpoint, and a style-src directive that specifies the hash of the expected style on the page.\nCoordinateClientLifetimesWithUserSession (added in v6.1)\nWhen enabled, all clients\u0026rsquo; token lifetimes (e.g. refresh tokens) will be tied to the user\u0026rsquo;s session lifetime. This means when the user logs out, any revokable tokens will be removed. If using server-side sessions, expired sessions will also remove any revokable tokens, and backchannel logout will be triggered. An individual client can override this setting with its own CoordinateLifetimeWithUserSession configuration setting.\nEvents Configures which events should be raised at the registered event sink.\nRaiseSuccessEvents\nEnables success events. Defaults to false. Success events include all the events whose names are postfixed with \u0026ldquo;SuccessEvent\u0026rdquo;. In general, they are raised when properly formed and valid requests are processed without errors.\nRaiseFailureEvents\nEnables failure events. Defaults to false. Failure events include all the events whose names are postfixed with \u0026ldquo;FailureEvent\u0026rdquo;. In general, they are raised when an action has failed because of incorrect or badly formed parameters in a request. They indicate that the user or client calling IdentityServer has done something wrong and are analogous to a 400: bad request error.\nRaiseErrorEvents\nEnables Error events. Defaults to false. Error events are raised when an error has occurred, either because of invalid configuration or an unhandled exception. They indicate that there is something wrong within the token server or its configuration and are analogous to a 500: internal server error.\nRaiseInformationEvents\nEnables Information events. Defaults to false. Information events are emitted when an action has occurred that is of informational interest, but that is neither a success nor a failure. For example, when the end user grants, denies, or revokes consent, that is considered an information event, because these events capture a valid choice of the user rather than success or failure.\nLogging Logging related settings, including filters that will remove sensitive values and unwanted exceptions from logs. Available on the Logging property of the IdentityServerOptions object.\nAuthorizeRequestSensitiveValuesFilter\nCollection of parameter names passed to the authorize endpoint that are considered sensitive and will be excluded from logging. Defaults to id_token_hint.\nTokenRequestSensitiveValuesFilter\nCollection of parameter names passed to the token endpoint that are considered sensitive and will be excluded from logging. In v7.0 and earlier, defaults to client_secret, password, client_assertion, refresh_token, and device_code. In v7.1, subject_token is also excluded.\nBackchannelAuthenticationRequestSensitiveValuesFilter\nCollection of parameter names passed to the backchannel authentication endpoint that are considered sensitive and will be excluded from logging. Defaults to client_secret, client_assertion, and id_token_hint.\nUnhandledExceptionLoggingFilter (added in v6.2)\nA function that is called when the IdentityServer middleware detects an unhandled exception, and is used to determine if the exception is logged. The arguments to the function are the HttpContext and the Exception. It should return true to log the exception, and false to suppress. The default is to suppress logging of cancellation-related exceptions when the CancellationToken on the HttpContext has requested cancellation. Such exceptions are thrown when Http requests are canceled, which is an expected occurrence. Logging them creates unnecessary noise in the logs. In v7.0 and earlier, only TaskCanceledExceptions were filtered. Beginning in v7.1, OperationCanceledExceptions are filtered as well.\nInputLengthRestrictions Settings that control the allowed length of various protocol parameters, such as client id, scope, redirect URI etc. Available on the InputLengthRestrictions property of the IdentityServerOptions object.\nClientId\nMax length for ClientId. Defaults to 100.\nClientSecret\nMax length for external client secrets. Defaults to 100.\nScope\nMax length for scope. Defaults to 300.\nRedirectUri\nMax length for redirect_uri. Defaults to 400.\nNonce\nMax length for nonce. Defaults to 300.\nUiLocale\nMax length for ui_locale. Defaults to 100.\nLoginHint\nMax length for login_hint. Defaults to 100.\nAcrValues\nMax length for acr_values. Defaults to 300.\nGrantType\nMax length for grant_type. Defaults to 100.\nUserName\nMax length for username. Defaults to 100.\nPassword\nMax length for password. Defaults to 100.\nCspReport\nMax length for CSP reports. Defaults to 2000.\nIdentityProvider\nMax length for external identity provider name. Defaults to 100.\nExternalError\nMax length for external identity provider errors. Defaults to 100.\nAuthorizationCode\nMax length for authorization codes. Defaults to 100.\nDeviceCode\nMax length for device codes. Defaults to 100.\nRefreshToken\nMax length for refresh tokens. Defaults to 100.\nTokenHandle\nMax length for token handles. Defaults to 100.\nJwt\nMax length for JWTs. Defaults to 51200.\nCodeChallengeMinLength\nMin length for the code challenge. Defaults to 43.\nCodeChallengeMaxLength\nMax length for the code challenge. Defaults to 128.\nCodeVerifierMinLength\nMin length for the code verifier. Defaults to 43.\nCodeVerifierMaxLength\nMax length for the code verifier. Defaults to 128.\nResourceIndicatorMaxLength\nMax length for resource indicator parameter. Defaults to 512.\nBindingMessage\nMax length for binding_message. Defaults to 100.\nUserCode\nMax length for user_code. Defaults to 100.\nIdTokenHint\nMax length for id_token_hint. Defaults to 4000.\nLoginHintToken\nMax length for login_hint_token. Defaults to 4000.\nAuthenticationRequestId Max length for auth_req_id. Defaults to 100.\nUserInteraction User interaction settings, including urls for pages in the UI, names of parameters to those pages, and other settings related to interactive flows. Available on the UserInteraction property of the IdentityServerOptions object.\nLoginUrl, LogoutUrl, ConsentUrl, ErrorUrl, DeviceVerificationUrl\nSets the URLs for the login, logout, consent, error and device verification pages.\nCreateAccountUrl (added in v6.3)\nSets the URL for the create account page, which is used by OIDC requests that include the prompt=create parameter. When this option is set, including the prompt=create parameter will cause the user to be redirected to the specified url. create will also be added to the discovery document\u0026rsquo;s prompt_values_supported array to announce support for this feature. When this option is not set, the prompt=create parameter is ignored, and create is not added to discovery. Defaults to null.\nLoginReturnUrlParameter\nSets the name of the return URL parameter passed to the login page. Defaults to returnUrl.\nLogoutIdParameter\nSets the name of the logout message id parameter passed to the logout page. Defaults to logoutId.\nConsentReturnUrlParameter\nSets the name of the return URL parameter passed to the consent page. Defaults to returnUrl.\nErrorIdParameter\nSets the name of the error message id parameter passed to the error page. Defaults to errorId.\nCustomRedirectReturnUrlParameter\nSets the name of the return URL parameter passed to a custom redirect from the authorization endpoint. Defaults to returnUrl.\nDeviceVerificationUserCodeParameter\nSets the name of the user code parameter passed to the device verification page. Defaults to userCode.\nCookieMessageThreshold\nCertain interactions between IdentityServer and some UI pages require a cookie to pass state and context (any of the pages above that have a configurable \u0026ldquo;message id\u0026rdquo; parameter). Since browsers have limits on the number of cookies and their size, this setting is used to prevent too many cookies being created. The value sets the maximum number of message cookies of any type that will be created. The oldest message cookies will be purged once the limit has been reached. This effectively indicates how many tabs can be opened by a user when using IdentityServer. Defaults to 2.\nAllowOriginInReturnUrl\nFlag that allows return URL validation to accept full URL that includes the IdentityServer origin. Defaults to false.\nPromptValuesSupported (added in v7.0.7)\nThe collection of OIDC prompt modes supported and that will be published in discovery. By default, this includes all values in Constants.SupportedPromptModes. If the CreateAccountUrl option is set, then the \u0026ldquo;create\u0026rdquo; value is also included. If additional prompt values are added, a customized IAuthorizeInteractionResponseGenerator\u0026quot; is also required to handle those values.\nCaching Caching settings for the stores. Available on the Caching property of the IdentityServerOptions object. These settings only apply if the respective caching has been enabled in the services configuration in startup.\nClientStoreExpiration\nCache duration of client configuration loaded from the client store. Defaults to 15 minutes.\nResourceStoreExpiration\nCache duration of identity and API resource configuration loaded from the resource store. Defaults to 15 minutes.\nCorsExpiration\nCache duration of CORS configuration loaded from the CORS policy service. Defaults to 15 minutes.\nIdentityProviderCacheDuration\nCache duration of identity provider configuration loaded from the identity provider store. Defaults to 60 minutes.\nCacheLockTimeout\nThe timeout for concurrency locking in the default cache. Defaults to 60 seconds.\nCORS CORS settings for IdentityServer\u0026rsquo;s endpoints. Available on the Cors property of the IdentityServerOptions object. The underlying CORS implementation is provided from ASP.NET Core, and as such it is automatically registered in the dependency injection system.\nCorsPolicyName\nName of the CORS policy that will be evaluated for CORS requests into IdentityServer. Defaults to IdentityServer. The policy provider that handles this is implemented in terms of the ICorsPolicyService registered in the dependency injection system. If you wish to customize the set of CORS origins allowed to connect, then it is recommended that you provide a custom implementation of ICorsPolicyService.\nCorsPaths\nThe endpoints within IdentityServer where CORS is supported. Defaults to the discovery, user info, token, and revocation endpoints.\nPreflightCacheDuration\nIndicates the value to be used in the preflight Access-Control-Max-Age response header. Defaults to null indicating no caching header is set on the response.\nContent Security Policy Settings for Content Security Policy (CSP) headers that IdentityServer emits. Available on the Csp property of the IdentityServerOptions object.\nLevel\nThe level of CSP to use. CSP Level 2 is used by default, but this can be changed to CspLevel.One to accommodate older browsers.\nAddDeprecatedHeader\nIndicates if the older X-Content-Security-Policy CSP header should also be emitted in addition to the standards-based header value. Defaults to true.\nDevice Flow OAuth device flow settings. Available on the DeviceFlow property of the IdentityServerOptions object.\nDefaultUserCodeType\nThe user code type to use, unless set at the client level. Defaults to Numeric, a 9-digit code.\nInterval\nThe maximum frequency in seconds that a client may poll the token endpoint in the device flow. Defaults to 5.\nMutual TLS Mutual TLS settings. Available on the MutualTls property of the IdentityServerOptions object.\nvar builder = services.AddIdentityServer(options =\u0026gt; { options.MutualTls.Enabled = true; // use mtls sub-domain options.MutualTls.DomainName = \u0026#34;mtls\u0026#34;; options.MutualTls.AlwaysEmitConfirmationClaim = true; }) Enabled\nSpecifies if MTLS support should be enabled. Defaults to false.\nClientCertificateAuthenticationScheme\nSpecifies the name of the authentication handler for X.509 client certificates. Defaults to Certificate.\nDomainName\nSpecifies either the name of the sub-domain or full domain for running the MTLS endpoints. MTLS will use path-based endpoints if not set (the default). Use a simple string (e.g. \u0026ldquo;mtls\u0026rdquo;) to set a sub-domain, use a full domain name (e.g. \u0026ldquo;identityserver-mtls.io\u0026rdquo;) to set a full domain name. When a full domain name is used, you also need to set the IssuerName to a fixed value.\nAlwaysEmitConfirmationClaim\nSpecifies whether a cnf claim gets emitted for access tokens if a client certificate was present. Normally the cnf claims only gets emitted if the client used the client certificate for authentication, setting this to true, will set the claim regardless of the authentication method. Defaults to false.\nPersistentGrants Shared settings for persisted grants behavior.\nDataProtectData\nData protect the persisted grants \u0026ldquo;data\u0026rdquo; column. Defaults to true. If your database is already protecting data at rest, then you can consider disabling this.\nDeleteOneTimeOnlyRefreshTokensOnUse (added in v6.3)\nWhen Refresh tokens that are configured with RefreshTokenUsage.OneTime are used, this option controls if they will be deleted immediately or retained and marked as consumed. The default is on - immediately delete.\nDynamic Providers Settings for dynamic providers. Available on the DynamicProviders property of the IdentityServerOptions object.\nPathPrefix\nPrefix in the pipeline for callbacks from external providers. Defaults to \u0026ldquo;/federation\u0026rdquo;.\nSignInScheme\nScheme used for signin. Defaults to the constant IdentityServerConstants.ExternalCookieAuthenticationScheme, which has the value \u0026ldquo;idsrv.external\u0026rdquo;.\nSignOutScheme\nScheme for signout. Defaults to the constant IdentityServerConstants.DefaultCookieAuthenticationScheme, which has the value \u0026ldquo;idsrv\u0026rdquo;.\nCIBA CIBA settings. Available on the Ciba property of the IdentityServerOptions object.\nDefaultLifetime\nThe default lifetime of the pending authentication requests in seconds. Defaults to 300.\nDefaultPollingInterval\nThe maximum frequency in seconds that a client may poll the token endpoint in the CIBA flow. Defaults to 5.\nServer-side Sessions Settings for server-side sessions. Added in v6.1. Available on the ServerSideSessions property of the IdentityServerOptions object.\nUserDisplayNameClaimType\nClaim type used for the user\u0026rsquo;s display name. Unset by default due to possible PII concerns. If used, this would commonly be JwtClaimTypes.Name, JwtClaimType.Email or a custom claim.\nRemoveExpiredSessions\nEnables periodic cleanup of expired sessions. Defaults to true.\nRemoveExpiredSessionsFrequency\nFrequency that expired sessions will be removed. Defaults to 10 minutes.\nRemoveExpiredSessionsBatchSize\nNumber of expired session records to be removed at a time. Defaults to 100.\nExpiredSessionsTriggerBackchannelLogout\nIf enabled, when server-side sessions are removed due to expiration, back-channel logout notifications will be sent. This will, in effect, tie a user\u0026rsquo;s session lifetime at a client to their session lifetime at IdentityServer. Defaults to true.\nFuzzExpiredSessionRemovalStart\nThe background session cleanup job runs at a configured interval. If multiple nodes run the cleanup job at the same time update conflicts might occur in the store. To reduce the propability of that happening, the startup time can be fuzzed. The first run is scheduled at a random time between the host startup and the configured RemoveExpiredSessionsFrequency. Subsequent runs are run on the configured RemoveExpiredSessionsFrequency. Defaults to true.\nValidation InvalidRedirectUriPrefixes\nCollection of URI scheme prefixes that should never be used as custom URI schemes in the redirect_uri passed to tha authorize endpoint or the post_logout_redirect_uri passed to the end_session endpoint. Defaults to [\u0026ldquo;javascript:\u0026rdquo;, \u0026ldquo;file:\u0026rdquo;, \u0026ldquo;data:\u0026rdquo;, \u0026ldquo;mailto:\u0026rdquo;, \u0026ldquo;ftp:\u0026rdquo;, \u0026ldquo;blob:\u0026rdquo;, \u0026ldquo;about:\u0026rdquo;, \u0026ldquo;ssh:\u0026rdquo;, \u0026ldquo;tel:\u0026rdquo;, \u0026ldquo;view-source:\u0026rdquo;, \u0026ldquo;ws:\u0026rdquo;, \u0026ldquo;wss:\u0026rdquo;].\nDPoP Added in 6.3.0.\nDemonstration of Proof-of-Possession settings. Available on the DPoP property of the IdentityServerOptions object.\nProofTokenValidityDuration\nDuration that DPoP proof tokens are considered valid. Defaults to 1 minute.\nServerClockSkew\nClock skew used in validating DPoP proof token expiration using a server-generated nonce value. Defaults to 0.\nPushed Authorization Requests Pushed Authorization Requests (PAR) settings. Added in v7.0. Available on the PushedAuthorization property of the IdentityServerOptions object.\nRequired\nCauses PAR to be required globally. Defaults to false.\nLifetime\nControls the lifetime of pushed authorization requests. The pushed authorization request\u0026rsquo;s lifetime begins when the request to the PAR endpoint is received, and is validated until the authorize endpoint returns a response to the client application. Note that user interaction, such as entering credentials or granting consent, may need to occur before the authorize endpoint can do so. Setting the lifetime too low will likely cause login failures for interactive users, if pushed authorization requests expire before those users complete authentication. Some security profiles, such as the FAPI 2.0 Security Profile recommend an expiration within 10 minutes to prevent attackers from pre-generating requests. To balance these constraints, this lifetime defaults to 10 minutes.\nPreview Features Preview Features settings. Available on the Preview property of the IdentityServerOptions object.\nDuende IdentityServer may ship preview features, which can be configured using preview options. Note that preview features can be removed and may break in future releases.\nDiscovery Document Cache In large deployments of Duende IdentityServer, where a lot of concurrent users attempt to consume the discovery endpoint to retrieve metadata about your IdentityServer, you can increase throughput by enabling the discovery document cache preview using the EnableDiscoveryDocumentCache flag. This will cache discovery document information for the duration specified in the DiscoveryDocumentCacheDuration option.\nIt\u0026rsquo;s best to keep the cache time low if you use the CustomEntries element on the discovery document or implement a custom IDiscoveryResponseGenerator.\nStrict Audience Validation When using private key JWT, there is a theoretical vulnerability where a Relying Party trusting multiple OpenID Providers could be attacked if one of the OpenID Providers is malicious or compromised.\nThe OpenID Foundation proposed a two-part fix: strictly validate the audience and set an explicit typ header in the authentication JWT.\nYou can enable strict audience validation in Duende IdentityServer using the StrictClientAssertionAudienceValidation flag, which strictly validates that the audience is equal to the issuer and validates the token\u0026rsquo;s typ header.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/configuration/dcr/installation/",
    "title": "Installation and Hosting",
    "tags": [],
    "description": "",
    "content": "The Configuration API can be installed in a separate host from IdentityServer, or in the same host. In many cases it is desirable to host the configuration API and IdentityServer separately. This facilitates the ability to restrict access to the configuration API at the network level separately from IdentityServer and keeps IdentityServer\u0026rsquo;s access to the configuration data read-only. In other cases, you may find that hosting the two systems together better fits your needs.\nSeparate Host for Configuration API To host the configuration API separately from IdentityServer:\nCreate a new empty web application dotnet new web -n Configuration Add the Duende.IdentityServer.Configuration package cd Configuration dotnet add package Duende.IdentityServer.Configuration Configure Services builder.Services.AddIdentityServerConfiguration(opt =\u0026gt; opt.LicenseKey = \u0026#34;\u0026lt;license\u0026gt;\u0026#34;; ); The Configuration API feature is included in the IdentityServer Business edition license and higher. Use the same license key for IdentityServer and the Configuration API.\nAdd and configure the store implementation The Configuration API uses the IClientConfigurationStore abstraction to persist new clients to the configuration store. Your Configuration API host needs an implementation of this interface. You can either use the built-in Entity Framework based implementation, or implement the interface yourself. See the IClientConfigurationStore reference for more details. If you wish to use the built-in implementation, install its NuGet package and add it to DI.\ndotnet add package Duende.IdentityServer.Configuration.EntityFramework builder.Services.AddIdentityServerConfiguration(opt =\u0026gt; opt.LicenseKey = \u0026#34;\u0026lt;license\u0026gt;\u0026#34; ).AddClientConfigurationStore(); var connectionString = builder.Configuration.GetConnectionString(\u0026#34;DefaultConnection\u0026#34;); builder.Services.AddConfigurationDbContext\u0026lt;ConfigurationDbContext\u0026gt;(options =\u0026gt; { options.ConfigureDbContext = builder =\u0026gt; builder.UseSqlite(connectionString); }); Map Configuration Endpoints app.MapDynamicClientRegistration().RequireAuthorization(\u0026#34;DCR\u0026#34;); MapDynamicClientRegistration registers the DCR endpoints and returns an IEndpointConventionBuilder which you can use to define authorization requirements for your DCR endpoint. See Authorization for more details.\nShared Host for Configuration API and IdentityServer To host the configuration API in the same host as IdentityServer:\nAdd the Duende.IdentityServer.Configuration package dotnet add package Duende.IdentityServer.Configuration Add the Configuration API\u0026rsquo;s services to the service collection: builder.Services.AddIdentityServerConfiguration(); Add and configure the store implementation The Configuration API uses the IClientConfigurationStore abstraction to persist new clients to the configuration store. Your Configuration API host needs an implementation of this interface. You can either use the built-in Entity Framework-based implementation, or implement the interface yourself. See the IClientConfigurationStore reference for more details. If you wish to use the built-in implementation, install its NuGet package and add it to DI.\ndotnet add package Duende.IdentityServer.Configuration.EntityFramework builder.Services.AddIdentityServerConfiguration(opt =\u0026gt; opt.LicenseKey = \u0026#34;\u0026lt;license\u0026gt;\u0026#34; ).AddClientConfigurationStore(); var connectionString = builder.Configuration.GetConnectionString(\u0026#34;DefaultConnection\u0026#34;); builder.Services.AddConfigurationDbContext\u0026lt;ConfigurationDbContext\u0026gt;(options =\u0026gt; { options.ConfigureDbContext = builder =\u0026gt; builder.UseSqlite(connectionString); }); Map Configuration Endpoints: app.MapDynamicClientRegistration().RequireAuthorization(\u0026#34;DCR\u0026#34;); MapDynamicClientRegistration registers the DCR endpoints and returns an IEndpointConventionBuilder which you can use to define authorization requirements for your DCR endpoint. See Authorization for more details.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/ui/login/",
    "title": "Login",
    "tags": [],
    "description": "",
    "content": "Login Page The login page is responsible for establishing the user\u0026rsquo;s authentication session. This requires a user to present credentials and typically involves these steps:\nProvide the user with a page to allow them to enter credentials locally, use an external login provider, or use some other means of authenticating. Start the session by creating the authentication session cookie in your IdentityServer. If the login is client initiated, redirect the user back to the client. When IdentityServer needs to show the login page, it redirects the user to a configurable LoginUrl.\nbuilder.Services.AddIdentityServer(opt =\u0026gt; { opt.UserInteraction.LoginUrl = \u0026#34;/path/to/login\u0026#34;; }) If no LoginUrl is set, IdentityServer will infer it from the LoginPath of your Cookie Authentication Handler. For example:\nbuilder.Services.AddAuthentication() .AddCookie(\u0026#34;cookie-handler-with-custom-path\u0026#34;, options =\u0026gt; { options.LoginPath = \u0026#34;/path/to/login/from/cookie/handler\u0026#34;; }) If you are using ASP.NET Identity, configure its cookie authentication handler like this:\nbuilder.Services .AddIdentityServer() .AddAspNetIdentity\u0026lt;ApplicationUser\u0026gt;(); builder.Services .ConfigureApplicationCookie(options =\u0026gt; { options.LoginPath = \u0026#34;/path/to/login/for/aspnet_identity\u0026#34;; }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/ui/logout/",
    "title": "Logout",
    "tags": [],
    "description": "",
    "content": "Logout Page The logout page is responsible for terminating the user\u0026rsquo;s authentication session. This is a potentially complicated process and involves these steps:\nEnding the session by removing the authentication session cookie in your IdentityServer. Possibly triggering sign-out in an external provider if an external login was used. Notify all client applications that the user has signed out. If the logout is client initiated, redirect the user back to the client. When IdentityServer needs to show the logout page, it redirects the user to a configurable LogoutUrl.\nbuilder.Services.AddIdentityServer(opt =\u0026gt; { opt.UserInteraction.LogoutUrl = \u0026#34;/path/to/logout\u0026#34;; }) If no LogoutUrl is set, IdentityServer will infer it from the LogoutPath of your Cookie Authentication Handler. For example:\nbuilder.Services.AddAuthentication() .AddCookie(\u0026#34;cookie-handler-with-custom-path\u0026#34;, options =\u0026gt; { options.LogoutPath = \u0026#34;/path/to/logout/from/cookie/handler\u0026#34;; }) If you are using ASP.NET Identity, configure its cookie authentication handler like this:\nbuilder.Services .AddIdentityServer() .AddAspNetIdentity\u0026lt;ApplicationUser\u0026gt;(); builder.Services .ConfigureApplicationCookie(options =\u0026gt; { options.LogoutPath = \u0026#34;/path/to/logout/for/aspnet_identity\u0026#34;; }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/ui/logout/logout_context/",
    "title": "Logout Context",
    "tags": [],
    "description": "",
    "content": "To correctly perform all the steps for logout, your logout page needs contextual information about the user\u0026rsquo;s session and the client that initiated logout request. This information is provided by the LogoutRequest class and will provide your logout page data needed for the logout workflow.\nAccessing the LogoutRequest and the logoutId The logout page can be triggered in different ways:\nClient Initiated Logout (protocol) External Provider Logout Notification (protocol) Direct User Access (non-protocol) If the logout page is being triggered by a protocol workflow, then this means Duende IdentityServer has redirected the user\u0026rsquo;s browser to the logout page. In these scenarios, a logoutId parameter will be passed that represents the logout context. The logoutId value can be exchanged with the GetLogoutContextAsync API on the interaction service to obtain a LogoutRequest object.\nIf the page is directly accessed by the user then there will be no logoutId parameter, but the context can still be accessed by calling GetLogoutContextAsync just without passing any parameters.\nIn either case, the LogoutRequest contains the data to perform client notification, and redirect the user back to the client after logout.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/troubleshooting/wilson/",
    "title": "Microsoft.IdentityModel.* versions",
    "tags": [],
    "description": "",
    "content": "Duende IdentityServer, the Microsoft external authentication handlers and other libraries all use the Microsoft.IdentityModel set of libraries. These libraries provides token and configuration handling features. The functionality is split up between different libraries and they all need to be exactly the same version. However this is not enforced by Nuget so it is common to end up with an application that brings in different versions of Microsoft.IdentityModel.* through transitive dependencies.\nKnown Errors Errors that we have seen because of IdentityModel version mismatches include:\nIDX10500: Signature validation failed. No security keys were provided to validate the signature. System.MissingMethodException: Method not found \u0026lsquo;Boolean Microsoft.IdentityModel.Tokens.TokenUtilities.IsRecoverableConfiguration(\u0026hellip;)\u0026rsquo; Microsoft.AspNetCore.Authentication.AuthenticationFailureException: An error was encountered while handling the remote login. \u0026mdash;\u0026gt; System.InvalidOperationException: An invalid request URI was provided. Either the request URI must be an absolute URI or BaseAddress must be set. Diagnosing Run this command in powershell: dotnet list package --include-transitive | sls \u0026quot;Microsoft.IdentityModel|System.IdentityModel\u0026quot;\nThe output should look something like this:\n\u0026gt; Microsoft.IdentityModel.Abstractions 7.4.0 \u0026gt; Microsoft.IdentityModel.JsonWebTokens 7.4.0 \u0026gt; Microsoft.IdentityModel.Logging 7.4.0 \u0026gt; Microsoft.IdentityModel.Protocols 7.0.3 \u0026gt; Microsoft.IdentityModel.Protocols.OpenIdConnect 7.0.3 \u0026gt; Microsoft.IdentityModel.Tokens 7.4.0 \u0026gt; System.IdentityModel.Tokens.Jwt 7.0.3 In the above example it is clear that there are different versions active.\nFixing To fix this, add explicit package references to upgrade the packages that are of lower version to the most recent version used.\n\u0026lt;PackageReference Include=\u0026#34;Microsoft.IdentityModel.Protocols\u0026#34; Version=\u0026#34;7.4.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.IdentityModel.Protocols.OpenIdConnect\u0026#34; Version=\u0026#34;7.4.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;System.IdentityModel.Tokens.Jwt\u0026#34; Version=\u0026#34;7.4.0\u0026#34; /\u0026gt; "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/tokens/pop/mtls/",
    "title": "Mutual TLS",
    "tags": [],
    "description": "",
    "content": "Proof-of-possession using Mutual TLS RFC 8705 specifies how to bind a TLS client certificate to an access token. With this method your IdentityServer will embed the SHA-256 thumbprint of the X.509 client certificate into the access token via the cnf claim, e.g.:\n{ // rest omitted \u0026#34;cnf\u0026#34;: { \u0026#34;x5t#S256\u0026#34;: \u0026#34;bwcK0esc3ACC3DB2Y5_lESsXE8o9ltc05O89jdN-dg2\u0026#34; } } This is done automatically if you authenticate the client using a TLS client certificate.\nThe client must then use the same client certificate to call the APIs, and your APIs can validate the cnf claim by comparing it to the thumbprint of the client certificate on the TLS channel.\nIf the access token would leak, it cannot be replayed without having access to the additional private key of the X.509 client certificate.\nCombine TLS proof-of-possession with other authentication methods It is not mandatory to authenticate your clients with a client certificate to get the benefit of proof-of-possession. You can combine this feature with an arbitrary client authentication method - or even no client authentication at all (e.g. for public mobile/native clients).\nIn this scenario, the client would create an X.509 certificate on the fly, and use that to establish the TLS channel to your IdentityServer. As long as the certificate is accepted by your web server, your IdentityServer can embed the cnf claim, and your APIs can validate it.\n.NET Client In .NET it is straight-forward to create an X.509 certificate on the fly and use it to open a TLS connection.\nstatic X509Certificate2 CreateClientCertificate(string name) { X500DistinguishedName distinguishedName = new X500DistinguishedName($\u0026#34;CN={name}\u0026#34;); using (RSA rsa = RSA.Create(2048)) { var request = new CertificateRequest(distinguishedName, rsa, HashAlgorithmName.SHA256,RSASignaturePadding.Pkcs1); request.CertificateExtensions.Add( new X509KeyUsageExtension( X509KeyUsageFlags.DataEncipherment | X509KeyUsageFlags.KeyEncipherment | X509KeyUsageFlags.DigitalSignature , false)); request.CertificateExtensions.Add( new X509EnhancedKeyUsageExtension( new OidCollection { new Oid(\u0026#34;1.3.6.1.5.5.7.3.2\u0026#34;) }, false)); return request.CreateSelfSigned( new DateTimeOffset(DateTime.UtcNow.AddDays(-1)), new DateTimeOffset(DateTime.UtcNow.AddDays(10))); } } Then use this client certificate on the TLS channel to request the token:\nstatic async Task\u0026lt;TokenResponse\u0026gt; RequestTokenAsync() { var client = new HttpClient(GetHandler(ClientCertificate)); var disco = await client.GetDiscoveryDocumentAsync(\u0026#34;https://demo.duendesoftware.com\u0026#34;); if (disco.IsError) throw new Exception(disco.Error); var response = await client.RequestClientCredentialsTokenAsync(new ClientCredentialsTokenRequest { Address = disco.MtlsEndpointAliases.TokenEndpoint, ClientId = \u0026#34;client\u0026#34;, Scope = \u0026#34;api1\u0026#34; }); if (response.IsError) throw new Exception(response.Error); return response; } static SocketsHttpHandler GetHandler(X509Certificate2 certificate) { var handler = new SocketsHttpHandler(); handler.SslOptions.ClientCertificates = new X509CertificateCollection { certificate }; return handler; } Enabling support in your IdentityServer The last step is to enable that feature in the options:\nvar idsvrBuilder = builder.Services.AddIdentityServer(options =\u0026gt; { // other settings options.MutualTls.AlwaysEmitConfirmationClaim = true; }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/efoptions/operational/",
    "title": "Operational Options",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.EntityFramework.Options.OperationalStoreOptions These options are configurable when using the Entity Framework Core for the operational store:\nYou set the options at startup time in your AddOperationalStore method:\nbuilder.Services.AddIdentityServer() .AddOperationalStore(options =\u0026gt; { // configure options here.. }) Pooling Settings that affect the DbContext pooling feature of Entity Framework Core.\nEnablePooling\nGets or set if EF DbContext pooling is enabled. Defaults to false.\nPoolSize\nGets or set the pool size to use when DbContext pooling is enabled. If not set, the EF default is used.\nSchema Settings that affect the database schema and table names.\nDefaultSchema\nGets or sets the default schema. Defaults to null.\nTableConfiguration settings for each individual table (schema and name) managed by this feature:\nPersistedGrants DeviceFlowCodes Keys ServerSideSessions Persisted Grants Cleanup Settings that affect the background cleanup of expired entries (tokens) from the persisted grants table.\nEnableTokenCleanup\nGets or sets a value indicating whether stale entries will be automatically cleaned up from the database. This is implemented by periodically connecting to the database (according to the TokenCleanupInterval) from the hosting application. Defaults to false.\nRemoveConsumedTokens\nGets or sets a value indicating whether consumed tokens will included in the automatic clean up. Defaults to false.\nTokenCleanupInterval\nGets or sets the token cleanup interval (in seconds). The default is 3600 (1 hour).\nTokenCleanupBatchSize\nGets or sets the number of records to remove at a time. Defaults to 100.\nFuzzTokenCleanupStart\nThe background token cleanup job runs at a configured interval. If multiple nodes run the cleanup job at the same time there will be updated conflicts in the store. To avoid that, the startup time can be fuzzed. The first run is scheduled at a random time between the host startup and the configured TokenCleanupInterval. Subsequent runs are run on the configured TokenCleanupInterval. Defaults to true\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/ui/server_side_sessions/session_management/",
    "title": "Session Management",
    "tags": [],
    "description": "Server Side Sessions",
    "content": "When using server-side sessions, there is a record of the user\u0026rsquo;s authentication activity at IdentityServer. This allows administrative and management tooling to be built on top of that data to query those sessions, as well as terminate them. In addition, since the session data has its own unique id and tracks clients that a user has used, then some types of tokens issued to these clients can be revoked. Finally, if clients support back-channel logout, then they can be notified that a user\u0026rsquo;s session has been terminated, which allows them to also terminate the user\u0026rsquo;s session within the client application.\nThese features are all provided via the ISessionManagementService service.\nISessionManagementService The session management service provides administrative operations for querying and revoking the server-side sessions.\nQuickstart UI The Quickstart UI contains a simple administrative page (under the \u0026ldquo;ServerSideSessions\u0026rdquo; folder) that uses the ISessionManagementService API.\nThe Quickstart session administrative page requires a logged in user to manage sessions. We strongly recommend that you add additional authorization suitable to your organization by adding an authorization policy.\nThe session management page looks like this by default, but of course you are free to customize or change it as needed:\nQuerying sessions Use the QuerySessionsAsync API to access a paged list of user sessions. You can optionally filter on a user\u0026rsquo;s claims mentioned above (subject identifier, session identifier, and/or display name).\nFor example:\nvar userSessions = await _sessionManagementService.QuerySessionsAsync(new SessionQuery { CountRequested = 10, SubjectId = \u0026#34;12345\u0026#34;, DisplayName = \u0026#34;Bob\u0026#34;, }); The results returned contains the matching users\u0026rsquo; session data, as well as paging information (depending if the store and backing database supports certain features such as total count and current page number).\nThis paging information contains a ResultsToken and allows subsequent requests for next or previous pages (set RequestPriorResults to true for the previous page, otherwise the next page is assumed):\n// this requests the first page var userSessions = await _sessionManagementService.QuerySessionsAsync(new SessionQuery { CountRequested = 10, }); // this requests the next page relative to the previous results userSessions = await _sessionManagementService.QuerySessionsAsync(new SessionQuery { ResultsToken = userSessions.ResultsToken, CountRequested = 10, }); // this requests the prior page relative to the previous results userSessions = await _sessionManagementService.QuerySessionsAsync(new SessionQuery { ResultsToken = userSessions.ResultsToken, RequestPriorResults = true, CountRequested = 10, }); Terminating sessions To terminate session(s) for a user, use the RemoveSessionsAsync API. This accepts a RemoveSessionsContext which can filter on the subject and/or the session identifier to terminate. It then also has flags for what to terminate or revoke. This allows deleting a user\u0026rsquo;s session record in the store, any associated tokens or consents in the operational database, and/or notifying any clients via back-channel logout that the user\u0026rsquo;s session has ended. There is also a list of client identifiers to control which clients are affected.\nAn example to revoke everything for current sessions for subject id 12345 might be:\nawait _sessionManagementService.RemoveSessionsAsync(new RemoveSessionsContext { SubjectId = \u0026#34;12345\u0026#34; }); Or to just revoke all refresh tokens for current sessions for subject id 12345 might be:\nawait _sessionManagementService.RemoveSessionsAsync(new RemoveSessionsContext { SubjectId = \u0026#34;12345\u0026#34;, RevokeTokens = true, RemoveServerSideSession = false, RevokeConsents = false, SendBackchannelLogoutNotification = false, }); Internally this uses the IServerSideTicketStore, IPersistedGrantStore and IBackChannelLogoutService features from IdentityServer.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/configuration/dcr/reference/validation/",
    "title": "Validation",
    "tags": [],
    "description": "DCR Reference",
    "content": "IDynamicClientRegistrationValidator The IDynamicClientRegistrationValidator is the contract for the service that validates a dynamic client registration request. It contains a single ValidateAsync(\u0026hellip;) method.\nConceptually, the validation step is responsible for checking the validity of the metadata supplied in the registration request, and using that metadata to set properties of a Client model. In contrast, the IDynamicClientRegistrationRequestProcessor is responsible for setting properties on the Client model that are generated by the Configuration API itself.\nIDynamicClientRegistrationValidator.ValidateAsync Validates a dynamic client registration request.\npublic Task\u0026lt;IDynamicClientRegistrationValidationResult\u0026gt; ValidateAsync( DynamicClientRegistrationContext context) parameter description context Contextual information about the DCR request. Return Value A task that returns an IDynamicClientRegistrationValidationResult, indicating success or failure.\nDynamicClientRegistrationValidator public class DynamicClientRegistrationValidator : IDynamicClientRegistrationValidator The DynamicClientRegistrationValidator class is the default implementation of the IDynamicClientRegistrationValidator. If you need to customize some aspect of Dynamic Client Registration validation, we recommend that you extend this class and override the appropriate methods.\nValidation Steps Each of these methods represents one step in the validation process. Each step is passed a DynamicClientRegistrationContext and returns a task that returns an IStepResult. The DynamicClientRegistrationContext includes the client model that will have its properties set, the DCR request, and other contextual information. The IStepResult either represents that the step succeeded or failed.\nThe steps are invoked in the same order as they appear in this table.\nname description ValidateSoftwareStatementAsync(…) Validates the software statement of the request. The default implementation does nothing, and is included as an extension point. SetGrantTypesAsync(…) Validates requested grant types and uses them to set the allowed grant types of the client. SetRedirectUrisAsync(…) Validates requested redirect uris and uses them to set the redirect uris of the client. SetScopesAsync(…) Validates requested scopes and uses them to set the scopes of the client. SetDefaultScopes(…) Sets scopes on the client when no scopes are requested. The default implementation sets no scopes and is intended as an extension point. SetSecretsAsync(…) Validates the requested jwks to set the secrets of the client. SetClientNameAsync(…) Validates the requested client name uses it to set the name of the client. SetLogoutParametersAsync(…) Validates the requested client parameters related to logout and uses them to set the corresponding properties in the client. Those parameters include the post logout redirect uris, front channel and back channel uris, and flags for the front and back channel uris indicating if they require session ids. SetMaxAgeAsync(…) Validates the requested default max age and uses it to set the user sso lifetime of the client. SetUserInterfaceProperties(…) Validates details of the request that control the user interface, including the logo uri, client uri, initiate login uri, enable local login flag, and identity provider restrictions, and uses them to set the corresponding client properties. SetPublicClientProperties(…) Validates the requested client parameters related to public clients and uses them to set the corresponding properties in the client. Those parameters include the require client secret flag and the allowed cors origins. SetAccessTokenProperties(…) Validates the requested client parameters related to access tokens and uses them to set the corresponding properties in the client. Those parameters include the allowed access token type and access token lifetime. SetIdTokenProperties(…) Validates the requested client parameters related to id tokens and uses them to set the corresponding properties in the client. Those parameters include the id token lifetime and the allowed id token signing algorithms. SetServerSideSessionProperties(…) Validates the requested client parameters related to server side sessions and uses them to set the corresponding properties in the client. Those parameters include the coordinate lifetime with user session flag. "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/efoptions/",
    "title": "EF Options",
    "tags": [],
    "description": "",
    "content": "Entity Framework Core Options If using the Entity Framework Core store implementation, you might need to configure those specific options.\nOperational Options Configuration Options "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/quickstarts/7_blazor/",
    "title": "Building Blazor WASM client applications",
    "tags": [],
    "description": "",
    "content": "Similar to JavaScript SPAs, you can build Blazor WASM applications with and without a backend. Not having a backend has all the security disadvantages we discussed already in the JavaScript quickstart.\nIf you are building Blazor WASM apps that do not deal with sensitive data and you want to use the no-backend approach, have a look at the standard Microsoft templates, which are using this style.\nIn this quickstart we will focus on how to build a Blazor WASM application using our Duende.BFF security framework. You can find the full source code here\nTo keep things simple, we will utilize our demo IdentityServer instance hosted at https://demo.duendesoftware.com. We will provide more details on how to configure a Blazor client in your own IdentityServer at then end.\nSetting up the project The .NET 6 CLI includes a Blazor WASM with backend template. Create the directory where you want to work in, and run the following command:\ndotnet new blazorwasm --hosted This will create three projects - server, client and shared.\nConfiguring the backend First add the following package references to the server project:\n\u0026lt;PackageReference Include=\u0026#34;Microsoft.AspNetCore.Authentication.OpenIdConnect\u0026#34; Version=\u0026#34;6.0.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Duende.BFF\u0026#34; Version=\u0026#34;1.1.0\u0026#34; /\u0026gt; Next, we will add OpenID Connect and OAuth support to the backend. For this we are adding the Microsoft OpenID Connect authentication handler for the protocol interactions with the token service, and the cookie authentication handler for managing the resulting authentication session. See here for more background information.\nThe BFF services provide the logic to invoke the authentication plumbing from the frontend (more about this later).\nAdd the following snippet to your Program.cs above the call to builder.Build();\nbuilder.Services.AddBff(); builder.Services.AddAuthentication(options =\u0026gt; { options.DefaultScheme = \u0026#34;cookie\u0026#34;; options.DefaultChallengeScheme = \u0026#34;oidc\u0026#34;; options.DefaultSignOutScheme = \u0026#34;oidc\u0026#34;; }) .AddCookie(\u0026#34;cookie\u0026#34;, options =\u0026gt; { options.Cookie.Name = \u0026#34;__Host-blazor\u0026#34;; options.Cookie.SameSite = SameSiteMode.Strict; }) .AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { options.Authority = \u0026#34;https://demo.duendesoftware.com\u0026#34;; options.ClientId = \u0026#34;interactive.confidential\u0026#34;; options.ClientSecret = \u0026#34;secret\u0026#34;; options.ResponseType = \u0026#34;code\u0026#34;; options.ResponseMode = \u0026#34;query\u0026#34;; options.Scope.Clear(); options.Scope.Add(\u0026#34;openid\u0026#34;); options.Scope.Add(\u0026#34;profile\u0026#34;); options.Scope.Add(\u0026#34;api\u0026#34;); options.Scope.Add(\u0026#34;offline_access\u0026#34;); options.MapInboundClaims = false; options.GetClaimsFromUserInfoEndpoint = true; options.SaveTokens = true; }); The last step is to add the required middleware for authentication, authorization and BFF session management. Add the following snippet after the call to UseRouting:\napp.UseAuthentication(); app.UseBff(); app.UseAuthorization(); app.MapBffManagementEndpoints(); Finally you can run the server project. This will start the host, which will in turn deploy the Blazor application to your browser.\nTry to manually invoke the BFF login endpoint on /bff/login - this should bring you to the demo IdentityServer. After login (e.g. using bob/bob), the browser will return to the Blazor application.\nIn other words, the fundamental authentication plumbing is already working. Now we need to make the frontend aware of it.\nModifying the frontend (part 1) A couple of steps are necessary to add the security and identity plumbing to a Blazor application.\na) Add the authentication/authorization related package to the client project file:\n\u0026lt;PackageReference Include=\u0026#34;Microsoft.AspNetCore.Components.WebAssembly.Authentication\u0026#34; Version=\u0026#34;6.0.0\u0026#34; /\u0026gt; b) Add a using statement to _Imports.razor to bring the above package in scope:\n@using Microsoft.AspNetCore.Components.Authorization c) To propagate the current authentication state to all pages in your Blazor client, you add a special component called CascadingAuthenticationState to your application. This is done by wrapping the Blazor router with that component in App.razor:\n\u0026lt;CascadingAuthenticationState\u0026gt; \u0026lt;Router AppAssembly=\u0026#34;@typeof(App).Assembly\u0026#34;\u0026gt; \u0026lt;Found Context=\u0026#34;routeData\u0026#34;\u0026gt; \u0026lt;RouteView RouteData=\u0026#34;@routeData\u0026#34; DefaultLayout=\u0026#34;@typeof(MainLayout)\u0026#34;/\u0026gt; \u0026lt;FocusOnNavigate RouteData=\u0026#34;@routeData\u0026#34; Selector=\u0026#34;h1\u0026#34;/\u0026gt; \u0026lt;/Found\u0026gt; \u0026lt;NotFound\u0026gt; \u0026lt;PageTitle\u0026gt;Not found\u0026lt;/PageTitle\u0026gt; \u0026lt;LayoutView Layout=\u0026#34;@typeof(MainLayout)\u0026#34;\u0026gt; \u0026lt;p role=\u0026#34;alert\u0026#34;\u0026gt;Sorry, there\u0026#39;s nothing at this address.\u0026lt;/p\u0026gt; \u0026lt;/LayoutView\u0026gt; \u0026lt;/NotFound\u0026gt; \u0026lt;/Router\u0026gt; \u0026lt;/CascadingAuthenticationState\u0026gt; d) Last but not least, we will add some conditional rendering to the layout page to be able to trigger login/logout as well as displaying the current user name when logged in. This is achieved by using the AuthorizeView component in MainLayout.razor:\n\u0026lt;div class=\u0026#34;page\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;sidebar\u0026#34;\u0026gt; \u0026lt;NavMenu /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;top-row px-4\u0026#34;\u0026gt; \u0026lt;AuthorizeView\u0026gt; \u0026lt;Authorized\u0026gt; \u0026lt;strong\u0026gt;Hello, @context.User.Identity.Name!\u0026lt;/strong\u0026gt; \u0026lt;a href=\u0026#34;@context.User.FindFirst(\u0026#34;bff:logout_url\u0026#34;)?.Value\u0026#34;\u0026gt;Log out\u0026lt;/a\u0026gt; \u0026lt;/Authorized\u0026gt; \u0026lt;NotAuthorized\u0026gt; \u0026lt;a href=\u0026#34;bff/login\u0026#34;\u0026gt;Log in\u0026lt;/a\u0026gt; \u0026lt;/NotAuthorized\u0026gt; \u0026lt;/AuthorizeView\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content px-4\u0026#34;\u0026gt; @Body \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; When you now run the Blazor application, you will see the following error in your browser console:\ncrit: Microsoft.AspNetCore.Components.WebAssembly.Rendering.WebAssemblyRenderer[100] Unhandled exception rendering component: Cannot provide a value for property \u0026#39;AuthenticationStateProvider\u0026#39; on type \u0026#39;Microsoft.AspNetCore.Components.Authorization.CascadingAuthenticationState\u0026#39;. There is no registered service of type \u0026#39;Microsoft.AspNetCore.Components.Authorization.AuthenticationStateProvider\u0026#39;. CascadingAuthenticationState is an abstraction over an arbitrary authentication system. It internally relies on a service called AuthenticationStateProvider to return the required information about the current authentication state and the information about the currently logged on user.\nThis component needs to be implemented, and that\u0026rsquo;s what we\u0026rsquo;ll do next.\nModifying the frontend (part 2) The BFF library has a server-side component that allows querying the current authentication session and state (see here). We will now add a Blazor AuthenticationStateProvider that will internally use this endpoint.\nAdd a file with the following content:\nusing System.Net; using System.Net.Http.Json; using System.Security.Claims; using Microsoft.AspNetCore.Components.Authorization; namespace Blazor6.Client.BFF; public class BffAuthenticationStateProvider : AuthenticationStateProvider { private static readonly TimeSpan UserCacheRefreshInterval = TimeSpan.FromSeconds(60); private readonly HttpClient _client; private readonly ILogger\u0026lt;BffAuthenticationStateProvider\u0026gt; _logger; private DateTimeOffset _userLastCheck = DateTimeOffset.FromUnixTimeSeconds(0); private ClaimsPrincipal _cachedUser = new ClaimsPrincipal(new ClaimsIdentity()); public BffAuthenticationStateProvider( HttpClient client, ILogger\u0026lt;BffAuthenticationStateProvider\u0026gt; logger) { _client = client; _logger = logger; } public override async Task\u0026lt;AuthenticationState\u0026gt; GetAuthenticationStateAsync() { return new AuthenticationState(await GetUser()); } private async ValueTask\u0026lt;ClaimsPrincipal\u0026gt; GetUser(bool useCache = true) { var now = DateTimeOffset.Now; if (useCache \u0026amp;\u0026amp; now \u0026lt; _userLastCheck + UserCacheRefreshInterval) { _logger.LogDebug(\u0026#34;Taking user from cache\u0026#34;); return _cachedUser; } _logger.LogDebug(\u0026#34;Fetching user\u0026#34;); _cachedUser = await FetchUser(); _userLastCheck = now; return _cachedUser; } record ClaimRecord(string Type, object Value); private async Task\u0026lt;ClaimsPrincipal\u0026gt; FetchUser() { try { _logger.LogInformation(\u0026#34;Fetching user information.\u0026#34;); var response = await _client.GetAsync(\u0026#34;bff/user?slide=false\u0026#34;); if (response.StatusCode == HttpStatusCode.OK) { var claims = await response.Content.ReadFromJsonAsync\u0026lt;List\u0026lt;ClaimRecord\u0026gt;\u0026gt;(); var identity = new ClaimsIdentity( nameof(BffAuthenticationStateProvider), \u0026#34;name\u0026#34;, \u0026#34;role\u0026#34;); foreach (var claim in claims) { identity.AddClaim(new Claim(claim.Type, claim.Value.ToString())); } return new ClaimsPrincipal(identity); } } catch (Exception ex) { _logger.LogWarning(ex, \u0026#34;Fetching user failed.\u0026#34;); } return new ClaimsPrincipal(new ClaimsIdentity()); } } ..and register it in the client\u0026rsquo;s Program.cs:\nbuilder.Services.AddAuthorizationCore(); builder.Services.AddScoped\u0026lt;AuthenticationStateProvider, BffAuthenticationStateProvider\u0026gt;(); If you run the server app now again, you will see a different error:\nfail: Duende.Bff.Endpoints.BffMiddleware[1] Anti-forgery validation failed. local path: \u0026#39;/bff/user\u0026#39; This is due to the antiforgery protection that is applied automatically to the management endpoints in the BFF host. To properly secure the call, you need to add a static X-CSRF header to the call. See here for more background information.\nThis can be easily accomplished by a delegating handler that can be plugged into the default HTTP client used by the Blazor frontend. Let\u0026rsquo;s first add the handler:\npublic class AntiforgeryHandler : DelegatingHandler { protected override Task\u0026lt;HttpResponseMessage\u0026gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken) { request.Headers.Add(\u0026#34;X-CSRF\u0026#34;, \u0026#34;1\u0026#34;); return base.SendAsync(request, cancellationToken); } } ..and register it in the client\u0026rsquo;s Program.cs (overriding the standard HTTP client configuration; requires package Microsoft.Extensions.Http):\n// HTTP client configuration builder.Services.AddTransient\u0026lt;AntiforgeryHandler\u0026gt;(); builder.Services.AddHttpClient(\u0026#34;backend\u0026#34;, client =\u0026gt; client.BaseAddress = new Uri(builder.HostEnvironment.BaseAddress)) .AddHttpMessageHandler\u0026lt;AntiforgeryHandler\u0026gt;(); builder.Services.AddTransient(sp =\u0026gt; sp.GetRequiredService\u0026lt;IHttpClientFactory\u0026gt;().CreateClient(\u0026#34;backend\u0026#34;)); This requires an additional reference in the client project:\n\u0026lt;PackageReference Include=\u0026#34;Microsoft.Extensions.Http\u0026#34; Version=\u0026#34;6.0.0\u0026#34; /\u0026gt; If you restart the application again, the logon/logoff logic should work now. In addition you can display the contents of the session on the main page by adding this code to Index.razor:\n@page \u0026#34;/\u0026#34; \u0026lt;PageTitle\u0026gt;Home\u0026lt;/PageTitle\u0026gt; \u0026lt;h1\u0026gt;Hello, Blazor BFF!\u0026lt;/h1\u0026gt; \u0026lt;AuthorizeView\u0026gt; \u0026lt;Authorized\u0026gt; \u0026lt;dl\u0026gt; @foreach (var claim in @context.User.Claims) { \u0026lt;dt\u0026gt;@claim.Type\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;@claim.Value\u0026lt;/dd\u0026gt; } \u0026lt;/dl\u0026gt; \u0026lt;/Authorized\u0026gt; \u0026lt;/AuthorizeView\u0026gt; Securing the local API The standard Blazor template contains an API endpoint (WeatherForecastController.cs). Try invoking the weather page from the UI. It works both in logged in and anonymous state. We want to change the code to make sure, that only authenticated users can call the API.\nThe standard way in ASP.NET Core would be to add an authorization requirement to the endpoint, either on the controller/action or via the endpoint routing, e.g.:\napp.MapControllers() .RequireAuthorization(); When you now try to invoke the API anonymously, you will see the following error in the browser console:\nAccess to fetch at \u0026#39;https://demo.duendesoftware.com/connect/authorize?client_id=...[shortened]... (redirected from \u0026#39;https://localhost:5002/WeatherForecast\u0026#39;) from origin \u0026#39;https://localhost:5002\u0026#39; has been blocked by CORS policy: Response to preflight request doesn\u0026#39;t pass access control check: No \u0026#39;Access-Control-Allow-Origin\u0026#39; header is present on the requested resource. If an opaque response serves your needs, set the request\u0026#39;s mode to \u0026#39;no-cors\u0026#39; to fetch the resource with CORS disabled. This happens because the ASP.NET Core authentication plumbing is triggering a redirect to the OpenID Connect provider for authentication. What we really want in that case is an API friendly status code - 401 in this scenario.\nThis is one of the features of the BFF middleware, but you need to mark the endpoint as a BFF API endpoint for that to take effect:\napp.MapControllers() .RequireAuthorization() .AsBffApiEndpoint(); After making this change, you should see a much better error message:\nResponse status code does not indicate success: 401 (Unauthorized). The client code can properly respond to this, e.g. triggering a login redirect.\nWhen you logon now and call the API, you can put a breakpoint server-side and inspect that the API controller has access to the claims of the authenticated user via the .User property.\nSetting up a Blazor BFF client in IdentityServer In essence a BFF client is \u0026ldquo;just\u0026rdquo; a normal authorization code flow client:\nuse the code grant type set a client secret enable AllowOfflineAccess if you want to use refresh tokens enable the required identity and resource scopes set the redirect URIs for the OIDC handler Below is a typical code snippet for the client definition:\nvar bffClient = new Client { ClientId = \u0026#34;bff\u0026#34;, ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, AllowedGrantTypes = GrantTypes.Code, RedirectUris = { \u0026#34;https://bff_host/signin-oidc\u0026#34; }, FrontChannelLogoutUri = \u0026#34;https://bff_host/signout-oidc\u0026#34;, PostLogoutRedirectUris = { \u0026#34;https://bff_host/signout-callback-oidc\u0026#34; }, AllowOfflineAccess = true, AllowedScopes = { \u0026#34;openid\u0026#34;, \u0026#34;profile\u0026#34;, \u0026#34;remote_api\u0026#34; } }; Further experiments Our Blazor BFF sample is based on this Quickstart. In addition it shows concepts like\nbetter organization with components reacting to logout using the authorize attribute to trigger automatic redirects to the login page "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/fundamentals/",
    "title": "Fundamentals",
    "tags": [],
    "description": "",
    "content": "Fundamentals Hosting Resources Clients Users and Logging In Claims Key Management Licensing "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/apis/add_apis/",
    "title": "Adding API Endpoints to your IdentityServer",
    "tags": [],
    "description": "",
    "content": "It\u0026rsquo;s a common scenario to add additional API endpoints to the application hosting IdentityServer. These endpoints are typically protected by IdentityServer itself.\nFor simple scenarios, we give you some helpers. See the advanced section to understand more of the internal plumbing.\nYou could achieve the same by using either Microsoft\u0026rsquo;s JwtBearer handler. But this requires more configuration and creates dependencies on external libraries that might lead to conflicts in future updates.\nStart by registering your API as an ApiScope, (or resource) e.g.:\nvar scopes = new List\u0026lt;ApiScope\u0026gt; { // local API new ApiScope(IdentityServerConstants.LocalApi.ScopeName), }; ..and give your clients access to this API, e.g.:\nnew Client { // rest omitted AllowedScopes = { IdentityServerConstants.LocalApi.ScopeName }, } The value of IdentityServerConstants.LocalApi.ScopeName is IdentityServerApi.\nTo enable token validation for local APIs, add the following to your IdentityServer startup:\nbuilder.Services.AddLocalApiAuthentication(); To protect an API controller, decorate it with an Authorize attribute using the LocalApi.PolicyName policy:\n[Route(\u0026#34;localApi\u0026#34;)] [Authorize(LocalApi.PolicyName)] public class LocalApiController : ControllerBase { public IActionResult Get() { // omitted } } Authorized clients can then request a token for the IdentityServerApi scope and use it to call the API.\nDiscovery You can also add your endpoints to the discovery document if you want, e.g like this::\nbuilder.Services.AddIdentityServer(options =\u0026gt; { options.Discovery.CustomEntries.Add(\u0026#34;local_api\u0026#34;, \u0026#34;~/localapi\u0026#34;); }) Advanced Under the covers, the AddLocalApiAuthentication helper does a couple of things:\nadds an authentication handler that validates incoming tokens using IdentityServer\u0026rsquo;s built-in token validation engine (the name of this handler is IdentityServerAccessToken or IdentityServerConstants.LocalApi.AuthenticationScheme configures the authentication handler to require a scope claim inside the access token of value IdentityServerApi sets up an authorization policy that checks for a scope claim of value IdentityServerApi This covers the most common scenarios. You can customize this behavior in the following ways:\nAdd the authentication handler yourself by calling services.AddAuthentication().AddLocalApi(\u0026hellip;) this way you can specify the required scope name yourself, or (by specifying no scope at all) accept any token from the current IdentityServer instance Do your own scope validation/authorization in your controllers using custom policies or code, e.g.: builder.Services.AddAuthorization(options =\u0026gt; { options.AddPolicy(IdentityServerConstants.LocalApi.PolicyName, policy =\u0026gt; { policy.AddAuthenticationSchemes(IdentityServerConstants.LocalApi.AuthenticationScheme); policy.RequireAuthenticatedUser(); // custom requirements }); }); Claims Transformation You can provide a callback to transform the claims of the incoming token after validation. Either use the helper method, e.g.:\nbuilder.Services.AddLocalApiAuthentication(principal =\u0026gt; { principal.Identities.First().AddClaim(new Claim(\u0026#34;additional_claim\u0026#34;, \u0026#34;additional_value\u0026#34;)); return Task.FromResult(principal); }); \u0026hellip;or implement the event on the options if you add the authentication handler manually.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/fundamentals/resources/api_scopes/",
    "title": "API Scopes",
    "tags": [],
    "description": "Overview",
    "content": "Designing your API surface can be a complicated task. Duende IdentityServer provides a couple of primitives to help you with that.\nThe original OAuth 2.0 specification has the concept of scopes, which is just defined as the scope of access that the client requests. Technically speaking, the scope parameter is a list of space delimited values - you need to provide the structure and semantics of it.\nIn more complex systems, often the notion of a resource is introduced. This might be e.g. a physical or logical API. In turn each API can potentially have scopes as well. Some scopes might be exclusive to that resource, and some scopes might be shared.\nLet\u0026rsquo;s start with simple scopes first, and then we\u0026rsquo;ll have a look how resources can help structure scopes.\nScopes Let\u0026rsquo;s model something very simple - a system that has three logical operations read, write, and delete.\nYou can define them using the ApiScope class:\npublic static IEnumerable\u0026lt;ApiScope\u0026gt; GetApiScopes() { return new List\u0026lt;ApiScope\u0026gt; { new ApiScope(name: \u0026#34;read\u0026#34;, displayName: \u0026#34;Read your data.\u0026#34;), new ApiScope(name: \u0026#34;write\u0026#34;, displayName: \u0026#34;Write your data.\u0026#34;), new ApiScope(name: \u0026#34;delete\u0026#34;, displayName: \u0026#34;Delete your data.\u0026#34;) }; } You can then assign the scopes to various clients, e.g.:\nvar webViewer = new Client { ClientId = \u0026#34;web_viewer\u0026#34;, AllowedScopes = { \u0026#34;openid\u0026#34;, \u0026#34;profile\u0026#34;, \u0026#34;read\u0026#34; } }; var mobileApp = new Client { ClientId = \u0026#34;mobile_app\u0026#34;, AllowedScopes = { \u0026#34;openid\u0026#34;, \u0026#34;profile\u0026#34;, \u0026#34;read\u0026#34;, \u0026#34;write\u0026#34;, \u0026#34;delete\u0026#34; } } Authorization based on Scopes When a client asks for a scope (and that scope is allowed via configuration and not denied via consent), the value of that scope will be included in the resulting access token as a claim of type scope (for both JWTs and introspection), e.g.:\n{ \u0026#34;typ\u0026#34;: \u0026#34;at+jwt\u0026#34; }. { \u0026#34;client_id\u0026#34;: \u0026#34;mobile_app\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;read write delete\u0026#34; } The format of the scope parameter can be controlled by the EmitScopesAsSpaceDelimitedStringInJwt setting on the options. Historically IdentityServer emitted scopes as an array, but you can switch to a space delimited string instead.\nThe consumer of the access token can use that data to make sure that the client is actually allowed to invoke the corresponding functionality. See the APIs section for more information on protecting APIs with access tokens.\nBe aware, that scopes are purely for authorizing clients, not users. In other words, the write scope allows the client to invoke the functionality associated with the scope and is unrelated to the user\u0026rsquo;s permission to do so. This additional user centric authorization is application logic and not covered by OAuth, yet still possibly important to implement in your API.\nAdding user claims You can add more identity information about the user to the access token. The additional claims added are based on the scope requested. The following scope definition tells the configuration system that when a write scope gets granted the user_level claim should be added to the access token:\nvar writeScope = new ApiScope( name: \u0026#34;write\u0026#34;, displayName: \u0026#34;Write your data.\u0026#34;, userClaims: new[] { \u0026#34;user_level\u0026#34; }); This will pass the user_level claim as a requested claim type to the profile service, so that the consumer of the access token can use this data as input for authorization decisions or business logic.\nWhen using the scope-only model, no aud (audience) claim will be added to the token since this concept does not apply. If you need an aud claim, you can enable the EmitStaticAudienceClaim setting on the options. This will emit an aud claim in the issuer_name/resources format. If you need more control of the aud claim, use API resources.\nParameterized Scopes Sometimes scopes have a certain structure, e.g. a scope name with an additional parameter: transaction:id or read_patient:patientid.\nIn this case you would create a scope without the parameter part and assign that name to a client, but in addition provide some logic to parse the structure of the scope at runtime using the IScopeParser interface or by deriving from our default implementation, e.g.:\npublic class ParameterizedScopeParser : DefaultScopeParser { public ParameterizedScopeParser(ILogger\u0026lt;DefaultScopeParser\u0026gt; logger) : base(logger) { } public override void ParseScopeValue(ParseScopeContext scopeContext) { const string transactionScopeName = \u0026#34;transaction\u0026#34;; const string separator = \u0026#34;:\u0026#34;; const string transactionScopePrefix = transactionScopeName + separator; var scopeValue = scopeContext.RawValue; if (scopeValue.StartsWith(transactionScopePrefix)) { // we get in here with a scope like \u0026#34;transaction:something\u0026#34; var parts = scopeValue.Split(separator, StringSplitOptions.RemoveEmptyEntries); if (parts.Length == 2) { scopeContext.SetParsedValues(transactionScopeName, parts[1]); } else { scopeContext.SetError(\u0026#34;transaction scope missing transaction parameter value\u0026#34;); } } else if (scopeValue != transactionScopeName) { // we get in here with a scope not like \u0026#34;transaction\u0026#34; base.ParseScopeValue(scopeContext); } else { // we get in here with a scope exactly \u0026#34;transaction\u0026#34;, which is to say we\u0026#39;re ignoring it // and not including it in the results scopeContext.SetIgnore(); } } } You then have access to the parsed value throughout the pipeline, e.g. in the profile service:\npublic class HostProfileService : IProfileService { public override async Task GetProfileDataAsync(ProfileDataRequestContext context) { var transaction = context.RequestedResources.ParsedScopes.FirstOrDefault(x =\u0026gt; x.ParsedName == \u0026#34;transaction\u0026#34;); if (transaction?.ParsedParameter != null) { context.IssuedClaims.Add(new Claim(\u0026#34;transaction_id\u0026#34;, transaction.ParsedParameter)); } } } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/deployment/data_protection/",
    "title": "ASP.NET Core Data Protection",
    "tags": [],
    "description": "",
    "content": "Duende IdentityServer makes extensive use of ASP.NET\u0026rsquo;s data protection feature. It is crucial that you configure data protection correctly before you start using your IdentityServer in production.\nIn local development, ASP.NET automatically creates data protection keys, but in a deployed environment, you will need to ensure that your data protection keys are stored in a persistent way and shared across all load balanced instances of your IdentityServer implementation. This means you\u0026rsquo;ll need to choose where to store and how to protect the data protection keys, as appropriate for your environment. Microsoft has extensive documentation here describing how to configure storage and protection of data protection keys.\nA typical IdentityServer implementation should include data protection configuration code, like this:\nbuilder.Services.AddDataProtection() // Choose an extension method for key persistence, such as // PersistKeysToFileSystem, PersistKeysToDbContext, // PersistKeysToAzureBlobStorage, or PersistKeysToAWSSystemsManager .PersistKeysToFoo() // Choose an extension method for key protection, such as // ProtectKeysWithCertificate, ProtectKeysWithAzureKeyVault .ProtectKeysWithBar() // Explicitly set an application name to prevent issues with // key isolation. .SetApplicationName(\u0026#34;IdentityServer\u0026#34;); Data Protection Keys and IdentityServer\u0026rsquo;s Signing Keys ASP.NET\u0026rsquo;s data protection keys are sometimes confused with IdentityServer\u0026rsquo;s signing keys, but the two are completely separate keys with different purposes. IdentityServer implementations need both to function correctly.\nData Protection Keys Data protection is a cryptographic library that is part of the ASP.NET framework. Data protection uses private key cryptography to encrypt and sign sensitive data to ensure that it is only written and read by the application. The framework uses data protection to secure data that is commonly used by IdentityServer implementations, such as authentication cookies and anti-forgery tokens. In addition, IdentityServer itself uses data protection to protect sensitive data at rest, such as persisted grants, as well as sensitive data passed through the browser, such as the context objects passed to pages in the UI. The data protection keys are critical secrets for an IdentityServer implementation because they encrypt a great deal of sensitive data at rest and prevent sensitive data that is roundtripped through the browser from being tampered with.\nIdentityServer Signing Key Separately, IdentityServer needs cryptographic keys, called signing keys, to sign tokens such as JWT access tokens and id tokens. The signing keys use public key cryptography to allow client applications and APIs to validate token signatures using the public keys, which are published by IdentityServer through discovery. The private key component of the signing keys are also critical secrets for IdentityServer because a valid signature provides integrity and non-repudiation guarantees that allow client applications and APIs to trust those tokens.\nCommon Problems Common data protection problems occur when data is protected with a key that is not available when the data is later read. A common symptom is CryptographicExceptions in the IdentityServer logs. For example, when automatic key management fails to read its signing keys due to a data protection failure, IdentityServer will log an error message such as \u0026ldquo;Error unprotecting key with kid {Signing Key ID}.\u0026rdquo;, and log the underlying System.Security.Cryptography.CryptographicException, with a message like \u0026ldquo;The key {Data Protection Key ID} was not found in the key ring.\u0026rdquo;\nFailures to read automatic signing keys are often the first place where a data protection problem manifests, but any of many places where IdentityServer and ASP.NET use data protection might also throw CryptographicExceptions.\nThere are several ways that data protection problems can occur:\nIn load balanced environments, every instance of IdentityServer needs to be configured to share data protection keys. Without shared data protection keys, each load balanced instance will only be able to read the data that it writes. Data protected data could be generated in a development environment and then accidentally included into the build output. This is most commonly the case for automatically managed signing keys that are stored on disk. If you are using automatic signing key management with the default file system based key store, you should exclude the ~/keys directory from source control and make sure keys are not included in your builds. Note that if you are using our Entity Framework based implementation of the operational data stores, then the keys will instead be stored in the database. Data protection creates keys isolated by application name. If you don\u0026rsquo;t specify a name, the content root path of the application will be used. But, beginning in .NET 6.0 Microsoft changed how they handle the path, which can cause data protection keys to break. Their docs on the problem are here, including a work-around where you de-normalize the path. Then, in .NET 7.0, this change was reverted. The solution is always to specify an explicit application name, and if you have old keys that were generated without an explicit application name, you need to set your application name to match the default behavior that produced the keys you want to be able to read. If your IdentityServer is hosted by IIS, special configuration is needed for data protection. In most default deployments, IIS lacks the permissions required to persist data protection keys, and falls back to using an ephemeral key generated every time the site starts up. Microsoft\u0026rsquo;s docs on this issue are here. Identity Server\u0026rsquo;s Usage of Data Protection Duende IdentityServer\u0026rsquo;s features that rely on data protection include\nprotecting signing keys at rest (if automatic key management is used and enabled) protecting persisted grants at rest (if enabled) protecting server-side session data at rest (if enabled) protecting the state parameter for external OIDC providers (if enabled) protecting message payloads sent between pages in the UI (e.g. logout context and error context). session management (because the ASP.NET Core cookie authentication handler requires it) "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/di/",
    "title": "DI Extension Methods",
    "tags": [],
    "description": "",
    "content": "AddIdentityServer return a builder object that provides many extension methods to add IdentityServer specific services to DI. Here\u0026rsquo;s a list grouped by feature areas.\nvar idsvrBuilder = builder.Services.AddIdentityServer(); Many of the fundamental configuration settings can be set on the options. See the IdentityServerOptions reference for more details.\nConfiguration Stores Several convenience methods are provided for registering custom stores:\nAddClientStore\u0026lt;T\u0026gt;\nRegisters a custom IClientStore implementation.\nAddCorsPolicyService\u0026lt;T\u0026gt;\nRegisters a custom ICorsPolicyService implementation.\nAddResourceStore\u0026lt;T\u0026gt;\nRegisters a custom IResourceStore implementation.\nAddIdentityProviderStore\u0026lt;T\u0026gt;\nRegisters a custom IIdentityProviderStore implementation.\nThe in-memory configuration stores can be registered in DI with the following extension methods.\nAddInMemoryClients\nRegisters IClientStore and ICorsPolicyService implementations based on the in-memory collection of Client configuration objects.\nAddInMemoryIdentityResources\nRegisters IResourceStore implementation based on the in-memory collection of IdentityResource configuration objects.\nAddInMemoryApiScopes\nRegisters IResourceStore implementation based on the in-memory collection of ApiScope configuration objects.\nAddInMemoryApiResources\nRegisters IResourceStore implementation based on the in-memory collection of ApiResource configuration objects.\nCaching Configuration Data Extension methods to enable caching for configuration data:\nAddInMemoryCaching\u0026lt;T\u0026gt;\nTo use any of the caches described below, an implementation of ICache\u0026lt;T\u0026gt; must be registered in DI. This API registers a default in-memory implementation of ICache\u0026lt;T\u0026gt; that\u0026rsquo;s based on ASP.NET Core\u0026rsquo;s MemoryCache.\nAddClientStoreCache\u0026lt;T\u0026gt; Registers a IClientStore decorator implementation which will maintain an in-memory cache of Client configuration objects. The cache duration is configurable on the Caching configuration options on the IdentityServerOptions.\nAddResourceStoreCache\u0026lt;T\u0026gt;\nRegisters a IResourceStore decorator implementation which will maintain an in-memory cache of IdentityResource and ApiResource configuration objects. The cache duration is configurable on the Caching configuration options on the IdentityServerOptions.\nAddCorsPolicyCache\u0026lt;T\u0026gt;\nRegisters a ICorsPolicyService decorator implementation which will maintain an in-memory cache of the results of the CORS policy service evaluation. The cache duration is configurable on the Caching configuration options on the IdentityServerOptions.\nAddIdentityProviderStoreCache\u0026lt;T\u0026gt;\nRegisters a IIdentityProviderStore decorator implementation which will maintain an in-memory cache of IdentityProvider configuration objects. The cache duration is configurable on the Caching configuration options on the IdentityServerOptions.\nTest Stores The TestUser class models a user, their credentials, and claims in IdentityServer.\nUse of TestUser is similar to the use of the \u0026ldquo;in-memory\u0026rdquo; stores in that it is intended for when prototyping, developing, and/or testing. The use of TestUser is not recommended in production.\nAddTestUsers\nRegisters TestUserStore based on a collection of TestUser objects. TestUserStore is e.g. used by the default quickstart UI. Also registers implementations of IProfileService and IResourceOwnerPasswordValidator that uses the test users as a backing store.\nSigning keys Duende IdentityServer needs key material to sign tokens. This key material can either be created and managed automatically or configured statically.\nWe recommend that you use automatic key management. This section covers the configuration methods needed for manual configuration of signing keys, which are usually only needed if your license does not include automatic key management or if you are migrating from manually managed keys to automatic key management.\nDuende IdentityServer supports X.509 certificates (both raw files and a reference to the certificate store), RSA keys and EC keys for token signatures and validation. Each key can be configured with a (compatible) signing algorithm, e.g. RS256, RS384, RS512, PS256, PS384, PS512, ES256, ES384 or ES512.\nYou can configure the key material with the following methods:\nAddSigningCredential\nAdds a signing key that provides the specified key material to the various token creation/validation services.\nAddDeveloperSigningCredential\nCreates temporary key material at startup time. This is for dev scenarios. The generated key will be persisted in the local directory by default (or just kept in memory).\nAddValidationKey\nAdds a key for validating tokens. They will be used by the internal token validator and will show up in the discovery document.\nAdditional services The following are convenient to add additional features to your IdentityServer.\nAddExtensionGrantValidator\nAdds an IExtensionGrantValidator implementation for use with extension grants.\nAddSecretParser\nAdds an ISecretParser implementation for parsing client or API resource credentials.\nAddSecretValidator\nAdds an ISecretValidator implementation for validating client or API resource credentials against a credential store.\nAddResourceOwnerValidator\nAdds an IResourceOwnerPasswordValidator implementation for validating user credentials for the resource owner password credentials grant type.\nAddProfileService\nAdds an IProfileService implementation. The default implementation (found in DefaultProfileService) relies upon the authentication cookie as the only source of claims for issuing in tokens.\nAddAuthorizeInteractionResponseGenerator\nAdds an IAuthorizeInteractionResponseGenerator implementation to customize logic at authorization endpoint for when a user must be shown a UI for error, login, consent, or any other custom page. The default implementation can be found in the AuthorizeInteractionResponseGenerator class, so consider deriving from this existing class if you need to augment the existing behavior.\nAddCustomAuthorizeRequestValidator\nAdds an ICustomAuthorizeRequestValidator implementation to customize request parameter validation at the authorization endpoint.\nAddCustomTokenRequestValidator\nAdds an ICustomTokenRequestValidator implementation to customize request parameter validation at the token endpoint.\nAddRedirectUriValidator\nAdds an IRedirectUriValidator implementation to customize redirect URI validation.\nAddAppAuthRedirectUriValidator\nAdds an \u0026ldquo;AppAuth\u0026rdquo; (OAuth 2.0 for Native Apps) compliant redirect URI validator (does strict validation but also allows http://127.0.0.1 with random port).\nAddJwtBearerClientAuthentication\nAdds support for client authentication using JWT bearer assertions.\nAddMutualTlsSecretValidators\nAdds the X509 secret validators for mutual TLS.\nAddIdentityProviderConfigurationValidator\nAdds an IdentityProvider configuration validator.\nAddBackchannelAuthenticationUserValidator\nAdds the backchannel login user validator.\nAddBackchannelAuthenticationUserNotificationService\nAdds the backchannel login user validator.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/diagnostics/events/",
    "title": "Events",
    "tags": [],
    "description": "",
    "content": "While logging is more low level \u0026ldquo;printf\u0026rdquo; style - events represent higher level information about certain operations in IdentityServer. Events are structured data and include event IDs, success/failure information, categories and details. This makes it easy to query and analyze them and extract useful information that can be used for further processing.\nEvents work great with structured logging stores like ELK, Seq or Splunk.\nEmitting events Events are not turned on by default - but can be globally configured when AddIdentityServer is called, e.g.:\nbuilder.Services.AddIdentityServer(options =\u0026gt; { options.Events.RaiseSuccessEvents = true; options.Events.RaiseFailureEvents = true; options.Events.RaiseErrorEvents = true; }); To emit an event use the IEventService from the DI container and call the RaiseAsync method, e.g.:\npublic async Task\u0026lt;IActionResult\u0026gt; Login(LoginInputModel model) { if (_users.ValidateCredentials(model.Username, model.Password)) { // issue authentication cookie with subject ID and username var user = _users.FindByUsername(model.Username); await _events.RaiseAsync(new UserLoginSuccessEvent(user.Username, user.SubjectId, user.Username)); } else { await _events.RaiseAsync(new UserLoginFailureEvent(model.Username, \u0026#34;invalid credentials\u0026#34;)); } } Custom sinks Our default event sink will simply serialize the event class to JSON and forward it to the ASP.NET Core logging system. If you want to connect to a custom event store, implement the IEventSink interface and register it with DI.\nThe following example uses Seq to emit events:\npublic class SeqEventSink : IEventSink { private readonly Logger _log; public SeqEventSink() { _log = new LoggerConfiguration() .WriteTo.Seq(\u0026#34;http://localhost:5341\u0026#34;) .CreateLogger(); } public Task PersistAsync(Event evt) { if (evt.EventType == EventTypes.Success || evt.EventType == EventTypes.Information) { _log.Information(\u0026#34;{Name} ({Id}), Details: {@details}\u0026#34;, evt.Name, evt.Id, evt); } else { _log.Error(\u0026#34;{Name} ({Id}), Details: {@details}\u0026#34;, evt.Name, evt.Id, evt); } return Task.CompletedTask; } } Add the Serilog.Sinks.Seq package to your host to make the above code work.\nBuilt-in events The following events are defined in IdentityServer:\nApiAuthenticationFailureEvent \u0026amp; ApiAuthenticationSuccessEvent\nGets raised for successful/failed API authentication at the introspection endpoint.\nClientAuthenticationSuccessEvent \u0026amp; ClientAuthenticationFailureEvent\nGets raised for successful/failed client authentication at the token endpoint.\nTokenIssuedSuccessEvent \u0026amp; TokenIssuedFailureEvent\nGets raised for successful/failed attempts to request identity tokens, access tokens, refresh tokens and authorization codes.\nTokenIntrospectionSuccessEvent \u0026amp; TokenIntrospectionFailureEvent\nGets raised for successful token introspection requests.\nTokenRevokedSuccessEvent\nGets raised for successful token revocation requests.\nUserLoginSuccessEvent \u0026amp; UserLoginFailureEvent\nGets raised by the quickstart UI for successful/failed user logins.\nUserLogoutSuccessEvent\nGets raised for successful logout requests.\nConsentGrantedEvent \u0026amp; ConsentDeniedEvent\nGets raised in the consent UI.\nUnhandledExceptionEvent\nGets raised for unhandled exceptions.\nDeviceAuthorizationFailureEvent \u0026amp; DeviceAuthorizationSuccessEvent\nGets raised for successful/failed device authorization requests.\nCustom events You can create your own events and emit them via our infrastructure.\nYou need to derive from our base Event class which injects contextual information like activity ID, timestamp, etc. Your derived class can then add arbitrary data fields specific to the event context::\npublic class UserLoginFailureEvent : Event { public UserLoginFailureEvent(string username, string error) : base(EventCategories.Authentication, \u0026#34;User Login Failure\u0026#34;, EventTypes.Failure, EventIds.UserLoginFailure, error) { Username = username; } public string Username { get; set; } } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/models/identity_resource/",
    "title": "Identity Resource",
    "tags": [],
    "description": "Reference",
    "content": "Duende.IdentityServer.Models.IdentityResource This class models an identity resource.\npublic static readonly IEnumerable\u0026lt;IdentityResource\u0026gt; IdentityResources = new[] { // some standard scopes from the OIDC spec new IdentityResources.OpenId(), new IdentityResources.Profile(), new IdentityResources.Email(), // custom identity resource with some associated claims new IdentityResource(\u0026#34;custom.profile\u0026#34;, userClaims: new[] { JwtClaimTypes.Name, JwtClaimTypes.Email, \u0026#34;location\u0026#34;, JwtClaimTypes.Address }) }; Enabled\nIndicates if this resource is enabled and can be requested. Defaults to true.\nName\nThe unique name of the identity resource. This is the value a client will use for the scope parameter in the authorize request.\nDisplayName\nThis value will be used e.g. on the consent screen.\nDescription\nThis value will be used e.g. on the consent screen.\nRequired\nSpecifies whether the user can de-select the scope on the consent screen (if the consent screen wants to implement such a feature). Defaults to false.\nEmphasize\nSpecifies whether the consent screen will emphasize this scope (if the consent screen wants to implement such a feature). Use this setting for sensitive or important scopes. Defaults to false.\nShowInDiscoveryDocument\nSpecifies whether this scope is shown in the discovery document. Defaults to true.\nUserClaims\nList of associated user claim types that should be included in the identity token.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/tokens/authentication/jwt/",
    "title": "Private Key JWTs",
    "tags": [],
    "description": "",
    "content": "The OpenID Connect specification recommends a client authentication method based on asymmetric keys. With this approach, instead of transmitting the shared secret over the network, the client creates a JWT and signs it with its private key. Your IdentityServer only needs to store the corresponding key to be able to validate the signature.\nThe technique is described here and is based on the OAuth JWT assertion specification (RFC 7523).\nSetting up a private key JWT secret The default private key JWT secret validator expects either a base64 encoded X.509 certificate or a JSON Web Key formatted RSA, EC or symmetric key on the secret definition:\nvar client = new Client { ClientId = \u0026#34;client.jwt\u0026#34;, ClientSecrets = { new Secret { // base64 encoded X.509 certificate Type = IdentityServerConstants.SecretTypes.X509CertificateBase64, Value = \u0026#34;MIID...xBXQ=\u0026#34; } new Secret { // JWK formatted RSA key Type = IdentityServerConstants.SecretTypes.JsonWebKey, Value = \u0026#34;{\u0026#39;e\u0026#39;:\u0026#39;AQAB\u0026#39;,\u0026#39;kid\u0026#39;:\u0026#39;Zz...GEA\u0026#39;,\u0026#39;kty\u0026#39;:\u0026#39;RSA\u0026#39;,\u0026#39;n\u0026#39;:\u0026#39;wWw...etgKw\u0026#39;}\u0026#34; } }, AllowedGrantTypes = GrantTypes.ClientCredentials, AllowedScopes = { \u0026#34;api1\u0026#34;, \u0026#34;api2\u0026#34; } }; You can share the same key for client authentication and signed authorize requests.\nAuthentication using a private key JWT On the client side, the caller must first generate the JWT, and then send it on the assertion body field:\nPOST /connect/token Content-type: application/x-www-form-urlencoded client_assertion=\u0026lt;jwt\u0026gt;\u0026amp; client_assertion_type=urn:ietf:params:oauth:grant-type:jwt-bearer\u0026amp; grant_type=authorization_code\u0026amp; code=hdh922\u0026amp; redirect_uri=https://myapp.com/callback .NET client library You can use the Microsoft JWT library to create JSON Web Tokens.\nprivate static string CreateClientToken(SigningCredentials credential, string clientId, string tokenEndpoint) { var now = DateTime.UtcNow; var token = new JwtSecurityToken( clientId, tokenEndpoint, new List\u0026lt;Claim\u0026gt;() { new Claim(JwtClaimTypes.JwtId, Guid.NewGuid().ToString()), new Claim(JwtClaimTypes.Subject, clientId), new Claim(JwtClaimTypes.IssuedAt, now.ToEpochTime().ToString(), ClaimValueTypes.Integer64) }, now, now.AddMinutes(1), credential ); var tokenHandler = new JwtSecurityTokenHandler(); return tokenHandler.WriteToken(token); } ..and the IdentityModel client library to programmatically interact with the protocol endpoint from .NET code.\nusing IdentityModel.Client; static async Task\u0026lt;TokenResponse\u0026gt; RequestTokenAsync(SigningCredentials credential) { var client = new HttpClient(); var disco = await client.GetDiscoveryDocumentAsync(\u0026#34;https://demo.duendesoftware.com\u0026#34;); if (disco.IsError) throw new Exception(disco.Error); var clientToken = CreateClientToken(credential, \u0026#34;private.key.jwt\u0026#34;, disco.TokenEndpoint); var response = await client.RequestClientCredentialsTokenAsync(new ClientCredentialsTokenRequest { Address = disco.TokenEndpoint, Scope = \u0026#34;api1.scope1\u0026#34;, ClientAssertion = { Type = OidcConstants.ClientAssertionTypes.JwtBearer, Value = clientToken } }); if (response.IsError) throw new Exception(response.Error); return response; } See here for a sample for using JWT-based authentication.\nUsing ASP.NET Core The OpenID Connect authentication handler in ASP.NET Core allows for replacing a static client secret with a dynamically created client assertion.\nThis is accomplished by handling the various events on the handler. We recommend to encapsulate the event handler in a separate type. This makes it easier to consume services from DI:\n// some details omitted builder.Services.AddTransient\u0026lt;OidcEvents\u0026gt;(); builder.Services.AddAuthentication(options =\u0026gt; .AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { options.Authority = Constants.Authority; // no static client secret options.ClientId = \u0026#34;mvc.jar.jwt\u0026#34;; // specifies type that handles events options.EventsType = typeof(OidcEvents); })); In your event handler you can inject code before the handler redeems the code:\npublic class OidcEvents : OpenIdConnectEvents { private readonly AssertionService _assertionService; public OidcEvents(AssertionService assertionService) { _assertionService = assertionService; } public override Task AuthorizationCodeReceived(AuthorizationCodeReceivedContext context) { context.TokenEndpointRequest.ClientAssertionType = OidcConstants.ClientAssertionTypes.JwtBearer; context.TokenEndpointRequest.ClientAssertion = _assertionService.CreateClientToken(); return Task.CompletedTask; } } The assertion service would be a helper to create the JWT as shown above in the CreateClientToken method. See here for a sample for using JWT-based authentication (and signed authorize requests) in ASP.NET Core.\nStrict Audience Validation Private key JWT have a theoretical vulnerability where a Relying Party trusting multiple OpenID Providers could be attacked if one of the OpenID Providers is malicious or compromised.\nThe attack relies on the OpenID Provider setting the audience value of the authentication JWT to the token endpoint based on the token endpoint value found in the discovery document. The malicious Open ID Provider can attack this because it controls what the discovery document contains, and can fool the Relying Party into creating authentication JWTs for the audience of a victim OpenID Provider.\nThe OpenID Foundation proposed a two-part fix: strictly validate the audience and set an explicit typ header (with value client-authentication+jwt) in the authentication JWT.\nYou can enable strict audience validation using the StrictClientAssertionAudienceValidation flag, which always strictly validates that the audience is equal to the issuer and validates the token\u0026rsquo;s typ header, as specified in RFC 7523 bis.\nWhen StrictClientAssertionAudienceValidation is not enabled, validation behavior is determined based on the typ header being present. When the token sets the typ header to client-authentication+jwt, IdentityServer assumes the client\u0026rsquo;s intention is to apply strict audience validation. If typ is not present, default audience validation is used.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/tokens/refresh/",
    "title": "Refreshing a Token",
    "tags": [],
    "description": "",
    "content": "Access tokens have finite lifetimes. If a client needs long-lived access to a resource, refresh tokens can be used to request a new access token. This can be done with an API call and does not require any user interaction or interruption.\nSince this is a privileged operation, the clients needs to be explicitly authorized to be able to use refresh tokens by setting the AllowOfflineAccess property to true. See the client reference section for additional refresh token related settings.\nRefresh tokens are supported for the following flows: authorization code, hybrid and resource owner password credential flow.\nRequesting a refresh token You can request a refresh token by adding a scope called offline_access to the scope parameter list of the authorize request.\nRequesting an access token using a refresh token To get a new access token, you send the refresh token to the token endpoint. This will result in a new token response containing a new access token and its expiration and potentially also a new refresh token depending on the client configuration (see rotation).\nPOST /connect/token client_id=client\u0026amp; client_secret=secret\u0026amp; grant_type=refresh_token\u0026amp; refresh_token=hdh922 .NET client library On .NET you can leverage the IdentityModel client library to request refresh tokens, e.g.:\nusing IdentityModel.Client; var client = new HttpClient(); var response = await client.RequestRefreshTokenAsync(new RefreshTokenRequest { Address = TokenEndpoint, ClientId = \u0026#34;client\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, RefreshToken = \u0026#34;...\u0026#34; }); The Duende.AccessTokenManagement library can be used to automate refresh \u0026amp; access token lifetime management in ASP.NET Core.\nBinding refresh tokens Refresh tokens are a high-value target for attackers, because they typically have a much higher lifetime than access tokens.\nHowever, refresh tokens for confidential clients are bound to that client; they can only be used by the client they are issued to and the client is required to authenticate itself in order to do so. An attacker able to obtain a refresh token issued to a confidential client cannot use it without the client\u0026rsquo;s credentials.\nRefresh tokens issued to public clients are not bound to the client in the same way, since the client cannot authenticate itself. We recommend that such refresh tokens be sender-constrained using Proof of Possession instead.\nYou can further reduce the attack surface of refresh tokens using the following techniques.\nConsent We encourage you to request consent when a client requests a refresh token, as it not only makes the user aware of the action being taken, but also provides them with an opportunity to opt-out if they choose.\nDuende IdentityServer will always ask for consent (if enabled) if the client asks for the offline_access scope which follows the recommendations in the OpenID Connect specification.\nSliding expiration Refresh tokens usually have a much longer lifetime than access tokens. You can reduce their exposure by adding a sliding lifetime on top of the absolute lifetime. This allows for scenarios where a refresh token can be silently used if the user is regularly using the client, but needs a fresh authorize request if the client has not been used for a certain time. In other words, they auto-expire much quicker without potentially interfering with the typical usage pattern.\nYou can use the AbsoluteRefreshTokenLifetime and SlidingRefreshTokenLifetime client settings to fine tune this behavior.\nRotation Rotation is configured with the RefreshTokenUsage client setting and, beginning in IdentityServer v7.0, is by default set to ReUse which disables rotation.\nWhen RefreshTokenUsage is configured for OneTime usage, rotation is enabled and refresh tokens can only be used once. When refresh tokens are used with OneTime usage configured, a new refresh token is included in the response along with the new access token. Each time the client application uses the refresh token, it must use the most recent refresh token. This chain of tokens will each appear as distinct token values to the client, but will have identical creation and expiration timestamps in the datastore.\nBeginning in version 6.3, the configuration option DeleteOneTimeOnlyRefreshTokensOnUse controls what happens to refresh tokens configured for OneTime usage. If the flag is on, then refresh tokens are deleted immediately on use. If the flag is off, the token is marked as consumed instead. Prior to version 6.3, OneTime usage refresh tokens are always marked as consumed.\nRotating the tokens on every use has limited security benefits regardless of which type of client is used. And it comes with the cost of database pressure and reliability issues. Reusable refresh tokens are robust to network failures in a way that one time use tokens are not: if a one-time use refresh token is used to produce a new token, but the response containing the new refresh token is lost due to a network issue, the client application has no way to recover without the user logging in again. Reusable refresh tokens do not have this problem.\nReusable tokens may have better performance in the persisted grants store. One-time use refresh tokens require additional records to be written to the store whenever a token is refreshed. Using reusable refresh tokens avoids those writes.\nAccepting Consumed Tokens To make one time use tokens more robust to network failures, you can customize the behavior of the RefreshTokenService such that consumed tokens can be used under certain circumstances, perhaps for a small length of time after they are consumed. To do so, create a subclass of the DefaultRefreshTokenService and override its AcceptConsumedTokenAsync(RefreshToken refreshToken) method. This method takes a consumed refresh token and returns a boolean flag that indicates if that token should be accepted, that is, allowed to be used to obtain an access token. The default implementation in the DefaultRefreshTokenService rejects all consumed tokens, but your customized implementation could create a time window where consumed tokens can be used.\nNew options added In 6.3 interact with this feature. The PersistentGrantOptions.DeleteOneTimeOnlyRefreshTokensOnUse flag will cause OneTime refresh tokens to be deleted on use, rather than marked as consumed. This flag will need to be disabled in order to allow a customized Refresh Token Service to use consumed tokens.\nConsumed tokens can be cleaned up by a background process, enabled with the existing OperationalStoreOptions.EnableTokenCleanup and OperationalStoreOptions.RemoveConsumedTokens flags. Starting in 6.3, the cleanup job can be further configured with the OperationalStoreOptions.ConsumedTokenCleanupDelay. This delay is the amount of time that must elapse before tokens marked as consumed will be deleted. If you are customizing the Refresh Token Service to allow for consumed tokens to be used for some period of time, then we recommend configuring the ConsumedTokenCleanupDelay to the same time period.\nThis customization must be registered in the DI system as an implementation of the IRefreshTokenService:\nbuilder.Services.TryAddTransient\u0026lt;IRefreshTokenService, YourCustomRefreshTokenService\u0026gt;(); Replay detection In addition to one-time only usage semantics, you might wish to add replay detection for refresh tokens. If a refresh token is configured for one-time only use but used multiple times, that means that either the client application is accidentally mis-using the token (a bug), a network failure is preventing the client application from rotating properly (see above), or an attacker is attempting a replay attack. Depending on your security requirements, you might decide to treat this situation as an attack, and take action. What you might do is, if a consumed refresh token is ever used, revoke all access for that client/user combination. This could include deleting refresh tokens, revoking access tokens (if they are introspection tokens), ending the user\u0026rsquo;s server side session, and sending back-channel logout notifications to client applications. You might also consider alerting the user to suspicious activity on their account. Keep in mind that these actions are disruptive and possibly alarming to the user, and there is a potential for false positives.\nImplementing replay detection is similar to accepting consumed tokens. Extend the AcceptConsumedTokenAsync method of the DefaultRefreshTokenService and add the additional revocation or alerting behavior that you choose. In 6.3, the same new options that interact with accepting consumed tokens also interact with replay detection. The PersistentGrantOptions.DeleteOneTimeOnlyRefreshTokensOnUse flag needs to be disabled so that used tokens persist and can be used to detect replays. The cleanup job should also be configured to not delete consumed tokens.\nSee also: The IRefreshTokenService reference.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/diagnostics/otel/traces/",
    "title": "Traces",
    "tags": [],
    "description": "",
    "content": "(added in v6.1)\nHere\u0026rsquo;s e.g. the output for a request to the discovery endpoint:\nWhen multiple applications send their traces to the same OTel server, this becomes super useful for following e.g. authentication flows over service boundaries.\nThe following screenshot shows the ASP.NET Core OpenID Connect authentication handler redeeming the authorization code:\n\u0026hellip;and then contacting the userinfo endpoint:\nThe above screenshots are from https://www.honeycomb.io.\nTracing sources IdentityServer can emit very fine grained traces which is useful for performance troubleshooting and general exploration of the control flow.\nThis might be too detailed in production.\nYou can select which information you are interested in by selectively listening to various traces:\nIdentityServerConstants.Tracing.Basic\nHigh level request processing like request validators and response generators\nIdentityServerConstants.Tracing.Cache\nCaching related tracing\nIdentityServerConstants.Tracing.Services\nServices related tracing\nIdentityServerConstants.Tracing.Stores\nStore related tracing\nIdentityServerConstants.Tracing.Validation\nMore detailed tracing related to validation\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/apis/aspnetcore/reference/",
    "title": "Using Reference Tokens",
    "tags": [],
    "description": "",
    "content": "If you are using reference tokens, you need an authentication handler that implements the back-channel validation via the OAuth 2.0 token introspection protocol, e.g. this one:.\nbuilder.Services.AddAuthentication(\u0026#34;token\u0026#34;) .AddOAuth2Introspection(\u0026#34;token\u0026#34;, options =\u0026gt; { options.Authority = Constants.Authority; // this maps to the API resource name and secret options.ClientId = \u0026#34;resource1\u0026#34;; options.ClientSecret = \u0026#34;secret\u0026#34;; }); Supporting both JWTs and reference tokens It is not uncommon to use the same API with both JWTs and reference tokens. In this case you setup two authentication handlers, make one the default handler and provide some forwarding logic, e.g.:\nbuilder.Services.AddAuthentication(\u0026#34;token\u0026#34;) // JWT tokens .AddJwtBearer(\u0026#34;token\u0026#34;, options =\u0026gt; { options.Authority = Constants.Authority; options.Audience = \u0026#34;resource1\u0026#34;; options.TokenValidationParameters.ValidTypes = new[] { \u0026#34;at+jwt\u0026#34; }; // if token does not contain a dot, it is a reference token options.ForwardDefaultSelector = Selector.ForwardReferenceToken(\u0026#34;introspection\u0026#34;); }) // reference tokens .AddOAuth2Introspection(\u0026#34;introspection\u0026#34;, options =\u0026gt; { options.Authority = Constants.Authority; options.ClientId = \u0026#34;resource1\u0026#34;; options.ClientSecret = \u0026#34;secret\u0026#34;; }); The logic of the forward selector looks like this:\n/// \u0026lt;summary\u0026gt; /// Provides a forwarding func for JWT vs reference tokens (based on existence of dot in token) /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;introspectionScheme\u0026#34;\u0026gt;Scheme name of the introspection handler\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static Func\u0026lt;HttpContext, string\u0026gt; ForwardReferenceToken(string introspectionScheme = \u0026#34;introspection\u0026#34;) { string Select(HttpContext context) { var (scheme, credential) = GetSchemeAndCredential(context); if (scheme.Equals(\u0026#34;Bearer\u0026#34;, StringComparison.OrdinalIgnoreCase) \u0026amp;\u0026amp; !credential.Contains(\u0026#34;.\u0026#34;)) { return introspectionScheme; } return null; } return Select; } /// \u0026lt;summary\u0026gt; /// Extracts scheme and credential from Authorization header (if present) /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;context\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static (string, string) GetSchemeAndCredential(HttpContext context) { var header = context.Request.Headers[\u0026#34;Authorization\u0026#34;].FirstOrDefault(); if (string.IsNullOrEmpty(header)) { return (\u0026#34;\u0026#34;, \u0026#34;\u0026#34;); } var parts = header.Split(\u0026#39; \u0026#39;, StringSplitOptions.RemoveEmptyEntries); if (parts.Length != 2) { return (\u0026#34;\u0026#34;, \u0026#34;\u0026#34;); } return (parts[0], parts[1]); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/fundamentals/resources/",
    "title": "Resources",
    "tags": [],
    "description": "Index",
    "content": "Resources The ultimate job of Duende IdentityServer is to control access to resources.\nIdentity Resources API Scopes API Resources Resource Isolation "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/ui/login/session/",
    "title": "Authentication Session",
    "tags": [],
    "description": "",
    "content": "Authentication Session Regardless of how the user proves their identity on the login page, an authentication session must be established. This authentication session is based on ASP.NET Core’s authentication system, and is tracked with a cookie managed by the cookie authentication handler.\nTo establish the session, ASP.NET Core provides a SignInAsync extension method on the HttpContext. This API accepts a ClaimsPrincipal which contains claims that describe the user. IdentityServer requires a special claim called sub whose value uniquely identifies the user. On your login page, this would be the code to establish the authentication session and issue the cookie:\nvar claims = new Claim[] { new Claim(\u0026#34;sub\u0026#34;, \u0026#34;unique_id_for_your_user\u0026#34;) }; var identity = new ClaimsIdentity(claims, \u0026#34;pwd\u0026#34;); var user = new ClaimsPrincipal(identity); await HttpContext.SignInAsync(user); The sub claim is the subject identifier and is the most important claim your IdentityServer will issue. It will uniquely identify the user and must never change and must never be reassigned to a different user. A GUID data type is a very common choice for the sub.\nAdditional claims can be added to the cookie if desired or needed at other UI pages. For example, it\u0026rsquo;s common to also issue a name claim which represents the user\u0026rsquo;s display name.\nThe claims issued in the cookie are passed as the Subject on the ProfileDataRequestContext in the profile service.\nWell Known Claims Issued From the Login Page There are some claims beyond sub that can be issued by your login page to capture additional information about the user\u0026rsquo;s authentication session. Internally Duende IdentityServer will set some of these values if you do not specify them when calling SignInAsync. The claims are:\nname: The display name of the user. amr: Name of the authentication method used for user authentication (defaults to pwd). auth_time: Time in epoch format the user entered their credentials (defaults to the current time). idp: Authentication scheme name of the external identity provider used for login. When not specified then the value defaults to local indicating that it was a local login. This is used to determine if a user must re-authenticate when clients make authorization requests using the acr_values with an idp value, or the client has IdentityProviderRestrictions. If the user’s idp does not match the request, then they should re-authenticate. tenant: Tenant identifier the user is associated with (if needed). This is used to determine if a user must re-authenticate when clients make authorization requests using the acr_values with a tenant value. If the user\u0026rsquo;s tenant does not match the request, then they should re-authenticate. While you can create the ClaimsPrincipal yourself, you can alternatively use IdentityServer extension methods and the IdentityServerUser class to make this easier:\nvar user = new IdentityServerUser(\u0026#34;unique_id_for_your_user\u0026#34;) { DisplayName = user.Username }; await HttpContext.SignInAsync(user); Cookie Handler Configuration Duende IdentityServer registers a cookie authentication handler by default for the authentication session. The scheme that the handler in the authentication system is identified by is from the constant IdentityServerConstants.DefaultCookieAuthenticationScheme.\nWhen configuring IdentityServer, the AuthenticationOptions expose some settings to control the cookie (e.g. expiration and sliding). For example:\nbuilder.Services.AddIdentityServer(options =\u0026gt; { options.Authentication.CookieLifetime = TimeSpan.FromHours(1); options.Authentication.CookieSlidingExpiration = false; }); In addition to the authentication cookie, IdentityServer will issue an additional cookie which defaults to the name idsrv.session. This cookie is derived from the main authentication cookie, and it used for the check session endpoint for browser-based JavaScript clients at signout time. It is kept in sync with the authentication cookie, and is removed when the user signs out.\nIf you require more control over the cookie authentication handler you can register your own cookie handler. You can then configure IdentityServer to use your cookie handler by setting the CookieAuthenticationScheme on the AuthenticationOptions. For example:\nbuilder.Services.AddAuthentication() .AddCookie(\u0026#34;your_cookie\u0026#34;, options =\u0026gt; { // ... }); builder.Services.AddIdentityServer(options =\u0026gt; { options.Authentication.CookieAuthenticationScheme = \u0026#34;your_cookie\u0026#34;; }); If the CookieAuthenticationScheme is not set, the DefaultAuthenticationScheme configured for ASP.NET Core will be used instead. Note that the AddAuthentication call that sets the default can come after the AddIdentityServer call. For example:\n// No cookie authentication scheme is set here. // Identity Server will use the default scheme from ASP.NET Core, // even though it is not yet defined. builder.Services.AddIdentityServer(); // Default scheme is registered. IdentityServer will use this scheme. builder.Services.AddAuthentication(defaultScheme: \u0026#34;your_cookie\u0026#34;) .AddCookie(\u0026#34;your_cookie\u0026#34;, options =\u0026gt; { // ... }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/configuration/dcr/authorization/",
    "title": "Authorization",
    "tags": [],
    "description": "",
    "content": "You should consider your requirements and design authentication and authorization policy for the Configuration API, if required. The specifications that define DCR envision both open registration, where authentication and authorization are absent and all client software can register with the authorization server, and protected registration, where an initial access token is required in order to register.\nThe Configuration API creates standard ASP.NET endpoints that can be protected through traditional ASP.NET authorization. Alternatively, the dynamic client registration software_statement parameter can be used to authenticate requests.\nTraditional ASP.NET Authorization You can authorize access to the Configuration API Endpoints using authorization policies just like any other endpoint created in an ASP.NET Web application. That authorization policy can use any criteria that an authorization policy might enforce, such as checking for particular claims or scopes.\nOne possibility is to authenticate the provisioning system, that is, the system making the DCR call, using OAuth. The resulting access token could include a scope that grants access to the Configuration API.\nFor example, you might protect the Configuration APIs with a JWT-bearer authentication scheme and an authorization policy that requires a particular scope to be present in the JWTs. You could choose any name for the scope that gives access to the Configuration APIs. Let\u0026rsquo;s use the name \u0026ldquo;IdentityServer.Configuration\u0026rdquo; for this example. You would then define the \u0026ldquo;IdentityServer.Configuration\u0026rdquo; scope as an ApiScope in your IdentityServer and allow the appropriate clients to access it. An automated process running in a CI pipeline could be configured as an OAuth client that uses the client credentials flow and is allowed to request the \u0026ldquo;IdentityServer.Configuration\u0026rdquo; scope. It could obtain a token using its client id and secret and then present that token when it calls the Configuration API. You might also have an interactive web application with a user interface that makes calls to the Configuration API. Again, you would define the application as an OAuth client allowed to request the appropriate scope, but this time, you\u0026rsquo;d use the authorization code flow.\nSoftware Statement The metadata within requests to the Configuration API can be bundled together into a JWT and sent in the software_statement parameter. If you can establish a trust relationship between the Configuration API and the issuer of the software statement, then that can be used to decide if you want to accept registration requests.\nIn order to use a software statement in this way, you would need to design the specific semantics of your software statements, how you will issue them, how you will create the necessary trust relationship between the issuer and your Configuration API, and how the Configuration API will validate the software statements. The configuration API doesn\u0026rsquo;t make any assumptions about that design. By default it does nothing with the software_statement parameter; to make use of it, customize the DynamicClientRegistrationValidator.ValidateSoftwareStatementAsync extension point.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/configuration/dcr/calling-registration/",
    "title": "Calling the Registration Endpoint",
    "tags": [],
    "description": "",
    "content": "The registration endpoint is invoked by making an HTTP POST request to the /connect/dcr endpoint with a json payload containing metadata describing the desired client as described in RFC 7591 and OpenID Connect Dynamic Client Registration 1.0.\nThe supported metadata properties are listed in the reference section on the DynamicClientRegistrationRequest model. A mixture of standardized and IdentityServer-specific properties are supported. Most standardized properties that are applicable to the client credentials or code flow grants (the two grants we support) are supported. Where IdentityServer\u0026rsquo;s configuration model includes important properties that are not standardized, we have included those properties as extensions. For example, there are no standardized properties describing token lifetimes, so the dynamic client registration endpoint adds absolute_refresh_token_lifetime, access_token_lifetime, identity_token_lifetime, etc.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/efoptions/configuration/",
    "title": "Configuration Options",
    "tags": [],
    "description": "Entity Framework",
    "content": "Duende.IdentityServer.EntityFramework.Options.ConfigurationStoreOptions These options are configurable when using the Entity Framework Core for the configuration store:\nYou set the options at startup time in your AddConfigurationStore method:\nvar builder = services.AddIdentityServer() .AddConfigurationStore(options =\u0026gt; { // configure options here.. }) Pooling Settings that affect the DbContext pooling feature of Entity Framework Core.\nEnablePooling\nGets or set if EF DbContext pooling is enabled. Defaults to false.\nPoolSize\nGets or set the pool size to use when DbContext pooling is enabled. If not set, the EF default is used.\nSchema Settings that affect the database schema and table names.\nDefaultSchema\nGets or sets the default schema. Defaults to null.\nTableConfiguration settings for each individual table (schema and name) managed by this feature:\nIdentity Resource related tables:\nIdentityResource IdentityResourceClaim IdentityResourceProperty API Resource related tables:\nApiResource ApiResourceSecret ApiResourceScope ApiResourceClaim ApiResourceProperty Client related tables:\nClient ClientGrantType ClientRedirectUri ClientPostLogoutRedirectUri ClientScopes ClientSecret ClientClaim ClientIdPRestriction ClientCorsOrigin ClientProperty API Scope related tables:\nApiScope ApiScopeClaim ApiScopeProperty Identity provider related tables:\nIdentityProvider "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/validators/custom_token_request_validator/",
    "title": "Custom Token Request Validator",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Validation.ICustomTokenRequestValidator Allows running custom code as part of the token issuance pipeline at the token endpoint.\n/// \u0026lt;summary\u0026gt; /// Allows inserting custom validation logic into token requests /// \u0026lt;/summary\u0026gt; public interface ICustomTokenRequestValidator { /// \u0026lt;summary\u0026gt; /// Custom validation logic for a token request. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;context\u0026#34;\u0026gt;The context.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt; /// The validation result /// \u0026lt;/returns\u0026gt; Task ValidateAsync(CustomTokenRequestValidationContext context); } ValidateAsync\nThis method gets called during token request processing. The context gives you access to request and response parameters.\nYou can also change certain parameters on the validated request object, e.g. the token lifetime, token type, confirmation method and client claims.\nThe CustomResponse dictionary allows emitting additional response fields.\nTo fail the request, set the the IsError, the Error, and optionally the ErrorDescription properties on the Result object on the CustomTokenRequestValidationContext.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/tokens/pop/dpop/",
    "title": "DPoP",
    "tags": [],
    "description": "",
    "content": "Proof-of-possession using Demonstrating Proof-of-Possession at the Application Layer (DPoP) Added in 6.3.0.\nDPoP is a security measure that addresses token replay attacks by making it difficult for attackers to use stolen tokens. Support for DPoP is included in IdentityServer Enterprise Edition. DPoP specifies how to bind an asymmetric key stored within a JSON Web Key (JWK) to an access token. With this enabled your IdentityServer will embed the thumbprint of the public key JWK into the access token via the cnf claim, e.g.:\n{ // rest omitted \u0026#34;cnf\u0026#34;: { \u0026#34;jkt\u0026#34;: \u0026#34;JGSVlE73oKtQQI1dypYg8_JNat0xJjsQNyOI5oxaZf4\u0026#34; } } The client must then prove possession of the private key to call the APIs, and your APIs can validate the cnf claim by comparing it to the thumbprint of the client\u0026rsquo;s public key in the JWK.\nIf the access token would leak, it cannot be replayed without having access to the private key of the JWK the client controls.\nThe mechanism by which the client proves control of the private key (both when connecting to the token server and when calling an API) is by sending an additional JWT called a proof token on HTTP requests. This proof token is passed via the DPoP request header and contains the public portion of the JWK, and is signed by the corresponding private key.\nThe creation and management of this DPoP key is up to the policy of the client. For example is can be dynamically created when the client starts up, and can be periodically rotated. The main constraint is that it must be stored for as long as the client uses any access tokens (and possibly refresh tokens) that they are bound to.\nEnabling DPoP in IdentityServer DPoP is something a client can use dynamically with no configuration in IdentityServer, but you can configure it as required. This is a per-client setting in your IdentityServer. There are additional client as well as global DPoP settings to control the behavior.\nnew Client { ClientId = \u0026#34;dpop_client\u0026#34;, RequireDPoP = true, // ... } Enabling DPoP support in your client The easiest approach for supporting DPoP in your client is to use the DPoP support in the Duende.AccessTokenManagement library (docs available here). It provides DPoP client support for both client credentials and code flow style clients. DPoP is enabled by simply assigning the DPoPJsonWebKey on the client configuration.\nFor example, here\u0026rsquo;s how to configure a client credentials client:\nbuilder.Services.AddClientCredentialsTokenManagement() .AddClient(\u0026#34;demo_dpop_client\u0026#34;, client =\u0026gt; { client.TokenEndpoint = \u0026#34;https://demo.duendesoftware.com/connect/token\u0026#34;; client.DPoPJsonWebKey = \u0026#34;...\u0026#34;; // ... }); And here\u0026rsquo;s how to configure a code flow client:\nbuilder.Services.AddAuthentication(...) .AddCookie(\u0026#34;cookie\u0026#34;, ...) .AddOpenIdConnect(\u0026#34;oidc\u0026#34;, ...); builder.Services.AddOpenIdConnectAccessTokenManagement(options =\u0026gt; { options.DPoPJsonWebKey = \u0026#34;...\u0026#34;; }); In either case, you will need to create a JWK. One approach to creating a JWK in string format is to use the .NET crypto APIs, for example:\nvar rsaKey = new RsaSecurityKey(RSA.Create(2048)); var jsonWebKey = JsonWebKeyConverter.ConvertFromSecurityKey(rsaKey); jsonWebKey.Alg = \u0026#34;PS256\u0026#34;; string jwk = JsonSerializer.Serialize(jsonWebKey); Once your client configuration has a DPoPJsonWebKey, then any protocol requests to obtain access tokens from the token server will automatically include a DPoP proof token created from the DPoPJsonWebKey. Furthermore, any API invocations using the AddClientCredentialsHttpClient or AddUserAccessTokenHttpClient helpers will also automatically include a DPoP proof token. The implication is that the DPoPJsonWebKey is a critical secret that must be carefully managed, because any tokens requested with this secret will be bound to it; if the secret is lost, the tokens can longer be used, and if the secret is leaked, the security benefits of DPoP are lost.\nEnabling DPoP support in your API See here for documentation describing how to enable DPoP in your APIs.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/ui/logout/session_cleanup/",
    "title": "Ending the Session",
    "tags": [],
    "description": "",
    "content": "Removing the Authentication Cookie To remove the authentication cookie, simply use the ASP.NET Core SignOutAsync extension method on the HttpContext. You will need to pass the scheme used (which is provided by IdentityServerConstants.DefaultCookieAuthenticationScheme unless you have changed it):\nawait HttpContext.SignOutAsync(IdentityServerConstants.DefaultCookieAuthenticationScheme); Or you can use the overload that will simply sign-out of the default authentication scheme:\nawait HttpContext.SignOutAsync(); If you are integrating with ASP.NET Identity, sign out using its SignInManager instead:\nawait _signInManager.SignOutAsync(); Prompting the User to Logout Typically you should prompt the user to logout which requires a POST to remove the cookie. Otherwise an attacker could hotlink to your logout page causing the user to be automatically logged out. This means you will need a page to prompt the user to logout.\nIf a logoutId is passed to the logout page and the returned LogoutRequest\u0026rsquo;s ShowSignoutPrompt is false then it is safe to skip the prompt. This would occur when the logout page is requested due to a validated client initiated logout via the end session endpoint. Your logout page process can continue as if the user submitted the post back to logout, in essence calling SignOutAsync.\nExternal Logins If your user has signed in with an external login, then it\u0026rsquo;s likely that they should perform an external logout of the external provider as well.\nRevoking Client Tokens at Logout During a user\u0026rsquo;s session, long-lived tokens (e.g. refresh tokens) might have been created for client applications. If at logout time you would like to have those tokens revoked, then this can be done automatically by setting the CoordinateLifetimeWithUserSession property on the client configuration, or globally on the IdentityServer Authentication Options.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/data/operational/",
    "title": "Operational Data",
    "tags": [],
    "description": "",
    "content": "Operational Data For certain operations, IdentityServer needs a persistence store to keep dynamically created state. This data is collectively called operational data, and includes:\nGrants for authorization and device codes, reference and refresh tokens, and remembered user consent Keys managing dynamically created signing keys Server Side Sessions for storing authentication session data for interactive users server-side "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/configuration/dcr/reference/processing/",
    "title": "Request Processing",
    "tags": [],
    "description": "",
    "content": "IDynamicClientRegistrationRequestProcessor The IDynamicClientRegistrationValidator is the contract for the service that processes a dynamic client registration request. It contains a single ProcessAsync(\u0026hellip;) method.\nConceptually, the request processing step is responsible for setting properties on the Client model that are generated by the Configuration API itself. In contrast, the IDynamicClientRegistrationRequestProcessor is responsible for checking the validity of the metadata supplied in the registration request, and using that metadata to set properties of a Client model. The request processor is also responsible for passing the finished Client to the store\nMembers name description ProcessAsync(…) Processes a valid dynamic client registration request, setting properties of the client that are not specified in the request, and storing the new client in the IClientConfigurationStore. DynamicClientRegistrationRequestProcessor The DynamicClientRegistrationRequestProcessor is the default implementation of the IDynamicClientRegistrationRequestProcessor. If you need to customize some aspect of Dynamic Client Registration request processing, we recommend that you extend this class and override the appropriate virtual methods.\npublic class DynamicClientRegistrationRequestProcessor : IDynamicClientRegistrationRequestProcessor Request Processing Steps Each of these virtual methods represents one step of request processing. Each step is passed a DynamicClientRegistrationContext and returns a task that returns an IStepResult. The DynamicClientRegistrationContext includes the client model that will have its properties set, the DCR request, and other contextual information. The IStepResult either represents that the step succeeded or failed.\nname description virtual AddClientId Generates a client ID and adds it to the validatedRequest\u0026rsquo;s client model. virtual AddClientSecret Adds a client secret to a dynamic client registration request. Secret Generation The AddClientSecret method is responsible for adding the client\u0026rsquo;s secret and plaintext of that secret to the context\u0026rsquo;s Items dictionary for later use. If you want to customize secret generation more simply, you can override the GenerateSecret method, which only needs to return a tuple containing the secret and its plaintext.\nname description virtual GenerateSecret Generates a secret for a dynamic client registration request. "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/ui/server_side_sessions/session_expiration/",
    "title": "Session Expiration",
    "tags": [],
    "description": "",
    "content": "If the user session ends when the session cookie expires without explicitly triggering logout, there is most likely the need to clean up the server-side session data. In order to remove these expired records, there is an automatic cleanup mechanism that periodically scans for expired sessions. When these records are cleaned up, you can optionally notify the client that the session has ended via back-channel logout.\nExpiration Configuration The expiration configuration features can be configured with the server-side session options. It is enabled by default, but if you wish to disable it or change how often IdentityServer will check for expired sessions, you can.\nFor example, to change the interval:\nbuilder.Services.AddIdentityServer(options =\u0026gt; { options.ServerSideSessions.RemoveExpiredSessionsFrequency = TimeSpan.FromSeconds(60); }) .AddServerSideSessions(); To disable:\nbuilder.Services.AddIdentityServer(options =\u0026gt; { options.ServerSideSessions.RemoveExpiredSessions = false; }) .AddServerSideSessions(); Back-channel Logout When the session cleanup job removes expired records, it will by default also trigger back-channel logout notifications to client applications participating in the session. You can use this mechanism to create an inactivity timeout that applies across all your client applications.\nThe ServerSideSessions.ExpiredSessionsTriggerBackchannelLogout flag enables this behavior, and it is on by default.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/response_handling/token_response_generator/",
    "title": "Token Response Generator",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.ResponseHandling.ITokenResponseGenerator The ITokenResponseGenerator interface is the contract for the service that generates responses to valid requests to the token endpoint. A response in this context refers to an object model that describes the content that will be serialized and transmitted in the HTTP response.\nThe default implementation is the TokenResponseGenerator class. You can customize the behavior of the token endpoint by providing your own implementation of the ITokenResponseGenerator to the DI system.\nTo create a customized implementation of ITokenResponseGenerator, we recommend that you create a class that derives from the default implementation. Your custom implementation should override the appropriate virtual methods of the default implementation and add your custom behavior to those overrides, possibly calling the base methods first and then manipulating their results.\nITokenResponseGenerator The ITokenResponseGenerator contains a single method to process validated token requests and return token responses.\nProcessInteractionAsync\nReturns the TokenResponse based on the ValidatedTokenRequest.\nTokenResponseGenerator The default implementation of the ITokenResponseGenerator contains virtual methods that can be overridden to customize particular behavior for particular token requests.\nProcessAsync\nReturns the TokenResponse for any TokenRequestValidationResult.\nProcessClientCredentialsRequestAsync\nReturns the TokenResponse for a TokenRequestValidationResult from the client credentials flow.\nProcessPasswordRequestAsync\nReturns the TokenResponse for a TokenRequestValidationResult from the resource owner password flow.\nProcessAuthorizationCodeRequestAsync\nReturns the TokenResponse for a TokenRequestValidationResult from the authorization code flow.\nProcessRefreshTokenRequestAsync\nReturns the TokenResponse for a TokenRequestValidationResult from the refresh token flow.\nProcessDeviceCodeRequestAsync\nReturns the TokenResponse for a TokenRequestValidationResult from the device code flow.\nProcessCibaRequestAsync\nReturns the TokenResponse for a TokenRequestValidationResult from the CIBA flow.\nProcessExtensionGrantRequestAsync\nReturns the TokenResponse for a TokenRequestValidationResult from an extension grant.\nCreateAccessTokenAsync\nCreates an access token and optionally a refresh token.\nCreateIdTokenFromRefreshTokenRequestAsync\nCreates an ID token in a refresh token request.\nTokenResponse The TokenResponse class represents the data that will be included in the body of the response returned from the token endpoint. It contains properties for the various tokens that can be returned, the scope and expiration of the access token, and a mechanism for adding custom properties to the result. Omitting property values will cause the entire property to be absent from the response.\nIdentityToken\nThe identity token.\nAccessToken\nThe access token.\nRefreshToken\nThe refresh token.\nAccessTokenLifetime\nThe access token lifetime in seconds.\nScope\nThe scope.\nCustom\nA dictionary of strings to objects that will be serialized to json and added to the token response.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/samples/ui/",
    "title": "User Interaction",
    "tags": [],
    "description": "Samples",
    "content": "These samples illustrate customization of the interactive pages used in your IdentityServer.\nCustom Profile Service This sample shows how to create a custom profile service to control what claims are issued from your IdentityServer. The majority of the sample is captured in CustomProfileService.cs in the IdentityServer project.\nAlso, another part of the sample shows how to collect a custom claim during the login workflow when using an external login provider (this is done in the ExternalLogin/Callback.cshtml.cs processing logic). This claim value is then stored in the user\u0026rsquo;s session, and is then ultimately copied into the created tokens via the custom profile service logic.\nlink to source code\nStep Up This sample shows how to implement step up. The Demo consists of 3 projects:\nIdentityServerHost is a token server implemented with Duende IdentityServer. Api is a protected resource that uses the IdentityServerHost as its authority and can make Step-Up responses when requests don\u0026rsquo;t meet its authentication requirements. Client is a client application that uses IdentityServerHost to login and makes requests to the Api. To run the demo, start all three projects and navigate to the Client application at https://localhost:6001. From there, you can click on links to pages that will trigger step up in various ways. For example, you could\nClick on the secure page to trigger login. Authenticate with user alice, password alice. Note that alice does not require MFA to log in. Click on the MFA page to make an API request that requires MFA. This will trigger step up for Alice, who should be shown a fake MFA page at IdentityServer before returning to the Client application. Finally, click on the Recent Auth page to make an API request that requires an authentication in the past minute. The page will show the age of the authentication. It may be necessary to refresh the page after a minute has passed to trigger step up. From there, you can experiment with other interactions. You can go to the Recent Auth with MFA page that has both authentication requirements, or try the user bob, who always requires MFA.\nlink to source code\nSPA-style login page This sample shows an example of building the interactive pages (login, consent, logout, and error) as client-rendered (typical of SPAs), rather than server-rendered. Since there are many different SPA frameworks, the actual pages are coded using vanilla JavaScript.\nKey takeaways:\nhow to handle the necessary request parameters how to contact the backend of IdentityServer to implement the various workflows (login, logout, etc.) how to implement a backend to support the frontend pages link to source code\nDynamic providers The dynamic providers feature allows for loading OpenID Connect identity provider configuration dynamically from a store. This sample sets up a simple database with one dynamic OIDC provider.\nSome key points about the IdentityServer project in the sample:\nExecute the command \u0026ldquo;dotnet run /seed\u0026rdquo; to create and populate the Sqlite database. SeedData.cs has the code to populate the dynamic provider in the database. In the Account/Login/Index.cshtml.cs file, the code to build the UI to list the dynamic providers is in the BuildModelAsync helper. It uses the IIdentityProviderStore to query the dynamic provider database. link to source code\nAdding other protocol types to dynamic providers The dynamic providers feature allows for loading OpenID Connect identity provider configuration dynamically from a store. This sample shows how to extend the dynamic providers feature to support additional protocol types, and specifically WS-Federation.\nKey takeaways:\nhow to define a custom identity provider model how to map from the custom identity provider model to the protocol options how to register the custom protocol type with IdentityServer how to register the custom protocol type with IdentityServer how to use the existing provider store to persist custom provider model data link to source code\nUsing Sustainsys.Saml2 with dynamic providers The Sustainsys.Saml2 open source library adds Saml2 protocol support to Asp.Net Core. It can be used together with the Duende dynamic identity providers feature. The sample is minimalistic to show a simple Saml2 config and does not handle the complete set of Saml2 config options.\nlink to source code\nClient Initiated Backchannel Login (CIBA) This sample shows how a client can make CIBA login requests using Duende IdentityServer. To run the sample, the IdentityServer and API hosts should be started first. Next run the ConsoleCibaClient which will initiate the backchannel login request. The URL the user would receive to login and approve the request is being written out to the IdentityServer log (visible in the console window). Follow that URL, login as \u0026ldquo;alice\u0026rdquo;, and then approve the login request to allow the client to receive the results.\nlink to source code\nWindows Authentication with IIS Hosting This sample shows how to use Windows Authentication when hosting your IdentityServer behind IIS (or IIS Express). The salient piece to understand is a new LoginWithWindows action method in the AccountController from the quickstarts. Windows authentication is triggered, and once the result is determined the main authentication session cookie is created based on the WindowsIdentity results. Also, note there is some configuration in Startup with a call to Configure\u0026lt;IISOptions\u0026gt; (mainly to set AutomaticAuthentication to false).\nlink to source code\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/models/api_scope/",
    "title": "API Scope",
    "tags": [],
    "description": "Model Reference",
    "content": "Duende.IdentityServer.Models.ApiScope This class models an OAuth scope.\nEnabled\nIndicates if this resource is enabled and can be requested. Defaults to true.\nName\nThe unique name of the API. This value is used for authentication with introspection and will be added to the audience of the outgoing access token.\nDisplayName\nThis value can be used e.g. on the consent screen.\nDescription\nThis value can be used e.g. on the consent screen.\nUserClaims\nList of associated user claim types that should be included in the access token.\nDefining API scope in appsettings.json The AddInMemoryApiResource extension method also supports adding clients from the ASP.NET Core configuration file::\n\u0026#34;IdentityServer\u0026#34;: { \u0026#34;IssuerUri\u0026#34;: \u0026#34;urn:sso.company.com\u0026#34;, \u0026#34;ApiScopes\u0026#34;: [ { \u0026#34;Name\u0026#34;: \u0026#34;IdentityServerApi\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;resource1.scope1\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;resource2.scope1\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;scope3\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;shared.scope\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;transaction\u0026#34;, \u0026#34;DisplayName\u0026#34;: \u0026#34;Transaction\u0026#34;, \u0026#34;Description\u0026#34;: \u0026#34;A transaction\u0026#34; } ] } Then pass the configuration section to the AddInMemoryApiScopes method:\nidsvrBuilder.AddInMemoryApiScopes(configuration.GetSection(\u0026#34;IdentityServer:ApiScopes\u0026#34;)) "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/upgrades/v7.1_to_v7.2/",
    "title": "Duende IdentityServer v7.1 to v7.2",
    "tags": [],
    "description": "",
    "content": "This upgrade guide covers upgrading from Duende IdentityServer v7.1 to v7.2 (release notes).\nWhat\u0026rsquo;s New Duende IdentityServer 7.2 adds:\nDo not issue TokenIssuedFailureEvent for use_dpop_nonce error Use AsyncServiceScope in Background Services Use query-safe URL fragment when returning an error Add an option for strict validation of assertion audiences General improvements to XML documentation and null reference exception handling Preview Features: Strict Audience Validation and Discovery Document Caching Bug fixes and ongoing maintenance There are no changes to the data stores in this release.\nStep 1: Update NuGet package In your IdentityServer host project, update the version of the NuGet. For example in your project file:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;7.1.0\u0026#34; /\u0026gt; would change to:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;7.2.0\u0026#34; /\u0026gt; Step 2: Done! That\u0026rsquo;s it. Of course, at this point you can and should test that your IdentityServer is updated and working properly.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/upgrades/v7.0_to_v7.1/",
    "title": "Duende IdentityServer v7.0 to v7.1",
    "tags": [],
    "description": "",
    "content": "What\u0026rsquo;s New IdentityServer v7.1 includes support for .NET 9 and many other smaller fixes and enhancements. Please see our release notes for complete details.\nThere are no schema changes needed for IdentityServer 7.1. There are two changes that may require small code changes for a minority of users:\nIdentityModel renamed Duende.IdentityModel ClientConfigurationStore now uses IConfigurationDbContext Step 1 (Optional): IdentityServer 7.1 supports both .NET 8 and 9. If you wish, you can update your .NET version as part of this upgrade.\nFor example in your project file:\n\u0026lt;TargetFramework\u0026gt;net8.0\u0026lt;/TargetFramework\u0026gt; would change to:\n\u0026lt;TargetFramework\u0026gt;net9.0\u0026lt;/TargetFramework\u0026gt; Any NuGet packages that you are using that target an older version of .NET should also be updated. For example, the version of Microsoft.EntityFrameworkCore.SqlServer or Microsoft.AspNetCore.Authentication.Google should be updated. Depending on what your IdentityServer host project is using, there may or may not be code changes based on those updated dependencies.\nStep 2: In your IdentityServer host project, update the version of the Duende.IdentityServer package. For example in your project file:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;7.0.8\u0026#34; /\u0026gt; would change to:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;7.1.0\u0026#34; /\u0026gt; Step 3: Breaking Changes IdentityModel renamed Duende.IdentityModel Our open source IdentityModel library has been renamed Duende.IdentityModel, and we now depend on Duende.IdentityModel instead of IdentityModel. Duende.IdentityModel is a drop-in replacement for IdentityModel with updated namespaces that include the Duende prefix. If you are using IdentityModel\u0026rsquo;s types in your IdentityServer implementation, you will need to update references from IdentityModel to Duende.IdentityModel (replace \u0026ldquo;using IdentityModel\u0026rdquo; with \u0026ldquo;using Duende.IdentityModel\u0026rdquo;)._\nClientConfigurationStore now uses IConfigurationDbContext The ClientConfigurationStore in the Duende.Configuration.EntityFramework package now depends on IConfigurationDbContext instead of ConfigurationDbContext to allow for customization. If you have a customized store that derives from the default store, you may need to update your constructors. Note that this only affects the Entity Framework based implementation of the configuration store used by the dynamic client registration configuration API.\nStep 4: Done! That\u0026rsquo;s it. Of course, at this point you can and should test that your IdentityServer is updated and working properly.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/models/api_resource/",
    "title": "API Resource",
    "tags": [],
    "description": "Model Reference",
    "content": "Duende.IdentityServer.Models.ApiResource This class models an API.\nEnabled\nIndicates if this resource is enabled and can be requested. Defaults to true.\nName\nThe unique name of the API. This value is used for authentication with introspection and will be added to the audience of the outgoing access token.\nDisplayName\nThis value can be used e.g. on the consent screen.\nDescription\nThis value can be used e.g. on the consent screen.\nRequireResourceIndicator\nIndicates if this API resource requires the resource indicator to request it, and expects access tokens issued to it will only ever contain this API resource as the audience.\nApiSecrets\nThe API secret is used for the introspection endpoint. The API can authenticate with introspection using the API name and secret.\nAllowedAccessTokenSigningAlgorithms\nList of allowed signing algorithms for access token. If empty, will use the server default signing algorithm.\nUserClaims\nList of associated user claim types that should be included in the access token.\nScopes\nList of API scope names. You need to create those using ApiScope.\nDefining API resources in appsettings.json The AddInMemoryApiResource extensions method also supports adding API resources from the ASP.NET Core configuration file::\n\u0026quot;IdentityServer\u0026quot;: { \u0026quot;IssuerUri\u0026quot;: \u0026quot;urn:sso.company.com\u0026quot;, \u0026quot;ApiResources\u0026quot;: [ { \u0026quot;Name\u0026quot;: \u0026quot;resource1\u0026quot;, \u0026quot;DisplayName\u0026quot;: \u0026quot;Resource #1\u0026quot;, \u0026quot;Scopes\u0026quot;: [ \u0026quot;resource1.scope1\u0026quot;, \u0026quot;shared.scope\u0026quot; ] }, { \u0026quot;Name\u0026quot;: \u0026quot;resource2\u0026quot;, \u0026quot;DisplayName\u0026quot;: \u0026quot;Resource #2\u0026quot;, \u0026quot;UserClaims\u0026quot;: [ \u0026quot;name\u0026quot;, \u0026quot;email\u0026quot; ], \u0026quot;Scopes\u0026quot;: [ \u0026quot;resource2.scope1\u0026quot;, \u0026quot;shared.scope\u0026quot; ] } ] } Then pass the configuration section to the AddInMemoryApiResource method:\nidsvrBuilder.AddInMemoryApiResources(configuration.GetSection(\u0026#34;IdentityServer:ApiResources\u0026#34;)) "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/fundamentals/resources/api_resources/",
    "title": "API Resources",
    "tags": [],
    "description": "Overview",
    "content": "When the API/resource surface gets larger, a flat list of scopes might become hard to manage.\nIn Duende IdentityServer, the ApiResource class allows for some additional organization as well as grouping and isolation of scopes as well as providing some common settings.\nLet\u0026rsquo;s use the following scope definition as an example:\npublic static IEnumerable\u0026lt;ApiScope\u0026gt; GetApiScopes() { return new List\u0026lt;ApiScope\u0026gt; { // invoice API specific scopes new ApiScope(name: \u0026#34;invoice.read\u0026#34;, displayName: \u0026#34;Reads your invoices.\u0026#34;), new ApiScope(name: \u0026#34;invoice.pay\u0026#34;, displayName: \u0026#34;Pays your invoices.\u0026#34;), // customer API specific scopes new ApiScope(name: \u0026#34;customer.read\u0026#34;, displayName: \u0026#34;Reads you customers information.\u0026#34;), new ApiScope(name: \u0026#34;customer.contact\u0026#34;, displayName: \u0026#34;Allows contacting one of your customers.\u0026#34;), // shared scopes new ApiScope(name: \u0026#34;manage\u0026#34;, displayName: \u0026#34;Provides administrative access.\u0026#34;), new ApiScope(name: \u0026#34;enumerate\u0026#34;, displayName: \u0026#34;Allows enumerating data.\u0026#34;) }; } With ApiResource you can now create two logical APIs and their corresponding scopes:\npublic static readonly IEnumerable\u0026lt;ApiResource\u0026gt; GetApiResources() { return new List\u0026lt;ApiResource\u0026gt; { new ApiResource(\u0026#34;invoice\u0026#34;, \u0026#34;Invoice API\u0026#34;) { Scopes = { \u0026#34;invoice.read\u0026#34;, \u0026#34;invoice.pay\u0026#34;, \u0026#34;manage\u0026#34;, \u0026#34;enumerate\u0026#34; } }, new ApiResource(\u0026#34;customer\u0026#34;, \u0026#34;Customer API\u0026#34;) { Scopes = { \u0026#34;customer.read\u0026#34;, \u0026#34;customer.contact\u0026#34;, \u0026#34;manage\u0026#34;, \u0026#34;enumerate\u0026#34; } } }; } Using the API resource grouping gives you the following additional features\nsupport for the JWT aud claim. The value(s) of the audience claim will be the name of the API resource(s) support for adding common user claims across all contained scopes support for introspection by assigning an API secret to the resource support for configuring the access token signing algorithm for the resource Let\u0026rsquo;s have a look at some example access tokens for the above resource configuration.\nClient requests: invoice.read and invoice.pay:\n{ \u0026#34;typ\u0026#34;: \u0026#34;at+jwt\u0026#34; }. { \u0026#34;client_id\u0026#34;: \u0026#34;client\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;aud\u0026#34;: \u0026#34;invoice\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;invoice.read invoice.pay\u0026#34; } Client requests: invoice.read and customer.read:\n{ \u0026#34;typ\u0026#34;: \u0026#34;at+jwt\u0026#34; }. { \u0026#34;client_id\u0026#34;: \u0026#34;client\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;aud\u0026#34;: [ \u0026#34;invoice\u0026#34;, \u0026#34;customer\u0026#34; ], \u0026#34;scope\u0026#34;: \u0026#34;invoice.read customer.read\u0026#34; } Client requests: manage:\n{ \u0026#34;typ\u0026#34;: \u0026#34;at+jwt\u0026#34; }. { \u0026#34;client_id\u0026#34;: \u0026#34;client\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;aud\u0026#34;: [ \u0026#34;invoice\u0026#34;, \u0026#34;customer\u0026#34; ], \u0026#34;scope\u0026#34;: \u0026#34;manage\u0026#34; } Adding user claims You can specify that an access token for an API resource (regardless of which scope is requested) should contain additional user claims.\nvar customerResource = new ApiResource(\u0026#34;customer\u0026#34;, \u0026#34;Customer API\u0026#34;) { Scopes = { \u0026#34;customer.read\u0026#34;, \u0026#34;customer.contact\u0026#34;, \u0026#34;manage\u0026#34;, \u0026#34;enumerate\u0026#34; }, // additional claims to put into access token UserClaims = { \u0026#34;department_id\u0026#34;, \u0026#34;sales_region\u0026#34; } } If a client now requested a scope belonging to the customer resource, the access token would contain the additional claims (if provided by your profile service).\n{ \u0026#34;typ\u0026#34;: \u0026#34;at+jwt\u0026#34; }. { \u0026#34;client_id\u0026#34;: \u0026#34;client\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;aud\u0026#34;: [ \u0026#34;invoice\u0026#34;, \u0026#34;customer\u0026#34; ], \u0026#34;scope\u0026#34;: \u0026#34;invoice.read customer.read\u0026#34;, \u0026#34;department_id\u0026#34;: 5, \u0026#34;sales_region\u0026#34;: \u0026#34;south\u0026#34; } Setting a signing algorithm Your APIs might have certain requirements for the cryptographic algorithm used to sign the access tokens for that resource. An example could be regulatory requirements, or that you are starting to migrate your system to higher security algorithms.\nThe following sample sets PS256 as the required signing algorithm for the invoices API:\nvar invoiceApi = new ApiResource(\u0026#34;invoice\u0026#34;, \u0026#34;Invoice API\u0026#34;) { Scopes = { \u0026#34;invoice.read\u0026#34;, \u0026#34;invoice.pay\u0026#34;, \u0026#34;manage\u0026#34;, \u0026#34;enumerate\u0026#34; }, AllowedAccessTokenSigningAlgorithms = { SecurityAlgorithms.RsaSsaPssSha256 } } Make sure that you have configured your IdentityServer for the required signing algorithm. See here for more details.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/apis/aspnetcore/authorization/",
    "title": "Authorization based on Scopes and other Claims",
    "tags": [],
    "description": "",
    "content": "The access token will include additional claims that can be used for authorization, e.g. the scope claim will reflect the scope the client requested (and was granted) during the token request.\nIn ASP.NET core, the contents of the JWT payload get transformed into claims and packaged up in a ClaimsPrincipal. So you can always write custom validation or authorization logic in C#:\npublic IActionResult Get() { var isAllowed = User.HasClaim(\u0026#34;scope\u0026#34;, \u0026#34;read\u0026#34;); // rest omitted } For better encapsulation and re-use, consider using the ASP.NET Core authorization policy feature.\nWith this approach, you would first turn the claim requirement(s) into a named policy:\nbuilder.Services.AddAuthorization(options =\u0026gt; { options.AddPolicy(\u0026#34;read_access\u0026#34;, policy =\u0026gt; policy.RequireClaim(\u0026#34;scope\u0026#34;, \u0026#34;read\u0026#34;)); }); ..and then enforce it, e.g. using the routing table:\napp.MapControllers().RequireAuthorization(\u0026#34;read_access\u0026#34;); \u0026hellip;or imperatively inside the controller:\npublic class DataController : ControllerBase { IAuthorizationService _authz; public DataController(IAuthorizationService authz) { _authz = authz; } public async Task\u0026lt;IActionResult\u0026gt; Get() { var allowed = _authz.CheckAccess(User, \u0026#34;read_access\u0026#34;); // rest omitted } } \u0026hellip; or declaratively:\npublic class DataController : ControllerBase { [Authorize(\u0026#34;read_access\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Get() { var allowed = authz.CheckAccess(User, \u0026#34;read_access\u0026#34;); // rest omitted } } Scope claim format Historically, Duende IdentityServer emitted the scope claims as an array in the JWT. This works very well with the .NET deserialization logic, which turns every array item into a separate claim of type scope.\nThe newer JWT Profile for OAuth spec mandates that the scope claim is a single space delimited string. You can switch the format by setting the EmitScopesAsSpaceDelimitedStringInJwt on the options. But this means that the code consuming access tokens might need to be adjusted. The following code can do a conversion to the multiple claims format that .NET prefers:\nnamespace IdentityModel.AspNetCore.AccessTokenValidation; /// \u0026lt;summary\u0026gt; /// Logic for normalizing scope claims to separate claim types /// \u0026lt;/summary\u0026gt; public static class ScopeConverter { /// \u0026lt;summary\u0026gt; /// Logic for normalizing scope claims to separate claim types /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;principal\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static ClaimsPrincipal NormalizeScopeClaims(this ClaimsPrincipal principal) { var identities = new List\u0026lt;ClaimsIdentity\u0026gt;(); foreach (var id in principal.Identities) { var identity = new ClaimsIdentity(id.AuthenticationType, id.NameClaimType, id.RoleClaimType); foreach (var claim in id.Claims) { if (claim.Type == \u0026#34;scope\u0026#34;) { if (claim.Value.Contains(\u0026#39; \u0026#39;)) { var scopes = claim.Value.Split(\u0026#39; \u0026#39;, StringSplitOptions.RemoveEmptyEntries); foreach (var scope in scopes) { identity.AddClaim(new Claim(\u0026#34;scope\u0026#34;, scope, claim.ValueType, claim.Issuer)); } } else { identity.AddClaim(claim); } } else { identity.AddClaim(claim); } } identities.Add(identity); } return new ClaimsPrincipal(identities); } } The above code could then be called as an extension method or as part of claims transformation.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/fundamentals/clients/",
    "title": "Clients",
    "tags": [],
    "description": "Fundamentals",
    "content": "Clients represent applications that can request tokens from your IdentityServer.\nThe details vary, but you typically define the following common settings for a client:\na unique client ID a secret if needed the allowed interactions with the token service (called a grant type) a network location where identity and/or access token gets sent to (called a redirect URI) a list of scopes (aka resources) the client is allowed to access Defining a client for server to server communication In this scenario no interactive user is present - a service (i.e. the client) wants to communicate with an API (i.e. the resource that supports the scope):\npublic class Clients { public static IEnumerable\u0026lt;Client\u0026gt; Get() { return new List\u0026lt;Client\u0026gt; { new Client { ClientId = \u0026#34;service.client\u0026#34;, ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, AllowedGrantTypes = GrantTypes.ClientCredentials, AllowedScopes = { \u0026#34;api1\u0026#34;, \u0026#34;api2.read_only\u0026#34; } } }; } } Defining an interactive application for use authentication and delegated API access Interactive applications (e.g. web applications or native desktop/mobile applications) use the authorization code flow. This flow gives you the best security because the access tokens are transmitted via back-channel calls only (and gives you access to refresh tokens):\nvar interactiveClient = new Client { ClientId = \u0026#34;interactive\u0026#34;, AllowedGrantTypes = GrantTypes.Code, AllowOfflineAccess = true, ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, RedirectUris = { \u0026#34;http://localhost:21402/signin-oidc\u0026#34; }, PostLogoutRedirectUris = { \u0026#34;http://localhost:21402/\u0026#34; }, FrontChannelLogoutUri = \u0026#34;http://localhost:21402/signout-oidc\u0026#34;, AllowedScopes = { IdentityServerConstants.StandardScopes.OpenId, IdentityServerConstants.StandardScopes.Profile, IdentityServerConstants.StandardScopes.Email, \u0026#34;api1\u0026#34;, \u0026#34;api2.read_only\u0026#34; }, }; Defining clients in appsettings.json The AddInMemoryClients extensions method also supports adding clients from the ASP.NET Core configuration file. This allows you to define static clients directly from the appsettings.json file:\n\u0026#34;IdentityServer\u0026#34;: { \u0026#34;Clients\u0026#34;: [ { \u0026#34;Enabled\u0026#34;: true, \u0026#34;ClientId\u0026#34;: \u0026#34;local-dev\u0026#34;, \u0026#34;ClientName\u0026#34;: \u0026#34;Local Development\u0026#34;, \u0026#34;ClientSecrets\u0026#34;: [ { \u0026#34;Value\u0026#34;: \u0026#34;\u0026lt;Insert Sha256 hash of the secret encoded as Base64 string\u0026gt;\u0026#34; } ], \u0026#34;AllowedGrantTypes\u0026#34;: [ \u0026#34;client_credentials\u0026#34; ], \u0026#34;AllowedScopes\u0026#34;: [ \u0026#34;api1\u0026#34; ], } ] } Then pass the configuration section to the AddInMemoryClients method:\nAddInMemoryClients(configuration.GetSection(\u0026#34;IdentityServer:Clients\u0026#34;)) "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/endpoints/",
    "title": "Endpoints",
    "tags": [],
    "description": "",
    "content": "Endpoints Discovery Endpoint Authorize Endpoint Token Endpoint UserInfo Endpoint Introspection Endpoint Revocation Endpoint End Session Endpoint Device Authorization Endpoint Backchannel Authentication Endpoint "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/ui/error/",
    "title": "Error",
    "tags": [],
    "description": "",
    "content": "The error page is used to display to the end user that an error has occurred during a request to the authorize endpoint.\nWhen an error occurs, IdentityServer will redirect the user to a configurable ErrorUrl.\nbuilder.Services.AddIdentityServer(opt =\u0026gt; { opt.UserInteraction.ErrorUrl = \u0026#34;/path/to/error\u0026#34;; }) The default ErrorUrl is \u0026ldquo;/home/error\u0026rdquo;. The quickstart UI includes a basic implementation of an error page at that route.\nErrors are commonly due to misconfiguration, and there\u0026rsquo;s not much an end user can do about that. But this allows the user to understand that something went wrong and that they are not in the middle of a successful workflow.\nError Context Details of the error are provided to the error page via a query string parameter. That parameter\u0026rsquo;s name is configurable using the ErrorId option.\nbuilder.Services.AddIdentityServer(opt =\u0026gt; { opt.UserInteraction.ErrorId = \u0026#34;ErrorQueryStringParamName\u0026#34;; }) By default, the ErrorId is simply the string \u0026ldquo;errorId\u0026rdquo;.\nThe interaction service provides a GetErrorContextAsync API that will load error details for an ErrorId. The returned ErrorMessage object contains these details.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/deployment/data_stores/",
    "title": "IdentityServer Data Stores",
    "tags": [],
    "description": "Deployment",
    "content": "IdentityServer itself is stateless and does not require server affinity - but there is data that needs to be shared between in multi-instance deployments.\nConfiguration data This typically includes:\nresources clients startup configuration, e.g. key material, external provider settings etc… The way you store that data depends on your environment. In situations where configuration data rarely changes we recommend using the in-memory stores and code or configuration files. In highly dynamic environments (e.g. Saas) we recommend using a database or configuration service to load configuration dynamically.\nOperational data For certain operations, IdentityServer needs a persistence store to keep state, this includes:\nissuing authorization codes issuing reference and refresh tokens storing consent automatic management for signing keys You can either use a traditional database for storing operational data, or use a cache with persistence features like Redis.\nDuende IdentityServer includes storage implementations for above data using EntityFramework, and you can build your own. See the data stores section for more information.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/tokens/password_grant/",
    "title": "Issuing Tokens based on User Passwords",
    "tags": [],
    "description": "",
    "content": "The password grant type is an OAuth 2.0 protocol flow for authenticating end-users at the token endpoint. It is designed for legacy applications, and it is generally recommended to use a browser-based flow instead - but in certain situation it is not feasible to change existing applications.\nThe password grant type is deprecated per OAuth 2.1.\nRequesting a token using Password grant First you need to add the GrantType.Password to the AllowedGrantTypes list of the client you want to use.\nThen your client application would provide some means for the end-user to enter their credentials and post them to the token endpoint:\nPOST /token HTTP/1.1 Host: demo.duendesoftware.com Content-Type: application/x-www-form-urlencoded client_id=client\u0026amp; client_secret=secret\u0026amp; grant_type=password\u0026amp; username=bob\u0026amp; password=password .NET client library On .NET you can use the IdentityModel client library to request tokens using the password grant type, e.g.:\nusing IdentityModel.Client; var client = new HttpClient(); var response = await client.RequestPasswordTokenAsync(new PasswordTokenRequest { Address = \u0026#34;https://demo.duendesoftware.com/connect/token\u0026#34;, ClientId = \u0026#34;client\u0026#34;, ClientSecret = \u0026#34;secret\u0026#34;, Scope = \u0026#34;api1\u0026#34;, UserName = \u0026#34;bob\u0026#34;, Password = \u0026#34;password\u0026#34; }); Validating the token request Since this flow is not generally recommended, no standard implementation for validating the token request and user credentials is included. To add support for it you need to to implement and register an implementation of the IResourceOwnerPasswordValidator interface::\npublic interface IResourceOwnerPasswordValidator { /// \u0026lt;summary\u0026gt; /// Validates the resource owner password credential /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;context\u0026#34;\u0026gt;The context.\u0026lt;/param\u0026gt; Task ValidateAsync(ResourceOwnerPasswordValidationContext context); } The context contains parsed protocol parameters like UserName and Password as well as the raw request.\nIt is the job of the validator to implement the password validation and set the Result property on the context accordingly (see the Grant Validation Result reference).\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/diagnostics/otel/",
    "title": "OpenTelemetry",
    "tags": [],
    "description": "",
    "content": "(added in v6.1, expanded in v7.0)\nOpenTelemetry is a collection of tools, APIs, and SDKs for generating and collecting telemetry data (metrics, logs, and traces). This is very useful for analyzing software performance and behavior, especially in highly distributed systems.\n.NET 8 comes with first class support for Open Telemetry. IdentityServer emits traces, metrics and logs.\nMetrics Metrics are high level statistic counters. They provide an aggregated overview and can be used to set monitoring rules.\nLogs OpenTelemetry in .NET 8 exports the logs written to the standard ILogger system. The logs are augmented with trace ids to be able to correlate log entries with traces.\nTraces Traces shows individual requests and dependencies. The output is very useful for visualizing the control flow and finding performance bottlenecks.\nThis is an example of distributed traces from a web application calling an API (displayed using our Aspire sample). The web application uses a refresh token to call IdentityServer to get a new access token and then calls the API. The API reads the discovery endpoint, finds the jwks url and then gets the keys from jwks endpoint. "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/overview/specs/",
    "title": "Supported Specifications",
    "tags": [],
    "description": "",
    "content": "Duende IdentityServer implements the following specifications:\nOpenID Connect OpenID Connect Core 1.0 (spec) OpenID Connect Discovery 1.0 (spec) OpenID Connect RP-Initiated Logout 1.0 (spec) OpenID Connect Session Management 1.0 (spec) OpenID Connect Front-Channel Logout 1.0 (spec) OpenID Connect Back-Channel Logout 1.0 (spec) Multiple Response Types (spec) Form Post Response Mode (spec) Enterprise Edition: OpenID Connect Client-Initiated Backchannel Authentication (CIBA) (spec). OAuth 2.x OAuth 2.0 (RFC 6749) OAuth 2.0 Bearer Token Usage (RFC 6750) JSON Web Token (RFC 7519) OAuth 2.0 Token Revocation (RFC 7009) OAuth 2.0 Token Introspection (RFC 7662) Proof Key for Code Exchange by OAuth Public Clients (RFC 7636) OAuth 2.0 JSON Web Tokens for Client Authentication (RFC 7523) OAuth 2.0 Device Authorization Grant (RFC 8628) Proof-of-Possession Key Semantics for JSON Web Tokens (RFC 7800) OAuth 2.0 Mutual TLS Client Authentication and Certificate-Bound Access Tokens (RFC 8705) OAuth 2.0 Token Exchange (RFC 8693) JWT Secured Authorization Request / JAR (RFC 9101) JWT Profile for OAuth 2.0 Access Tokens (RFC 9068) OAuth 2.0 Authorization Server Issuer Identifier in Authorization Response (RFC 9207) OAuth 2.0 Step-up Authentication Challenge Protocol (RFC 9470) Business Edition: OAuth 2.0 Dynamic Client Registration Protocol (RFC 7591) Business Edition: OAuth 2.0 Pushed Authorization Requests (RFC 9126) Enterprise Edition: Resource Indicators for OAuth 2.0 (RFC 8707) Enterprise Edition: OAuth 2.0 Demonstrating Proof-of-Possession at the Application Layer / DPoP (RFC 9449) "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/tokens/authentication/mtls/",
    "title": "TLS Client Certificates",
    "tags": [],
    "description": "",
    "content": "Clients can use an X.509 client certificate as an authentication mechanism to endpoints in your IdentityServer.\nFor this you need to associate a client certificate with a client in your IdentityServer and enable MTLS support on the options.\nvar idsvrBuilder = builder.Services.AddIdentityServer(options =\u0026gt; { options.MutualTls.Enabled = true; }) Use the DI extensions methods to add the services to DI which contain a default implementation to do that either thumbprint or common-name based:\nidsvrBuilder.AddMutualTlsSecretValidators(); Then add client secret of type SecretTypes.X509CertificateName (for PKI-based scenarios) or SecretTypes.X509CertificateThumbprint (for self-issued certificates) to the client you want to authenticate.\nFor example::\nnew Client { ClientId = \u0026#34;mtls.client\u0026#34;, AllowedGrantTypes = GrantTypes.ClientCredentials, AllowedScopes = { \u0026#34;api1\u0026#34; }, ClientSecrets = { // name based new Secret(@\u0026#34;CN=client, OU=production, O=company\u0026#34;, \u0026#34;client.dn\u0026#34;) { Type = SecretTypes.X509CertificateName }, // or thumbprint based new Secret(\u0026#34;bca0d040847f843c5ee0fa6eb494837470155868\u0026#34;, \u0026#34;mtls.tb\u0026#34;) { Type = SecretTypes.X509CertificateThumbprint }, } } .NET client library When writing a client to connect to IdentityServer, the SocketsHttpHandler (or HttpClientHandler depending on your .NET version) class provides a convenient mechanism to add a client certificate to outgoing requests.\nUse such a handler with HttpClient to perform the client certificate authentication handshake at the TLS channel. The following snippet is using IdentityModel to read the discovery document and request a token:\nstatic async Task\u0026lt;TokenResponse\u0026gt; RequestTokenAsync() { var handler = new SocketsHttpHandler(); var cert = new X509Certificate2(\u0026#34;client.p12\u0026#34;, \u0026#34;password\u0026#34;); handler.SslOptions.ClientCertificates = new X509CertificateCollection { cert }; var client = new HttpClient(handler); var disco = await client.GetDiscoveryDocumentAsync(Constants.Authority); if (disco.IsError) throw new Exception(disco.Error); var response = await client.RequestClientCredentialsTokenAsync(new ClientCredentialsTokenRequest { Address = disco.MtlEndpointAliases.TokenEndpoint, ClientId = \u0026#34;mtls.client\u0026#34;, Scope = \u0026#34;api1\u0026#34; }); if (response.IsError) throw new Exception(response.Error); return response; } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/quickstarts/",
    "title": "Quickstarts",
    "tags": [],
    "description": "",
    "content": "Quickstarts The following hands-on tutorials guide you through a couple of common scenarios.\nOverview Protecting an API using Client Credentials Interactive Applications with ASP.NET Core ASP.NET Core and API access Token Management Using EntityFramework Core for configuration and operational data Using ASP.NET Core Identity Building Browser-Based Client Applications Building Blazor WASM client applications "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/samples/aspid/",
    "title": "ASP.NET Identity Integration",
    "tags": [],
    "description": "Sample",
    "content": "link to source code\nThis sample shows using ASP.NET Identity with Duende IdentityServer. The intent was to show the least amount of code needed to get a working sample that used Microsoft\u0026rsquo;s ASP.NET Identity user management library.\nThe first step in creating the sample was to create a new project that used the ASP.NET Identity templates from Visual Studio (\u0026ldquo;Individual Accounts\u0026rdquo; for the authentication type). This provides all of the \u0026ldquo;out of the box\u0026rdquo; features from ASP.NET Identity for user management with only minor modifications, which are described below.\nThen Duende IdentityServer was added to add OIDC/OAuth2 capabilities to the application. Only the minimal configuration was done to get Duende IdentityServer functional for this sample.\nFinally another project was added which acts as a OIDC client application to exercise the OIDC login (and logout) capabilities.\nThe changes to the template in the ASP.NET Identity project (i.e. \u0026ldquo;IdentityServerAspNetIdentity\u0026rdquo;):\nSqlite support was added, replacing the default of SqlServer. Duende IdentityServer was configured in Startup.cs with the necessary information about the client application, and the OIDC scopes it would be requesting. Debug level logging was enabled for the \u0026ldquo;Duende\u0026rdquo; prefix to allow viewing the logging emitted during request processing. In the middleware pipeline, UseIdentityServer replaced UseAuthentication. The logout page was scaffolded to allow modification (located in Areas/Identity/Pages/Account/Logout.cshtml). The default logout page from the template is unaware of OIDC single signout, so this feature was added. In the client application:\nA simple ASP.NET Core Razor Web Application was used as the starting point. In Startup.cs the standard cookie and OIDC authentication configuration was added. A secure page (Secure.cshtml) that required an authenticated user will render the logged in user\u0026rsquo;s claim in the page. The index page (Index.cshtml) was modified to allow a POST to trigger OIDC logout. A logout button was added to trigger the POST. "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/validators/ciba_user_validator/",
    "title": "Backchannel Authentication User Validator",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Validation.IBackchannelAuthenticationUserValidator The IBackchannelAuthenticationUserValidator interface is used to validate request hints and identify the user for whom the CIBA request is intended. To use CIBA, you are expected to implement this interface and register it in the DI system.\nIBackchannelAuthenticationUserValidator APIs ValidateRequestAsync\nValidates the backchannel login request with the provided BackchannelAuthenticationUserValidatorContext for the current request. Returns a BackchannelAuthenticationUserValidationResult object.\nBackchannelAuthenticationUserValidatorContext Models the information to validate and identity the user for a CIBA login request.\nClient\nThe Client making the request.\nLoginHintToken\nThe login hint request parameter from the request.\nIdTokenHint\nThe id token hint request parameter from the request.\nIdTokenHintClaims\nThe claims contained in the validated id token hint from the request.\nLoginHint\nThe login hint request parameter from the request.\nUserCode\nThe user code request parameter from the request.\nBindingMessage\nThe binding request parameter from the request.\nBackchannelAuthenticationUserValidationResult Models the result of a CIBA login request.\nSubject\nThe ClaimsPrincipal that represents the user that was successfully identified for the login request. This must contain the user\u0026rsquo;s \u0026ldquo;sub\u0026rdquo; claim.\nError\nThe error if the user validation failed.\nErrorDescription\nThe error description if the user validation failed.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/upgrades/v6.3_to_v7.0/",
    "title": "Duende IdentityServer v6.3 to v7.0",
    "tags": [],
    "description": "",
    "content": "What\u0026rsquo;s New IdentityServer v7.0 includes support for .NET 8, pushed authorization requests, OpenTelemetry metrics, cleanup job improvements, and many other fixes and enhancements. Please see our release notes for complete details.\nStep 1: Update .NET Version In your IdentityServer host project, update the version of the .NET framework. For example in your project file:\n\u0026lt;TargetFramework\u0026gt;net6.0\u0026lt;/TargetFramework\u0026gt; would change to:\n\u0026lt;TargetFramework\u0026gt;net8.0\u0026lt;/TargetFramework\u0026gt; Any NuGet packages that you are using that target an older version of .NET should also be updated. For example, the version of Microsoft.EntityFrameworkCore.SqlServer or Microsoft.AspNetCore.Authentication.Google should be updated. Depending on what your IdentityServer host project is using, there may or may not be code changes based on those updated dependencies.\nStep 2: Update NuGet package In your IdentityServer host project, update the version of the Duende.IdentityServer package. For example in your project file:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;6.3.0\u0026#34; /\u0026gt; would change to:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;7.0\u0026#34; /\u0026gt; Step 3: Update Database Schema The schema updates required in this version are:\nThe server-side session entity in Duende.IdentityServer.EntityFramework now uses a 64-bit long as its primary key (previously was a 32-bit int). Two new properties have been added to the client model for PAR support. Client.RequirePushedAuthorization is a new boolean property that controls if this client requires PAR. PAR is required if either the global configuration is enabled or if the client\u0026rsquo;s flag is enabled (this can\u0026rsquo;t be used to opt out of the global configuration). It is safe to initialize this column to false for existing clients, which will mean that the global configuration will be used. Client.PushedAuthorizationLifetime is a new nullable integer property that controls the lifetime of pushed authorization requests (in seconds) for a client. If this lifetime is set, it takes precedence over the global configuration. It is safe to initialize this column to null for existing clients, which means the global configuration is used. A new table has been added to store pushed authorization requests. This new table contains a hashed identifier, the pushed parameters (as a string, serialized and data protected), and the expiration time of the request. IdentityServer is abstracted from the data store on multiple levels, so the steps involved in updating your data store will depend on your implementation details.\nCustom Store Implementations The core of IdentityServer is written against the store interfaces, which abstract all the implementation details of actually storing data. If your IdentityServer implementation includes a custom implementation of those stores, then you will have to determine how best to include the changes in the model in the underlying data store and make any necessary changes to schemas, if your data store requires that.\nDuende.IdentityServer.EntityFramework We also provide a default implementation of the stores in the Duende.IdentityServer.EntityFramework package, but this implementation is still highly abstracted because it is usable with any database that has an EF provider. Different database vendors have very different dialects of sql that have different syntax and type systems, so we don\u0026rsquo;t provide schema changes directly. Instead, we provide the Entity Framework entities and mappings which can be used with Entity Framework\u0026rsquo;s migrations feature to generate the schema updates that are needed in your database.\nTo generate a migration for the new columns, run the command below. Note that you might need to adjust paths based on your specific organization of the migration files.\ndotnet ef migrations add Update_DuendeIdentityServer_v7_0 -c ConfigurationDbContext -o Migrations/ConfigurationDb dotnet ef migrations add Update_DuendeIdentityServer_v7_0 -c PersistedGrantDbContext -o Migrations/PersistedGrantDb The ServerSideSession.Id property has been changed from int to long. The generated migration handles the data type change but does not take into account that this column is the primary key for the table. If the primary key constraint is not removed, running the migration will fail. The primary key of the table needs to be dropped before the type is altered and then recreated. The easiest way to do so is to update the generated migration file:\n// Add this line before AlterColumn migrationBuilder.DropPrimaryKey(\u0026#34;PK_ServerSideSessions\u0026#34;, \u0026#34;ServerSideSessions\u0026#34;); // This should already be in the generated code migrationBuilder.AlterColumn\u0026lt;long\u0026gt;( name: \u0026#34;Id\u0026#34;, table: \u0026#34;ServerSideSessions\u0026#34;, type: \u0026#34;bigint\u0026#34;, nullable: false, oldClrType: typeof(int), oldType: \u0026#34;int\u0026#34;) .Annotation(\u0026#34;SqlServer:Identity\u0026#34;, \u0026#34;1, 1\u0026#34;) .OldAnnotation(\u0026#34;SqlServer:Identity\u0026#34;, \u0026#34;1, 1\u0026#34;); // Add this after AlterColumn migrationBuilder.AddPrimaryKey(\u0026#34;PK_ServerSideSessions\u0026#34;, \u0026#34;ServerSideSessions\u0026#34;, \u0026#34;Id\u0026#34;); For most deployments the approach above will work. For deployments with high volumes of sessions, high availability demands and no low traffic hours this might cause unacceptable downtime. The impact and possible workarounds depend on the database engine used, but most databases include features for performing indexing operations and schema changes to an online system. Please consult your database\u0026rsquo;s documentation or your DBA for more guidance.\nOnce you\u0026rsquo;ve updated that migration, both migrations should be applied to your database:\ndotnet ef database update -c ConfigurationDbContext dotnet ef database update -c PersistedGrantDbContext Some organizations prefer to use other tools for managing schema changes. You\u0026rsquo;re free to manage your schema however you see fit, as long as the entities can be successfully mapped. Even if you\u0026rsquo;re not going to ultimately use Entity Framework migrations to manage your database changes, generating a migration can be a useful development step to get an idea of what needs to be done.\nStep 4: Breaking changes Only impacts particular customizations or edge cases The DefaultCorsPolicyService now depends on the IConfigurationDbContext directly, instead of taking a dependency on the IServiceProvider and resolving that DbContext from it. If you have a customized CORS implementation that derives from the DefaultCorsPolicyService, you need to update the constructor of your derived class to use the IConfigurationDbContext. The DPoPProofValidationContext has been refactored. Instead of the Client property, we now put the relevant details (expiration validation mode and clock skew) directly in the context. We also have added the HTTP method and URL to the context. If you have a custom implementation of the IDPoPProofValidator or a class that derives from the DefaultDPoPProofValidator, update your usage of the context appropriately. The DefaultTokenService no longer includes an IHttpContextAccessor. This member was unused by the default implementation and marked as obsolete. Customizations that derive from the DefaultTokenService no longer need to pass the accessor to the base constructor. If such a customization needs the accessor, add it to the derived class. The ValidatedAuthorizeRequest.RequestedResourceIndicators property was misspelled and has been renamed RequestedResourceIndicators. The reference token store now includes the session id when revoking reference tokens. Implementors of IReferenceTokenStore should update their implementation of token revocation to include the session id. Invalid prompt modes now cause validation errors that result in an HTTP 400 (Bad Request). Previously, invalid prompt modes were ignored. This complies with updates to the OpenID Connect specification. A new interface IIdentityServerTools has been introduced for the IdentityServerTools helper class to allow mocking. Update any direct references to IdentityServerTools to IIdentityServerTools. Newly Deprecated IAuthorizationParametersMessageStore is deprecated. PAR is a more robust/standardized approach to get similar benefits.\nThe IHttpContextAccessor in the EndSessionRequestValidator is unused and has been marked as obsolete. It will be removed in a future version.\nPreviously Deprecated, Now Removed The obsolete IdentityServerOrigin constant has been removed. Several obsolete extension methods on HttpContext have been removed. These methods are replaced by methods in IServerUrls and IIssuerNameService. See #1457 HttpContext.GetSchemeSupportsSignOutAsync is replaced by IAuthenticationHandlerProvider.GetHandlerAsync (you will also need to check if the handler implements IAuthenticationSignOutHandler). HttpContext.GetIdentityServerOrigin and HttpContext.SetIdentityServerOrigin are replaced by IServerUrls.Origin. HttpContext.GetIdentityServerBasePath and HttpContext.SetIdentityServerBasePath are replaced by IServerUrls.BasePath. GetIdentityServerHost is replaced by IServerUrls.Origin GetIdentityServerBaseUrl is replaced by IServerUrls.BaseUrl GetIdentityServerRelativeUrl is replaced by IServerUrls.GetIdentityServerRelativeUrl GetIdentityServerIssuerUri is replaced by IIssuerNameService.GetCurrentAsync RedirectToAbsoluteUrl is replaced by redirecting to a call to IServerUrls.GetAbsoluteUrl. The obsolete and unused IUserSessionExtensions interface has been removed. The obsolete IPrincipal.GetName and IIdentity.GetName extension methods have been removed. Use ClaimsPrincipal.GetDisplayName instead. The obsolete ResourceValidationRequest.IncludeNonIsolatedApiResources has been removed. This flag was no longer used. Unlikely to impact anyone The KeyManagementOptions.SigningAlgorithms is now an ICollection rather than an IEnumerable. If you are configuring signing algorithms using code, and setting the SigningAlgorithms to some type that implements IEnumerable but not ICollection, then you must change the type that you are using. In practice, we expect everyone uses a list or array (which are both ICollections).\nThe value of the constant IdentityServerAuthenticationType has changed from \u0026ldquo;IdentityServer4\u0026rdquo; to \u0026ldquo;Duende.IdentityServer\u0026rdquo;. This constant is used as the value of the authentication type within the ClaimsIdentity that IdentityServer constructs. The authentication type\u0026rsquo;s value is never used by IdentityServer or ASP.NET, so this is unlikely to impact anyone. It is also the name of the default cors policy created by IdentityServer. This could theoretically impact you if you have a CORS policy named \u0026ldquo;Duende.IdentityServer\u0026rdquo;, as the new name now conflicts.\nStep 5: Done! That\u0026rsquo;s it. Of course, at this point you can and should test that your IdentityServer is updated and working properly.\nStep 6 (if needed): Troubleshooting .NET 8 Issues You are now done with everything related to the IdentityServer upgrade, but we would also like to add a references to breaking changes in .NET 8 and associated libraries that are likely to affect the IdentityServer setup.\nEntity Framework Core 8 has some performance improvements in the query generation for Microsoft SQL Server that relies on database features that requires a database compatibility level of at least 130. This can cause errors on database access like Microsoft.Data.SqlClient.SqlException (0x80131904): The syntax near \u0026lsquo;$\u0026rsquo; is incorrect. or Microsoft.Data.SqlClient.SqlException (0x80131904): Incorrect syntax near the keyword \u0026lsquo;WITH\u0026rsquo;. Please see https://learn.microsoft.com/en-us/ef/core/what-is-new/ef-core-8.0/breaking-changes#mitigations for more information. For container deployments, the default ASP.NET Core port changed from 80 to 8080. This might require configuration updates to either continue using port 80 or to migrate to using 8080. IdentityServer and the Asp.Net Authentication packages all depends on the Microsoft.IdentityModel.* packages. With packages that are brought in as transient dependencies there is less control of the versions being pulled in. If different packages from the Microsoft.IdentityModel.* family end up having different versions, there will be odd bugs. We\u0026rsquo;ve seen reports where the refresh token isn\u0026rsquo;t stored and where the OIDC handler fails to redirect to an OIDC Provider because it failed reading the discovery document. Always ensure that all Microsoft.IdentityModel.* packages are of exactly the same version. If they are not, you might need to make an explicit to pin an exact version. "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/data/operational/grants/",
    "title": "Grants",
    "tags": [],
    "description": "",
    "content": "Many protocol flows produce state that represents a grant of one type or another. These include authorization and device codes, reference and refresh tokens, and remembered user consent.\nStores The persistence for grants is abstracted behind two interfaces:\nThe persisted grant store is a common store for most grants. The device flow store is a specialized store for device grants. Registering Custom Stores Custom implementations of IPersistedGrantStore, and/or IDeviceFlowStore must be registered in the DI system. For example:\nbuilder.Services.AddIdentityServer(); builder.Services.AddTransient\u0026lt;IPersistedGrantStore, YourCustomPersistedGrantStore\u0026gt;(); builder.Services.AddTransient\u0026lt;IDeviceFlowStore, YourCustomDeviceFlowStore\u0026gt;(); Grant Expiration and Consumption The presence of the record in the store without a ConsumedTime and while still within the Expiration represents the validity of the grant. Setting either of these two values, or removing the record from the store effectively revokes the grant.\nSome grant types are one-time use only (either by definition or configuration). Once they are \u0026ldquo;used\u0026rdquo;, rather than deleting the record, the ConsumedTime value is set in the database marking them as having been used. This \u0026ldquo;soft delete\u0026rdquo; allows for custom implementations to either have flexibility in allowing a grant to be re-used (typically within a short window of time), or to be used in risk assessment and threat mitigation scenarios (where suspicious activity is detected) to revoke access. For refresh tokens, this sort of custom logic would be performed in the IRefreshTokenService.\nGrant Data The Data property of the model contains the authoritative copy of the values in the store. This data is protected at rest using the ASP.NET Data Protection API. With the exception of ConsumedTime, The other properties of the model should be treated as read-only.\nPersisted Grant Service Working with the grants store directly might be too low level. As such, a higher level service called the IPersistedGrantService is provided. It abstracts and aggregates the different grant types into one concept, and allows querying and revoking the persisted grants for a user.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/ui/server_side_sessions/inactivity_timeout/",
    "title": "Inactivity Timeout",
    "tags": [],
    "description": "",
    "content": "A common requirement in several industries is the concept of a system-wide \u0026ldquo;inactivity timeout\u0026rdquo;. The expectation is that if a user is active in the system, then their authentication session should continue to be active. But if the user were to be inactive for some amount of time (e.g. after walking away from their computer), then this inactivity should cause the user to be logged out of the entire system.\nUnfortunately, the OpenID Connect protocol is primarily focused with signing users into applications, not distributed session management due to user inactivity. What makes this difficult to achieve is that there are many different artifacts from the protocol each with their own expiration (e.g. cookies, refresh tokens, and access tokens). Also, different entities in the system have control over the lifetime and renewal of these artifacts. Coordinating all of their expirations to become invalid at the same time is not trivial.\nDespite the protocol not providing a formal solution to this requirement, it is still possible to achieve this while using features of the protocols and not resorting to the use of custom, out-of-band techniques.\nDesign To achieve the goal of distributed session management, there must be a single record tracking the user\u0026rsquo;s session. Using server-side sessions at IdentityServer provides this central location to monitor user activity and track session expiration.\nUser Activity Monitoring As a user is active interactively at IdentityServer, the session\u0026rsquo;s expiration will be extended given the normal cookie authentication handler mechanics of ASP.NET Core. Most of the time, though, a user is active at the client applications, not at IdentityServer. This makes it difficult for the session at IdentityServer to be extended.\nFortunately as a user uses a client application, it\u0026rsquo;s common for that client to make server to server protocol invocations back to IdentityServer on behalf of the user (e.g. with the refresh token). These invocations can be used as the signal to the server-side session management at IdentityServer that the user is still active, and thus can be used to extend the session.\nIn addition to refresh tokens, any client activity using an access token that originated from the user\u0026rsquo;s session could also be used to extend the user\u0026rsquo;s server-side session at IdentityServer. This would only work if IdentityServer were aware of this activity, but userinfo and introspection endpoint requests are examples of those types of activity.\nInternally IdentityServer provides a ISessionCoordinationService which is invoked from the endpoints describes above. Its purpose is to then extend the lifetime of the server-side session. Below is a picture of the various types of requests to do this:\nUser Inactivity Detection and Session Termination When the user becomes inactive, the server-side session management system at IdentityServer can detect and remove the abandoned session. When this happens, the ISessionCoordinationService provides another operation to perform any client related cleanup for the session. This could invoke back-channel logout for any client the user has logged into during their session, or this could revoke any grants in the operational store issued during the user\u0026rsquo;s session.\nClients that receive back-channel logout would know the user\u0026rsquo;s session has ended, and can cleanup appropriately. But if back-channel is not used, then the client would need some other signal to consider the user\u0026rsquo;s session has ended. The obvious signal would be if the refresh token request failed, then that would be an appropriate signal that the user\u0026rsquo;s session has also ended.\nGiven this understanding, client applications can participate in this convention and IdentityServer can coordinate to achieve this system-wide \u0026ldquo;inactivity timeout\u0026rdquo; requirement.\nConfiguration Configuration is needed in both IdentityServer and client applications.\nIdentityServer To prepare IdentityServer, these features need to be enabled:\nServer-side sessions need to be enabled. Either the global CoordinateClientLifetimesWithUserSession option should be enabled, or the client-specific CoordinateLifetimeWithUserSession option should be enabled. Enable back-channel logout for session expiration with the ExpiredSessionsTriggerBackchannelLogout option. Client Applications Depending on what protocol features the client is using, different approaches will need to be taken. The two main actions a client must take are to 1) notify IdentityServer of the user\u0026rsquo;s activity, and 2) detect user inactivity at IdentityServer and terminate the user\u0026rsquo;s session in the client.\nClients with Refresh Tokens As the client uses the refresh token at IdentityServer, the user\u0026rsquo;s session expiration will be extended. Be sure to configure the access token lifetime to be less than the server-side session lifetime at IdentityServer.\nTo detect inactivity:\nEither handle refresh token request failure, and consider the session ended. Or implement back-channel logout. Clients with Reference Access Tokens but without Refresh Tokens It\u0026rsquo;s possible a client is using a reference access token and no refresh token. The API would then use introspection to validate the token, which would then extend the associated user\u0026rsquo;s session at IdentityServer.\nTo detect inactivity:\nEither handle 401 errors from the API, and then consider the session ended. Or implement back-channel logout. Clients without Access Tokens Clients without access tokens have no way to notify IdentityServer that the user is still active. But they can implement back-channel logout to be notified that the user\u0026rsquo;s session has ended.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/ui/login/redirect/",
    "title": "Redirecting back to the client",
    "tags": [],
    "description": "",
    "content": "The Return URL and the Login Workflow Once the user has been logged in, they must complete the protocol workflow so they can ultimately be logged into the client. To facilitate this, the login page is passed a returnUrl query parameter which refers to the URL the prior request came from. This URL is, in essence, the same authorization endpoint to which the client made the original authorize request.\nIn the request to your login page where it logs the user in with a call to SignInAsync, it would then simply use the returnUrl to redirect the response back. This will cause the browser to re-issue the original authorize request from the client allowing your IdentityServer to complete the protocol work. An example of this redirect can be seen in the local login topic.\nBeware open-redirect attacks via the returnUrl parameter. You should validate that the returnUrl refers to a well-known location. Either use the Url.IsLocalUrl helper from ASP.NET Core, or use the interaction service from Duende IdentityServer for APIs to validate the returnUrl parameter.\nKeep in mind that this returnUrl is state that needs to be maintained during the user\u0026rsquo;s login workflow. If your workflow involves page post-backs, redirecting the user to an external login provider, or just sending the user through a custom workflow, then this value must be preserved across all of those page transitions.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/samples/tokens/",
    "title": "Requesting tokens",
    "tags": [],
    "description": "Samples",
    "content": "Extension grants and Token Exchange link to source code\nThis sample shows an implementation of the Token Exchange specification RFC 8693 via the Duende IdentityServer extension grant mechanism.\nSee here for more information on extension grants.\nPersonal Access Tokens (PAT) link to source code\nThis sample shows how to provide a self-service UI to create access tokens. This is a common approach to enable integrations with APIs without having to create full-blown OAuth clients.\nWhen combining PATs with the reference token feature, you also get automatic validation and revocation support. This is very similar to API keys, but does not require custom infrastructure. The sample also contains an API that accepts both JWT and reference tokens.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/configuration/dcr/reference/store/",
    "title": "Store",
    "tags": [],
    "description": "DCR Reference",
    "content": "IClientConfigurationStore The IClientConfigurationStore interface defines the contract for a service that communication with the client configuration data store. It contains a single AddAsync method.\npublic interface IClientConfigurationStore Members name description AddAsync(…) Adds a client to the configuration store. ClientConfigurationStore The ClientConfigurationStore is the default implementation of the IClientConfigurationStore. It uses Entity Framework to communicate with the client configuration store, and is intended to be used when IdentityServer is configured to use the Entity Framework based configuration stores.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/stores/resource_store/",
    "title": "Resource Store",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Stores.IResourceStore Used to dynamically load resource configuration.\n/// \u0026lt;summary\u0026gt; /// Resource retrieval /// \u0026lt;/summary\u0026gt; public interface IResourceStore { /// \u0026lt;summary\u0026gt; /// Gets identity resources by scope name. /// \u0026lt;/summary\u0026gt; Task\u0026lt;IEnumerable\u0026lt;IdentityResource\u0026gt;\u0026gt; FindIdentityResourcesByScopeNameAsync(IEnumerable\u0026lt;string\u0026gt; scopeNames); /// \u0026lt;summary\u0026gt; /// Gets API scopes by scope name. /// \u0026lt;/summary\u0026gt; Task\u0026lt;IEnumerable\u0026lt;ApiScope\u0026gt;\u0026gt; FindApiScopesByNameAsync(IEnumerable\u0026lt;string\u0026gt; scopeNames); /// \u0026lt;summary\u0026gt; /// Gets API resources by scope name. /// \u0026lt;/summary\u0026gt; Task\u0026lt;IEnumerable\u0026lt;ApiResource\u0026gt;\u0026gt; FindApiResourcesByScopeNameAsync(IEnumerable\u0026lt;string\u0026gt; scopeNames); /// \u0026lt;summary\u0026gt; /// Gets API resources by API resource name. /// \u0026lt;/summary\u0026gt; Task\u0026lt;IEnumerable\u0026lt;ApiResource\u0026gt;\u0026gt; FindApiResourcesByNameAsync(IEnumerable\u0026lt;string\u0026gt; apiResourceNames); /// \u0026lt;summary\u0026gt; /// Gets all resources. /// \u0026lt;/summary\u0026gt; Task\u0026lt;Resources\u0026gt; GetAllResourcesAsync(); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/models/client/",
    "title": "Client",
    "tags": [],
    "description": "Model Reference",
    "content": "Duende.IdentityServer.Models.Client The Client class models an OpenID Connect or OAuth 2.0 client - e.g. a native application, a web application or a JS-based application.\npublic static IEnumerable\u0026lt;Client\u0026gt; Get() { return new List\u0026lt;Client\u0026gt; { /////////////////////////////////////////// // machine to machine client ////////////////////////////////////////// new Client { ClientId = \u0026#34;machine\u0026#34;, ClientSecrets = { Configuration[\u0026#34;machine.secret\u0026#34;] }, AllowedGrantTypes = GrantTypes.ClientCredentials, AllowedScopes = machineScopes }, /////////////////////////////////////////// // web client ////////////////////////////////////////// new Client { ClientId = \u0026#34;web\u0026#34;, ClientSecrets = { new Secret(Configuration[\u0026#34;web.secret\u0026#34;]) }, AllowedGrantTypes = GrantTypes.Code, RedirectUris = { \u0026#34;https://myapp.com:/signin-oidc\u0026#34; }, PostLogoutRedirectUris = { \u0026#34;https://myapp.com/signout-callback-oidc\u0026#34; }, BackChannelLogoutUri = \u0026#34;https://myapp.com/backchannel-logout\u0026#34;, AllowOfflineAccess = true, AllowedScopes = webScopes } } } Basics Enabled\nSpecifies if client is enabled. Defaults to true.\nClientId\nUnique ID of the client\nClientSecrets\nList of client secrets - credentials to access the token endpoint.\nRequireClientSecret\nSpecifies whether this client needs a secret to request tokens from the token endpoint (defaults to true)\nRequireRequestObject\nSpecifies whether this client needs to wrap the authorize request parameters in a JWT (defaults to false)\nAllowedGrantTypes\nSpecifies the grant types the client is allowed to use. Use the GrantTypes class for common combinations.\nRequirePkce\nSpecifies whether clients using an authorization code based grant type must send a proof key (defaults to true).\nAllowPlainTextPkce\nSpecifies whether clients using PKCE can use a plain text code challenge (not recommended - and defaults to false)\nRedirectUris\nSpecifies the allowed URIs to return tokens or authorization codes to\nAllowedScopes\nBy default a client has no access to any resources - specify the allowed resources by adding the corresponding scopes names\nAllowOfflineAccess\nSpecifies whether this client can request refresh tokens (be requesting the offline_access scope)\nAllowAccessTokensViaBrowser\nSpecifies whether this client is allowed to receive access tokens via the browser. This is useful to harden flows that allow multiple response types (e.g. by disallowing a hybrid flow client that is supposed to use code id_token to add the token response type and thus leaking the token to the browser).\nProperties\nDictionary to hold any custom client-specific values as needed.\nAuthentication / Session Management PostLogoutRedirectUris\nSpecifies allowed URIs to redirect to after logout.\nFrontChannelLogoutUri\nSpecifies logout URI at client for HTTP based front-channel logout.\nFrontChannelLogoutSessionRequired\nSpecifies if the user\u0026rsquo;s session id should be sent to the FrontChannelLogoutUri. Defaults to true.\nBackChannelLogoutUri\nSpecifies logout URI at client for HTTP based back-channel logout.\nBackChannelLogoutSessionRequired\nSpecifies if the user\u0026rsquo;s session id should be sent in the request to the BackChannelLogoutUri. Defaults to true.\nEnableLocalLogin\nSpecifies if this client can use local accounts, or external IdPs only. Defaults to true.\nIdentityProviderRestrictions\nSpecifies which external IdPs can be used with this client (if list is empty all IdPs are allowed). Defaults to empty.\nUserSsoLifetime\nThe maximum duration (in seconds) since the last time the user authenticated. Defaults to null. You can adjust the lifetime of a session token to control when and how often a user is required to reenter credentials instead of being silently authenticated, when using a web application.\nAllowedCorsOrigins\nIf specified, will be used by the default CORS policy service implementations (In-Memory and EF) to build a CORS policy for JavaScript clients.\nCoordinateLifetimeWithUserSession (added in v6.1)\nWhen enabled, the client\u0026rsquo;s token lifetimes (e.g. refresh tokens) will be tied to the user\u0026rsquo;s session lifetime. This means when the user logs out, any revokable tokens will be removed. If using server-side sessions, expired sessions will also remove any revokable tokens, and backchannel logout will be triggered. This client\u0026rsquo;s setting overrides the global CoordinateTokensWithUserSession configuration setting.\nToken IdentityTokenLifetime\nLifetime to identity token in seconds (defaults to 300 seconds / 5 minutes)\nAllowedIdentityTokenSigningAlgorithms\nList of allowed signing algorithms for identity token. If empty, will use the server default signing algorithm.\nAccessTokenLifetime\nLifetime of access token in seconds (defaults to 3600 seconds / 1 hour)\nAuthorizationCodeLifetime\nLifetime of authorization code in seconds (defaults to 300 seconds / 5 minutes)\nAccessTokenType\nSpecifies whether the access token is a reference token or a self contained JWT token (defaults to Jwt).\nIncludeJwtId\nSpecifies whether JWT access tokens should have an embedded unique ID (via the jti claim). Defaults to true.\nClaims\nAllows settings claims for the client (will be included in the access token).\nAlwaysSendClientClaims\nIf set, the client claims will be sent for every flow. If not, only for client credentials flow (default is false)\nAlwaysIncludeUserClaimsInIdToken\nWhen requesting both an id token and access token, should the user claims always be added to the id token instead of requiring the client to use the userinfo endpoint. Default is false.\nClientClaimsPrefix\nIf set, the prefix client claim types will be prefixed with. Defaults to client_. The intent is to make sure they don\u0026rsquo;t accidentally collide with user claims.\nPairWiseSubjectSalt Salt value used in pair-wise subjectId generation for users of this client. Currently not implemented.\nRefresh Token AbsoluteRefreshTokenLifetime\nMaximum lifetime of a refresh token in seconds. Defaults to 2592000 seconds / 30 days.\nSetting this to 0 has the following effect:\nWhen RefreshTokenExpiration is set to Absolute, the behavior is the same as when no refresh tokens are used. When RefreshTokenExpiration is set to Sliding, refresh tokens only expire after the SlidingRefreshTokenLifetime has passed. SlidingRefreshTokenLifetime\nSliding lifetime of a refresh token in seconds. Defaults to 1296000 seconds / 15 days.\nRefreshTokenUsage\nReUse\nthe refresh token handle will stay the same when refreshing tokens. This is the default.\nOneTimeOnly\nthe refresh token handle will be updated when refreshing tokens.\nRefreshTokenExpiration\nAbsolute\nthe refresh token will expire on a fixed point in time (specified by the AbsoluteRefreshTokenLifetime). This is the default.\nSliding\nwhen refreshing the token, the lifetime of the refresh token will be renewed (by the amount specified in SlidingRefreshTokenLifetime). The lifetime will not exceed AbsoluteRefreshTokenLifetime.\nUpdateAccessTokenClaimsOnRefresh\nGets or sets a value indicating whether the access token (and its claims) should be updated on a refresh token request.\nConsent Screen Consent screen specific settings.\nRequireConsent\nSpecifies whether a consent screen is required. Defaults to false.\nAllowRememberConsent\nSpecifies whether user can choose to store consent decisions. Defaults to true.\nConsentLifetime\nLifetime of a user consent in seconds. Defaults to null (no expiration).\nClientName\nClient display name (used for logging and consent screen).\nClientUri\nURI to further information about client.\nLogoUri\nURI to client logo.\nCross Device Flows Settings used in the CIBA and OAuth device flows.\nPollingInterval\nMaximum polling interval for the client in cross device flows. If the client polls more frequently than the polling interval during those flows, it will receive a slow_down error response. Defaults to null, which means the throttling will use the global default appropriate for the flow (IdentityServerOptions.Ciba.DefaultPollingInterval or IdentityServerOptions.DeviceFlow.Interval).\nDevice Flow Device flow specific settings.\nUserCodeType\nSpecifies the type of user code to use for the client. Otherwise falls back to default.\nDeviceCodeLifetime\nLifetime to device code in seconds (defaults to 300 seconds / 5 minutes)\nCIBA Client initiated backchannel authentication specific settings.\nCibaLifetime\nSpecifies the backchannel authentication request lifetime in seconds. Defaults to null.\nDPoP Added in 6.3.0.\nSettings specific to the Demonstration of Proof-of-Possession at the Application Layer (DPoP) feature.\nRequireDPoP\nSpecifies whether a DPoP (Demonstrating Proof-of-Possession) token is required to be used by this client. Defaults to false.\nDPoPValidationMode\nEnum setting to control validation for the DPoP proof token expiration. This supports both the client generated \u0026lsquo;iat\u0026rsquo; value and/or the server generated \u0026rsquo;nonce\u0026rsquo; value. Defaults to DPoPTokenExpirationValidationMode.Iat, which only validates the \u0026lsquo;iat\u0026rsquo; value.\nDPoPClockSkew\nClock skew used in validating the client\u0026rsquo;s DPoP proof token \u0026lsquo;iat\u0026rsquo; claim value. Defaults to 5 minutes.\nThird-Party Initiated Login Added in 6.3.0.\nInitiateLoginUri\nAn optional URI that can be used to initiate login from the IdentityServer host or a third party. This is most commonly used to create a client application portal within the IdentityServer host. Defaults to null.\nPushed Authorization Requests Added in 7.0.0\nRequirePushedAuthorization\nControls if this client requires PAR. PAR is required if either the global configuration is enabled or if the client\u0026rsquo;s flag is enabled (this can\u0026rsquo;t be used to opt out of the global configuration). This defaults to false, which means the global configuration will be used.\nPushedAuthorizationLifetime\nControls the lifetime of pushed authorization requests for a client. If this lifetime is set, it takes precedence over the global configuration. This defaults to null, which means the global configuration is used.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/models/idp/",
    "title": "Identity Provider",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Models.OidcProvider The OidcProvider models an external OpenID Connect provider for use in the dynamic providers feature. Its properties map to the Open ID Connect options class from ASP.NET Core, and those properties include:\nEnabled\nSpecifies if provider is enabled. Defaults to true.\nScheme\nScheme name for the provider.\nDisplayName\nDisplay name for the provider.\nType\nProtocol type of the provider. Defaults to \u0026ldquo;oidc\u0026rdquo; for the OidcProvider.\nAuthority\nThe base address of the OIDC provider.\nResponseType\nThe response type. Defaults to \u0026ldquo;id_token\u0026rdquo;.\nClientId\nThe client id.\nClientSecret\nThe client secret. By default this is the plaintext client secret and great consideration should be taken if this value is to be stored as plaintext in the store. It is possible to store this in a protected way and then unprotect when loading from the store either by implementing a custom IIdentityProviderStore or registering a custom IConfigureNamedOptions\u0026lt;OpenIdConnectOptions\u0026gt;.\nScope\nSpace separated list of scope values.\nGetClaimsFromUserInfoEndpoint\nIndicates if userinfo endpoint is to be contacted. Defaults to true.\nUsePkce\nIndicates if PKCE should be used. Defaults to true.\nDuende.IdentityServer.Models.IdentityProviderName The IdentityProviderName models the display name of an identity provider.\nEnabled\nSpecifies if provider is enabled. Defaults to true.\nScheme\nScheme name for the provider.\nDisplayName\nDisplay name for the provider.\nDuende.IdentityServer.Models.IdentityProvider The IdentityProvider is a base class to model arbitrary identity providers, which OidcProvider derives from. This leaves open the possibility for extensions to the dynamic provider feature to support other protocol types (as distinguished by the Type property).\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/stores/client_store/",
    "title": "Client Store",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Stores.IClientStore Used to dynamically load client configuration.\n/// \u0026lt;summary\u0026gt; /// Retrieval of client configuration /// \u0026lt;/summary\u0026gt; public interface IClientStore { /// \u0026lt;summary\u0026gt; /// Finds a client by id /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;clientId\u0026#34;\u0026gt;The client id\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;The client\u0026lt;/returns\u0026gt; Task\u0026lt;Client\u0026gt; FindClientByIdAsync(string clientId); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/stores/cors_policy_service/",
    "title": "CORS Policy Service",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Stores.ICorsPolicyService Used to determine if CORS requests are allowed to certain protocol endpoints.\n/// \u0026lt;summary\u0026gt; /// Service that determines if CORS is allowed. /// \u0026lt;/summary\u0026gt; public interface ICorsPolicyService { /// \u0026lt;summary\u0026gt; /// Determines whether origin is allowed. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;origin\u0026#34;\u0026gt;The origin.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task\u0026lt;bool\u0026gt; IsOriginAllowedAsync(string origin); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/stores/idp_store/",
    "title": "Identity Provider Store",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Stores.IIdentityProviderStore Used to dynamically load identity provider configuration.\n/// \u0026lt;summary\u0026gt; /// Interface to model storage of identity providers. /// \u0026lt;/summary\u0026gt; public interface IIdentityProviderStore { /// \u0026lt;summary\u0026gt; /// Gets all identity providers name. /// \u0026lt;/summary\u0026gt; Task\u0026lt;IEnumerable\u0026lt;IdentityProviderName\u0026gt;\u0026gt; GetAllSchemeNamesAsync(); /// \u0026lt;summary\u0026gt; /// Gets the identity provider by scheme name. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;scheme\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task\u0026lt;IdentityProvider\u0026gt; GetBySchemeAsync(string scheme); } The IdentityProvider is intended to be a base class to model arbitrary identity providers. The default implementation included in Duende IdentityServer will return a derived class for OpenID Connect providers, via the OidcProvider class.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/models/",
    "title": "Models",
    "tags": [],
    "description": "Reference",
    "content": "Models Identity Resource API Scope API Resource Client Identity Provider Grant Validation Result Secrets Backchannel User Login Request License Usage Summary "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/ui/consent/",
    "title": "Consent",
    "tags": [],
    "description": "",
    "content": "During an authorization request, if user consent is required the browser will be redirected to the consent page.\nYou can configure the consent requirement per client. By default no consent is required, but this setting can be changed via the RequireConsent setting.\nConsent is used to allow an end user to grant a client access to resources.\nConsent Page In order for the user to grant consent, a consent page must be provided by the hosting application. When IdentityServer needs to prompt the user for consent, it will redirect the user to a configurable ConsentUrl.\nbuilder.Services.AddIdentityServer(opt =\u0026gt; { opt.UserInteraction.ConsentUrl = \u0026#34;/path/to/consent\u0026#34;; }) By default, the ConsentUrl is set to \u0026ldquo;/consent\u0026rdquo;. The quickstart UI includes a basic implementation of a consent page at that route.\nA consent page normally renders the display name of the current user, the display name of the client requesting access, the logo of the client, a link for more information about the client, and the list of resources the client is requesting access to. It\u0026rsquo;s also common to allow the user to indicate that their consent should be \u0026ldquo;remembered\u0026rdquo; so they are not prompted again in the future for the same client.\nOnce the user has provided consent, the consent page must inform your IdentityServer of the consent, and then the browser must be redirected back to the authorization endpoint.\nAuthorization Context Your IdentityServer will pass a returnUrl parameter to the consent page which contains the parameters of the authorization request. These parameters provide the context for the consent page, and can be read with help from the interaction service.\nThe GetAuthorizationContextAsync API will return an instance of AuthorizationRequest. Additional details about the client or resources can be obtained using the IClientStore and IResourceStore interfaces.\nInforming IdentityServer of the consent result The GrantConsentAsync API on the interaction service allows the consent page to inform your IdentityServer of the outcome of consent (which might also be to deny the client access).\nYour IdentityServer will temporarily persist the outcome of the consent. This persistence uses a cookie by default, as it only needs to last long enough to convey the outcome back to the authorization endpoint. This temporary persistence is different than the persistence used for the \u0026ldquo;remember my consent\u0026rdquo; feature (and it is the authorization endpoint which persists the \u0026ldquo;remember my consent\u0026rdquo; for the user). If you wish to use some other persistence between the consent page and the authorization redirect, then you can implement IMessageStore and register the implementation in DI.\nReturning the user to the authorization endpoint Once the consent page has informed IdentityServer of the outcome, the user can be redirected back to the returnUrl. Your consent page should protect against open redirects by verifying that the returnUrl is valid. This can be done by calling IsValidReturnUrl on the interaction service.\nAlso, if GetAuthorizationContextAsync returns a non-null result, then you can also trust that the returnUrl is valid.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/deployment/caching/",
    "title": "Distributed Caching",
    "tags": [],
    "description": "",
    "content": "Some optional features rely on ASP.NET Core distributed caching:\nState data formatter for OpenID Connect Replay cache (e.g. for JWT client credentials) Device flow throttling service Authorization parameter store In order to work in a multi server environment, this needs to be set up correctly. Please consult the Microsoft documentation for more details.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/overview/packaging/",
    "title": "Packaging and Builds",
    "tags": [],
    "description": "",
    "content": "Product The licensed and supported libraries can be accessed via Nuget:\nDuende IdentityServer Duende IdentityServer EntityFramework Integration Duende IdentityServer ASP.NET Identity Integration UI Duende IdentityServer does not contain any UI, because this is always custom to the project. We still provide you with the IdentityServer Quickstart UI as a starting point for your modifications.\nTemplates Contains templates for the dotnet CLI.\nNuGet package source code You can install the templates using the following command:\ndotnet new -i Duende.Templates You may have a previous version of Duende templates (Duende.IdentityServer.Templates) installed on your machine. Please uninstall the template package and install the latest version.\nSource Code You can find the Duende IdentityServer source code on GitHub.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/services/profile_service/",
    "title": "Profile Service",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Services.IProfileService Encapsulates retrieval of user claims from a data source of your choice. See here for a sample.\n/// \u0026lt;summary\u0026gt; /// This interface allows IdentityServer to connect to your user and profile store. /// \u0026lt;/summary\u0026gt; public interface IProfileService { /// \u0026lt;summary\u0026gt; /// This method is called whenever claims about the user are requested (e.g. during token creation or via the userinfo endpoint) /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;context\u0026#34;\u0026gt;The context.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task GetProfileDataAsync(ProfileDataRequestContext context); /// \u0026lt;summary\u0026gt; /// This method gets called whenever identity server needs to determine if the user is valid or active (e.g. if the user\u0026#39;s account has been deactivated since they logged in). /// (e.g. during token issuance or validation). /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;context\u0026#34;\u0026gt;The context.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task IsActiveAsync(IsActiveContext context); } GetProfileDataAsync\nThe API that is expected to load claims for a user. It is passed an instance of ProfileDataRequestContext.\nIsActiveAsync\nThe API that is expected to indicate if a user is currently allowed to obtain tokens. It is passed an instance of IsActiveContext.\nDuende.IdentityServer.Models.ProfileDataRequestContext Models the request for user claims and is the vehicle to return those claims. It contains these properties:\nSubject\nThe ClaimsPrincipal modeling the user associated with this request for profile data. When the profile service is invoked for tokens, the Subject property will contain the user\u0026rsquo;s principal. Which claims are contained in the principal depends on the following:\nWhen the server side sessions feature is enabled Subject will always contain the claims stored in the server side session. When that is not the case, it depends on the caller context: If the ProfileService is called in the context of a grant (e.g. exchanging a code for a token), the claims associated with that grant in the grant store will be used. When grants are stored, by default a snapshot of the logged in user\u0026rsquo;s claims are captured with the grant. If there\u0026rsquo;s no grant context (e.g. when the user info endpoint is called) the claims in the access token will be used. Client\nThe Client for which the claims are being requested.\nRequestedClaimTypes\nThe collection of claim types being requested. This data is source from the requested scopes and their associated claim types.\nCaller\nAn identifier for the context in which the claims are being requested (e.g. an identity token, an access token, or the user info endpoint). The IdentityServerConstants.ProfileDataCallers class contains the different constant values.\nIssuedClaims\nThe list of claims that will be returned. This is expected to be populated by the custom IProfileService implementation.\nAddRequestedClaims\nExtension method on the ProfileDataRequestContext to populate the IssuedClaims, but first filters the claims based on RequestedClaimTypes.\nDuende.IdentityServer.Models.IsActiveContext Models the request to determine if the user is currently allowed to obtain tokens. It contains these properties:\nSubject\nThe ClaimsPrincipal modeling the user.\nClient\nThe Client for which the claims are being requested.\nCaller\nAn identifier for the context in which the claims are being requested (e.g. an identity token, an access token, or the user info endpoint. The constant IdentityServerConstants.ProfileIsActiveCallers contains the different constant values.\nIsActive\nThe flag indicating if the user is allowed to obtain tokens. This is expected to be assigned by the custom IProfileService implementation.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/fundamentals/resources/isolation/",
    "title": "Resource Isolation",
    "tags": [],
    "description": "",
    "content": " This is an Enterprise Edition feature.\nOAuth itself only knows about scopes - the (API) resource concept does not exist from a pure protocol point of view. This means that all the requested scope and audience combination get merged into a single access token. This has a couple of downsides, e.g.\ntokens can become very powerful (and big) if such a token leaks, it allows access to multiple resources resources within that single token might have conflicting settings, e.g. user claims of all resources share the same token resource specific processing like signing or encryption algorithms conflict without sender-constraints, a resource could potentially re-use (or abuse) a token to call another contained resource directly To solve this problem RFC 8707 adds an additional request parameter for the authorize and token endpoint called resource. This allows requesting a token for a specific resource (in other words - making sure the audience claim has a single value only, and all scopes belong to that single resource).\nUsing the resource parameter Let\u0026rsquo;s assume you have the following resource design and that the client is allowed access to all scopes:\nvar resources = new[] { new ApiResource(\u0026#34;urn:invoices\u0026#34;) { Scopes = { \u0026#34;read\u0026#34;, \u0026#34;write\u0026#34; } }, new ApiResource(\u0026#34;urn:products\u0026#34;) { Scopes = { \u0026#34;read\u0026#34;, \u0026#34;write\u0026#34; } } }; If the client would simply request a token for the read scope, the resulting access token would contain the audience of both the invoice and the products API and thus be accepted at both APIs.\nMachine to machine scenarios If the client in addition passes the resource parameter specifying the name of the resource where it wants to use the access token, the token engine can down-scope the resulting access token to the single resource, e.g.:\nPOST /token grant_type=client_credentials\u0026amp; client_id=client\u0026amp; client_secret=...\u0026amp; scope=read\u0026amp; resource=urn:invoices Thus resulting in an access token like this (some details omitted):\n{ \u0026#34;aud\u0026#34;: [ \u0026#34;urn:invoice\u0026#34; ], \u0026#34;scope\u0026#34;: \u0026#34;read\u0026#34;, \u0026#34;client_id\u0026#34;: \u0026#34;client\u0026#34; } Interactive applications The authorize endpoint supports the resource parameter as well, e.g.:\nGET /authorize?client_id=client\u0026amp;response_type=code\u0026amp;scope=read\u0026amp;resource=urn:invoices Once the front-channel operations are done, the resulting code can be redeemed by passing the resource name on the token endpoint:\nPOST /token grant_type=authorization_code\u0026amp; client_id=client\u0026amp; client_secret=...\u0026amp; authorization_code=...\u0026amp; redirect_uri=...\u0026amp; resource=urn:invoices Requesting access to multiple resources It is also possible to request access to multiple resources. This will result in multiple access tokens - one for each request resource.\nGET /authorize?client_id=client\u0026amp;response_type=code\u0026amp;scope=read offline_access\u0026amp;resource=urn:invoices\u0026amp;resource=urn:products When you redeem the code, you need to specify for which resource you want to have an access token, e.g.:\nPOST /token grant_type=authorization_code\u0026amp; client_id=client\u0026amp; client_secret=...\u0026amp; authorization_code=...\u0026amp; redirect_uri=...\u0026amp; resource=urn:invoices Which will return an access token for the invoices API and a refresh token. If you want to also retrieve the access token for the products API, you use the refresh token and make another roundtrip to the token endpoint.\nPOST /token grant_type=refresh_token\u0026amp; client_id=client\u0026amp; client_secret=...\u0026amp; refresh_token=...\u0026amp; resource=urn:products The end-result will be that the client has two access tokens - one for each resource and can manage their lifetime via the refresh token.\nEnforcing resource isolation All examples so far used the resource parameter optionally. If you have API resources, where you want to make sure they are not sharing access tokens with other resources, you can enforce the resource indicator, e.g.:\nvar resources = new[] { new ApiResource(\u0026#34;urn:invoices\u0026#34;) { Scopes = { \u0026#34;read\u0026#34;, \u0026#34;write\u0026#34; }, RequireResourceIndicator = true }, new ApiResource(\u0026#34;urn:products\u0026#34;) { Scopes = { \u0026#34;read\u0026#34;, \u0026#34;write\u0026#34; } } }; "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/diagnostics/otel/setup/",
    "title": "Setup",
    "tags": [],
    "description": "",
    "content": "To start emitting Otel tracing and metrics information you need\nadd the Otel libraries to your IdentityServer and client applications start collecting traces and Metrics from the various IdentityServer sources (and other sources e.g. ASP.NET Core) For development a simple option is to export the tracing information to the console and use the Prometheus exporter to create a human readable /metrics endpoint for the metrics.\nAdd the Open Telemetry configuration to your service setup.\nvar openTelemetry = builder.Services.AddOpenTelemetry(); openTelemetry.ConfigureResource(r =\u0026gt; r .AddService(builder.Environment.ApplicationName)); openTelemetry.WithMetrics(m =\u0026gt; m .AddMeter(Telemetry.ServiceName) .AddMeter(Pages.Telemetry.ServiceName) .AddPrometheusExporter()); openTelemetry.WithTracing(t =\u0026gt; t .AddSource(IdentityServerConstants.Tracing.Basic) .AddSource(IdentityServerConstants.Tracing.Cache) .AddSource(IdentityServerConstants.Tracing.Services) .AddSource(IdentityServerConstants.Tracing.Stores) .AddSource(IdentityServerConstants.Tracing.Validation) .AddAspNetCoreInstrumentation() .AddConsoleExporter()); Add the Prometheus exporter to the pipeline\n// Map /metrics that displays Otel data in human readable form. app.UseOpenTelemetryPrometheusScrapingEndpoint(); This setup will write the tracing information to the console and provide metrics on the /metrics endpoint.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/ui/",
    "title": "User Interaction",
    "tags": [],
    "description": "Overview",
    "content": "User Interaction and Pages The design goal of Duende IdentityServer is to provide a full implementation of the OpenID Connect and OAuth protocols that is extremely flexible and easily customizable. One facet of IdentityServer that implementations typically customize is the user interface that users see when they need to log in, log out, etc. This UI is almost always branded to have the same look and feel as other applications of the organization that is implementing IdentityServer. But the customization that is possible within the UI goes much deeper than a logo or stylesheet. The entire user experience in your IdentityServer implementation is code that you control. This allows you to build customizations such as\nMulti-factor authentication Knowledge-based authentication Passwordless authentication Requiring the user to accept terms of service or other legal agreements Home-realm discovery to determine which user store or external authentication provider should be used Reconciliation of accounts across multiple user stores Gathering additional user information and provisioning resources when new users arrive from external providers To allow full flexibility of the UI, including business rules and user flow, the UI is separated from the core IdentityServer engine. The engine implements the endpoints specified in the protocols and hands off control to your code in the UI as necessary.\nOur templates include a quick start UI as well as a quick start UI adapted to ASP.NET Identity which provide a starting point for all the necessary pages, ready to be customized.\nRequired Pages As browser requests are made to the protocol endpoints in your IdentityServer implementation, they will be redirected to the interactive pages for the user to see. Depending on the features required, the pages expected in your IdentityServer implementation are:\nLogin: allows the user to login. This could be achieved with a local credential, or could utilize an external login provider (e.g. social or enterprise federation system). Logout: allows the user to logout (including providing single sign-out). Error: display error information to the end user, typically when there are workflow errors. Consent: allows the user to grant resource access to clients (typically only used if the client is third-party). Additional custom pages that you might want are then also possible (e.g. password reset, registration), and those are typically available to the user as links from one of the above pages.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/fundamentals/users/",
    "title": "Users and Logging In",
    "tags": [],
    "description": "",
    "content": "Users and User Interface The design of Duende IdentityServer allows you to use any user database and build any user interface (UI) workflow needed to satisfy your requirements. This means you have the ability to customize any UI page (registration, login, password reset, etc.), support any credential type (password, MFA, etc.), use any user database (greenfield or legacy), and/or use federated logins from any provider (social or enterprise). You have the ability to control the entire user experience while Duende IdentityServer provides the implementation of the security protocol (OpenID Connect and OAuth).\nWhile you can use any custom user database or identity management library for your users, we provide integration support for ASP.NET Identity.\nAuthorization Endpoint and Login Page Workflow The standard mechanism to allow users to login is for the client application to use a web browser. This is obvious if the client application is a web application, but it\u0026rsquo;s also the recommended practice for native and mobile applications.\nWhen a user must login, the client application will redirect the user to the protocol endpoint called the authorization endpoint in your IdentityServer server to request authentication. As part of the authorize request, your IdentityServer will typically display a login page for the user to enter their credentials. Once the user has authenticated, your IdentityServer will redirect the user back to the application with the protocol response.\nA user\u0026rsquo;s authentication session is managed using Microsoft\u0026rsquo;s ASP.NET cookie authentication framework. It is very important that you understand how it works when building the login pages in IdentityServer.\nRecall the diagram showing the relationship of your custom UI pages and the IdentityServer middleware in your IdentityServer host application:\nWhen your IdentityServer receives an authorize request, it will inspect it for a current authentication session for a user. This authentication session is based on ASP.NET Core\u0026rsquo;s authentication system and is ultimately determined by a cookie issued from your login page.\nIf the user has never logged in there will be no cookie, and then the request to the authorize endpoint will result in a redirect to your login page. This is the entry point into your custom workflow that can take over to get the user logged in.\nOnce the login page has finished logging in the user with the ASP.NET Core authentication system, it will redirect the user back to the authorize endpoint. This time the request to the authorize endpoint will have an authenticated session for the user, and it can then create the protocol response and redirect to the client application.\nAdditional Pages In addition to the login page, there are other pages that Duende IdentityServer expects (e.g. logout, error, consent), and you could implement custom pages as well (e.g. register, forgot password, etc.). Details about building these pages, and coverage of additional topics are in the User Interaction section of this documentation.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/apis/aspnetcore/confirmation/",
    "title": "Validating Proof-of-Possession",
    "tags": [],
    "description": "",
    "content": "IdentityServer can bind tokens to clients using either mTLS or DPoP, creating a Proof-of-Possession (PoP) access token. When one of these mechanisms is used, APIs that use those access tokens for authorization need to validate the binding between the client and token. This document describes how to perform such validation, depending on which mechanism was used to produce a PoP token.\nValidating mTLS Proof-of-Possession If you are using a mutual TLS connection to establish proof-of-possession, the resulting access token will contain a cnf claim containing the client\u0026rsquo;s certificate thumbprint. APIs validate such tokens by comparing this thumbprint to the thumbprint of the client certificate in the mTLS connection. This validation should be performed early in the pipeline, ideally immediately after the standard validation of the access token.\nYou can do so with custom middleware like this:\n// normal token validation happens here app.UseAuthentication(); // This adds custom middleware to validate cnf claim app.UseConfirmationValidation(); app.UseAuthorization(); Here, UseConfirmationValidation is an extension method that registers the middleware that performs the necessary validation:\npublic static class ConfirmationValidationExtensions { public static IApplicationBuilder UseConfirmationValidation(this IApplicationBuilder app, ConfirmationValidationMiddlewareOptions options = default) { return app.UseMiddleware\u0026lt;ConfirmationValidationMiddleware\u0026gt;(options ?? new ConfirmationValidationMiddlewareOptions()); } } And this is the actual middleware that validates the cnf claim:\n// this middleware validates the cnf claim (if present) against the thumbprint of the X.509 client certificate for the current client public class ConfirmationValidationMiddleware { private readonly RequestDelegate _next; private readonly ILogger _logger; private readonly ConfirmationValidationMiddlewareOptions _options; public ConfirmationValidationMiddleware( RequestDelegate next, ILogger\u0026lt;ConfirmationValidationMiddlewareOptions\u0026gt; logger, ConfirmationValidationMiddlewareOptions options = null) { _next = next; _logger = logger; _options ??= new ConfirmationValidationMiddlewareOptions(); } public async Task Invoke(HttpContext ctx) { if (ctx.User.Identity.IsAuthenticated) { // read the cnf claim from the validated token var cnfJson = ctx.User.FindFirst(\u0026#34;cnf\u0026#34;)?.Value; if (!String.IsNullOrWhiteSpace(cnfJson)) { // if present, make sure a valid certificate was presented as well var certResult = await ctx.AuthenticateAsync(_options.CertificateSchemeName); if (!certResult.Succeeded) { await ctx.ChallengeAsync(_options.CertificateSchemeName); return; } // get access to certificate from transport var certificate = await ctx.Connection.GetClientCertificateAsync(); var thumbprint = Base64UrlTextEncoder.Encode(certificate.GetCertHash(HashAlgorithmName.SHA256)); // retrieve value of the thumbprint from cnf claim var cnf = JObject.Parse(cnfJson); var sha256 = cnf.Value\u0026lt;string\u0026gt;(\u0026#34;x5t#S256\u0026#34;); // compare thumbprint claim with thumbprint of current TLS client certificate if (String.IsNullOrWhiteSpace(sha256) || !thumbprint.Equals(sha256, StringComparison.OrdinalIgnoreCase)) { _logger.LogError(\u0026#34;certificate thumbprint does not match cnf claim.\u0026#34;); await ctx.ChallengeAsync(_options.JwtBearerSchemeName); return; } _logger.LogDebug(\u0026#34;certificate thumbprint matches cnf claim.\u0026#34;); } } await _next(ctx); } } public class ConfirmationValidationMiddlewareOptions { public string CertificateSchemeName { get; set; } = CertificateAuthenticationDefaults.AuthenticationScheme; public string JwtBearerSchemeName { get; set; } = JwtBearerDefaults.AuthenticationScheme; } Validating DPoP Proof-of-Possession If you are using DPoP for proof-of-possession, there is a non-trivial amount of work needed to validate the cnf claim. In addition to the normal validation mechanics of the access token itself, DPoP requires additional validation of the DPoP proof token sent in the \u0026ldquo;DPoP\u0026rdquo; HTTP request header. DPoP proof token processing involves requiring the DPoP scheme on the authorization header where the access token is sent, JWT validation of the proof token, \u0026ldquo;cnf\u0026rdquo; claim validation, HTTP method and URL validation, replay detection (which requires some storage for the replay information), nonce generation and validation, additional clock skew logic, and emitting the correct response headers in the case of the various validation errors.\nYou can use the Duende.AspNetCore.Authentication.JwtBearer NuGet package to implement this validation. With this package, the configuration necessary in your startup can be as simple as this:\n// adds the normal JWT bearer validation builder.Services.AddAuthentication(\u0026#34;token\u0026#34;) .AddJwtBearer(\u0026#34;token\u0026#34;, options =\u0026gt; { options.Authority = Constants.Authority; options.TokenValidationParameters.ValidateAudience = false; options.MapInboundClaims = false; options.TokenValidationParameters.ValidTypes = new[] { \u0026#34;at+jwt\u0026#34; }; }); // extends the \u0026#34;token\u0026#34; scheme above with DPoP processing and validation builder.Services.ConfigureDPoPTokensForScheme(\u0026#34;token\u0026#34;); You will also typically need a distributed cache, used to perform replay detection of DPoP proofs. Duende.AspNetCore.Authentication.JwtBearer relies on IDistributedCache for this, so you can supply the cache implementation of your choice. See the Microsoft documentation for more details on on setting up distributed caches, along with many examples, including Redis, CosmosDB, and Sql Server.\nA full sample using the default in memory caching is available here.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/tokens/extension_grants/",
    "title": "Extension Grants",
    "tags": [],
    "description": "",
    "content": "Extension Grants OAuth defines an extensibility point called extension grants.\nExtension grants allow adding support for non-standard token issuance scenarios, e.g.\ntoken transformation SAML to JWT, or Windows to JWT delegation or impersonation federation encapsulating custom input parameters You can add support for additional grant types by implementing the IExtensionGrantValidator interface.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/validators/dpop_proof_validator/",
    "title": "DPoP Proof Validator",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Validation.IDPoPProofValidator The IDPoPProofValidator interface is used to validate DPoP proof tokens submitted to IdentityServer. A default implementation is provided and can be overridden as necessary.\nIDPoPProofValidator APIs ValidateAsync\nValidates a DPoP proof token with the provided DPoPProofValidationContext for the current request. Returns a DPoPProofValidationResult object.\nDPoPProofValidationContext Models the information to validate a DPoP proof token request.\nClient\nThe Client making the request.\nProofToken\nThe proof token sent with the request.\nDPoPProofValidationResult Models the result of a DPoP proof token validation.\nIsError\nFlag to indicate if validation failed.\nError\nThe error code if the validation failed.\nErrorDescription\nThe error description if the validation failed.\nJsonWebKey\nThe serialized JWK from the validated DPoP proof token.\nJsonWebKeyThumbprint\nThe JWK thumbprint from the validated DPoP proof token.\nConfirmation\nThe \u0026lsquo;cnf\u0026rsquo; value for the DPoP proof token.\nPayload\nThe payload values of the DPoP proof token.\nTokenId\nThe \u0026lsquo;jti\u0026rsquo; value read from the payload.\nNonce\nThe \u0026rsquo;nonce\u0026rsquo; value read from the payload.\nIssuedAt\nThe \u0026lsquo;iat\u0026rsquo; value read from the payload.\nServerIssuedNonce\nThe \u0026rsquo;nonce\u0026rsquo; value issued by the server that should be emitted on the response.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/upgrades/v6.2_to_v6.3/",
    "title": "Duende IdentityServer v6.2 to v6.3",
    "tags": [],
    "description": "",
    "content": "This upgrade guide covers upgrading from Duende IdentityServer v6.2 to v6.3 (release notes).\nWhat\u0026rsquo;s New Duende IdentityServer 6.3 adds:\nSupport for OAuth 2.0 Demonstrating Proof-of-Possession at the Application Layer (DPoP) , a new OAuth specification for sender-constraining refresh tokens and access tokens.\nA new Configuration API distributed through the separate Duende.IdentityServer.Configuration NuGet package that supports the OAuth and OIDC Dynamic Client Registration specifications.\nSupport for 3rd party initiated login through the new client configuration property InitiateLoginUri. This is typically used to create a client application portal page within an IdentityServer host.\nSupport for the OIDC prompt=create parameter, which gives the client application the ability to provide a hint that the user needs to register.\nNew configuration options for managing refresh token rotation.\nSupport for the unmet_authentication_requirements error response code, improving error responses during step-up flows.\nNullable reference type annotations on many public APIs.\nProgrammer quality of life improvements, bug fixes, and more! See the release notes for more details.\nStep 1: Update NuGet package In your IdentityServer host project, update the version of the NuGet package reference. For example in your project file:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;6.2.0\u0026#34; /\u0026gt; would change to:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;6.3.0\u0026#34; /\u0026gt; Step 2: Update Database Schema (if necessary) IdentityServer 6.3 adds new four new properties to the Duende.IdentityServer.Models.Client model that are needed to support DPoP and 3rd party initiated login. If you are storing you Client configuration in a database, then you will need to update the database\u0026rsquo;s schema.\nThe InitiateLoginUri string is a nullable string used for Third Party Initiated Login. Existing clients only need a value set for this property if the IdentityServer host itself is using third party initiated login (e.g., if you are building a client application portal within your IdentityServer) and want the client to be part of the portal.\nNew properties added to the Client Model for DPoP support:\nRequireDPoP is a non-nullable boolean flag that controls if a client is required to use DPoP. Existing clients that are not using DPoP can set this to false. DPoPValidationMode is a non-nullable column that stores a \u0026ldquo;flags\u0026rdquo;-style enum that controls the DPoP validation mechanism. In most databases, this is represented as an integer. Existing clients that are not using DPoP can set its value to 0. DPoPClockSkew is a non-nullable timespan that controls how much clock skew is allowed for a particular DPoP client. Existing clients that are not using DPoP can set its value to a timespan of length 0. IdentityServer is abstracted from the data store on multiple levels, so the exact steps involved in updating your data store will depend on your implementation details.\nCustom Store Implementations The core of IdentityServer is written against the store interfaces, which abstract all the implementation details of actually storing data. If your IdentityServer implementation includes a custom implementation of those stores, then you will have to determine how best to include the changes in the model in the underlying data store and make any necessary changes to schemas, if your data store requires that.\nDuende.IdentityServer.EntityFramework We also provide a default implementation of the stores in the Duende.IdentityServer.EntityFramework package, but this implementation is still highly abstracted because it is usable with any database that has an EF provider. Different database vendors have very different dialects of sql that have different syntax and type systems, so we don\u0026rsquo;t provide schema changes directly. Instead, we provide the Entity Framework entities and mappings which can be used with Entity Framework\u0026rsquo;s migrations feature to generate the schema updates that are needed in your database.\nTo generate a migration for the new columns, run the command below. Note that you might need to adjust paths based on your specific organization of the migration files.\ndotnet ef migrations add Update_DuendeIdentityServer_v6_3 -c ConfigurationDbContext -o Migrations/ConfigurationDb Then to apply this migration to your database:\ndotnet ef database update -c ConfigurationDbContext Some organizations prefer to use other tools for managing schema changes. You\u0026rsquo;re free to manage your schema however you see fit, as long as the entities can be successfully mapped. Even if you\u0026rsquo;re not going to ultimately use Entity Framework migrations to manage your database changes, generating a migration can be a useful development step to get an idea of what needs to be done.\nStep 3: Verify Data Protection Configuration IdentityServer depends on ASP.NET Data Protection. Data Protection encrypts and signs data using keys managed by ASP.NET. Those keys are isolated by application name, which by default is set to the content root path of the host. This prevents multiple applications from sharing encryption keys, which is necessary to protect your encryption against certain forms of attack. However, this means that if your content root path changes, the default settings for data protection will prevent you from using your old keys. Beginning in .NET 6, the content root path was normalized so that it ends with a directory separator. In .NET 7 that change was reverted. This means that your content root path might change if you upgrade from .NET 6 to .NET 7. This can be mitigated by explicitly setting the application name and removing the separator character. See Microsoft\u0026rsquo;s documentation for more information.\nStep 4: Breaking changes A new ITokenCleanupService interface has been extracted from the TokenCleanupService, and IdentityServer now depends on that interface, rather than the service itself. Customizations of TokenCleanupService that previously were implemented by deriving from that class and registering the derived class in the DI system need to\nRegister the derived class as an implementation of ITokenCleanupService, and Remove the IServerSideSessionsMarker from any calls to the base constructor. See issue #981.\nThe TokenCleanupService.RemoveExpiredGrantsAsync method was renamed to CleanupGrantsAsync to reflect that it performs all grant cleanup work, including removing consumed grants and expired device codes in addition to expired grants. In the strictest sense, this is a breaking change, but it is very unlikely to cause issues during an upgrade because even though RemoveExpiredGrantsAsync was public, it was not virtual. If you were using RemoveExpiredGrantsAsync elsewhere, update your code to use the new name.\nSee issue #981.\nThe value of the typ claim in the header of Logout tokens has changed to logout+jwt, which complies with OpenID Connect Back-Channel Logout 1.0. Clients that were previously validating the typ need to be updated, or the old typ can continue to be used via the new LogoutTokenJwtType configuration option.\nSee issue #1169.\nThe TokenResponseGenerator.ProcessTokenRequestAsync virtual method, which generates access and refresh tokens and adds them to a response object, is now called by all token flows except the refresh token flow. This unifies the programming and extensibility model of the generator, which previously had duplicated code in some flows. If you have overridden this virtual method, be aware that it will now be called in all flows. Previously, the authorization code flow, device code flow, and CIBA flow did not invoke this method.\nSee pull request: #1178.\nOne time use (rotated) refresh tokens are now deleted immediately when they are used by default. If you rely on the existing behavior of marking refresh tokens as consumed (perhaps to allow for lenient rotations or replay detection), set the new PersistentGrantOptions.DeleteOneTimeOnlyRefreshTokensOnUse option to false.\nSee issue #1102.\nStep 5: Done! That\u0026rsquo;s it. Of course, at this point you can and should test that your IdentityServer is updated and working properly.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/data/operational/keys/",
    "title": "Keys",
    "tags": [],
    "description": "",
    "content": "The automatic key management feature in Duende IdentityServer requires a store to persist keys that are dynamically created.\nSigning Key Store By default, the file system is used, but the storage of these keys is abstracted behind a extensible store interface. The ISigningKeyStore is that storage interface.\nRegistering a custom signing key store To register a custom signing key store in the DI container, there is a AddSigningKeyStore helper on the IIdentityServerBuilder. For example:\nbuilder.Services.AddIdentityServer() .AddSigningKeyStore\u0026lt;YourCustomStore\u0026gt;(); Key Lifecycle When keys are required, LoadKeysAsync will be called to load them all from the store. They are then cached automatically for some amount of time based on configuration. Periodically a new key will be created, and StoreKeyAsync will be used to persist the new key. Once a key is past its retirement, DeleteKeyAsync will be used to purge the key from the store.\nSerialized Key The SerializedKey is the model that contains the key data to persist.\nIt is expected that the Id is the unique identifier for the key in the store. The Data property is the main payload of the key and contains a copy of all the other values. Some of the properties affect how the Data is processed (e.g. DataProtected), and the other properties are considered read-only and thus can\u0026rsquo;t be changed to affect the behavior (e.g. changing the Created value will not affect the key lifetime, nor will changing Algorithm change which signing algorithm the key is used for).\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/ui/login/context/",
    "title": "Login Context",
    "tags": [],
    "description": "",
    "content": "The returnUrl query parameter passed to the login page refers to the URL the prior request came from. This URL typically refers to the IdentityServer authorization endpoint and contains the original request parameters sent from the client. These parameters might contain information your login page needs to customize its workflow. Some examples would be for branding, dynamic page customization (e.g. which external login providers to use), or controlling what credentials the client application expects (e.g. perhaps MFA is required).\nAuthorization Request Context In order to read the original authorize request parameter values, you can use the interaction service. It provides a GetAuthorizationContextAsync API that will extract that information from the returnUrl and return an AuthorizationRequest object which contains these values.\nIt is unnecessary (and discouraged) for your login page logic to parse the returnUrl itself.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/configuration/dcr/reference/response/",
    "title": "Response Generation",
    "tags": [],
    "description": "DCR Reference",
    "content": "IDynamicClientRegistrationResponseGenerator The IDynamicClientRegistrationResponseGenerator interface defines the contract for a service that generates dynamic client registration responses.\npublic interface IDynamicClientRegistrationResponseGenerator Members name description WriteBadRequestError(…) Writes a bad request error to the HTTP context. WriteContentTypeError(…) Writes a content type error to the HTTP response. WriteProcessingError(…) Writes a processing error to the HTTP context. WriteResponse(…) Writes a response object to the HTTP context with the given status code. WriteSuccessResponse(…) Writes a success response to the HTTP context. WriteValidationError(…) Writes a validation error to the HTTP context. DynamicClientRegistrationResponseGenerator The DynamicClientRegistrationResponseGenerator is the default implementation of the IDynamicClientRegistrationResponseGenerator. If you wish to customize a particular aspect of response generation, you can extend this class and override the appropriate methods. You can also set JSON serialization options by overriding its SerializerOptions property.\nMembers name description SerializerOptions { get; set; } The options used for serializing json in responses. "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/stores/persisted_grant_store/",
    "title": "Persisted Grant Store",
    "tags": [],
    "description": "",
    "content": "The IPersistedGrantStore interface is the contract for a service that stores, retrieves, and deletes persisted grants. A grant is a somewhat abstract concept that is used in various protocol flows and represents that a resource owner has given authorization of some kind. Grants that require server side state in IdentityServer are the persisted grants stored by the IPersistedGrantStore.\nThe IPersistedGrantStore is abstracted to allow for storage of several grant types, including authorization codes, refresh tokens, user consent, and reference tokens. Some specialized grant types, including device flow and CIBA, use their own specialized stores instead.\nIdentityServer includes two implementations of the IPersistedGrantStore. The InMemoryPersistedGrantStore unsurprisingly persists grants in memory and is intended for demos, tests, and other situations where persistent storage is not actually necessary. In contrast, the Duende.IdentityServer.EntityFramework.Stores.PersistedGrantStore durably persists grants to a database using EntityFramework, and can be used with any database with an EF provider.\nYou can also provide your own implementation of the IPersistedGrantStore. This allows for complete control of the data access code so that you can support other data stores that lack an EF provider, and so that you can optimize the data access for your environment and usage.\nDuende.IdentityServer.Stores.IPersistedGrantStore Members name description Task StoreAsync(PersistedGrant grant); Stores a grant. Task GetAsync(string key); Retrieves a grant by its key. Task\u0026lt;IEnumerable\u0026gt; GetAllAsync(PersistedGrantFilter filter); Retrieves all grants that fulfill the conditions of a filter. Task RemoveAsync(string key); Removes a grant by key. Task RemoveAllAsync(PersistedGrantFilter filter); Removes all grants that fulfill the conditions of a filter. Duende.IdentityServer.Models.PersistedGrant Members name description string Key A string that uniquely identifies the grant. string Type A string that specifies the type of grant. The possible values are constants in the PersistedGrantTypes class (see below). string SubjectId The identifier of the subject that granted authorization. string SessionId The identifier of the session where the grant was made, if applicable. string ClientId The identifier of the client that was granted authorization. string Description The description the user assigned to the device being authorized. DateTime CreationTime The time that the grant expires. DateTime? Expiration The time that the grant expires. DateTime? ConsumedTime The time that the grant was consumed. string Data A serialized and data protected representation of the grant. Key Property The Key property contains a SHA256 hash of the value used to refer to individual grants. For authorization codes, refresh tokens, and reference tokens, the stored Key hashes the actual value sent to the client as part of the protocol flow. For example, refresh token records use a hash of the actual refresh token parameter sent to the client as their Key. In contrast, user consent is not identified by a single protocol parameter. Instead, the Key value for user consent records comes from a hash of a combination of subject id and client id. In all cases, the value that is hashed to compute the Key also includes the grant type.\nBeginning in v6.0, the hashes that IdentityServer passes to the IPersistedGrantStore to use as Key values are formatted as hex values. In earlier versions, the Keys were base-64 encoded. That occasionally caused database collation issues in case-insensitive databases, which prompted the change to hex encoding. To facilitate migration, IdentityServer adds a version suffix (\u0026quot;-1\u0026quot;) to indicate that the newer hex encoding should be used during hashing. For example, the refresh token parameter \u0026ldquo;27931A10FBCA75583C5576DAFB5DBDF0A9BCA8D6BD38B7CF142C47D6E44ED24D-1\u0026rdquo; ends in the \u0026ldquo;-1\u0026rdquo; suffix, so when IdentityServer searches for its persisted grant record, it computes the hash of the parameter value, applies hex encoding, and then calls IPersistedGrantStore.GetAsync(\u0026hellip;), passing the resulting hex encoded value. A refresh token created before v6.0 would not include the \u0026ldquo;-1\u0026rdquo; suffix, so IdentityServer would instead pass a base-64 encoded hash to the GetAsync method.\nHowever, consent records were not migrated to use hex encoding of their Key values until IdentityServer v7.0. Since there\u0026rsquo;s no protocol parameter that corresponds to consent records, there\u0026rsquo;s no way to use the protocol parameters to determine which encoding to use. So, prior to v7.0, the consent Key values remained in the base-64 encoding.\nBeginning in v7.0, IdentityServer uses hex encoding for Consent Key values, but falls back to base-64 encoding when hex encoding fails to find a grant. In that case, IdentityServer will automatically update the grant to use a hex encoded Key.\nData Property The Data property contains information that is specific to the grant type. For example, consent records contain the scopes that the user consented to grant to the client.\nThe Data property also contains a copy of the SubjectId, SessionId, ClientId, Description, CreationTime, and Expiration properties when those properties are applicable to the grant type. The copy in the Data is treated as authoritative by IdentityServer, in the sense that the copy is used when grants are retrieved from the store. The other properties exist to enable querying the grants and/or for informational purposes and should be treated as read-only.\nBy default, the Data property is encrypted at rest using the ASP.NET Data Protection API. The DataProtectData option can be used to disable this encryption.\nTime Stamps All grants set their CreationTime when they are created as a UTC timestamp.\nGrants that expire set their Expiration when they are created as well. Consent records only expire if the ConsentLifetime property of the Client is set. By default, ConsentLifetime is not set and consent lasts until it is revoked. Authorization code records always include an Expiration. They expire after the AuthorizationCodeLifetime has elapsed, so they are initialized with their Expiration set that far into the future. Reference token records expire in the same way, with their Expiration controlled by the AccessTokenLifetime. Refresh token records also always include Expiration, controlled by the AbsoluteRefreshTokenLifetime and SlidingRefreshTokenLifetime client settings. Custom grant records should set the Expiration to indicate that they are only usable for a length of time, or not set it to indicate that they can be used indefinitely.\nSome grants can set a ConsumedTime when they are used. This applies to grants that are intended to be used once and that need to be retained after their use for some purpose (for example, replay detection or to allow certain kinds of limited reuse). Refresh tokens can be configured to have one-time use semantics. Refresh tokens that are configured this way can be further configured to set a ConsumedTime when they are used. Authorization codes do not set a ConsumedTime. They are instead always removed on use. ConsumedTime is not applicable to reference tokens and consent, so they both never set it. Custom grant records should set the ConsumedTime if one-time use semantics are appropriate for the grant.\nPersistedGrantFilter /// \u0026lt;summary\u0026gt; /// Represents a filter used when accessing the persisted grants store. /// Setting multiple properties is interpreted as a logical \u0026#39;AND\u0026#39; to further filter the query. /// At least one value must be supplied. /// \u0026lt;/summary\u0026gt; public class PersistedGrantFilter { /// \u0026lt;summary\u0026gt; /// Subject id of the user. /// \u0026lt;/summary\u0026gt; public string SubjectId { get; set; } /// \u0026lt;summary\u0026gt; /// Session id used for the grant. /// \u0026lt;/summary\u0026gt; public string SessionId { get; set; } /// \u0026lt;summary\u0026gt; /// Client id the grant was issued to. /// \u0026lt;/summary\u0026gt; public string ClientId { get; set; } /// \u0026lt;summary\u0026gt; /// Client ids the grant was issued to. /// \u0026lt;/summary\u0026gt; public IEnumerable\u0026lt;string\u0026gt; ClientIds { get; set; } /// \u0026lt;summary\u0026gt; /// The type of grant. /// \u0026lt;/summary\u0026gt; public string Type { get; set; } /// \u0026lt;summary\u0026gt; /// The types of grants. /// \u0026lt;/summary\u0026gt; public IEnumerable\u0026lt;string\u0026gt; Types { get; set; } } PersistedGrantTypes The types of persisted grants are defined by the IdentityServerConstants.PersistedGrantTypes constants:\npublic static class PersistedGrantTypes { public const string AuthorizationCode = \u0026#34;authorization_code\u0026#34;; public const string BackChannelAuthenticationRequest = \u0026#34;ciba\u0026#34;; public const string ReferenceToken = \u0026#34;reference_token\u0026#34;; public const string RefreshToken = \u0026#34;refresh_token\u0026#34;; public const string UserConsent = \u0026#34;user_consent\u0026#34;; public const string DeviceCode = \u0026#34;device_code\u0026#34;; public const string UserCode = \u0026#34;user_code\u0026#34;; } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/stores/device_flow_store/",
    "title": "Device Flow Store",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Stores.IDeviceFlowStore Models storage of grants for the device flow.\n/// \u0026lt;summary\u0026gt; /// Interface for the device flow store /// \u0026lt;/summary\u0026gt; public interface IDeviceFlowStore { /// \u0026lt;summary\u0026gt; /// Stores the device authorization request. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;deviceCode\u0026#34;\u0026gt;The device code.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;userCode\u0026#34;\u0026gt;The user code.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;The data.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task StoreDeviceAuthorizationAsync(string deviceCode, string userCode, DeviceCode data); /// \u0026lt;summary\u0026gt; /// Finds device authorization by user code. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;userCode\u0026#34;\u0026gt;The user code.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task\u0026lt;DeviceCode\u0026gt; FindByUserCodeAsync(string userCode); /// \u0026lt;summary\u0026gt; /// Finds device authorization by device code. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;deviceCode\u0026#34;\u0026gt;The device code.\u0026lt;/param\u0026gt; Task\u0026lt;DeviceCode\u0026gt; FindByDeviceCodeAsync(string deviceCode); /// \u0026lt;summary\u0026gt; /// Updates device authorization, searching by user code. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;userCode\u0026#34;\u0026gt;The user code.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;The data.\u0026lt;/param\u0026gt; Task UpdateByUserCodeAsync(string userCode, DeviceCode data); /// \u0026lt;summary\u0026gt; /// Removes the device authorization, searching by device code. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;deviceCode\u0026#34;\u0026gt;The device code.\u0026lt;/param\u0026gt; Task RemoveByDeviceCodeAsync(string deviceCode); } DeviceCode /// \u0026lt;summary\u0026gt; /// Represents data needed for device flow. /// \u0026lt;/summary\u0026gt; public class DeviceCode { /// \u0026lt;summary\u0026gt; /// Gets or sets the creation time. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The creation time. /// \u0026lt;/value\u0026gt; public DateTime CreationTime { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the lifetime. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The lifetime. /// \u0026lt;/value\u0026gt; public int Lifetime { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the client identifier. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The client identifier. /// \u0026lt;/value\u0026gt; public string ClientId { get; set; } /// \u0026lt;summary\u0026gt; /// Gets the description the user assigned to the device being authorized. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The description. /// \u0026lt;/value\u0026gt; public string Description { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets a value indicating whether this instance is open identifier. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt; if this instance is open identifier; otherwise, \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;. /// \u0026lt;/value\u0026gt; public bool IsOpenId { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets a value indicating whether this instance is authorized. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt; if this instance is authorized; otherwise, \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;. /// \u0026lt;/value\u0026gt; public bool IsAuthorized { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the requested scopes. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The authorized scopes. /// \u0026lt;/value\u0026gt; public IEnumerable\u0026lt;string\u0026gt; RequestedScopes { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the authorized scopes. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The authorized scopes. /// \u0026lt;/value\u0026gt; public IEnumerable\u0026lt;string\u0026gt; AuthorizedScopes { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the subject. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The subject. /// \u0026lt;/value\u0026gt; public ClaimsPrincipal Subject { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the session identifier. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The session identifier. /// \u0026lt;/value\u0026gt; public string SessionId { get; set; } } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/services/persisted_grant_service/",
    "title": "Persisted Grant Service",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Services.IPersistedGrantService Provides access to a user\u0026rsquo;s grants.\n/// \u0026lt;summary\u0026gt; /// Implements persisted grant logic /// \u0026lt;/summary\u0026gt; public interface IPersistedGrantService { /// \u0026lt;summary\u0026gt; /// Gets all grants for a given subject ID. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;subjectId\u0026#34;\u0026gt;The subject identifier.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task\u0026lt;IEnumerable\u0026lt;Grant\u0026gt;\u0026gt; GetAllGrantsAsync(string subjectId); /// \u0026lt;summary\u0026gt; /// Removes all grants for a given subject id, and optionally client id and session id combination. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;subjectId\u0026#34;\u0026gt;The subject identifier.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;clientId\u0026#34;\u0026gt;The client identifier (optional).\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;sessionId\u0026#34;\u0026gt;The session id (optional).\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task RemoveAllGrantsAsync(string subjectId, string clientId = null, string sessionId = null); } Grant /// \u0026lt;summary\u0026gt; /// Models a grant the user has given. /// \u0026lt;/summary\u0026gt; public class Grant { /// \u0026lt;summary\u0026gt; /// Gets or sets the subject identifier. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The subject identifier. /// \u0026lt;/value\u0026gt; public string SubjectId { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the client identifier. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The client identifier. /// \u0026lt;/value\u0026gt; public string ClientId { get; set; } /// \u0026lt;summary\u0026gt; /// Gets the description the user assigned to the device being authorized. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The description. /// \u0026lt;/value\u0026gt; public string Description { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the scopes. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The scopes. /// \u0026lt;/value\u0026gt; public IEnumerable\u0026lt;string\u0026gt; Scopes { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the creation time. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The creation time. /// \u0026lt;/value\u0026gt; public DateTime CreationTime { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the expiration. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The expiration. /// \u0026lt;/value\u0026gt; public DateTime? Expiration { get; set; } } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/fundamentals/claims/",
    "title": "Claims",
    "tags": [],
    "description": "",
    "content": "IdentityServer emits claims about users and clients into tokens. You are in full control of which claims you want to emit, in which situations you want to emit those claims, and where to retrieve those claims from.\nUser claims User claims can be emitted in both identity and access tokens and in the userinfo endpoint. The central extensibility point to implement to emit claims is called the profile service. The profile service is responsible for both gathering claim data and deciding which claims should be emitted.\nWhenever IdentityServer needs the claims for a user, it invokes the registered profile service with a context that presents detailed information about the current request, including\nthe client that is making the request the identity of the user the type of the request (access token, id token, or userinfo) the requested claim types, which are the claims types associated with requested scopes and resources Strategies for Emitting Claims You can use different strategies to determine which claims to emit based on the information in the profile context.\nemit claims based on the requested claim types emit claims based on user or client identity always emit certain claims Emit claims based on the client\u0026rsquo;s request You can filter the claims you emit to only include the claim types requested by the client. If your client requires consent, this will also give end users the opportunity to approve or deny sharing those claims with the client.\nClients can request claims in several ways:\nRequesting an IdentityResource by including the scope parameter for the IdentityResource requests the claims associated with the IdentityResource in its UserClaims collection. Requesting an ApiScope by including the scope parameter for the ApiScope requests the claims associated with the ApiScope in its UserClaims collection. Requesting an ApiResource by including the resource indicator parameter for the ApiResource requests the claims associated with the ApiResource in its UserClaims collection. The RequestedClaimTypes property of the ProfileDataRequestContext contains the collection of claims requested by the client.\nIf your profile service extends the DefaultProfileService, you can use its AddRequestedClaims method to add only requested and approved claims. The intent is that your profile service can retrieve claim data and then filter that claim data based on what was requested by the client. For example:\npublic class SampleProfileService : DefaultProfileService { public virtual async Task GetProfileDataAsync(ProfileDataRequestContext context) { var claims = await GetClaimsAsync(context); context.AddRequestedClaims(claims); } private async Task\u0026lt;List\u0026lt;Claim\u0026gt;\u0026gt; GetClaimsAsync(ProfileDataRequestContext context) { // Your implementation that retrieves claims goes here } } Always emit claims We generally recommend emitting claims based on the requested claim types, as that respects the scopes and resources requested by the client and gives the end user an opportunity to consent to this sharing of information. However, if you have claims that don\u0026rsquo;t need to follow such rules, such as claims that are an integral part of the user\u0026rsquo;s identity and that are needed in most scenarios, they can be added by directly updating the context.IssuedClaims collection. For example:\npublic class SampleProfileService : DefaultProfileService { public virtual async Task GetProfileDataAsync(ProfileDataRequestContext context) { var claims = await GetClaimsAsync(context); context.IssuedClaims.AddRange(claims); } private async Task\u0026lt;Claim\u0026gt; GetClaimsAsync(ProfileDataRequestContext context) { // Your implementation that retrieves claims goes here } } Emit claims based on the user or client identity Finally, you might have claims that are only appropriate for certain users or clients. Your ProfileService can add whatever filtering or logic that you like.\nThe Subject of the ProfileDataRequestContext When the profile service is invoked to add claims to tokens, the Subject property on the ProfileDataRequestContext contains the principal that was issued during user sign-in. Typically, the profile service will source some claims from the Subject and others from databases or other data sources.\nWhen the profile service is called for requests to the userinfo endpoint, the Subject property will not contain the principal issued during user sign-in, since userinfo calls don\u0026rsquo;t happen as part of a session. Instead, the Subject property will contain a claims principal populated with the claims in the access token used to authorize the userinfo call. You can check the caller of the profile service by querying the Caller property on the context.\nClient claims Client claims are a set of pre-defined claims that are emitted in access tokens. They are defined on a per-client basis, meaning that each client can have its own unique set of client claims. The following shows an example of a client that is associated with a certain customer in your system:\nvar client = new Client { ClientId = \u0026#34;client\u0026#34;, // rest omitted Claims = { new ClientClaim(\u0026#34;customer_id\u0026#34;, \u0026#34;123\u0026#34;) } }; To avoid accidental collision with user claims, client claims are prefixed with client_. For example, the above ClientClaim would be emitted as the client_customer_id claim type in access tokens. You can change or remove this prefix by setting the ClientClaimsPrefix on the client definition.\nBy default, client claims are only sent in the client credentials flow. If you want to enable them for other flows, you need to set the AlwaysSendClientClaims property on the client definition.\nSetting client claims dynamically If you want to set client claims dynamically, you could either do that at client load time (via a client store implementation), or using a custom token request validator.\nClaim Serialization Claim values are serialized based on the ClaimValueType of the claim. Claims that don\u0026rsquo;t specify a ClaimValueType are simply serialized as strings. Claims that specify a ClaimValueType of System.Security.Claims.ClaimValueTypes.Integer, System.Security.Claims.ClaimValueTypes.Integer32, System.Security.Claims.ClaimValueTypes.Integer64, System.Security.Claims.ClaimValueTypes.Double, or System.Security.Claims.ClaimValueTypes.Boolean are parsed as the corresponding type, while those that specify IdentityServerConstants.ClaimValueTypes.Json are serialized to JSON using System.Text.Json.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/models/grant_validation_result/",
    "title": "Grant Validation Result",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Validation.GrantValidationResult The GrantValidationResult class models the outcome of grant validation for extensions grants and resource owner password grants.\nIt models either a successful validation result with claims (e.g. subject ID) or an invalid result with an error code and message, e.g.:\npublic class ExtensionGrantValidator : IExtensionGrantValidator { public Task ValidateAsync(ExtensionGrantValidationContext context) { // some validation steps if (success) { context.Result = new GrantValidationResult( subject: \u0026#34;818727\u0026#34;, authenticationMethod: \u0026#34;custom\u0026#34;, claims: extraClaims); } else { // custom error message context.Result = new GrantValidationResult( TokenRequestErrors.InvalidGrant, \u0026#34;invalid custom credential\u0026#34;); } return Task.CompletedTask; } } It also allows passing additional custom values that will be included in the token response, e.g.:\ncontext.Result = new GrantValidationResult( subject: \u0026#34;818727\u0026#34;, authenticationMethod: \u0026#34;custom\u0026#34;, customResponse: new Dictionary\u0026lt;string, object\u0026gt; { { \u0026#34;some_data\u0026#34;, \u0026#34;some_value\u0026#34; } }); This will result in the following token response:\n{ \u0026#34;access_token\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;Bearer\u0026#34;, \u0026#34;expires_in\u0026#34;: 360, \u0026#34;some_data\u0026#34;: \u0026#34;some_value\u0026#34; } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/samples/clients/",
    "title": "Clients",
    "tags": [],
    "description": "Samples",
    "content": "This section contains a collection of various client technologies connecting to IdentityServer.\n.NET 4.8 Clients This sample shows how to add OpenID Connect code flow with PKCE to a .NET 4.8 WebForms client and a .NET 4.8 MVC Client. Each client can login, logout, make API requests to a .NET 4.8 WebApi using OAuth, and refresh access tokens.\nlink to source code\n.NET MAUI client This sample shows how to use the IdentityModel.OidcClient FOSS library to connect a .NET MAUI app to IdentityServer\nlink to source code\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/fundamentals/keys/automatic_key_management/",
    "title": "Automatic Key Management",
    "tags": [],
    "description": "",
    "content": "Duende IdentityServer can manage signing keys for you using the Automatic Key Management feature.\nAutomatic Key Management follows best practices for handling signing key material, including\nautomatic rotation of keys secure storage of keys at rest using data protection announcement of upcoming new keys maintenance of retired keys Automatic Key Management is included in IdentityServer Business Edition or higher.\nConfiguration Automatic Key Management is configured by the options in the KeyManagement property on the IdentityServerOptions.\nManaged Key Lifecycle Keys created by Automatic Key Management move through several phases. First, new keys are announced, that is, they are added to the list of keys in discovery, but not yet used for signing. After a configurable amount of PropagationTime, keys are promoted to be signing credentials, and will be used by IdentityServer to sign tokens. Eventually, enough time will pass that the key is older than the configurable RotationTime, at which point the key is retired, but kept in discovery for a configurable RetentionDuration. After the RetentionDuration has passed, keys are removed from discovery, and optionally deleted.\nThe default is to rotate keys every 90 days, announce new keys with 14 days of propagation time, retain old keys for a duration of 14 days, and to delete keys when they are retired. All of these options are configurable in the KeyManagement options. For example:\nvar idsvrBuilder = builder.Services.AddIdentityServer(options =\u0026gt; { // new key every 30 days options.KeyManagement.RotationInterval = TimeSpan.FromDays(30); // announce new key 2 days in advance in discovery options.KeyManagement.PropagationTime = TimeSpan.FromDays(2); // keep old key for 7 days in discovery for validation of tokens options.KeyManagement.RetentionDuration = TimeSpan.FromDays(7); // don\u0026#39;t delete keys after their retention period is over options.KeyManagement.DeleteRetiredKeys = false; }); Key storage Automatic Key Management stores keys through the abstraction of the ISigningKeyStore. You can implement this extensibility point to customize the storage of your keys (perhaps using a key vault of some kind), or use one of the two implementations of the ISigningKeyStore that we provide:\nthe default FileSystemKeyStore, which writes keys to the file system. the EntityFramework operational store which writes keys to a database using EntityFramework. The default FileSystemKeyStore writes keys to the KeyPath directory configured in your IdentityServer host, which defaults to the directory ~/keys. This directory should be excluded from source control.\nIf you are deploying in a load balanced environment and wish to use the FileSystemKeyStore, all instances of IdentityServer will need read/write access to the KeyPath.\nvar idsvrBuilder = builder.Services.AddIdentityServer(options =\u0026gt; { // set path to store keys options.KeyManagement.KeyPath = \u0026#34;/home/shared/keys\u0026#34;; }); Encryption of Keys at Rest The keys created by Automatic Key Management are sensitive cryptographic secrets that should be encrypted at rest. By default, keys managed by Automatic Key Management are protected at rest using ASP.NET Core Data Protection. This is controlled with the DataProtectKeys flag, which is on by default. We recommend leaving this flag on unless you are using a custom ISigningKeyStore to store your keys in a secure location that will ensure keys are encrypted at rest. For example, if you implement the ISigningKeyStore to store your keys in Azure Key Vault, you could safely disabled DataProtectKeys, relying on Azure Key Vault to encrypt your signing keys at rest.\nSee the deployment section for more information about setting up data protection.\nManage multiple keys By default, Automatic Key Management will maintain a signing credential and validation keys for a single cryptographic algorithm (RS256). You can specify multiple keys, algorithms, and if those keys should additionally get wrapped in an X.509 certificate. Automatic key management will create and rotate keys for each signing algorithm you specify.\nX.509 certificates have an expiration date, but IdentityServer does not use this data to validate the certificate and throw an exception. If a certificate has expired then you must decide whether to continue using it or replace it with a new certificate.\noptions.KeyManagement.SigningAlgorithms = new[] { // RS256 for older clients (with additional X.509 wrapping) new SigningAlgorithmOptions(SecurityAlgorithms.RsaSha256) { UseX509Certificate = true }, // PS256 new SigningAlgorithmOptions(SecurityAlgorithms.RsaSsaPssSha256), // ES256 new SigningAlgorithmOptions(SecurityAlgorithms.EcdsaSha256) }; When you register multiple signing algorithms, the first in the list will be the default used for signing tokens. Client and API resource definitions both have an AllowedTokenSigningAlgorithm property to override the default on a per resource and client basis.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/fundamentals/keys/static_key_management/",
    "title": "Manual Key Management",
    "tags": [],
    "description": "",
    "content": "Instead of using Automatic Key Management, IdentityServer\u0026rsquo;s signing keys can be set manually. Automatic Key Management is generally recommended, but if you want to explicitly control your keys statically, or you have a license that does not include the feature (e.g. the Starter Edition), you will need to manually manage your keys. With static configuration you are responsible for secure storage, loading and rotation of keys.\nDisabling Key Management The automatic key management feature can be disabled by setting the Enabled flag to false on the the KeyManagement property of IdentityServerOptions:\nvar idsvrBuilder = builder.Services.AddIdentityServer(options =\u0026gt; { options.KeyManagement.Enabled = false; }); Key Creation Without automatic key management, you are responsible for creating your own cryptographic keys. Such keys can be created with many tools. Some options include:\nUse the PowerShell commandlet New-SelfSignedCertificate to self-sign your own certificate Create certificates using Azure KeyVault Create certificates using your Public Key Infrastructure. Create certificates using C# (see bellow) var name = \u0026#34;MySelfSignedCertificate\u0026#34;; // Generate a new key pair using var rsa = RSA.Create(keySizeInBits: 2048); // Create a certificate request var request = new CertificateRequest( subjectName: $\u0026#34;CN={name}\u0026#34;, rsa, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1 ); // Self-sign the certificate var certificate = request.CreateSelfSigned( DateTimeOffset.Now, DateTimeOffset.Now.AddYears(1) ); // Export the certificate to a PFX file var pfxBytes = certificate.Export( // TODO: pick a format X509ContentType.Pfx, // TODO: change the password password: \u0026#34;password\u0026#34; ); File.WriteAllBytes($\u0026#34;{name}.pfx\u0026#34;, pfxBytes); Console.Write(certificate); Console.WriteLine(\u0026#34;Self-signed certificate created successfully.\u0026#34;); Console.WriteLine($\u0026#34;Certificate saved to {name}.pfx\u0026#34;); Adding Keys Signing keys are added with the AddSigningCredential configuration method:\nvar idsvrBuilder = builder.Services.AddIdentityServer(); var key = LoadKeyFromVault(); // (Your code here) idsvrBuilder.AddSigningCredential(key, SecurityAlgorithms.RsaSha256); You can call AddSigningCredential multiple times if you want to register more than one signing key. When you register multiple signing algorithms, the first one added will be the default used for signing tokens. Client and API resource definitions both have an AllowedTokenSigningAlgorithm property to override the default on a per resource and client basis.\nAnother configuration method called AddValidationKey can be called to register public keys that should be accepted for token validation.\nKey Storage With automatic key management disabled, secure storage of the key material is left to you. This key material should be treated as highly sensitive. Key material should be encrypted at rest, and access to it should be restricted.\nLoading a key from disk into memory can be done using the X509CertificateLoader found in .NET assuming your hosting environment has proper security practices in place.\n// load certificate from disk var bytes = File.ReadAllBytes(\u0026#34;mycertificate.pfx\u0026#34;); var importedCertificate = X509CertificateLoader.LoadPkcs12(bytes, \u0026#34;password\u0026#34;); You may also choose to load a certificate from the current environment\u0026rsquo;s key store using the X509Store class.\n// Pick the appropriate StoreName and StoreLocation var store = new X509Store(StoreName.My, StoreLocation.CurrentUser); store.Open(OpenFlags.ReadWrite); var certificate = store .Certificates .First(c =\u0026gt; c.Thumbprint == \u0026#34;\u0026lt;thumbprint\u0026gt;\u0026#34;); If you\u0026rsquo;re generating self-signed certificates using C#, you can use the X509Store to store the certificate into the current hosting environment as well.\n// Pick the appropriate StoreName and StoreLocation var store = new X509Store(StoreName.My, StoreLocation.CurrentUser); store.Open(OpenFlags.ReadWrite); // push certificate into store var certificate = CreateCertificate(); store.Add(certificate); Manual Key Rotation With automatic key management disabled, you will need to rotate your keys manually. The rotation process must be done carefully for two reasons:\nClient applications and APIs cache key material. If you begin using a new key too quickly, new tokens will be signed with a key that is not yet in their caches. This will cause clients to not be able to validate the signatures of new id tokens which will prevent users from logging in, and APIs will not be able to validate signatures of access tokens, which will prevent authorization of calls to those APIs. Tokens signed with the old key material probably exist. If you tell APIs to stop using the old key too quickly, APIs will reject the signatures of old tokens, again causing authorization failures at your APIs. There are two solutions to these problems. Which one is right for you depends on the level of control you have over client applications, the amount of downtime that is acceptable, and the degree to which invalidating old tokens matters to you.\nSolution 1: Invalidate all caches when keys are rotated One solution to these problems is to invalidate the caches in all the client applications and APIs immediately after the key is rotated. In ASP.NET, the simplest way to do so is to restart the hosting process, which clears the cached signing keys of the authentication middleware.\nThis is only appropriate if all of the following are true:\nYou have control over the deployment of all of the client applications. You can tolerate a maintenance window in which your services are all restarted. You don\u0026rsquo;t mind that users will need to log in again after the key is rotated. Solution 2: Phased Rotation A more robust solution is to gradually transition from the old to the new key. This requires three phases.\nPhase 1: Announce the new key First, announce a new key that will be used for signing in the future. During this phase, continue to sign tokens with the old key. The idea is to allow for all the applications and APIs to update their caches without any interruption in service. Configure IdentityServer for phase 1 by registering the new key as a validation key.\nvar idsvrBuilder = builder.Services.AddIdentityServer(options =\u0026gt; { options.KeyManagement.Enabled = false; }); var oldKey = LoadOldKeyFromVault(); var newKey = LoadNewKeyFromVault(); idsvrBuilder.AddSigningCredential(oldKey, SecurityAlgorithms.RsaSha256); idsvrBuilder.AddValidationKey(newKey, SecurityAlgorithms.RsaSha256) Once IdentityServer is updated with the new key as a validation key, wait to proceed to phase 2 until all the applications and services have updated their signing key caches. The default cache duration in .NET is 24 hours, but this is customizable. You may also need to support clients or APIs built with other platforms or that were customized to use a different value. Ultimately you have to decide how long to wait to proceed to phase 2 in order to ensure that all clients and APIs have updated their caches.\nPhase 2: Start signing with the new key Next, start signing tokens with the new key, but continue to publish the public key of the old key so that tokens that were signed with that key can continue to be validated. The IdentityServer configuration change needed is simply to swap the signing credential and validation key.\nvar idsvrBuilder = builder.Services.AddIdentityServer(options =\u0026gt; { options.KeyManagement.Enabled = false; }); var oldKey = LoadOldKeyFromVault(); var newKey = LoadNewKeyFromVault(); idsvrBuilder.AddSigningCredential(newKey, SecurityAlgorithms.RsaSha256); idsvrBuilder.AddValidationKey(oldKey, SecurityAlgorithms.RsaSha256) Again, you need to wait to proceed to phase 3. The delay here is typically shorter, because the reason for the delay is to ensure that tokens signed with the old key remain valid until they expire. IdentityServer\u0026rsquo;s token lifetime defaults to 1 hour, though it is configurable.\nPhase 3: Remove the old key Once enough time has passed that there are no unexpired tokens signed with the old key, it is safe to completely remove the old key.\nvar idsvrBuilder = builder.Services.AddIdentityServer(options =\u0026gt; { options.KeyManagement.Enabled = false; }); var newKey = LoadNewKeyFromVault(); idsvrBuilder.AddSigningCredential(newKey, SecurityAlgorithms.RsaSha256); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/fundamentals/keys/migration/",
    "title": "Migrating from Static Keys to Automatic Key Management",
    "tags": [],
    "description": "",
    "content": "To migrate from static to automatic key management, you can set keys manually and enable automatic key management at the same time. This allows the automatic key management feature to begin creating keys and announce them in discovery, while you continue to use the old statically configured key. Eventually you can transition from the statically configured key to the automatically managed keys.\nA signing key registered with AddSigningCredential will take precedence over any keys created by the automatic key management feature. IdentityServer will sign tokens with the credential specified in AddSigningCredential, but also automatically create and manage validation keys.\nValidation keys registered manually with AddValidationKey are added to the collection of validation keys along with the keys produced by automatic key management. When automatic key management is enabled and there are keys statically specified with AddValidationkey, the set of validation keys will include:\nnew keys created by automatic key management that are not yet used for signing old keys created by automatic key management that are retired the keys added explicitly with calls to AddValidationKey. The migration path from manual to automatic keys is a three phase process, similar to the phased approach to manual key rotation. The difference here is that you are phasing out the old key and allowing the automatically generated keys to phase in.\nPhase 1: Announce new (automatic) key First, enable automatic key management while continuing to register your old key as the signing credential. In this phase, the new automatically managed key will be announced so that as client apps and APIs update their caches, they get the new key. IdentityServer will continue to sign keys with your old static key.\nvar idsvrBuilder = builder.Services.AddIdentityServer(options =\u0026gt; { options.KeyManagement.Enabled = true; }); var oldKey = LoadOldKeyFromVault(); idsvrBuilder.AddSigningCredential(oldKey, SecurityAlgorithms.RsaSha256); Wait until all APIs and applications have updated their signing key caches, and then proceed to phase 2.\nPhase 2: Start signing with the new (automatic) key Next, switch to using the new automatically managed keys for signing, but still keep the old key for validation purposes.\nvar idsvrBuilder = builder.Services.AddIdentityServer(options =\u0026gt; { options.KeyManagement.Enabled = true; }); var oldKey = LoadOldKeyFromVault(); idsvrBuilder.AddValidationKey(oldKey, SecurityAlgorithms.RsaSha256); Keep the old key as a validation key until all tokens signed with that key are expired, and then proceed to phase 3.\nPhase 3: Drop the old key Now the static key configuration can be removed entirely.\nvar idsvrBuilder = builder.Services.AddIdentityServer(options =\u0026gt; { options.KeyManagement.Enabled = true; }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/tokens/dynamic_validation/",
    "title": "Dynamic Request Validation and Customization",
    "tags": [],
    "description": "",
    "content": "You can hook into the token request pipeline by implementing the ICustomTokenRequestValidator interface.\nThis allows you to\nadd additional token request validation logic do custom per-client processing add custom response parameters return custom errors and error descriptions modify parameters on-the-fly access token lifetime and type client claims confirmation method The following example emits additional claims and changes the token lifetime on-the-fly based on a granted scope.\npublic class TransactionScopeTokenRequestValidator : ICustomTokenRequestValidator { public Task ValidateAsync(CustomTokenRequestValidationContext context) { var transaction = context .Result .ValidatedRequest .ValidatedResources .ParsedScopes.FirstOrDefault(x =\u0026gt; x.ParsedName == \u0026#34;transaction\u0026#34;); // transaction scope has been requested if (transaction?.ParsedParameter != null) { // emit transaction id as a claim context.Result.ValidatedRequest.ClientClaims.Add( new Claim(transaction.ParsedName, transaction.ParsedParameter)); // also shorten token lifetime context.Result.ValidatedRequest.AccessTokenLifetime = 10; } return Task.CompletedTask; } } You can register your implementation like this:\nidsvrBuilder.AddCustomTokenRequestValidator\u0026lt;TransactionScopeTokenRequestValidator\u0026gt;(); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/fundamentals/keys/",
    "title": "Key Management",
    "tags": [],
    "description": "",
    "content": "Duende IdentityServer issues several types of tokens that are cryptographically signed, including identity tokens, JWT access tokens, and logout tokens. To create those signatures, IdentityServer needs key material. That key material can be configured automatically, by using the Automatic Key Management feature, or manually, by loading the keys from a secured location with static configuration.\nIdentityServer supports signing tokens using the RS, PS and ES family of cryptographic signing algorithms.\nAutomatic Key Management Manual Key Management Migrating from Static Keys to Automatic Key Management "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/services/",
    "title": "Services",
    "tags": [],
    "description": "",
    "content": "Services Profile Service Persisted Grant Service Refresh Token Service Token Creation Service User Session Service Session Management Service IdentityServer Interaction Service Device Flow Interaction Service Backchannel Authentication Interaction Service Backchannel Authentication User Notification Service "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/overview/support/",
    "title": "Support and Issues",
    "tags": [],
    "description": "",
    "content": "Source Code You can find all source code for IdentityServer and its supporting repos in our organization.\nIssue Tracker The IdentityServer issue tracker and pull requests allow you to follow the current work. Join our developer community forum to ask questions and discuss potential bugs.\nMilestones / release notes\nSupport See here for our support policy.\nStandard support and feature requests are handled via our public developer community forum. Please start a discussion there if you need help.\nPriority support is part of our Enterprise Edition. It includes a private email alias, guaranteed two US business days response time.\nReporting a security vulnerability Security issues and bugs should be reported privately here. You should receive a response within two business days.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/tokens/",
    "title": "Requesting Tokens",
    "tags": [],
    "description": "index",
    "content": "Requesting Tokens At its very heart, Duende IdentityServer is a so-called Security Token Service (STS).\nOverview Requesting a Token Refreshing a Token Issuing Tokens based on User Passwords Extension Grants Dynamic Request Validation and Customization Issuing Internal Tokens Proof-of-Possession Access Tokens Reference Tokens Client Authentication Signed Authorize Requests Pushed Authorization Requests Calling Endpoints from JavaScript "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/ui/login/local/",
    "title": "Accepting Local Credentials",
    "tags": [],
    "description": "",
    "content": "The steps for implementing a local login page are:\nValidate the user\u0026rsquo;s credentials Issue the authentication cookie Redirect the user to the return URL The code below shows a sample Razor Page that could act as a login page. This sample hard codes the logic for the credentials. In production code, use your custom user database or identity management library here.\nIf you are using ASP.NET Identity for user management, our Identity Server ASP.NET Identity (isaspid) template includes a login page that shows how you might use the abstractions of that library on your login page. Notably, it uses the SignInManager to start the session, rather than HttpContext.SignInAsync.\nThis is the cshtml for the login Razor Page:\n@page @model Sample.Pages.Account.LoginModel @addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers \u0026lt;div asp-validation-summary=\u0026#34;All\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;form method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; asp-for=\u0026#34;ReturnUrl\u0026#34; /\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label asp-for=\u0026#34;Username\u0026#34;\u0026gt;Username\u0026lt;/label\u0026gt; \u0026lt;input asp-for=\u0026#34;Username\u0026#34; autofocus\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label asp-for=\u0026#34;Password\u0026#34;\u0026gt;Password\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; asp-for=\u0026#34;Password\u0026#34; autocomplete=\u0026#34;off\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Login\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; And this is the code behind for the login Razor Page:\nnamespace Sample.Pages.Account { public class LoginModel : PageModel { [BindProperty(SupportsGet = true)] public string ReturnUrl { get; set; } [BindProperty] public string Username { get; set; } [BindProperty] public string Password { get; set; } public async Task\u0026lt;IActionResult\u0026gt; OnPost() { if (Username == \u0026#34;alice\u0026#34; \u0026amp;\u0026amp; Password == \u0026#34;password\u0026#34;) { var claims = new Claim[] { new Claim(\u0026#34;sub\u0026#34;, \u0026#34;unique_id_for_alice\u0026#34;) }; var identity = new ClaimsIdentity(claims, \u0026#34;pwd\u0026#34;); var user = new ClaimsPrincipal(identity); await HttpContext.SignInAsync(user); if (Url.IsLocalUrl(ReturnUrl)) { return Redirect(ReturnUrl); } } ModelState.AddModelError(\u0026#34;\u0026#34;, \u0026#34;Invalid username or password\u0026#34;); return Page(); } } } When IdentityServer redirects to the LoginUrl, the user should arrive at this page. If you\u0026rsquo;re using the default urls, then this page should be created at the path: ~/Pages/Account/Login.cshtml, which allows it to be loaded from the browser at the \u0026ldquo;/Account/Login\u0026rdquo; path.\nWhile you can use any custom user database or identity management library for your users, we provide first class integration support for ASP.NET Identity.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/ui/logout/notification/",
    "title": "Client Notifications",
    "tags": [],
    "description": "",
    "content": "Notifying clients that the user has signed-out As part of the logout process you will want to ensure client applications are informed that the user has signed out.\nThis is done by sending a notification to an endpoint provided by the each client application. Depending on your architecture, there are three supported techniques to call these endpoints:\nfront-channel notifications via the browser back-channel notifications via server-side call a PostMessage-based notification for JavaScript clients Regardless which technique you are using, Duende IdentityServer keeps track of the client applications involved with the current user session and provides helpers and automated ways of invoking the notification mechanisms.\nBoth the front-channel and JS-based notifications make use of cookies in iframes. If your architecture spans multiple sites, this will not work reliably. We recommend using back-channel notifications in this case. See the supported specifications page for links to the relevant documents.\nFront-channel server-side clients To sign the user out of the server-side client applications via the front-channel spec, the \u0026ldquo;logged out\u0026rdquo; page in IdentityServer must render an \u0026lt;iframe\u0026gt; for each client that points to the corresponding notification endpoint at the client.\nClients that wish to be notified must have the FrontChannelLogoutUri configuration value set. IdentityServer tracks which clients the user has signed into, and provides an API called GetLogoutContextAsync on the IIdentityServerInteractionService. This API returns a LogoutRequest object with a SignOutIFrameUrl property that your logged out page must render into an \u0026lt;iframe\u0026gt;.\nSee the Quickstart UI Logout page for an example.\nBack-channel server-side clients To sign the user out of the server-side client applications via the back-channel the IBackChannelLogoutService service can be used. IdentityServer will automatically use this service when your logout page removes the user\u0026rsquo;s authentication cookie via a call to HttpContext.SignOutAsync.\nClients that wish to be notified must have the BackChannelLogoutUri configuration value set.\nImplementing Back-channel Logout in .NET Applications .NET does not have native support for back-channel logout notification. We do provide a sample, though. Alternatively, if you are using our BFF framework, back-channel logout is already implemented for you.\nBack-channel logout notifications are logout tokens as specified by OpenID Connect Back-Channel Logout 1.0. Beginning in v6.3, IdentityServer sets the typ header of the logout token to logout+jwt to comply with the final version of the specification. The LogoutTokenJwtType option can override this behavior.\nBrowser-based JavaScript clients There is nothing special you need to do to notify these clients that the user has signed out.\nThe clients, though, must perform monitoring on the check_session_iframe, and this is implemented by spec compliant client libraries, e.g. the oidc-client JavaScript library.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/ui/custom/",
    "title": "Custom Pages",
    "tags": [],
    "description": "",
    "content": "In addition to the pages your IdentityServer is expected to provide, you can add any other pages you wish. These could be pages needed during login (e.g. registration, password reset), self-service pages to allow the user to manage their profile (e.g. change password, change email), or even more specialized pages for various user workflows (e.g. password expired, or EULA).\nThese custom pages can be made available to the end user as links from the standard pages in your IdentityServer (i.e. login, consent), they can be rendered to the user during login page workflows, or they could be displayed as a result of requests into the authorize endpoint.\nAuthorize Endpoint Requests and Custom Pages As requests are made into the authorize endpoint, if a user already has an established authentication session then they will not be presented with a login page at your IdentityServer (as that is the normal expectation for single sign-on).\nDuende IdentityServer provides the authorize interaction response generator extensibility point to allow overriding or controlling the response from the authorize endpoint.\nBuilt-in AuthorizeInteractionResponseGenerator To provide custom logic for the authorize endpoint, the recommendation is to derive from the built-in AuthorizeInteractionResponseGenerator to inherit all the default logic pertaining to login and consent semantics. To augment the built-in logic, override ProcessLoginAsync and/or ProcessConsentAsync (depending on the nature of the custom logic). The pattern would be to invoke the base implementation and if the result did not cause a login, consent or error, then the custom logic could be tested to determine if it is desired to prevent SSO and instead force the user to interact in some way (e.g. re-login, trigger MFA, accept a EULA, etc). The sample below illustrates:\npublic class CustomAuthorizeInteractionResponseGenerator : AuthorizeInteractionResponseGenerator { public CustomAuthorizeInteractionResponseGenerator(IdentityServerOptions options, ISystemClock clock, ILogger\u0026lt;AuthorizeInteractionResponseGenerator\u0026gt; logger, IConsentService consent, IProfileService profile) : base(options, clock, logger, consent, profile) { } protected override async Task\u0026lt;InteractionResponse\u0026gt; ProcessLoginAsync(ValidatedAuthorizeRequest request) { var result = await base.ProcessLoginAsync(request); if (!result.IsLogin \u0026amp;\u0026amp; !result.IsError) { // check EULA database var mustShowEulaPage = !HasUserAcceptedEula(request.Subject); if (mustShowEulaPage) { result = new InteractionResponse { RedirectUrl = \u0026#34;/eula/accept\u0026#34; }; } } return result; } } Custom Redirects When using custom redirect pages by setting the RedirectUrl on the InteractionResponse, IdentityServer will provide a returnUrl query parameter with the request (much like on the login page). Once the custom logic is complete on the page, then the URL in the returnUrl query parameter should be used to return the user back into the IdentityServer authorize request workflow.\nBeware open-redirect attacks via the returnUrl parameter. You should validate that the returnUrl refers to a well-known location. Either use the Url.IsLocalUrl helper from ASP.NET Core, or use the interaction service from Duende IdentityServer for APIs to validate the returnUrl parameter.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/configuration/dcr/customization/",
    "title": "Customization",
    "tags": [],
    "description": "",
    "content": "The behavior of the Configuration API can be customized through the use of several extension points that control the steps that occur when a dynamic client registration request arrives.\nFirst, the incoming request is validated to ensure that it is syntactically valid and semantically correct. The result of the validation process is a model which will either contain error details or a validated Client model.\nWhen validation succeeds, the validated request is passed on to the request processor. The request processor is responsible for generating properties of the Client that are not specified in the request. For example, the client_id is not normally specified in the request and is instead generated by the processor.\nWhen the processor is finished generating values, it passes the final client object to the store and returns an IDynamicClientRegistrationResponse indicating success or failure. This response object is finally used by the response generator to generate an HTTP response.\nEach of the validation and processing steps might also encounter an error. When that occurs, errors are conveyed using the DynamicClientRegistrationError class.\nValidation To customize the validation process, you can either implement the IDynamicClientRegistrationValidator interface or extend from the default implementation of that interface, the DynamicClientRegistrationValidator. The default implementation includes many virtual methods, allowing you to use most of the base functionality and add your customization in a targeted manner.\nEach virtual method is responsible for validating a small number of parameters in the request and setting corresponding values on the client. The steps are passed a context object containing the client object that is being built up, the original request, the claims principal that made the request, and a dictionary of additional items that can be used to pass state between customized steps. Each step should update the client in the context and return an IStepResult to indicate success or failure.\nFor more details, see the reference section on validation\nProcessing In a similar way, the request processor can be customized by implementing an IDynamicClientRegistrationRequestProcessor or by extending from the default DynamicClientRegistrationRequestProcessor. Again, the default request processor contains virtual methods that allow you to override a part of its functionality.\nFor more details, see the reference section on request processing\nResponse Generation Finally, to customize the HTTP responses of the Configuration API, you can implement the IDynamicClientRegistrationResponseGenerator or extend from the default DynamicClientRegistrationResponseGenerator.\nFor more details, see the reference section on response generation\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/samples/diagnostics/",
    "title": "Diagnostics",
    "tags": [],
    "description": "Samples",
    "content": "OpenTelemetry with Aspire link to source code\nIdentityServer emits OpenTelemetry metrics, traces and logs (see here for more information). This sample uses .NET Aspire to display OpenTelemetry data. The solution contains an IdentityServer host, an API and a web client. The access token lifetime is set to a very small value to force frequent refresh token flows.\nRunning the sample requires the dotnet aspire workload to be installed with dotnet workload install aspire. Run the Aspire.AppHost project, it will automatically launch the other projects.\nThis sample is not intended to be a full Aspire sample, it simply uses Aspire as a local standalone tool for displaying traces, logs and metrics.\nOpenTelemetry tracing link to source code\nIdentityServer emits OpenTelemetry traces for input validators, stores and response generators (see here for more information).\nThe sample shows how to setup Otel for console tracing.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/upgrades/v6.1_to_v6.2/",
    "title": "Duende IdentityServer v6.1 to v6.2",
    "tags": [],
    "description": "",
    "content": "This upgrade guide covers upgrading from Duende IdentityServer v6.1 to v6.2 (release notes).\nWhat\u0026rsquo;s New Duende IdentityServer 6.2 adds:\nSupport for .NET 7.0 A new option that can help filter unhandled exceptions out of the logs Bug fixes and ongoing maintenance There are no changes to the data stores in this release.\nStep 1: Update NuGet package In your IdentityServer host project, update the version of the NuGet. For example in your project file:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;6.1.0\u0026#34; /\u0026gt; would change to:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;6.2.0\u0026#34; /\u0026gt; Step 2: Verify Data Protection Configuration IdentityServer depends on ASP.NET Data Protection. Data Protection encrypts and signs data using keys managed by ASP.NET. Those keys are isolated by application name, which by default is set to the content root path of the host. This prevents multiple applications from sharing encryption keys, which is necessary to protect your encryption against certain forms of attack. However, this means that if your content root path changes, the default settings for data protection will prevent you from using your old keys. Beginning in .NET 6, the content root path was normalized so that it ends with a directory separator. In .NET 7 that change was reverted. This means that your content root path might change if you upgrade from .NET 6 to .NET 7. This can be mitigated by explicitly setting the application name and removing the separator character. See Microsoft\u0026rsquo;s documentation for more information.\nStep 3: Done! That\u0026rsquo;s it. Of course, at this point you can and should test that your IdentityServer is updated and working properly.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/data/ef/",
    "title": "Entity Framework Integration",
    "tags": [],
    "description": "",
    "content": "An EntityFramework-based implementation is provided for the configuration and operational data extensibility points in IdentityServer. The use of EntityFramework allows any EF-supported database to be used with this library.\nThe features provided by this library are broken down into two main areas: configuration store and operational store support. These two different areas can be used independently or together, based upon the needs of the hosting application.\nTo use this library, ensure that you have the NuGet package for the EntityFramework integration. It is called Duende.IdentityServer.EntityFramework. You can install it with:\ndotnet add package Duende.IdentityServer.EntityFramework Configuration Store Support For storing configuration data, then the configuration store can be used. This support provides implementations of the IClientStore, IResourceStore, IIdentityProviderStore, and the ICorsPolicyService extensibility points. These implementations use a DbContext-derived class called ConfigurationDbContext to model the tables in the database.\nTo use the configuration store support, in Program.cs use the AddConfigurationStore extension method after the call to AddIdentityServer:\nconst string connectionString = @\u0026#34;Data Source=(LocalDb)\\MSSQLLocalDB;database=YourIdentityServerDatabase;trusted_connection=yes;\u0026#34;; var migrationsAssembly = typeof(Program).GetTypeInfo().Assembly.GetName().Name; builder.Services.AddIdentityServer() // this adds the config data from DB (clients, resources, CORS) .AddConfigurationStore(options =\u0026gt; { options.ConfigureDbContext = builder =\u0026gt; builder.UseSqlServer(connectionString, sql =\u0026gt; sql.MigrationsAssembly(migrationsAssembly)); }); To configure the configuration store, use the ConfigurationStoreOptions options object passed to the configuration callback.\nConfigurationStoreOptions This options class contains properties to control the configuration store and ConfigurationDbContext.\nConfigureDbContext Delegate of type Action used as a callback to configure the underlying ConfigurationDbContext. The delegate can configure the ConfigurationDbContext in the same way if EF were being used directly with AddDbContext, which allows any EF-supported database to be used.\nDefaultSchema Allows setting the default database schema name for all the tables in the ConfigurationDbContext\noptions.DefaultSchema = \u0026#34;myConfigurationSchema\u0026#34;; If you need to change the schema for the Migration History Table, you can chain another action to the UseSqlServer:\noptions.ConfigureDbContext = b =\u0026gt; b.UseSqlServer(connectionString, sql =\u0026gt; sql.MigrationsAssembly(migrationsAssembly).MigrationsHistoryTable(\u0026#34;MyConfigurationMigrationTable\u0026#34;, \u0026#34;myConfigurationSchema\u0026#34;)); Enabling Caching for Configuration Store To enable caching for the EF configuration store implementation, use the AddConfigurationStoreCache extension method:\nbuilder.Services.AddIdentityServer() .AddConfigurationStore(options =\u0026gt; { ... }) // this is something you will want in production to reduce load on and requests to the DB .AddConfigurationStoreCache(); Operational Store For storing operational data then the operational store can be used. This support provides implementations of the IPersistedGrantStore, IDeviceFlowStore, IServerSideSessionStore, and ISigningKeyStore extensibility points. The implementation uses a DbContext-derived class called PersistedGrantDbContext to model the table in the database.\nTo use the operational store support, in Program.cs use the AddOperationalStore extension method after the call to AddIdentityServer:\nconst string connectionString = @\u0026#34;Data Source=(LocalDb)\\MSSQLLocalDB;database=YourIdentityServerDatabase;trusted_connection=yes;\u0026#34;; var migrationsAssembly = typeof(Program).GetTypeInfo().Assembly.GetName().Name; builder.Services.AddIdentityServer() // this adds the operational data from DB (codes, tokens, consents) .AddOperationalStore(options =\u0026gt; { options.ConfigureDbContext = builder =\u0026gt; builder.UseSqlServer(connectionString, sql =\u0026gt; sql.MigrationsAssembly(migrationsAssembly)); // this enables automatic token cleanup. this is optional. options.EnableTokenCleanup = true; options.TokenCleanupInterval = 3600; // interval in seconds (default is 3600) }); To configure the operational store, use the OperationalStoreOptions options object passed to the configuration callback.\nOperationalStoreOptions This options class contains properties to control the operational store and PersistedGrantDbContext.\nConfigureDbContext Delegate of type Action used as a callback to configure the underlying PersistedGrantDbContext. The delegate can configure the PersistedGrantDbContext in the same way if EF were being used directly with AddDbContext, which allows any EF-supported database to be used.\nDefaultSchema Allows setting the default database schema name for all the tables in the PersistedGrantDbContext.\nEnableTokenCleanup Indicates whether expired grants and pushed authorization requests will be automatically cleaned up from the database. The default is false.\nRemoveConsumedTokens [added in 5.1] Indicates whether consumed grants will be automatically cleaned up from the database. The default is false.\nTokenCleanupInterval The token cleanup interval (in seconds). The default is 3600 (1 hour).\nConsumedTokenCleanupDelay [added in 6.3] The consumed token cleanup delay (in seconds). The default is 0. This delay is the amount of time that must elapse before tokens marked as consumed can be deleted. Note that only refresh tokens with OneTime usage can be marked as consumed.\nFuzzTokenCleanupStart [added in 7.0] The background token cleanup job runs at a configured interval. If multiple nodes run the cleanup job at the same time, update conflicts might occur in the store. To reduce the probability of that happening, the startup time can be fuzzed. When enabled, the first run is scheduled at a random time between the host startup and the configured TokenCleanupInterval. Subsequent runs are run on the configured TokenCleanupInterval. Defaults to true.\nThe token cleanup feature does not remove persisted grants that are consumed (see persisted grants). It only removes persisted grants that are beyond their Expiration.\nDatabase creation and schema changes across different versions of IdentityServer It is very likely that across different versions of IdentityServer (and the EF support) that the database schema will change to accommodate new and changing features.\nWe do not provide any support for creating your database or migrating your data from one version to another. You are expected to manage the database creation, schema changes, and data migration in any way your organization sees fit.\nUsing EF migrations is one possible approach to this. If you do wish to use migrations, then see the EF quickstart for samples on how to get started, or consult the Microsoft documentation on EF migrations.\nWe publish a sample app that we use internally for creating databases to test the latest database schema (this is SQL Server specific).\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/deployment/health_checks/",
    "title": "Health Checks",
    "tags": [],
    "description": "",
    "content": "You can use ASP.NET\u0026rsquo;s health checks to monitor the health of your IdentityServer deployment. Health checks can contain arbitrary logic to test various conditions of a system. One common strategy for checking the health of IdentityServer is to make discovery requests. Successful discovery responses indicate not just that the IdentityServer host is running and able to receive requests and generate responses, but also that it was able to communicate with the configuration store.\nThe following example code creates a health check that makes requests to the discovery endpoint. It finds the discovery endpoint\u0026rsquo;s handler by name, which requires IdentityServer v6.3.\npublic class DiscoveryHealthCheck : IHealthCheck { private readonly IEnumerable\u0026lt;Hosting.Endpoint\u0026gt; _endpoints; private readonly IHttpContextAccessor _httpContextAccessor; public DiscoveryHealthCheck(IEnumerable\u0026lt;Hosting.Endpoint\u0026gt; endpoints, IHttpContextAccessor httpContextAccessor) { _endpoints = endpoints; _httpContextAccessor = httpContextAccessor; } public async Task\u0026lt;HealthCheckResult\u0026gt; CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default) { try { var endpoint = _endpoints.FirstOrDefault(x =\u0026gt; x.Name == IdentityServerConstants.EndpointNames.Discovery); if (endpoint != null) { var handler = _httpContextAccessor.HttpContext.RequestServices.GetRequiredService(endpoint.Handler) as IEndpointHandler; if (handler != null) { var result = await handler.ProcessAsync(_httpContextAccessor.HttpContext); if (result is DiscoveryDocumentResult) { return HealthCheckResult.Healthy(); } } } } catch { } return new HealthCheckResult(context.Registration.FailureStatus); } } Another health check that you can perform is to request the public keys that IdentityServer uses to sign tokens - the JWKS (JSON Web Key Set). Doing so demonstrates that IdentityServer is able to communicate with the signing key store, a critical dependency. The following example code creates such a health check. Just as with the previous health check, it finds the endpoint\u0026rsquo;s handler by name, which requires IdentityServer v6.3.\npublic class DiscoveryKeysHealthCheck : IHealthCheck { private readonly IEnumerable\u0026lt;Hosting.Endpoint\u0026gt; _endpoints; private readonly IHttpContextAccessor _httpContextAccessor; public DiscoveryKeysHealthCheck(IEnumerable\u0026lt;Hosting.Endpoint\u0026gt; endpoints, IHttpContextAccessor httpContextAccessor) { _endpoints = endpoints; _httpContextAccessor = httpContextAccessor; } public async Task\u0026lt;HealthCheckResult\u0026gt; CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default) { try { var endpoint = _endpoints.FirstOrDefault(x =\u0026gt; x.Name == IdentityServerConstants.EndpointNames.Jwks); if (endpoint != null) { var handler = _httpContextAccessor.HttpContext.RequestServices.GetRequiredService(endpoint.Handler) as IEndpointHandler; if (handler != null) { var result = await handler.ProcessAsync(_httpContextAccessor.HttpContext); if (result is JsonWebKeysResult) { return HealthCheckResult.Healthy(); } } } } catch { } return new HealthCheckResult(context.Registration.FailureStatus); } } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/configuration/dcr/reference/models/",
    "title": "Models",
    "tags": [],
    "description": "DCR Reference",
    "content": "DynamicClientRegistrationRequest Represents a dynamic client registration request. The parameters that are supported include a subset of the parameters defined by IANA, and custom properties needed by IdentityServer.\npublic class DynamicClientRegistrationRequest Public Members name description AbsoluteRefreshTokenLifetime { get; set; } The absolute lifetime of refresh tokens, in seconds. This property is an extension to the Dynamic Client Registration Protocol. AccessTokenLifetime { get; set; } The lifetime of access tokens, in seconds. This property is an extension to the Dynamic Client Registration Protocol. AccessTokenType { get; set; } The type of access tokens that this client will create. Either \u0026ldquo;Jwt\u0026rdquo; or \u0026ldquo;Reference\u0026rdquo;. This property is an extension to the Dynamic Client Registration Protocol. AllowedCorsOrigins { get; set; } List of allowed CORS origins for JavaScript clients. This property is an extension to the Dynamic Client Registration Protocol. AllowedIdentityTokenSigningAlgorithms { get; set; } List of signing algorithms to use when signing identity tokens. If not set, will use the server default signing algorithm. This property is an extension to the Dynamic Client Registration Protocol. AllowRememberConsent { get; set; } Boolean value specifying whether a user\u0026rsquo;s consent can be remembered in flows initiated by this client. This property is an extension to the Dynamic Client Registration Protocol. AuthorizationCodeLifetime { get; set; } The lifetime of authorization codes, in seconds. This property is an extension to the Dynamic Client Registration Protocol. BackChannelLogoutSessionRequired { get; set; } Boolean value specifying whether the RP requires that a sid (session ID) Claim be included in the Logout Token to identify the RP session with the OP when the backchannel_logout_uri is used. BackChannelLogoutUri { get; set; } RP URL that will cause the RP to log itself out when sent a Logout Token by the OP. ClientName { get; set; } Human-readable string name of the client to be presented to the end-user during authorization. ClientUri { get; set; } Web page providing information about the client. ConsentLifetime { get; set; } The lifetime of consent, in seconds. This property is an extension to the Dynamic Client Registration Protocol. CoordinateLifetimeWithUserSession { get; set; } When enabled, the client\u0026rsquo;s token lifetimes (e.g. refresh tokens) will be tied to the user\u0026rsquo;s session lifetime. This means when the user logs out, any revokable tokens will be removed. If using server-side sessions, expired sessions will also remove any revokable tokens, and backchannel logout will be triggered. This client\u0026rsquo;s setting overrides the global CoordinateTokensWithUserSession configuration setting. This property is an extension to the Dynamic Client Registration Protocol. DefaultMaxAge { get; set; } Default maximum authentication age. This is stored as the UserSsoLifetime property of the IdentityServer client model. EnableLocalLogin { get; set; } Boolean value specifying if local logins are enabled when this client uses interactive flows. This property is an extension to the Dynamic Client Registration Protocol. Extensions { get; set; } Custom client metadata fields to include in the serialization. FrontChannelLogoutSessionRequired { get; set; } Boolean value specifying whether the RP requires that a sid (session ID) query parameter be included to identify the RP session with the OP when the frontchannel_logout_uri is used. FrontChannelLogoutUri { get; set; } RP URL that will cause the RP to log itself out when rendered in an iframe by the OP. GrantTypes { get; set; } List of OAuth 2.0 grant type strings that the client can use at the token endpoint. Valid values are \u0026ldquo;authorization_code\u0026rdquo;, \u0026ldquo;client_credentials\u0026rdquo;, \u0026ldquo;refresh_token\u0026rdquo;. IdentityProviderRestrictions { get; set; } List of external IdPs that can be used with this client. If list is empty all IdPs are allowed. Defaults to empty. This property is an extension to the Dynamic Client Registration Protocol. IdentityTokenLifetime { get; set; } The lifetime of identity tokens, in seconds. This property is an extension to the Dynamic Client Registration Protocol. InitiateLoginUri { get; set; } URI using the https scheme that a third party can use to initiate a login by the relying party. Jwks { get; set; } JWK Set document which contains the client\u0026rsquo;s public keys. The JwksUri and Jwks parameters MUST NOT both be present in the same request or response. JwksUri { get; set; } URL to a JWK Set document which contains the client\u0026rsquo;s public keys. The JwksUri and Jwks parameters MUST NOT both be present in the same request or response. The default validator must be extended to make use of the JwksUri. The default implementation ignores this property. LogoUri { get; set; } Logo for the client. If present, the server should display this image to the end-user during approval. PostLogoutRedirectUris { get; set; } List of post-logout redirection URIs for use in the end session endpoint. RedirectUris { get; set; } List of redirection URI strings for use in redirect-based flows such as the authorization code flow. Clients using flows with redirection must register their redirection URI values. RefreshTokenExpiration { get; set; } The type of expiration for refresh tokens. Either \u0026ldquo;sliding\u0026rdquo; or \u0026ldquo;absolute\u0026rdquo;. This property is an extension to the Dynamic Client Registration Protocol. RefreshTokenUsage { get; set; } The usage type for refresh tokens. Either \u0026ldquo;OneTimeOnly\u0026rdquo; or \u0026ldquo;ReUse\u0026rdquo;. This property is an extension to the Dynamic Client Registration Protocol. RequireClientSecret { get; set; } Boolean value specifying if a client secret is needed to request tokens at the token endpoint. This property is an extension to the Dynamic Client Registration Protocol. RequireConsent { get; set; } Boolean value specifying whether consent is required in user-centric flows initiated by this client. This property is an extension to the Dynamic Client Registration Protocol. RequireSignedRequestObject { get; set; } Boolean value specifying whether authorization requests must be protected as signed request objects and provided through either the request or request_uri parameters. Scope { get; set; } String containing a space-separated list of scope values that the client can use when requesting access tokens. If omitted, the configuration API will register a client with the scopes set by the DynamicClientRegistrationValidator.SetDefaultScopes method, which defaults to no scopes. SlidingRefreshTokenLifetime { get; set; } The sliding lifetime of refresh tokens, in seconds. This property is an extension to the Dynamic Client Registration Protocol. SoftwareId { get; set; } A unique identifier string (e.g., a Universally Unique Identifier (UUID)) assigned by the client developer or software publisher used by registration endpoints to identify the client software to be dynamically registered. Unlike \u0026ldquo;client_id\u0026rdquo;, which is issued by the authorization server and SHOULD vary between instances, the \u0026ldquo;software_id\u0026rdquo; SHOULD remain the same for all instances of the client software. The \u0026ldquo;software_id\u0026rdquo; SHOULD remain the same across multiple updates or versions of the same piece of software. The value of this field is not intended to be human readable and is usually opaque to the client and authorization server. The default validator must be extended to make use of the SoftwareId. The default implementation ignores this property. SoftwareStatement { get; set; } A software statement containing client metadata values about the client software as claims. This is a string value containing the entire signed JWT. The default validator must be extended to make use of the software statement. The default implementation ignores this property. SoftwareVersion { get; set; } A version identifier string for the client software identified by \u0026ldquo;software_id\u0026rdquo;. The value of the \u0026ldquo;software_version\u0026rdquo; SHOULD change on any update to the client software identified by the same \u0026ldquo;software_id\u0026rdquo;. The value of this field is intended to be compared using string equality matching and no other comparison semantics are defined by this specification. The default validator must be extended to make use of the SoftwareVersion. The default implementation ignores this property. TokenEndpointAuthenticationMethod { get; set; } Requested Client Authentication method for the Token Endpoint. The supported options are client_secret_post, client_secret_basic, client_secret_jwt, private_key_jwt. UpdateAccessTokenClaimsOnRefresh { get; set; } Boolean value specifying whether access token claims are updated during token refresh. This property is an extension to the Dynamic Client Registration Protocol. Dynamic Client Registration Response Represents the response to a successful dynamic client registration request. This class extends the registration request by adding additional properties that are generated server side and not set by the client.\npublic class DynamicClientRegistrationResponse : DynamicClientRegistrationRequest, IDynamicClientRegistrationResponse Public Members name description ClientId { get; set; } Gets or sets the client ID. ClientSecret { get; set; } Gets or sets the client secret. ClientSecretExpiresAt { get; set; } Gets or sets the expiration time of the client secret. ResponseTypes { get; set; } List of the OAuth 2.0 response type strings that the client can use at the authorization endpoint. DynamicClientRegistrationContext Represents the context of a dynamic client registration request, including the original DCR request, the client model that is built up through validation and processing, the caller who made the DCR request, and other contextual information.\npublic class DynamicClientRegistrationContext Public Members name description Caller { get; set; } The ClaimsPrincipal that made the DCR request. Client { get; set; } The client model that is built up through validation and processing. Items { get; set; } A collection where additional contextual information may be stored. This is intended as a place to pass additional custom state between validation steps. Request { get; set; } The original dynamic client registration request. DynamicClientRegistrationError Represents an error that occurred during validation of a dynamic client registration request. This class implements the appropriate marker interfaces so that it can be returned from various points in the validator or processor.\npublic class DynamicClientRegistrationValidationError : IStepResult, IDynamicClientRegistrationResponse, IDynamicClientRegistrationValidationResult Public Members name description Error { get; set; } Gets or sets the error code for the error that occurred during validation. Error codes defined by RFC 7591 are defined as constants in the DynamicClientRegistrationErrors class. ErrorDescription { get; set; } Gets or sets a human-readable description of the error that occurred during validation. Marker Interfaces IDynamicClientRegistrationResponse Marker interface for the response to a dynamic client registration request. This interface has two implementations; DynamicClientRegistrationResponse indicates success, while DynamicClientRegistrationError indicates failure.\nIDynamicClientRegistrationValidationResult Marker interface for the result of validating a dynamic client registration request. This interface has two implementations; DynamicClientRegistrationValidatedRequest indicates success, while DynamicClientRegistrationError indicates failure. Note that the DynamicClientRegistrationError implements multiple interfaces and can be used throughout the pipeline to convey errors.\nIStepResult Marker interface for the result of a step in the dynamic client registration validator or processor. This interface has two implementations; SuccessfulStep indicates success, while DynamicClientRegistrationError indicates failure. Note that the DynamicClientRegistrationError implements multiple interfaces and can be used throughout the pipeline to convey errors.\nIStepResult Convenience Functions Your validation or processing steps can return a call to convenience functions in the static class StepResult to conveniently construct a success or failure from a step wrapped in a task.\nname description static Task\u0026lt;IStepResult\u0026gt; Success() Indicates that the validation step was completed was completed successfully static Task\u0026lt;IStepResult\u0026gt; Failure(string errorDescription) Indicates that the validation step failed with the specified error description and the default error code of invalid_client_metadata static Task\u0026lt;IStepResult\u0026gt; Failure(string errorDescription, string error) Indicates that the validation step failed with the specified error description and error code DynamicClientRegistrationValidatedRequest Represents a successfully validated dynamic client registration request.\npublic class DynamicClientRegistrationValidatedRequest : DynamicClientRegistrationValidationResult SuccessfulStep Represents a successful validation step.\npublic class SuccessfulStep : IStepResult "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/ui/login/mfa/",
    "title": "Multi Factor Authentication",
    "tags": [],
    "description": "",
    "content": "Duende IdentityServer itself doesn\u0026rsquo;t implement multi-factor authentication (MFA). MFA is part of the login process in the user interface which is the responsibility of the hosting application. Microsoft provides some general guidelines on how to enable MFA in ASP.NET Core.\nMFA hosted in IdentityServer An IdentityServer implementation can include MFA in its login page using anything that works with ASP.NET Core. One approach is to use ASP.NET Identity\u0026rsquo;s MFA support.\nMFA and external authentication When using IdentityServer as a federation gateway, interactive users authenticate at the upstream provider. Typically the upstream provider will perform the entire user authentication process, including any MFA required. There\u0026rsquo;s no special configuration or implementation needed in IdentityServer in this case, as the upstream provider handles everything.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/services/refresh_token_service/",
    "title": "Refresh Token Service",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Services.IRefreshTokenService All refresh token handling is implemented in the DefaultRefreshTokenService (which is the default implementation of the IRefreshTokenService interface):\npublic interface IRefreshTokenService { /// \u0026lt;summary\u0026gt; /// Validates a refresh token. /// \u0026lt;/summary\u0026gt; Task\u0026lt;TokenValidationResult\u0026gt; ValidateRefreshTokenAsync(string token, Client client); /// \u0026lt;summary\u0026gt; /// Creates the refresh token. /// \u0026lt;/summary\u0026gt; Task\u0026lt;string\u0026gt; CreateRefreshTokenAsync(ClaimsPrincipal subject, Token accessToken, Client client); /// \u0026lt;summary\u0026gt; /// Updates the refresh token. /// \u0026lt;/summary\u0026gt; Task\u0026lt;string\u0026gt; UpdateRefreshTokenAsync(string handle, RefreshToken refreshToken, Client client); } The behavior of the refresh token service is complex. We don\u0026rsquo;t recommend implementing the interface from scratch, unless you know exactly know what you are doing. If you want to customize how refresh tokens are handled, we recommended that you create a class that derives from the default implementation and override its virtual methods, calling the methods in the base class before adding your own custom logic.\nThe most common customizations to the refresh token service involve how to handle consumed tokens. In these situations, the token usage has been set to one-time only, but the same token gets sent more than once. This could either point to a replay attack of the refresh token, bugs in the client code, or transient network failures.\nWhen one-time use refresh tokens are used, they are not necessarily deleted from the database. The DeleteOneTimeOnlyRefreshTokensOnUse configuration flag, added in version 6.3, controls if such tokens are immediately deleted or consumed. If configured for consumption instead of deletion, then when the token is used, the ConsumedTime property will be set. If a token is received that has already been consumed, the default service will call the AcceptConsumedTokenAsync virtual method. The purpose of AcceptConsumedTokenAsync is to determine if a consumed token should be allowed to be used to produce new tokens. The default implementation of AcceptConsumedTokenAsync rejects all consumed tokens, causing the protocol request to fail with the \u0026ldquo;invalid_grant\u0026rdquo; error. Your customized implementation could instead add a grace period to allow recovery after network failures or could treat this as a replay attack and take steps to notify the user and/or revoke their access.\nSee also: Refreshing a token\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/data/operational/sessions/",
    "title": "Server-Side Sessions",
    "tags": [],
    "description": "Data Store",
    "content": "(added in 6.1)\nThe server-side sessions feature in Duende IdentityServer requires a store to persist a user\u0026rsquo;s session data.\nServer-Side Session Store The IServerSideSessionStore abstracts storing the server-side session data. ServerSideSession objects act as the storage entity, and provide several properties uses as metadata for the session. The Ticket property contains the actual serialized data used by the ASP.NET Cookie Authentication handler.\nThe methods on the IServerSideSessionStore are used to orchestrate the various management functions needed by the server-side sessions feature.\nRegistering a custom store To register a custom server-side session store in the DI container, there is a AddServerSideSessionStore helper on the IIdentityServerBuilder. It is still necessary to call AddServerSideSessions to enable the server-side session feature. For example:\nbuilder.Services.AddIdentityServer() .AddServerSideSessions() .AddServerSideSessionStore\u0026lt;YourCustomStore\u0026gt;(); There is also an overloaded version of a AddServerSideSessions that will perform both registration steps in one call. For example:\nbuilder.Services.AddIdentityServer() .AddServerSideSessions\u0026lt;YourCustomStore\u0026gt;(); EntityFramework store implementation An EntityFramework Core implementation of the server-side session store is included in the Entity Framework Integration operational store.\nWhen using the EntityFramework Core operational store, it will be necessary to indicate that server-side sessions need to be used with the call to the AddServerSideSessions fluent API. For example:\nbuilder.Services.AddIdentityServer() .AddServerSideSessions() .AddOperationalStore(options =\u0026gt; { // ... }); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/services/token_creation_service/",
    "title": "Token Creation Service",
    "tags": [],
    "description": "",
    "content": "IdentityServer uses an ITokenCreationService which is responsible for the creation of tokens, with the default implementation of DefaultTokenCreationService.\n/// \u0026lt;summary\u0026gt; /// Logic for creating security tokens /// \u0026lt;/summary\u0026gt; public interface ITokenCreationService { /// \u0026lt;summary\u0026gt; /// Creates a token. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;token\u0026#34;\u0026gt;The token description.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;A protected and serialized security token\u0026lt;/returns\u0026gt; Task\u0026lt;string\u0026gt; CreateTokenAsync(Token token); } The Token creation service takes the Token model and converts it into a JWT. During the JWT creation, you have one last opportunity to modify the Token by adding, removing, or altering property values. Common use cases for implementing the ITokenCreationService include modifying claims, audiences, and more from a secondary data source, such as a profile service, database, or third-party service when other approaches are not an option.\nNote that there are better places within IdentityServer\u0026rsquo;s infrastructure to add additional claims, such as IClaimService, ITokenService, and IProfileService. We recommend investigating whether overriding those interfaces would be enough before implementing ITokenCreationService.\nYou can think of each of the services as providing the following functionality:\nITokenCreationService : Serialization of the Token model into a JWT ITokenService: Building the Token model IClaimsService: Customizing claims on the Token IProfileService: User-centric profile data used in the Token and UserInfo endpoint If, after research, you have still decided to implement ITokenCreationService, we recommend you inherit and override methods on DefaultTokenCreationService, specifically the CreatePayloadAsync method.\nDo not overload your tokens with large amounts of data, as it can lead to large JWTs and adversely affect system performance.\npublic class CustomTokenCreationService : DefaultTokenCreationService { public CustomTokenCreationService(IClock clock, IKeyMaterialService keys, IdentityServerOptions options, ILogger\u0026lt;DefaultTokenCreationService\u0026gt; logger) : base(clock, keys, options, logger) { } protected override Task\u0026lt;string\u0026gt; CreatePayloadAsync(Token token) { token.Audiences.Add(\u0026#34;custom1\u0026#34;); return base.CreatePayloadAsync(token); } } After creating your new implementation, register the type in your application\u0026rsquo;s service collection.\nbuilder.Services.AddTransient\u0026lt;ITokenCreationService, CustomTokenCreationService\u0026gt;(); IdentityServer will begin to use your new implementation in place of DefaultTokenCreationService.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/overview/security/",
    "title": "Security best-practices",
    "tags": [],
    "description": "",
    "content": "This document describes how the integrity of software produced by Duende Software is maintained during the software development life cycle.\nData processing Our products are off-the shelf downloadable developer components. They are not managed services or SaaS - nor do we store, have access to, or process any of our customers\u0026rsquo; data or their customers\u0026rsquo; data.\nSystems access Multiple systems are used in the development life cycle, including GitHub, NuGet, and Microsoft Azure Key Vault. Multi-factor authentication is required for all services mentioned above. Only a limited subset of Duende Software employees act as administrators for each system. Software development All code is stored in GitHub. Any code added to a project must be added via pull request. At least one other staff member must review a pull request before it can be merged to a release branch. Static code security analysis is performed for every check-in (using GitHub CodeQL). Testing Automated test suites are run on code in every pull request branch. Pull requests cannot be merged if the automated test suite fails. Deployment Merging a pull request does not immediately release new features to users, this requires an additional release step. All compiled software packages with associated source are available as GitHub releases. Compiled software libraries (such as Duende IdentityServer) are published to NuGet. Packages must be pushed to NuGet by a Duende Software staff member only after additional validation by the staff member. All NuGet packages are signed with a code signing certificate The private key (RSA 4096 bits) is stored in Azure Key Vault. The private key never leaves Key Vault and the signature process is performed by Key Vault. NuGet will validate the package signature with Duende\u0026rsquo;s public key to verify they were legitimately built by Duende Software and have not been compromised or tampered with. NuGet client tooling can be configured to accept signed packages only. Once on NuGet, the package is available for end users to update their own solutions. End users still must take explicit action to upgrade after reviewing the package\u0026rsquo;s release notes. Vulnerability management process Potential security vulnerabilities can be responsibly disclosed via our contact form. We guarantee to reply within two US business days. All licenses includes a security notification service. Whenever a medium severity or higher security vulnerability has been confirmed and fixed, customers will get a private update prior to public release. We will publish an official advisory Dependencies IdentityServer has two dependencies:\nMicrosoft .NET IdentityModel maintained by Duende Software using the same principles as outlined above Certification Duende IdentityServer is a certified implementation of OpenID Connect.\nPackage Signing NuGet packages published by Duende are cryptographically signed to ensure their authenticity and integrity. Our certificate is signed by DigiCert, which is a widely trusted certificate authority and installed by default in most environments. This means that in many circumstances, the NuGet tools can validate our packages\u0026rsquo; signatures automatically.\nHowever, some environments (notably the dotnet sdk docker image which is sometimes used in build pipelines) do not trust the certificate. In that case, it might be necessary to add the root certificate to NuGet\u0026rsquo;s code signing certificate bundle.\nPackages released after January 1, 2025 (IdentityServer 7.1+): Use DigiCert\u0026rsquo;s root certificate (PEM). Packages released before January 1, 2025: Use Sectigo\u0026rsquo;s root certificate (P7C). Trusting the DigiCert certificate Here is an example of how to configure NuGet to trust the DigiCert root CA on the dotnet sdk docker image. This applies for Duende packages released after January 1, 2025, such as IdentityServer 7.1 and newer versions.\nNote the dotnet sdk docker image already includes the tools used in this section. If you are using another container image, make sure the following tools are available in the image: wget, openssl, cat, and the .NET SDK.\nFirst, get the DigiCert certificate:\nwget https://cacerts.digicert.com/DigiCertTrustedG4CodeSigningRSA4096SHA2562021CA1.crt.pem Next, you validate that the thumbprint of the certificate is correct. Bootstrapping trust in a certificate chain can be challenging. Fortunately, most desktop environments already trust this certificate, so you can compare the downloaded certificate\u0026rsquo;s thumbprint to the thumbprint of the certificate on a machine that already trusts it. You should verify this independently, but for your convenience, the thumbprint is 8F:B2:8D:D3:CF:FA:5D:28:6E:7C:71:8A:A9:07:CB:4F:9B:17:67:C2. You can check the thumbprint of the downloaded certificate with openssl:\nopenssl x509 -in DigiCertTrustedG4CodeSigningRSA4096SHA2562021CA1.crt.pem -fingerprint -sha1 -noout Then append that PEM to the certificate bundle at /usr/share/dotnet/sdk/9.0.102/trustedroots/codesignctl.pem:\ncat DigiCertTrustedG4CodeSigningRSA4096SHA2562021CA1.crt.pem \u0026gt;\u0026gt; /usr/share/dotnet/sdk/9.0.102/trustedroots/codesignctl.pem After that, NuGet packages signed by Duende can be successfully verified, even if they are not distributed by NuGet.org:\ndotnet nuget verify Duende.IdentityServer.7.1.x.nupkg Trusting the Sectigo certificate Here is an example of how to configure NuGet to trust the Sectigo root CA on the dotnet sdk docker image for Duende packages released before January 1, 2025\nNote the dotnet sdk docker image already includes the tools used in this section. If you are using another container image, make sure the following tools are available in the image: wget, openssl, cat, and the .NET SDK.\nFirst, get the Sectigo certificate and convert it to PEM format:\nwget http://crt.sectigo.com/SectigoPublicCodeSigningRootR46.p7c openssl pkcs7 -inform DER -outform PEM -in SectigoPublicCodeSigningRootR46.p7c -print_certs -out sectigo.pem Next, you should validate that the thumbprint of the certificate is correct. Bootstrapping trust in a certificate chain can be challenging. Fortunately, most desktop environments already trust this certificate, so you can compare the downloaded certificate\u0026rsquo;s thumbprint to the thumbprint of the certificate on a machine that already trusts it. You should verify this independently, but for your convenience, the thumbprint is CC:BB:F9:E1:48:5A:F6:3C:E4:7A:BF:8E:9E:64:8C:25:04:FC:31:9D. You can check the thumbprint of the downloaded certificate with openssl:\nopenssl x509 -in sectigo.pem -fingerprint -sha1 -noout Then append that PEM to the certificate bundle at /usr/share/dotnet/sdk/8.0.303/trustedroots/codesignctl.pem:\ncat sectigo.pem \u0026gt;\u0026gt; /usr/share/dotnet/sdk/8.0.303/trustedroots/codesignctl.pem After that, NuGet packages signed by Duende can be successfully verified, even if they are not distributed by NuGet.org:\ndotnet nuget verify Duende.IdentityServer.7.0.x.nupkg "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/response_handling/",
    "title": "Response Generators",
    "tags": [],
    "description": "",
    "content": "Response Generators IdentityServer\u0026rsquo;s endpoints follow a pattern of abstraction in which a response generator uses a validated input model to produce a response model. The response model is a type that represents the data that will be returned from the endpoint. The response model is then wrapped in a result model, which is a type that facilitates serialization by an implementation of IHttpResponseWriter.\nCustomization of protocol endpoint responses is possible in both the response generators and response writers. Response generator customization is appropriate when you want to change the \u0026ldquo;business logic\u0026rdquo; of an endpoint and is typically accomplished by overriding virtual methods in the default response generator. Response writer customization is appropriate when you want to change the serialization, encoding, or headers of the HTTP response and is accomplished by registering a custom implementation of the IHttpResponseWriter.\nAuthorize Interaction Response Generator Token Response Generator IHttpResponseWriter "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/services/user_sesion_service/",
    "title": "User Session Service",
    "tags": [],
    "description": "",
    "content": "The IUserSession interface is the contract for a service that manages the user\u0026rsquo;s session and tracks the clients that are participating in the session.\nUser sessions are identified by the session identifier, which is a unique random number assigned when the user initially logs in. When client applications request tokens for a flow that involves a user, that client application\u0026rsquo;s id is recorded in the user\u0026rsquo;s session. Using that information, IdentityServer can determine which applications are participating in the current session. This can be useful for various purposes, but most notably, at signout time, IdentityServer sends logout notifications to the clients that are participating in the session that is ending.\nThe IUserSession interface also contains methods for manipulating the session cookie. The session cookie contains a copy of the session id value, and is used by IdentityServer\u0026rsquo;s implementation of OIDC session management. The session id cookie\u0026rsquo;s name is controlled by the IdentityServerOptions.Authentication.CheckSessionCookieName option, which defaults to \u0026ldquo;idsrv.session\u0026rdquo;.\nThe default implementation of the IUserSession is the DefaultUserSession class. It stores the session identifier and client list in the authentication properties.\nDuende.IdentityServer.Services.IUserSession Members name description Task CreateSessionIdAsync(ClaimsPrincipal principal, AuthenticationProperties properties) Creates a session id and issues the session id cookie. Task GetUserAsync() Gets the current authenticated user. Task\u0026lt;string?\u0026gt; GetSessionIdAsync() Gets the current session identifier. Task EnsureSessionIdCookieAsync() Ensures the session identifier cookie is synchronized with the current session identifier. Task RemoveSessionIdCookieAsync() Removes the session identifier cookie. Task AddClientIdAsync(string clientId) Adds a client to the list of clients the user has signed into during their session. Task\u0026lt;IEnumerable\u0026gt; GetClientListAsync() Gets the list of clients the user has signed into during their session. GetUserAsync Generally GetUserAsync should be preferred over IAuthenticationService.AuthenticateAsync for two reasons:\nIt does not cause claims transformation to run, which prevents issues where a claims transformation is run more than once. It has a cache of the authentication result which is updated whenever a new authentication cookie is issued. Calls to SignInAsync that issue an updated authentication ticket will be reflected immediately in GetUserAsync, while AuthenticateAsync\u0026rsquo;s results will reflect the incoming authentication cookie throughout the entire duration of an HTTP request. "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/services/session_management_service/",
    "title": "Session Management Service",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Services.ISessionManagementService When using server-side sessions, the ISessionManagementService provides an administrative feature to query those sessions and terminate those sessions (including associated tokens, consents, and triggering back-channel logout to the clients).\n/// \u0026lt;summary\u0026gt; /// Session management service /// \u0026lt;/summary\u0026gt; public interface ISessionManagementService { /// \u0026lt;summary\u0026gt; /// Queries all the session related data for a user. /// \u0026lt;/summary\u0026gt; Task\u0026lt;QueryResult\u0026lt;UserSession\u0026gt;\u0026gt; QuerySessionsAsync(SessionQuery filter = null, CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// Removes all the session related data for a user. /// \u0026lt;/summary\u0026gt; Task RemoveSessionsAsync(RemoveSessionsContext context, CancellationToken cancellationToken = default); } QuerySessionsAsync allows for returning paged results of UserSession data based on the optional SessionQuery filter.\n/// \u0026lt;summary\u0026gt; /// Results from querying user sessions from session management service. /// \u0026lt;/summary\u0026gt; public class UserSession { /// \u0026lt;summary\u0026gt; /// The subject ID /// \u0026lt;/summary\u0026gt; public string SubjectId { get; set; } = default!; /// \u0026lt;summary\u0026gt; /// The session ID /// \u0026lt;/summary\u0026gt; public string SessionId { get; set; } = default!; /// \u0026lt;summary\u0026gt; /// The display name for the user /// \u0026lt;/summary\u0026gt; public string DisplayName { get; set; } /// \u0026lt;summary\u0026gt; /// The creation time /// \u0026lt;/summary\u0026gt; public DateTime Created { get; set; } /// \u0026lt;summary\u0026gt; /// The renewal time /// \u0026lt;/summary\u0026gt; public DateTime Renewed { get; set; } /// \u0026lt;summary\u0026gt; /// The expiration time /// \u0026lt;/summary\u0026gt; public DateTime? Expires { get; set; } /// \u0026lt;summary\u0026gt; /// The client ids for the session /// \u0026lt;/summary\u0026gt; public IReadOnlyCollection\u0026lt;string\u0026gt; ClientIds { get; set; } = default!; /// \u0026lt;summary\u0026gt; /// The underlying AuthenticationTicket /// \u0026lt;/summary\u0026gt; public AuthenticationTicket AuthenticationTicket { get; set; } = default!; } RemoveSessionsAsync will terminate server-side sessions based on SubjectId and/or SessionId, and allow for fine-grained flags for what to revoke and/or notify.\n/// \u0026lt;summary\u0026gt; /// Models the information to remove a user\u0026#39;s session data. /// \u0026lt;/summary\u0026gt; public class RemoveSessionsContext { /// \u0026lt;summary\u0026gt; /// The subject ID /// \u0026lt;/summary\u0026gt; public string SubjectId { get; init; } /// \u0026lt;summary\u0026gt; /// The sesion ID /// \u0026lt;/summary\u0026gt; public string SessionId { get; init; } /// \u0026lt;summary\u0026gt; /// The client ids for which to trigger logout notification, or revoke tokens or consent. /// If not set, then all clients will be removed. /// \u0026lt;/summary\u0026gt; public IEnumerable\u0026lt;string\u0026gt; ClientIds { get; set; } = default!; /// \u0026lt;summary\u0026gt; /// Removes the server side session for the user\u0026#39;s session. /// \u0026lt;/summary\u0026gt; public bool RemoveServerSideSession { get; set; } = true; /// \u0026lt;summary\u0026gt; /// Sends a back channel logout notification (if clients are registered for one). /// \u0026lt;/summary\u0026gt; public bool SendBackchannelLogoutNotification { get; set; } = true; /// \u0026lt;summary\u0026gt; /// Revokes all tokens (e.g. refresh and reference) for the clients. /// \u0026lt;/summary\u0026gt; public bool RevokeTokens { get; set; } = true; /// \u0026lt;summary\u0026gt; /// Revokes all prior consent granted to the clients. /// \u0026lt;/summary\u0026gt; public bool RevokeConsents { get; set; } = true; } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/overview/demo_server/",
    "title": "Demo Server",
    "tags": [],
    "description": "",
    "content": "You can try Duende IdentityServer with your favourite client library. We have a test instance at demo.duendesoftware.\nOn the main page you can find instructions on how to configure your client and how to call an API.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/services/interaction_service/",
    "title": "IdentityServer Interaction Service",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Services.IIdentityServerInteractionService The IIdentityServerInteractionService interface is intended to provide services to be used by the user interface to communicate with IdentityServer, mainly pertaining to user interaction. It is available from the dependency injection system and would normally be injected as a constructor parameter into your MVC controllers for the user interface of IdentityServer.\nIIdentityServerInteractionService APIs GetAuthorizationContextAsync\nReturns the AuthorizationRequest based on the returnUrl passed to the login or consent pages.\nIsValidReturnUrl\nIndicates if the returnUrl is a valid URL for redirect after login or consent.\nGetErrorContextAsync\nReturns the ErrorMessage based on the errorId passed to the error page.\nGetLogoutContextAsync\nReturns the LogoutRequest based on the logoutId passed to the logout page.\nCreateLogoutContextAsync\nUsed to create a logoutId if there is not one presently. This creates a cookie capturing all the current state needed for signout and the logoutId identifies that cookie. This is typically used when there is no current logoutId and the logout page must capture the current user\u0026rsquo;s state needed for sign-out prior to redirecting to an external identity provider for signout. The newly created logoutId would need to be roundtripped to the external identity provider at signout time, and then used on the signout callback page in the same way it would be on the normal logout page.\nGrantConsentAsync\nAccepts a ConsentResponse to inform IdentityServer of the user\u0026rsquo;s consent to a particular AuthorizationRequest.\nDenyAuthorizationAsync\nAccepts a AuthorizationError to inform IdentityServer of the error to return to the client for a particular AuthorizationRequest.\nGetAllUserGrantsAsync\nReturns a collection of Grant for the user. These represent a user\u0026rsquo;s consent or a clients access to a user\u0026rsquo;s resource.\nRevokeUserConsentAsync\nRevokes all of a user\u0026rsquo;s consents and grants for a client.\nRevokeTokensForCurrentSessionAsync\nRevokes all of a user\u0026rsquo;s consents and grants for clients the user has signed into during their current session.\nReturned models The above methods return various models.\nAuthorizationRequest Client\nThe client that initiated the request.\nRedirectUri\nThe URI to redirect the user to after successful authorization.\nDisplayMode\nThe display mode passed from the authorization request.\nUiLocales\nThe UI locales passed from the authorization request.\nIdP The external identity provider requested. This is used to bypass home realm discovery (HRD). This is provided via the \u0026ldquo;idp:\u0026rdquo; prefix to the acr_values parameter on the authorize request.\nTenant\nThe tenant requested. This is provided via the \u0026ldquo;tenant:\u0026rdquo; prefix to the acr_values parameter on the authorize request.\nLoginHint\nThe expected username the user will use to login. This is requested from the client via the login_hint parameter on the authorize request.\nPromptMode\nThe prompt mode requested from the authorization request.\nAcrValues\nThe acr values passed from the authorization request.\nValidatedResources\nThe ResourceValidationResult which represents the validated resources from the authorization request.\nParameters\nThe entire parameter collection passed to the authorization request.\nRequestObjectValues\nThe validated contents of the request object (if present).\nResourceValidationResult Resources\nThe resources of the result.\nParsedScopes\nThe parsed scopes represented by the result.\nRawScopeValues\nThe original (raw) scope values represented by the validated result.\nErrorMessage Error\nThe error code.\nErrorDescription\nThe error description.\nDisplayMode\nThe display mode passed from the authorization request.\nUiLocales\nThe UI locales passed from the authorization request.\nRequestId\nThe per-request identifier. This can be used to display to the end user and can be used in diagnostics.\nClientId\nThe client id making the request (if available).\nRedirectUri\nThe redirect URI back to the client (if available).\nLogoutRequest ClientId\nThe client identifier that initiated the request.\nPostLogoutRedirectUri\nThe URL to redirect the user to after they have logged out.\nSessionId\nThe user\u0026rsquo;s current session id.\nSignOutIFrameUrl\nThe URL to render in an \u0026lt;iframe\u0026gt; on the logged out page to enable single sign-out.\nParameters\nThe entire parameter collection passed to the end session endpoint.\nShowSignoutPrompt\nIndicates if the user should be prompted for signout based upon the parameters passed to the end session endpoint.\nConsentResponse ScopesValuesConsented\nThe collection of scopes the user consented to.\nRememberConsent\nFlag indicating if the user\u0026rsquo;s consent is to be persisted.\nDescription\nOptional description the user can set for the grant (e.g. the name of the device being used when consent is given). This can be presented back to the user from the persisted grant service.\nError\nError, if any, for the consent response. This will be returned to the client in the authorization response.\nErrorDescription\nError description. This will be returned to the client in the authorization response.\nGrant SubjectId\nThe subject id that allowed the grant.\nClientId\nThe client identifier for the grant.\nDescription\nThe description the user assigned to the client or device being authorized.\nScopes\nThe collection of scopes granted.\nCreationTime\nThe date and time when the grant was granted.\nExpiration\nThe date and time when the grant will expire.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/tokens/internal/",
    "title": "Issuing Internal Tokens",
    "tags": [],
    "description": "",
    "content": "Sometimes, extensibility code running on your IdentityServer needs access tokens to call other APIs. In this case it is not necessary to use the protocol endpoints. The tokens can be issued internally.\nIIdentityServerTools is a collection of useful internal tools that you might need when writing extensibility code for IdentityServer. To use it, inject it into your code, e.g. a controller::\npublic MyController(IIdentityServerTools tools) { _tools = tools; } The IssueJwtAsync method allows creating JWT tokens using the IdentityServer token creation engine. The IssueClientJwtAsync is an easier version of that for creating tokens for server-to-server communication (e.g. when you have to call an IdentityServer protected API from your code):\npublic async Task\u0026lt;IActionResult\u0026gt; MyAction() { var token = await _tools.IssueClientJwtAsync( clientId: \u0026#34;client_id\u0026#34;, lifetime: 3600, audiences: new[] { \u0026#34;backend.api\u0026#34; }); // more code } The IIdentityServerTools interface was added in v7 to allow mocking. Previous versions referenced the IdentityServerTools implementation class directly.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/apis/",
    "title": "Protecting APIs",
    "tags": [],
    "description": "",
    "content": "Protecting APIs Duende IdentityServer issues tokens for accessing resources.\nThese resources are very often HTTP-based APIs, but could be also other \u0026ldquo;invocable\u0026rdquo; functionality like messaging endpoints, gRPC services or even good old XML Web Services. See the issuing tokens section on more information on access tokens and how to request them.\nProtecting APIs using ASP.NET Core Adding API Endpoints to your IdentityServer "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/samples/configuration/",
    "title": "Configuration API",
    "tags": [],
    "description": "Samples",
    "content": "Dynamic Client Registration Sample This sample of the IdentityServer.Configuration API shows how to make simple Dynamic Client Registration (DCR) requests. link to source code\nPermissions Sample This sample of the IdentityServer.Configuration API shows how you might make authorization decisions during Dynamic Client Registration (DCR). link to source code\nCI/CD Pipeline Sample using a Personal Access Token This sample of the IdentityServer.Configuration API shows how you might use Personal Access Tokens to authorize access to the configuration API in a CI/CD pipeline. link to source code\nSoftware Statement Sample This sample of the IdentityServer.Configuration API shows how you might use a software statement to pass client metadata values used in Dynamic Client Registration. link to source code\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/upgrades/v6.0_to_v6.1/",
    "title": "Duende IdentityServer v6.0 to v6.1",
    "tags": [],
    "description": "",
    "content": "This upgrade guide covers upgrading from Duende IdentityServer v6.0 to v6.1 (release notes).\nStep 1: Update NuGet package In your IdentityServer host project, update the version of the NuGet. For example in your project file:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;6.0.0\u0026#34; /\u0026gt; would change to:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;6.1.0\u0026#34; /\u0026gt; Step 2: Update Database Schema (if needed) If you are using a database for your configuration or operational data, then there is a database schema update. This includes:\nServer-side sessions feature, which requires a new table (more details). Session coordination feature, which adds a column to the Clients table (more details). Improve primary key on the persisted grants table (more details). IdentityServer is abstracted from the data store on multiple levels, so the exact steps involved in updating your data store will depend on your implementation details.\nCustom Store Implementations The core of IdentityServer is written against the store interfaces, which abstract all the implementation details of actually storing data. If your IdentityServer implementation includes a custom implementation of those stores, then you will have to determine how best to include the changes in the model in the underlying data store and make any necessary changes to schemas, if your data store requires that.\nDuende.IdentityServer.EntityFramework We also provide a default implementation of the stores in the Duende.IdentityServer.EntityFramework package, but this implementation is still highly abstracted because it is usable with any database that has an EF provider. Different database vendors have very different dialects of sql that have different syntax and type systems, so we don\u0026rsquo;t provide schema changes directly. Instead, we provide the Entity Framework entities and mappings which can be used with Entity Framework\u0026rsquo;s migrations feature to generate the schema updates that are needed in your database.\nTo generate migrations, run the commands below. Note that you might need to adjust paths based on your specific organization of the migration files.\ndotnet ef migrations add Update_DuendeIdentityServer_v6_1 -c ConfigurationDbContext -o Data/Migrations/IdentityServer/ConfigurationDb dotnet ef migrations add Update_DuendeIdentityServer_v6_1 -c PersistedGrantDbContext -o Data/Migrations/IdentityServer/PersistedGrantDb Then to apply those changes to your database:\ndotnet ef database update -c ConfigurationDbContext dotnet ef database update -c PersistedGrantDbContext Some organizations prefer to use other tools for managing schema changes. You\u0026rsquo;re free to manage your schema however you see fit, as long as the entities can be successfully mapped. Even if you\u0026rsquo;re not going to ultimately use Entity Framework migrations to manage your database changes, generating a migration can be a useful development step to get an idea of what needs to be done.\nStep 3: Done! That\u0026rsquo;s it. Of course, at this point you can and should test that your IdentityServer is updated and working properly.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/ui/login/external/",
    "title": "Integrating with External Providers",
    "tags": [],
    "description": "",
    "content": "External Identity Providers One option for allowing your users to login is by using an external identity provider. These external providers can be a social login for your users (e.g. Google), a corporate login system (e.g. Azure AD for employees), or some other login system your users use.\nThe workflow using an external provider is much like the workflow from one of your client applications using your IdentityServer. Your login page must redirect the user to the identity provider for login, and the identity provider will redirect the user to a callback endpoint in your IdentityServer to process the results. This means the external provider should implement a standard protocol (e.g. Open ID Connect, SAML2-P, or WS-Federation) to allow such an integration.\nIt is possible to use a custom protocol to allow logins from an external provider, but you are taking on risk using something that is not as widely validated and scrutinized as one of the standard authentication protocols (e.g. Open ID Connect, SAML2-P, or WS-Federation).\nTo ease integration with external providers, it is recommended to use an authentication handler for ASP.NET Core that implements the corresponding protocol used by the provider. Many are available as part of ASP.NET Core, but you might need to find others (both commercial and free) for things like SAML2-P and other social login systems not provided by ASP.NET Core.\nRegistering Authentication Handlers for External Providers Supporting an external provider is achieved by simply registering the handler in your IdentityServer\u0026rsquo;s startup configuration. For example, to use employee logins from Azure AD (AAD):\nbuilder.Services.AddIdentityServer(); builder.Services.AddAuthentication() .AddOpenIdConnect(\u0026#34;AAD\u0026#34;, \u0026#34;Employee Login\u0026#34;, options =\u0026gt; { // options omitted }); The above snippet registers a scheme called AAD in the ASP.NET Core authentication system, and uses a human-friendly display name of \u0026ldquo;Employee Login\u0026rdquo;. The options necessary will be different based on the protocol and identity provider used, and are beyond the scope of this documentation.\nTriggering the Authentication Handler To allow the user to be redirected to the external provider, there must be some code in your login page that triggers the handler. This can be done because you have provided the user with a button to click, or it could be due to inspecting some property of the authorization context, or it could be based on any other aspect of the request (e.g. such as the user entering their email).\nThe process of determining which identity provider to use is called Home Realm Discovery, or HRD for short.\nTo invoke an external authentication handler use the ChallengeAsync extension method on the HttpContext (or using the MVC ChallengeResult). When triggering challenge, it\u0026rsquo;s common to pass some properties to indicate the callback URL where you intend to process the external login results and any other state you need to maintain across the workflow (e.g. such as the return URL passed to the login page):\nvar callbackUrl = Url.Action(\u0026#34;MyCallback\u0026#34;); var props = new AuthenticationProperties { RedirectUri = callbackUrl, Items = { { \u0026#34;scheme\u0026#34;, \u0026#34;AAD\u0026#34; }, { \u0026#34;returnUrl\u0026#34;, returnUrl } } }; return Challenge(\u0026#34;AAD\u0026#34;, props); The Role of Cookies in External Logins ASP.NET Core needs a way to manage the state produced from the result of the external login. This state is managed (by default) with another cookie using ASP.NET Core\u0026rsquo;s cookie authentication handler.\nThis extra cookie is necessary since there are typically several redirects involved until you are done with the external authentication process.\nIf you are using ASP.NET Identity, many of these technical details are hidden from you. It is recommended that you also read the Microsoft docs and do the ASP.NET Identity quickstart.\nOne option on an external authentication handlers is called SignInScheme. This specifies the cookie handler to manage the state:\nbuilder.Services.AddAuthentication() .AddOpenIdConnect(\u0026#34;AAD\u0026#34;, \u0026#34;Employee Login\u0026#34;, options =\u0026gt; { options.SignInScheme = \u0026#34;scheme of cookie handler to use\u0026#34;; // other options omitted }); Given that this is such a common practice, IdentityServer registers a cookie handler specifically for this external provider workflow. The scheme is represented via the IdentityServerConstants.ExternalCookieAuthenticationScheme constant. If you were to use our external cookie handler, then for the SignInScheme above you\u0026rsquo;d assign the value to be the IdentityServerConstants.ExternalCookieAuthenticationScheme constant:\nbuilder.Services.AddAuthentication() .AddOpenIdConnect(\u0026#34;AAD\u0026#34;, \u0026#34;Employee Login\u0026#34;, options =\u0026gt; { options.SignInScheme = IdentityServerConstants.ExternalCookieAuthenticationScheme; // other options omitted }); Alternatively, you can also register your own custom cookie handler instead. For example:\nbuilder.Services.AddAuthentication() .AddCookie(\u0026#34;MyTempHandler\u0026#34;) .AddOpenIdConnect(\u0026#34;AAD\u0026#34;, \u0026#34;Employee Login\u0026#34;, options =\u0026gt; { options.SignInScheme = \u0026#34;MyTempHandler\u0026#34;; // other options omitted }); For specialized scenarios, you can also short-circuit the external cookie mechanism and forward the external user directly to the main cookie handler. This typically involves handling events on the external handler to make sure you do the correct claims transformation from the external identity source.\nHandling the Callback On the callback page your typical tasks are:\nInspect the identity returned by the external provider. Make a decision how you want to deal with that user. This might be different based on if this is a new user or a returning user. New users might need additional steps and UI before they are allowed in. Typically this involves creating a new internal user account that is linked to the user from the external provider. Store the external claims that you want to keep. Delete the temporary cookie. Establish the user\u0026rsquo;s authentication session. Complete the login workflow. Inspecting the External Identity To access the result of the external login, invoke the AuthenticateAsync method. This will read the external cookie to retrieve the claims issued by the external provider and any other state you previously stored when calling ChallengeAsync:\n// read external identity from the temporary cookie var result = await HttpContext.AuthenticateAsync(IdentityServerConstants.ExternalCookieAuthenticationScheme); if (result?.Succeeded != true) { throw new Exception(\u0026#34;External authentication error\u0026#34;); } // retrieve claims of the external user var externalUser = result.Principal; if (externalUser == null) { throw new Exception(\u0026#34;External authentication error\u0026#34;); } // retrieve claims of the external user var userId = externalUser.FindFirst(\u0026#34;sub\u0026#34;).Value; var scheme = result.Properties.Items[\u0026#34;scheme\u0026#34;]; // retrieve returnUrl var returnUrl = result.Properties.Items[\u0026#34;returnUrl\u0026#34;] ?? \u0026#34;~/\u0026#34;; // use the user information to find your user in your database, or provision a new user The sub claim from the external cookie is the external provider\u0026rsquo;s unique id for the user. This value should be used to locate your local user record for the user.\nEstablish Session, Clean Up, and Resume Workflow Once your callback page logic has identified the user based on the external identity provider, it will log the user in and complete the original login workflow:\nvar user = FindUserFromExternalProvider(scheme, userId); // issue authentication cookie for user await HttpContext.SignInAsync(new IdentityServerUser(user.SubjectId) { DisplayName = user.DisplayName, IdentityProvider = scheme }); // delete temporary cookie used during external authentication await HttpContext.SignOutAsync(IdentityServerConstants.ExternalCookieAuthenticationScheme); // return back to protocol processing return Redirect(returnUrl); Typically, the sub value used to log the user in would be the user\u0026rsquo;s unique id from your local user database.\nState, URL length, and ISecureDataFormat When redirecting to an external provider for sign-in, frequently state from the client application must be roundtripped. This means that state is captured prior to leaving the client and preserved until the user has returned to the client application. Many protocols, including OpenID Connect, allow passing some sort of state as a parameter as part of the request, and the identity provider will return that state in the response. The OpenID Connect authentication handler provided by ASP.NET Core utilizes this feature of the protocol, and that is how it implements the returnUrl feature mentioned above.\nThe problem with storing state in a request parameter is that the request URL can get too large (over the common limit of 2000 characters). The OpenID Connect authentication handler does provide an extensibility point to store the state in your server, rather than in the request URL. You can implement this yourself by implementing ISecureDataFormat and configuring it on the OpenIdConnectOptions.\nFortunately, IdentityServer provides an implementation of this for you, backed by the IDistributedCache implementation registered in the DI container (e.g. the standard MemoryDistributedCache). To use the IdentityServer provided secure data format implementation, simply call the AddOidcStateDataFormatterCache extension method on the IServiceCollection when configuring DI.\nIf no parameters are passed, then all OpenID Connect handlers configured will use the IdentityServer provided secure data format implementation:\n// configures the OpenIdConnect handlers to persist the state parameter into the server-side IDistributedCache. builder.Services.AddOidcStateDataFormatterCache(); builder.Services.AddAuthentication() .AddOpenIdConnect(\u0026#34;demoidsrv\u0026#34;, \u0026#34;IdentityServer\u0026#34;, options =\u0026gt; { // ... }) .AddOpenIdConnect(\u0026#34;aad\u0026#34;, \u0026#34;Azure AD\u0026#34;, options =\u0026gt; { // ... }) .AddOpenIdConnect(\u0026#34;adfs\u0026#34;, \u0026#34;ADFS\u0026#34;, options =\u0026gt; { // ... }); If only particular schemes are to be configured, then pass those schemes as parameters:\n// configures the OpenIdConnect handlers to persist the state parameter into the server-side IDistributedCache. builder.Services.AddOidcStateDataFormatterCache(\u0026#34;aad\u0026#34;, \u0026#34;demoidsrv\u0026#34;); See this quickstart for step-by-step instructions for adding external authentication and configuring it.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/fundamentals/license_key/",
    "title": "Licensing",
    "tags": [],
    "description": "",
    "content": "IdentityServer is free for development, testing and personal projects, but production use requires a license.\nEditions There are three license editions which include different features.\nStarter Edition The Starter edition includes the core OIDC and OAuth protocol implementation. This is an economical option that is a good fit for organizations with basic needs. It\u0026rsquo;s also a great choice if you have an aging IdentityServer4 implementation that needs to be updated and licensed. The Starter edition includes all the features that were part of IdentityServer4, along with support for the latest .NET releases, improved observability through OTEL support, and years of bug fixes and enhancements.\nBusiness Edition The Business edition adds additional features that go beyond the core protocol support included in the Starter edition. This is a popular license because it adds the most commonly needed tools and features outside a basic protocol implementation. Feature highlights include support for server side sessions and automatic signing key management.\nEnterprise Edition Finally, the Enterprise edition includes everything in the Business edition and adds support for features that are typically used by enterprises with particularly complex architectures or that handle particularly sensitive data. Highlights include resource isolation, the OpenId Connect CIBA flow, and dynamic federation. This is the best option when you have a specific threat model or architectural need for these features.\nLicense Key The license key can be configured in one of two ways:\nVia a well-known file on the file system Programmatically in your startup code You can also use other configuration sources such as Azure Key Vault, by using the programmatic approach.\nIf you want to redistribute Duende IdentityServer as part of a product to your customers, you can use our redistributable license. To include the license key with your product, we recommend loading it at startup from an embedded resource.\nFile System IdentityServer looks for a file named Duende_License.key in the ContentRootPath. If present, the content of the file will be used as the license key.\nWe consider the license key to be private to your organization, but not necessarily a secret. If you\u0026rsquo;re using private source control that is scoped to your organization, storing your license key within it is acceptable.\nStartup If you prefer to load the license key programmatically, you can do so in your startup code. This allows you to use the ASP.NET configuration system to load the license key from any configuration provider, including environment variables, appsettings.json, an external configuration service such as Azure App Configuration, etc.\nThe AddIdentityServer method accepts a lambda expression to configure various options in your IdentityServer, including the LicenseKey. Set the value of this property to the content of the license key file.\nbuilder.Services.AddIdentityServer(options =\u0026gt; { options.LicenseKey = \u0026#34;eyJhbG...\u0026#34;; // the content of the license key file }); Azure Key Vault When deploying IdentityServer to Microsoft Azure, you can make use of Azure Key Vault to load the IdentityServer license key at startup.\nSimilarly to setting the license key programmatically, you can use the AddIdentityServer method and use the overload that accepts a lambda expression to configure the LicenseKey property for your IdentityServer.\nvar keyVaultUrl = new Uri(\u0026#34;https://\u0026lt;YourKeyVaultName\u0026gt;.vault.azure.net/\u0026#34;); var secretClient = new Azure.Security.KeyVault.Secrets.SecretClient( keyVaultUrl, new Azure.Identity.DefaultAzureCredential() ); KeyVaultSecret licenseKeySecret = secretClient.GetSecret(\u0026#34;\u0026lt;YourSecretName\u0026gt;\u0026#34;); var licenseKey = licenseKeySecret.Value; // Inject the secret (license key) into the IdentityServer configuration builder.Services.AddIdentityServer(options =\u0026gt; { options.LicenseKey = licenseKey; }); If you are using Azure App Configuration, you can use a similar approach to load the license key into your IdentityServer host.\nLicense Validation and Logging The license is validated at startup and during runtime. All license validation is self-contained and does not leave the host. There are no outbound calls related to license validation.\nStartup Validation At startup, IdentityServer first checks for a license. If there is no license configured, IdentityServer logs a warning indicating that a license is required in a production deployment and enters Trial Mode.\nNext, assuming a license is configured, IdentityServer compares its configuration to the license. If there are discrepancies between the license and the configuration, IdentityServer will write log messages indicating the nature of the problem.\nRuntime Validation Most common licensing issues, such as expiration of the license or configuring more clients than is included in the license do not prevent IdentityServer from functioning. We trust our customers and we don\u0026rsquo;t want a simple oversight to cause an outage. However, some features will be disabled at runtime if your license does not include them, including:\nServer Side Sessions DPoP Resource Isolation PAR Dynamic Identity Providers CIBA Again, the absence of a license is permitted for development and testing, and therefore does not disable any of these features. Similarly, using an expired license that includes those features does not cause those features to be disabled.\nTrial Mode Using IdentityServer without a license is considered Trial Mode. In Trial Mode, all enterprise features are enabled. Trial Mode is limited to 500 protocol requests. This includes all HTTP requests that IdentityServer itself handles, such as requests for the discovery, authorize, and token endpoints. UI requests, such as the login page, are not included in this limit. Beginning in IdentityServer 7.1, IdentityServer will log a warning when the trial mode threshold is exceeded:\nYou are using IdentityServer in trial mode and have exceeded the trial threshold of 500 requests handled by IdentityServer. In a future version, you will need to restart the server or configure a license key to continue testing. In a future version, IdentityServer will shut down at that time instead.\nWhen operating non-production environments, such as development, test, or QA, without a valid license key, you may run into this trial mode limitation.\nTo prevent your non-production IdentityServer from shutting down in the future, you can use your production license key. IdentityServer is free for development, testing and personal projects, and we support using your production license in these environments when trial mode is not sufficient.\nIf you have feedback on trial mode, or specific use cases where you\u0026rsquo;d prefer other options, please open a community discussion.\nRedistribution We understand that when IdentityServer is redistributed, log messages from the licensing system are not likely to be very useful to your redistribution customers. For that reason, in a redistribution the severity of log messages from the license system is turned all the way down to the trace level. We also appreciate that it might be cumbersome to deploy updated licenses in this scenario, especially if the deployment of your software does not coincide with the duration of the IdentityServer license. In that situation, we ask that you update the license key at the next deployment of your software to your redistribution customers. Of course, you are always responsible for ensuring that your license is renewed.\nLog Severity The severity of the log messages described above depend on the nature of the message and the type of license.\nType of Message Standard License Redistribution License (development*) Redistribution License (production*) Startup, missing license Warning Warning Warning Startup, license details Debug Debug Trace Startup, valid license notice Informational Informational Trace Startup, violations Error Error Trace Runtime, violations Error Error Trace * as determined by IHostEnvironment.IsDevelopment()\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/configuration/dcr/reference/options/",
    "title": "Options",
    "tags": [],
    "description": "",
    "content": "IdentityServerConfigurationOptions Top level options for IdentityServer.Configuration.\npublic class IdentityServerConfigurationOptions Public Members name description DynamicClientRegistration { get; set; } Options for Dynamic Client Registration DynamicClientRegistrationOptions Options for dynamic client registration.\npublic class DynamicClientRegistrationOptions Public Members name description SecretLifetime { get; set; } Gets or sets the lifetime of secrets generated for clients. If unset, generated secrets will have no expiration. Defaults to null (secrets never expire). "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/ui/logout/client_redirect/",
    "title": "Returning to the Client",
    "tags": [],
    "description": "",
    "content": "If sign-out was initiated by a client application, then the client first redirected the user to the end session endpoint. This can be determined if a logoutId is passed to the login page and the returned LogoutRequest\u0026rsquo;s PostLogoutRedirectUri is set.\nHow to Redirect If there is a PostLogoutRedirectUri value, then it\u0026rsquo;s important how this URL is used to redirect the user. The logout page typically should not directly redirect the user to this URL. Doing so would skip the necessary front-channel notifications to clients.\nInstead, the typical approach is to render the PostLogoutRedirectUri as a link on the \u0026ldquo;logged out\u0026rdquo; page. This will allow the page to render, the front-channel iframes will load and perform their duty. It\u0026rsquo;s possible to add JavaScript to the page to enhance this experience even more.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/stores/",
    "title": "Stores",
    "tags": [],
    "description": "Reference",
    "content": "Stores Resource Store Client Store CORS Policy Service Identity Provider Store Persisted Grant Store Device Flow Store Backchannel Authentication Request Store Signing Key Store Server-Side Session Store Pushed Authorization Request Store "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/services/device_flow_interaction_service/",
    "title": "Device Flow Interaction Service",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Services.IDeviceFlowInteractionService The IDeviceFlowInteractionService interface is intended to provide services to be used by the user interface to communicate with Duende IdentityServer during device flow authorization. It is available from the dependency injection system and would normally be injected as a constructor parameter into your MVC controllers for the user interface of IdentityServer.\nIDeviceFlowInteractionService APIs GetAuthorizationContextAsync\nReturns the DeviceFlowAuthorizationRequest based on the userCode passed to the login or consent pages.\nDeviceFlowInteractionResult\nCompletes device authorization for the given userCode.\nDeviceFlowAuthorizationRequest ClientId\nThe client identifier that initiated the request.\nScopesRequested\nThe scopes requested from the authorization request.\nDeviceFlowInteractionResult IsError\nSpecifies if the authorization request errored.\nErrorDescription\nError description upon failure.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/ui/login/dynamicproviders/",
    "title": "Dynamic Providers",
    "tags": [],
    "description": "",
    "content": "Dynamic Identity Providers Normally authentication handlers for external providers are added into your IdentityServer using AddAuthentication() and AddOpenIdConnect(). This is fine for a handful of schemes, but the authentication handler architecture in ASP.NET Core was not designed for dozens or more statically registered in the DI system. At some point you will incur a performance penalty for having too many. Also, as you need to add or change this configuration you will need to re-compile and re-run your startup code for those changes to take effect.\nDuende IdentityServer provides support for dynamic configuration of OpenID Connect providers loaded from a store. This is designed to address the performance concern as well as allowing changes to the configuration to a running server.\nSupport for Dynamic Identity Providers is included in IdentityServer Enterprise Edition.\nListing and displaying the dynamic providers on the login page The identity provider store can be used to query the database containing the dynamic providers.\n/// \u0026lt;summary\u0026gt; /// Interface to model storage of identity providers. /// \u0026lt;/summary\u0026gt; public interface IIdentityProviderStore { /// \u0026lt;summary\u0026gt; /// Gets all identity providers name. /// \u0026lt;/summary\u0026gt; Task\u0026lt;IEnumerable\u0026lt;IdentityProviderName\u0026gt;\u0026gt; GetAllSchemeNamesAsync(); // other APIs omitted } These results can then be used to populate the list of options presented to the user on the login page.\nThis API is deliberately separate than the IAuthenticationSchemeProvider provided by ASP.NET Core, which returns the list of statically configured providers (from Startup.cs). This allows the developer to have more control over the customization on the login page (e.g. there might be hundreds or thousands on dynamic providers, and therefore you would not want them displayed on the login page, but you might have a few social providers statically configured that you would want to display).\nHere is an example of how the IdentityServer Quickstart UI uses both interfaces to then present a merged and unified list to the end user:\nvar schemes = await _schemeProvider.GetAllSchemesAsync(); var providers = schemes .Where(x =\u0026gt; x.DisplayName != null) .Select(x =\u0026gt; new ExternalProvider { DisplayName = x.DisplayName ?? x.Name, AuthenticationScheme = x.Name }).ToList(); var dynamicSchemes = (await _identityProviderStore.GetAllSchemeNamesAsync()) .Where(x =\u0026gt; x.Enabled) .Select(x =\u0026gt; new ExternalProvider { AuthenticationScheme = x.Scheme, DisplayName = x.DisplayName }); providers.AddRange(dynamicSchemes); Store and Configuration Data To use the dynamic providers feature an identity provider store must be provided that will load model data for the OIDC identity provider to be used. If you\u0026rsquo;re using the Entity Framework Integration then this is implemented for you.\nLike other configuration data in IdentityServer, by default the dynamic provider configuration is loaded from the store on every request unless caching is enabled. If you use a custom store, there is an extension method to enable caching. If you use the EF stores, there is general helper to enable caching for all configuration data.\nThe configuration data for the OIDC provider is used to assign the configuration on the ASP.NET Core OpenID Connect Options class, much like you would if you were to statically configure the options when using AddOpenIdConnect(). The identity provider model documentation provides details for the model properties and how they are mapped to the options.\nCustomizing OpenIdConnectOptions If it is needed to further customize the OpenIdConnectOptions, you can register in the DI system an instance of IConfigureNamedOptions\u0026lt;OpenIdConnectOptions\u0026gt;. For example:\npublic class CustomConfig : IConfigureNamedOptions\u0026lt;OpenIdConnectOptions\u0026gt; { public void Configure(string name, OpenIdConnectOptions options) { if (name == \u0026#34;MyScheme\u0026#34;) { options.ClaimActions.MapAll(); } } public void Configure(OpenIdConnectOptions options) { } } And to register this in the DI system:\nbuilder.Services.ConfigureOptions\u0026lt;CustomConfig\u0026gt;(); Accessing OidcProvider data in IConfigureNamedOptions If your customization of the OpenIdConnectOptions requires per-provider data that you are storing on the OidcProvider, then we provide an abstraction for the IConfigureNamedOptions\u0026lt;OpenIdConnectOptions\u0026gt;. This abstraction requires your code to derive from ConfigureAuthenticationOptions\u0026lt;OpenIdConnectOptions, OidcProvider\u0026gt; (rather than IConfigureNamedOptions\u0026lt;OpenIdConnectOptions\u0026gt;). For example:\nclass CustomOidcConfigureOptions : ConfigureAuthenticationOptions\u0026lt;OpenIdConnectOptions, OidcProvider\u0026gt; { public CustomOidcConfigureOptions(IHttpContextAccessor httpContextAccessor, ILogger\u0026lt;CustomOidcConfigureOptions\u0026gt; logger) : base(httpContextAccessor, logger) { } protected override void Configure(ConfigureAuthenticationContext\u0026lt;OpenIdConnectOptions, OidcProvider\u0026gt; context) { var oidcProvider = context.IdentityProvider; var oidcOptions = context.AuthenticationOptions; // TODO: configure oidcOptions with values from oidcProvider } } The above class would need to be configured in DI (as before):\nbuilder.Services.ConfigureOptions\u0026lt;CustomOidcConfigureOptions\u0026gt;(); Callback Paths As part of the architecture of the dynamic providers feature, the various callback paths are required and are automatically set to follow a convention. The convention of these paths follows the form of ~/federation/{scheme}/{suffix}.\nThese are three paths that are set on the OpenIdConnectOptions:\nCallbackPath. This is the OIDC redirect URI protocol value. The suffix \u0026ldquo;/signin\u0026rdquo; is used for this path. SignedOutCallbackPath. This is the OIDC post logout redirect URI protocol value. The suffix \u0026ldquo;/signout-callback\u0026rdquo; is used for this path. RemoteSignOutPath. This is the OIDC front channel logout URI protocol value. The suffix \u0026ldquo;/signout\u0026rdquo; is used for this path. This means for your IdentityServer running at \u0026ldquo;https://sample.duendesoftware.com\u0026rdquo; and an OIDC identity provider whose scheme is \u0026ldquo;idp1\u0026rdquo;, your client configuration with the external OIDC identity provider would be:\nThe redirect URI would be \u0026ldquo;https://sample.duendesoftware.com/federation/idp1/signin\u0026quot; The post logout redirect URI would be \u0026ldquo;https://sample.duendesoftware.com/federation/idp1/signout-callback\u0026quot; The front channel logout URI would be \u0026ldquo;https://sample.duendesoftware.com/federation/idp1/signout\u0026quot; DynamicProviderOptions The DynamicProviderOptions is a new options class in the IdentityServer options object model. It provides shared settings for the dynamic identity providers feature.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/overview/glossary/",
    "title": "Glossary",
    "tags": [],
    "description": "",
    "content": "Client A client is a piece of software that requests tokens from your IdentityServer - either for authenticating a user (requesting an identity token) or for accessing a resource (requesting an access token). A client must be first registered with your IdentityServer before it can request tokens and is identified by a unique client ID.\nThere are many different client types, e.g. web applications, native mobile or desktop applications, SPAs, server processes, etc.\nMore details\nAutomatic key management (Business Edition)\nThe automatic key management feature creates and manages key material for signing tokens and follows best practices for handling this key material, including storage and rotation.\nMore details\nDocumentation\nServer-side Session Management (Business Edition)\nThe server-side session management feature extends the ASP.NET Core cookie authentication handler to maintain a user\u0026rsquo;s authentication session state in a server-side store, rather than putting it all into a self-contained cookie. Using server-side sessions enables more architectural features in your IdentityServer, such as:\nquery and manage active user sessions (e.g. from an administrative app). detect session expiration and perform cleanup both in IdentityServer as well as in client apps. centralize and monitor session activity in order to achieve a system-wide inactivity timeout. More details\nDocumentation\nBFF Security Framework (Business Edition)\nThe Duende BFF (Backend for Frontend) security framework packages up guidance and the necessary components to secure browser-based frontends (e.g. SPAs or Blazor WASM applications) with ASP.NET Core backends.\nMore details\nDocumentation\nDynamic Client Registration (Business Edition)\nImplementation of RFC 8707. Provides a standards-based endpoint to register clients and their configuration.\nDocumentation\nPushed Authorization Requests (Business Edition)\nImplementation of RFC 9126. Provides a more secure way to start a browser-based token/authentication request.\nDocumentation\nDynamic Authentication Providers (Enterprise Edition)\nThe dynamic configuration feature allows dynamic loading of configuration for OpenID Connect providers from a store. This is designed to address the performance concern as well as allowing changes to the configuration to a running server.\nMore details\nDocumentation\nResource Isolation (Enterprise Edition)\nThe resource isolation feature allows a client to request access tokens for an individual resource server. This allows API-specific features such as access token encryption and isolation of APIs that are not in the same trust boundary.\nMore details\nDocumentation\nCIBA (Enterprise Edition)\nDuende IdentityServer supports the Client-Initiated Backchannel Authentication Flow (also known as CIBA). This allows a user to login with a higher security device (e.g. their mobile phone) than the device on which they are using an application (e.g. a public kiosk). CIBA is one of the requirements to support the Financal-grade API compliance.\nMore details\nDocumentation\nProof-of-Possession at the Application Layer / DPoP (Enterprise Edition)\nA mechanism for sender-constraining OAuth 2.0 tokens via a proof-of-possession mechanism on the application level. This mechanism allows for the detection of replay attacks with access and refresh tokens.\nDocumentation\nSingle Deployment A single deployment acts as a single OpenID Connect / OAuth authority hosted at a single URL. It can consist of multiple physical or virtual nodes for load-balancing or fail-over purposes.\nMultiple Deployment Can be either completely independent single deployments, or a single deployment that acts as multiple authorities.\nMultiple Authorities A single logical deployment that acts as multiple logical token services on multiple URLs or host names (e.g. for branding, isolation or multi-tenancy reasons).\nStandard Developer Support Online developer community forum for Duende Software product issues and bugs.\nPriority Developer Support (Enterprise Edition)\nHelpdesk system with guaranteed response time for Duende Software product issues and bugs.\nMore details\nSecurity Notification System Notification system for security bugs and/or reported vulnerabilities.\nMore details\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/models/secrets/",
    "title": "Secrets",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Validation.ISecretParser Parses a secret from the raw HTTP request.\npublic interface ISecretParser { /// \u0026lt;summary\u0026gt; /// Tries to find a secret on the context that can be used for authentication /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;context\u0026#34;\u0026gt;The HTTP context.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;A parsed secret\u0026lt;/returns\u0026gt; Task\u0026lt;ParsedSecret\u0026gt; ParseAsync(HttpContext context); /// \u0026lt;summary\u0026gt; /// Returns the authentication method name that this parser implements /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;The authentication method.\u0026lt;/value\u0026gt; string AuthenticationMethod { get; } } AuthenticationMethod\nThe name of the authentication method that this parser registers for. This value must be unique and will be displayed in the discovery document.\nParseAsync\nThe job of this method is to extract the secret from the HTTP request and parse it into a ParsedSecret\nDuende.IdentityServer.Model.ParsedSecret Represents a parsed secret.\n/// \u0026lt;summary\u0026gt; /// Represents a secret extracted from the HttpContext /// \u0026lt;/summary\u0026gt; public class ParsedSecret { /// \u0026lt;summary\u0026gt; /// Gets or sets the identifier associated with this secret /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The identifier. /// \u0026lt;/value\u0026gt; public string Id { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the credential to verify the secret /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The credential. /// \u0026lt;/value\u0026gt; public object Credential { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the type of the secret /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The type. /// \u0026lt;/value\u0026gt; public string Type { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets additional properties. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The properties. /// \u0026lt;/value\u0026gt; public Dictionary\u0026lt;string, string\u0026gt; Properties { get; set; } = new Dictionary\u0026lt;string, string\u0026gt;(); } The parsed secret is forwarded to the registered secret validator. The validator will typically inspect the Type property to determine if this secret is something that can be validated by that validator instance. If yes, it will know how to cast the Credential object into a format that is understood.\nDuende.IdentityServer.Validation.ISecretParser Validates a parsed secret.\npublic interface ISecretValidator { /// \u0026lt;summary\u0026gt;Validates a secret\u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;secrets\u0026#34;\u0026gt;The stored secrets.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;parsedSecret\u0026#34;\u0026gt;The received secret.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;A validation result\u0026lt;/returns\u0026gt; Task\u0026lt;SecretValidationResult\u0026gt; ValidateAsync( IEnumerable\u0026lt;Secret\u0026gt; secrets, ParsedSecret parsedSecret); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/upgrades/v5.2_to_v6.0/",
    "title": "Duende IdentityServer v5.2 to v6.0",
    "tags": [],
    "description": "",
    "content": "This upgrade guide covers upgrading from Duende IdentityServer v5.2 to v6.0 (release notes). The most significant aspect of this upgrade is that Duende IdentityServer v6.0 targets .NET 6, and CIBA support was added.\nWith any major release, there is always the possibility of some breaking changes. This issue tracks the list of updates where a breaking change might affect your use of IdentityServer. It would be useful to review it to understand if any of these changes affect you.\nStep 1: Update to .NET 6 In your IdentityServer host project, update the version of the .NET framework. For example in your project file:\n\u0026lt;TargetFramework\u0026gt;netcoreapp3.1\u0026lt;/TargetFramework\u0026gt; would change to:\n\u0026lt;TargetFramework\u0026gt;net6.0\u0026lt;/TargetFramework\u0026gt; Also, any other NuGets that you were previously using that targeted an older version of .NET should be updated. For example, Microsoft.EntityFrameworkCore.SqlServer or Microsoft.AspNetCore.Authentication.Google. Depending on what your application was using, there may or may not be code changes based on those updated NuGet packages.\nStep 2: Update the IdentityServer NuGet package In your IdentityServer host project, update the version of the Duende IdentityServer NuGet. For example in your project file:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;5.2.0\u0026#34; /\u0026gt; would change to:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;6.0.0\u0026#34; /\u0026gt; Step 3: Update Database Schema (if needed) If you are using a database for your configuration data, then there is a small database schema update. This includes:\nAdd missing columns for created, updated, etc to EF entities (more details). Add unique constraints to EF tables where duplicate records not allowed (more details). IdentityServer is abstracted from the data store on multiple levels, so the exact steps involved in updating your data store will depend on your implementation details. Custom Store Implementations The core of IdentityServer is written against the store interfaces, which abstract all the implementation details of actually storing data. If your IdentityServer implementation includes a custom implementation of those stores, then you will have to determine how best to include the changes in the model in the underlying data store and make any necessary changes to schemas, if your data store requires that.\nDuende.IdentityServer.EntityFramework We also provide a default implementation of the stores in the Duende.IdentityServer.EntityFramework package, but this implementation is still highly abstracted because it is usable with any database that has an EF provider. Different database vendors have very different dialects of sql that have different syntax and type systems, so we don\u0026rsquo;t provide schema changes directly. Instead, we provide the Entity Framework entities and mappings which can be used with Entity Framework\u0026rsquo;s migrations feature to generate the schema updates that are needed in your database.\nTo generate a migration, run the command below. Note that you might need to adjust paths based on your specific organization of the migration files.\ndotnet ef migrations add Update_DuendeIdentityServer_v6_0 -c ConfigurationDbContext -o Data/Migrations/IdentityServer/ConfigurationDb You will likely get the warning \u0026ldquo;An operation was scaffolded that may result in the loss of data. Please review the migration for accuracy.\u0026rdquo;. This is due to the fact that in this release the column length for redirect URIs (for both login and logout) was reduced from 2000 to 400. This was needed because some database providers have limits on index size. This should not affect you unless you are using redirect URIs greater than 400 characters.\nThen to apply those changes to your database:\ndotnet ef database update -c ConfigurationDbContext Some organizations prefer to use other tools for managing schema changes. You\u0026rsquo;re free to manage your schema however you see fit, as long as the entities can be successfully mapped. Even if you\u0026rsquo;re not going to ultimately use Entity Framework migrations to manage your database changes, generating a migration can be a useful development step to get an idea of what needs to be done.\nStep 4: Verify Data Protection Configuration IdentityServer depends on ASP.NET Data Protection. Data Protection encrypts and signs data using keys managed by ASP.NET. Those keys are isolated by application name, which by default is set to the content root path of the host. This prevents multiple applications from sharing encryption keys, which is necessary to protect your encryption against certain forms of attack. However, this means that if your content root path changes, the default settings for data protection will prevent you from using your old keys. Beginning in .NET 6, the content root path is now normalized so that it ends with a directory separator. This means that your content root path might change when you upgrade to .NET 6. This can be mitigated by explicitly setting the application name and removing the separator character. See Microsoft\u0026rsquo;s documentation for more information.\nStep 5: Done! That\u0026rsquo;s it. Of course, at this point you can and should test that your IdentityServer is updated and working properly.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/ui/logout/external/",
    "title": "External Logout",
    "tags": [],
    "description": "",
    "content": "When a user is logging out, and they have used an external identity provider to sign-in then it is likely that they should be redirected to also sign-out of the external provider. Not all external providers support sign-out, as it depends on the protocol and features they support.\nDon\u0026rsquo;t forget that your logout page still needs to complete all the other steps to properly sign the user out. This is complicated if the logout page must redirect to an external provider to sign out. To achieve both, it is necessary to have the external provider to redirect the user back to your IdentityServer after signing out of the external provider. Across this redirect exchange, there will be state that must be maintained so the complete sign out workflow can complete successfully.\nDetermining the Identity Provider To detect that a user must be redirected to an external identity provider for sign-out is typically done by using an idp claim issued into the cookie at IdentityServer. The value is either local for a local sign-in or the scheme of the corresponding authentication handler used for an external provider. At sign-out time this claim should be consulted to determine if an external sign-out is required.\nThe constant IdentityServerConstants.LocalIdentityProvider can be used instead of hard coding the value local for the local login provider identifier.\nRedirecting to the External Provider To trigger logout at an external provider, use the SignOutAsync extension method on the HttpContext (or the SignOutResult action result in MVC or Razor Pages). You must pass the scheme of the provider as configured in your startup (which should also match the idp claim mentioned above).\npublic IActionResult Logout(string logoutId) { // other code elided var idp = User.FindFirst(\u0026#34;idp\u0026#34;).Value; if (idp != IdentityServerConstants.LocalIdentityProvider) { return SignOut(idp); } // other code elided } Redirecting back from the External Provider and State Management To redirect back to your IdentityServer after the external provider sign-out, the RedirectUri should be used on the AuthenticationProperties when using ASP.NET Core\u0026rsquo;s SignOutAsync API.\nRecall that after we return, we must perform the other steps to complete the logout workflow. These steps require the context passed as the logoutId parameter, so this state needs to be roundtripped to the external provider. We can do so by incorporating the logoutId value into the RedirectUri.\nIf there is no logoutId parameter on the original logout page request, we still might have context that needs to be round tripped. We can obtain a logoutId to use by calling CreateLogoutContextAsync API on the interaction service.\nFor example:\npublic async Task\u0026lt;IActionResult\u0026gt; Logout(string logoutId) { // other code elided var idp = User.FindFirst(\u0026#34;idp\u0026#34;).Value; if (idp != IdentityServerConstants.LocalIdentityProvider) { logoutId = logoutId ?? await _interaction.CreateLogoutContextAsync(); string url = Url.Action(\u0026#34;Logout\u0026#34;, new { logoutId = logoutId }); return SignOut(new AuthenticationProperties { RedirectUri = url }, idp); } // other code elided } Once the user is signed-out of the external provider and then redirected back, the normal sign-out processing at your IdentityServer should execute which involves processing the logoutId and doing all necessary cleanup.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/validators/",
    "title": "Validators",
    "tags": [],
    "description": "Reference",
    "content": "Validators Custom Authorize Request Validator Custom Token Request Validator Backchannel Authentication User Validator DPoP Proof Validator Extension Grant Validator "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/ui/login/windows/",
    "title": "Windows Authentication",
    "tags": [],
    "description": "",
    "content": "There are several ways how you can enable Windows authentication in ASP.NET Core (and thus in your IdentityServer).\nOn Windows using IIS hosting (both in- and out-of process) On Windows using HTTP.SYS hosting On any platform using the Negotiate authentication handler (added in ASP.NET Core 3.0) See the Microsoft documentation for additional information.\nOn Windows using IIS hosting The typical ASP.NET Core CreateDefaultBuilder host setup enables support for IIS-based Windows authentication when hosting in IIS. Make sure that Windows authentication is enabled in launchSettings.json or your IIS configuration.\nThe IIS integration layer will configure a Windows authentication handler into DI that can be invoked via the authentication service. Typically in your IdentityServer it is advisable to disable the automatic behavior.\nThis is done in ConfigureServices (details vary depending on in-proc vs out-of-proc hosting)::\n// configures IIS out-of-proc settings (see https://github.com/aspnet/AspNetCore/issues/14882) builder.Services.Configure\u0026lt;IISOptions\u0026gt;(iis =\u0026gt; { iis.AuthenticationDisplayName = \u0026#34;Windows\u0026#34;; iis.AutomaticAuthentication = false; }); // ..or configures IIS in-proc settings builder.Services.Configure\u0026lt;IISServerOptions\u0026gt;(iis =\u0026gt; { iis.AuthenticationDisplayName = \u0026#34;Windows\u0026#34;; iis.AutomaticAuthentication = false; }); You trigger Windows authentication by calling ChallengeAsync using the Windows scheme (or if you want to use a constant: Microsoft.AspNetCore.Server.IISIntegration.IISDefaults.AuthenticationScheme).\nThis will send the Www-Authenticate header back to the browser which will then re-load the current URL including the Windows identity. You can tell that Windows authentication was successful, when you call AuthenticateAsync on the Windows scheme and the principal returned is of type WindowsPrincipal.\nThe principal will have information like user and group SID and the Windows account name. The following snippet shows how to trigger authentication, and if successful convert the information into a standard ClaimsPrincipal for the temp-Cookie approach::\nprivate async Task\u0026lt;IActionResult\u0026gt; ChallengeWindowsAsync(string returnUrl) { // see if windows auth has already been requested and succeeded var result = await HttpContext.AuthenticateAsync(\u0026#34;Windows\u0026#34;); if (result?.Principal is WindowsPrincipal wp) { // we will issue the external cookie and then redirect the // user back to the external callback, in essence, treating windows // auth the same as any other external authentication mechanism var props = new AuthenticationProperties() { RedirectUri = Url.Action(\u0026#34;Callback\u0026#34;), Items = { { \u0026#34;returnUrl\u0026#34;, returnUrl }, { \u0026#34;scheme\u0026#34;, \u0026#34;Windows\u0026#34; }, } }; var id = new ClaimsIdentity(\u0026#34;Windows\u0026#34;); // the sid is a good sub value id.AddClaim(new Claim(JwtClaimTypes.Subject, wp.FindFirst(ClaimTypes.PrimarySid).Value)); // the account name is the closest we have to a display name id.AddClaim(new Claim(JwtClaimTypes.Name, wp.Identity.Name)); // add the groups as claims -- be careful if the number of groups is too large var wi = wp.Identity as WindowsIdentity; // translate group SIDs to display names var groups = wi.Groups.Translate(typeof(NTAccount)); var roles = groups.Select(x =\u0026gt; new Claim(JwtClaimTypes.Role, x.Value)); id.AddClaims(roles); await HttpContext.SignInAsync( IdentityServerConstants.ExternalCookieAuthenticationScheme, new ClaimsPrincipal(id), props); return Redirect(props.RedirectUri); } else { // trigger windows auth // since windows auth don\u0026#39;t support the redirect uri, // this URL is re-triggered when we call challenge return Challenge(\u0026#34;Windows\u0026#34;); } } A sample is provided here.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/services/ciba_interaction_service/",
    "title": "Backchannel Authentication Interaction Service",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Services.IBackchannelAuthenticationInteractionService The IBackchannelAuthenticationInteractionService interface provides services for a user to access or complete a login requests for CIBA. It is available from the dependency injection system and would normally be injected as a constructor parameter into your MVC controllers for the user interface of IdentityServer.\nIBackchannelAuthenticationInteractionService APIs GetPendingLoginRequestsForCurrentUserAsync\nReturns a collection of BackchannelUserLoginRequest objects which represent pending login requests for the current user.\nGetLoginRequestByInternalIdAsync\nReturns the BackchannelUserLoginRequest object for the id.\nCompleteLoginRequestAsync\nCompletes the login request with the provided CompleteBackchannelLoginRequest response for the current user or the subject passed.\nCompleteBackchannelLoginRequest Models the data needed for a user to complete a backchannel authentication request.\nInternalId\nThe internal store id for the request.\nScopesValuesConsented\nGets or sets the scope values consented to. Setting any scopes grants the login request. Leaving the scopes null or empty denies the request.\nDescription\nGets or sets the optional description to associate with the consent.\nSubject\nThe subject for which the completion is being made. This allows more claims to be associated with the request that was identified on the backchannel authentication request. If not provided, then the IUserSession service will be consulting to obtain the current subject.\nSessionId\nThe session id to associate with the completion request if the Subject is provided. If the Subject is not provided, then this property is ignored in favor of the session id provided by the IUserSession service.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/stores/backchannel_auth_request_store/",
    "title": "Backchannel Authentication Request Store",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Stores.IBackChannelAuthenticationRequestStore Used to store backchannel login requests (for CIBA).\n/// \u0026lt;summary\u0026gt; /// Interface for the backchannel authentication request store /// \u0026lt;/summary\u0026gt; public interface IBackChannelAuthenticationRequestStore { /// \u0026lt;summary\u0026gt; /// Creates the request. /// \u0026lt;/summary\u0026gt; Task\u0026lt;string\u0026gt; CreateRequestAsync(BackChannelAuthenticationRequest request); /// \u0026lt;summary\u0026gt; /// Gets the requests. /// \u0026lt;/summary\u0026gt; Task\u0026lt;IEnumerable\u0026lt;BackChannelAuthenticationRequest\u0026gt;\u0026gt; GetLoginsForUserAsync(string subjectId, string clientId = null); /// \u0026lt;summary\u0026gt; /// Gets the request. /// \u0026lt;/summary\u0026gt; Task\u0026lt;BackChannelAuthenticationRequest\u0026gt; GetByAuthenticationRequestIdAsync(string requestId); /// \u0026lt;summary\u0026gt; /// Gets the request. /// \u0026lt;/summary\u0026gt; Task\u0026lt;BackChannelAuthenticationRequest\u0026gt; GetByInternalIdAsync(string id); /// \u0026lt;summary\u0026gt; /// Removes the request. /// \u0026lt;/summary\u0026gt; Task RemoveByInternalIdAsync(string id); /// \u0026lt;summary\u0026gt; /// Updates the request. /// \u0026lt;/summary\u0026gt; Task UpdateByInternalIdAsync(string id, BackChannelAuthenticationRequest request); } BackChannelAuthenticationRequest /// \u0026lt;summary\u0026gt; /// Models a backchannel authentication request. /// \u0026lt;/summary\u0026gt; public class BackChannelAuthenticationRequest { /// \u0026lt;summary\u0026gt; /// The identifier for this request in the store. /// \u0026lt;/summary\u0026gt; public string InternalId { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the creation time. /// \u0026lt;/summary\u0026gt; public DateTime CreationTime { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the life time in seconds. /// \u0026lt;/summary\u0026gt; public int Lifetime { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the ID of the client. /// \u0026lt;/summary\u0026gt; public string ClientId { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the subject. /// \u0026lt;/summary\u0026gt; public ClaimsPrincipal Subject { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the requested scopes. /// \u0026lt;/summary\u0026gt; public IEnumerable\u0026lt;string\u0026gt; RequestedScopes { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the requested resource indicators. /// \u0026lt;/summary\u0026gt; public IEnumerable\u0026lt;string\u0026gt; RequestedResourceIndicators { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the authentication context reference classes. /// \u0026lt;/summary\u0026gt; public ICollection\u0026lt;string\u0026gt; AuthenticationContextReferenceClasses { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the tenant. /// \u0026lt;/summary\u0026gt; public string Tenant { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the idp. /// \u0026lt;/summary\u0026gt; public string IdP { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the binding message. /// \u0026lt;/summary\u0026gt; public string BindingMessage { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets a value indicating whether this instance has been completed. /// \u0026lt;/summary\u0026gt; public bool IsComplete { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the authorized scopes. /// \u0026lt;/summary\u0026gt; public IEnumerable\u0026lt;string\u0026gt; AuthorizedScopes { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the session identifier from which the user approved the request. /// \u0026lt;/summary\u0026gt; public string SessionId { get; set; } /// \u0026lt;summary\u0026gt; /// Gets the description the user assigned to the client being authorized. /// \u0026lt;/summary\u0026gt; public string Description { get; set; } } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/models/ciba_login_request/",
    "title": "Backchannel User Login Request",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Models.BackchannelUserLoginRequest Models the information to initiate a user login request for CIBA.\nInternalId\nIhe identifier of the request in the store.\nSubject\nThe subject for whom the login request is intended.\nBindingMessage\nThe binding message used in the request.\nAuthenticationContextReferenceClasses\nThe acr_values used in the request.\nTenant\nThe tenant value from the acr_values used the request.\nIdP\nThe idp value from the acr_values used in the request.\nRequestedResourceIndicators\nThe resource indicator values used in the request.\nClient\nThe client that initiated the request.\nValidatedResources\nThe validated resources (i.e. scopes) used in the request.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/data/",
    "title": "Data Stores and Persistence",
    "tags": [],
    "description": "",
    "content": "Data Stores and Persistence Duende IdentityServer is backed by two kinds of data:\nConfiguration Data Operational Data Data access is abstracted by store interfaces that are registered in the DI system. These store interfaces allow IdentityServer to access the data it needs at runtime when processing requests. You can implement these interfaces yourself and thus can use any database you wish. If you prefer a relational database for this data, then we provide EntityFramework Core implementations.\nGiven that data stores abstract the details of the data stored, strictly speaking, IdentityServer does not know or understand where the data is actually being stored. As such, there is no built-in administrative tool to populate or manage this data. There are third-party options (both commercial and FOSS) that provide an administrative UI for managing the data when using the EntityFramework Core implementations.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/upgrades/v5.1_to_v5.2/",
    "title": "Duende IdentityServer v5.1 to v5.2",
    "tags": [],
    "description": "",
    "content": "This upgrade guide covers upgrading from Duende IdentityServer v5.1 to v5.2 (release notes).\nStep 1: Update NuGet package In your IdentityServer host project, update the version of the NuGet. For example in your project file:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;5.1.0\u0026#34; /\u0026gt; would change to:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;5.2.0\u0026#34; /\u0026gt; Step 2: Update Database Schema (if needed) If you are using a database for your configuration data, then there is a database schema update for the new Dynamic Providers feature (more details). This includes:\nA new table called IdentityProviders for storing the OIDC provider details. Its TSQL schema would look like this: CREATE TABLE [IdentityProviders] ( [Id] int NOT NULL IDENTITY, [Scheme] nvarchar(200) NOT NULL, [DisplayName] nvarchar(200) NULL, [Enabled] bit NOT NULL, [Type] nvarchar(20) NOT NULL, [Properties] nvarchar(max) NULL, CONSTRAINT [PK_IdentityProviders] PRIMARY KEY ([Id]) ); IdentityServer is abstracted from the data store on multiple levels, so the exact steps involved in updating your data store will depend on your implementation details.\nCustom Store Implementations The core of IdentityServer is written against the store interfaces, which abstract all the implementation details of actually storing data. If your IdentityServer implementation includes a custom implementation of those stores, then you will have to determine how best to include the changes in the model in the underlying data store and make any necessary changes to schemas, if your data store requires that.\nDuende.IdentityServer.EntityFramework We also provide a default implementation of the stores in the Duende.IdentityServer.EntityFramework package, but this implementation is still highly abstracted because it is usable with any database that has an EF provider. Different database vendors have very different dialects of sql that have different syntax and type systems, so we don\u0026rsquo;t provide schema changes directly. Instead, we provide the Entity Framework entities and mappings which can be used with Entity Framework\u0026rsquo;s migrations feature to generate the schema updates that are needed in your database.\nTo generate a migration, run the command below. Note that you might need to adjust paths based on your specific organization of the migration files.\ndotnet ef migrations add Update_DuendeIdentityServer_v5_2 -c ConfigurationDbContext -o Data/Migrations/IdentityServer/ConfigurationDb Then to apply those changes to your database:\ndotnet ef database update -c ConfigurationDbContext Some organizations prefer to use other tools for managing schema changes. You\u0026rsquo;re free to manage your schema however you see fit, as long as the entities can be successfully mapped. Even if you\u0026rsquo;re not going to ultimately use Entity Framework migrations to manage your database changes, generating a migration can be a useful development step to get an idea of what needs to be done.\nStep 4: Update custom AuthorizeInteractionResponseGenerator (if needed) If you have created a custom, derived implementation of the AuthorizeInteractionResponseGenerator, then the constructor must accept an additional parameter of type IdentityServerOptions. This is needed for the new tenant validation in authorize endpoint requests.\nStep 5: Done! That\u0026rsquo;s it. Of course, at this point you can and should test that your IdentityServer is updated and working properly.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/validators/extension_grant_validator/",
    "title": "Extension Grant Validator",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Validation.IExtensionGrantValidator Use an implementation of this interface to handle extension grants.\npublic interface IExtensionGrantValidator { /// \u0026lt;summary\u0026gt; /// Handles the custom grant request. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;request\u0026#34;\u0026gt;The validation context.\u0026lt;/param\u0026gt; Task ValidateAsync(ExtensionGrantValidationContext context); /// \u0026lt;summary\u0026gt; /// Returns the grant type this validator can deal with /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// The type of the grant. /// \u0026lt;/value\u0026gt; string GrantType { get; } } GrantType\nSpecifies the name of the extension grant that the implementation wants to register for.\nValidateAsync\nThis methods gets called at runtime, when a request comes in that is using the registered extension grant. The job of this method is to validate the request and to populate ExtensionGrantValidationContext.Result with a grant validation result\nThe instance of the extension grant validator gets registered with:\nbuilder.AddExtensionGrantValidator\u0026lt;MyValidator\u0026gt;(); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/ui/logout/external_notification/",
    "title": "External Logout Notification",
    "tags": [],
    "description": "",
    "content": "Federated sign-out is the situation where a user has used an external identity provider to log into IdentityServer, and then the user logs out of that external identity provider via a workflow unknown to IdentityServer. When the user signs out, it will be useful for IdentityServer to be notified so that it can sign the user out of IdentityServer and all of the applications that use IdentityServer.\nNot all external identity providers support federated sign-out, but those that do will provide a mechanism to notify clients that the user has signed out. This notification usually comes in the form of a request in an \u0026lt;iframe\u0026gt; from the external identity provider\u0026rsquo;s \u0026ldquo;logged out\u0026rdquo; page. IdentityServer must then notify all of its clients (as discussed here), also typically in the form of a request in an \u0026lt;iframe\u0026gt; from within the external identity provider\u0026rsquo;s \u0026lt;iframe\u0026gt;.\nWhat makes federated sign-out a special case (when compared to a normal logout) is that the federated sign-out request is not to the normal sign-out endpoint in IdentityServer. In fact, each external IdentityProvider will have a different endpoint into your IdentityServer host. This is due to that fact that each external identity provider might use a different protocol, and each middleware listens on different endpoints.\nThe net effect of all of these factors is that there is no \u0026ldquo;logged out\u0026rdquo; page being rendered as we would on the normal sign-out workflow, which means we are missing the sign-out notifications to IdentityServer\u0026rsquo;s clients. We must add code for each of these federated sign-out endpoints to render the necessary notifications to achieve federated sign-out.\nFortunately IdentityServer already contains this code. When requests come into IdentityServer and invoke the handlers for external authentication providers, IdentityServer detects if these are federated signout requests and if they are it will automatically render the same \u0026lt;iframe\u0026gt; as described here for logout.\nIn short, federated signout is automatically supported.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/overview/resources/",
    "title": "Resources",
    "tags": [],
    "description": "External Links",
    "content": "Below are links to relevant topics:\nOAuth and OIDC Fundamentals OAuth the good Parts (video from NDC Porto 2022) Securing SPAs and Blazor Applications using the BFF (video from NDC Porto 2022) Automated OAuth Access Token Management for .NET Workers and ASP.NET Web Applications ASP.NET Security Introduction to ASP.NET Core Authentication and Authorization ASP.NET Cookie Authentication Documentation Supporting External Authentication Providers Part 1 Supporting External Authentication Providers Part 2 End-User Authorization Authorization for Modern Applications (video from DevConf 2018) "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/models/license_usage_summary/",
    "title": "License Usage Summary",
    "tags": [],
    "description": "Get detailed information about your IdentityServer usage",
    "content": "Duende.IdentityServer.Licensing.LicenseUsageSummary The LicenseUsageSummary class allows developers to get a detailed summary of clients, issuers, and features used during the lifetime of an active .NET application for self-auditing purposes.\nLicenseEdition\nIndicates the current IdentityServer instance\u0026rsquo;s license edition.\nClientsUsed\nA string collection of clients used with the current IdentityServer instance.\nIssuersUsed\nA string collection of issuers used with the current IdentityServer instance.\nFeaturesUsed\nA string collection of issuers used with the current IdentityServer instance.\nUsing LicenseUsageSummary with .NET Lifetime Events In .NET, an IHost implementation allows developers to subscribe to application lifetime events, including Application Started, Application Stopped, and Application Stopping. IdentityServer tracks usage metrics internally and that information may be accessed by developers at any time during the application\u0026rsquo;s lifetime from the application\u0026rsquo;s service collection using the following code snippet.\n// from a valid services scope app.Services.GetRequiredService\u0026lt;LicenseUsageSummary\u0026gt;(); For self-auditing purposes, we recommend using the IHost lifetime event ApplicationStopping as shown in the example below.\nNote, LicenseUsageSummary is read-only.\napp.Lifetime.ApplicationStopping.Register(() =\u0026gt; { var usage = app.Services.GetRequiredService\u0026lt;LicenseUsageSummary\u0026gt;(); // Todo: Substitue a different logging mechanism Console.Write(Summary(usage)); }); Developers may also use common dependency injection techniques such as property or constructor injection.\n// An ASP.NET Core MVC Controller public class MyController: Controller { public MyController(LicenseUsageSummary summary) { // use the summary information } } Developers can use the license usage summary to determine if their organization is within their current licensing tier or if they need to make adjustments to stay within compliance of Duende licensing terms.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/diagnostics/",
    "title": "Diagnostics",
    "tags": [],
    "description": "",
    "content": "Logging IdentityServer offers multiple diagnostics possibilities. The logs contains detailed information and are your best friend when troubleshooting. For security reasons the error messages returned to the UI/client are very brief - the logs always have all the details of what went wrong.\nOpen Telemetry Open Telemetry is the new standard way of emitting diagnostics information from a process and IdentityServer supports Traces (.NET Activities), Metrics and Logs.\nEvents The eventing system was created as an extension point to integrate with application monitoring systems (APM). They used to have their own different APIs so IdentityServer only provided events that could be used to call the APM\u0026rsquo;s APIs. Thanks to Open Telemetry there is now a standardized way to emit diagnostic information from a process. The events may eventually be deprecated and removed.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/aspnet_identity/",
    "title": "ASP.NET Identity Integration",
    "tags": [],
    "description": "Overview",
    "content": "ASP.NET Identity Integration An ASP.NET Identity-based implementation is provided for managing the identity database for users of IdentityServer. This implementation implements the extensibility points in IdentityServer needed to load identity data for your users to emit claims into tokens.\nTo use this library, ensure that you have the NuGet package for the ASP.NET Identity integration. It is called Duende.IdentityServer.AspNetIdentity. You can install it with:\ndotnet add package Duende.IdentityServer.AspNetIdentity Next, configure ASP.NET Identity normally in your IdentityServer host with the standard calls to AddIdentity and any other related configuration.\nThen in your Program.cs, use the AddAspNetIdentity extension method after the call to AddIdentityServer:\nbuilder.Services.AddIdentity\u0026lt;ApplicationUser, IdentityRole\u0026gt;() .AddEntityFrameworkStores\u0026lt;ApplicationDbContext\u0026gt;() .AddDefaultTokenProviders(); builder.Services.AddIdentityServer() .AddAspNetIdentity\u0026lt;ApplicationUser\u0026gt;(); AddAspNetIdentity requires as a generic parameter the class that models your user for ASP.NET Identity (and the same one passed to AddIdentity to configure ASP.NET Identity). This configures IdentityServer to use the ASP.NET Identity implementations of IUserClaimsPrincipalFactory to convert the user data into claims, IResourceOwnerPasswordValidator to support the password grant type, and IProfileService which uses the IUserClaimsPrincipalFactory to add claims to tokens. It also configures some of ASP.NET Identity\u0026rsquo;s options for use with IdentityServer (such as claim types to use and authentication cookie settings).\nIf you need to use your own implementation of IUserClaimsPrincipalFactory, then that is supported. Our implementation of the IUserClaimsPrincipalFactory will use the decorator pattern to encapsulate yours. For this to work properly, ensure that your implementation is registered in the DI system prior to calling the IdentityServer AddAspNetIdentity extension method.\nThe IUserProfileService interface has two methods that IdentityServer uses to interact with the user store. The profile service added for Asp.Net Identity implements GetProfileDataAsync by invoking the IUserClaimsPrincipalFactory implementation registered in the dependency injection cotainer. The other method on IProfileService is IsActiveAsync which is used in various places in IdentityServer to validate that the user is (still) active. There is no built in concept in Asp.Net Identity to deactive users, so our implementation is simply hard coded to return true. If you extend the Asp.Net Identity user with enabled/disabled functionality you should derive from our ProfileService and override IsUserActiveAsync(TUser user) to check your custom enabled/disabled flags.\nTemplate Alternatively, you can use the isaspid template to create a starter IdentityServer host project configured to use ASP.NET Identity. See the Quickstart Documentation for a detailed walkthrough.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/services/ciba_user_notification/",
    "title": "Backchannel Authentication User Notification Service",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Services.IBackchannelAuthenticationUserNotificationService The IBackchannelAuthenticationUserNotificationService interface is used to contact users when a CIBA login request has been made. To use CIBA, you are expected to implement this interface and register it in the DI system.\nIBackchannelAuthenticationUserNotificationService APIs SendLoginRequestAsync\nSends a notification for the user to login via the BackchannelUserLoginRequest parameter.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/upgrades/v5.0_to_v5.1/",
    "title": "Duende IdentityServer v5.0 to v5.1",
    "tags": [],
    "description": "",
    "content": "This upgrade guide covers upgrading from Duende IdentityServer v5.0 to v5.1 (release notes). Fortunately there\u0026rsquo;s not much to do :)\nStep 1: Update NuGet package In your IdentityServer host project, update the version of the NuGet. For example in your project file:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;5.0.0\u0026#34; /\u0026gt; would change to:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;5.1.0\u0026#34; /\u0026gt; Step 2: Update Database Schema (if needed) If you are using the Duende.IdentityServer.EntityFramework package as the implementation for the database for your operational data, then there is a small database schema update. This includes:\nA new index on the ConsumedTime column in the PersistedGrants table (more details). If you\u0026rsquo;re using EntityFramework Core migrations as the mechanism for managing schema changes over time, the commands below will update those migrations with the new changes. Note that you might need to adjust based on your specific organization of the migration files.\ndotnet ef migrations add Update_DuendeIdentityServer_v5_1 -c PersistedGrantDbContext -o Data/Migrations/IdentityServer/PersistedGrantDb Then to apply those changes to your database:\ndotnet ef database update -c PersistedGrantDbContext Some organizations prefer to use other tools for managing schema changes. You\u0026rsquo;re free to manage your schema however you see fit, as long as the entities can be successfully mapped. Even if you\u0026rsquo;re not going to ultimately use Entity Framework migrations to manage your database changes, generating a migration can be a useful development step to get an idea of what needs to be done.\nStep 3: Done! That\u0026rsquo;s it. Of course, at this point you can and should test that your IdentityServer is updated and working properly.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/stores/signing_key_store/",
    "title": "Signing Key Store",
    "tags": [],
    "description": "",
    "content": "Duende.IdentityServer.Stores.ISigningKeyStore Used to dynamically load client configuration.\n/// \u0026lt;summary\u0026gt; /// Interface to model storage of serialized keys. /// \u0026lt;/summary\u0026gt; public interface ISigningKeyStore { /// \u0026lt;summary\u0026gt; /// Returns all the keys in storage. /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task\u0026lt;IEnumerable\u0026lt;SerializedKey\u0026gt;\u0026gt; LoadKeysAsync(); /// \u0026lt;summary\u0026gt; /// Persists new key in storage. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task StoreKeyAsync(SerializedKey key); /// \u0026lt;summary\u0026gt; /// Deletes key from storage. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;id\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task DeleteKeyAsync(string id); } SerializedKey /// \u0026lt;summary\u0026gt; /// Serialized key. /// \u0026lt;/summary\u0026gt; public class SerializedKey { /// \u0026lt;summary\u0026gt; /// Version number of serialized key. /// \u0026lt;/summary\u0026gt; public int Version { get; set; } /// \u0026lt;summary\u0026gt; /// Key identifier. /// \u0026lt;/summary\u0026gt; public string Id { get; set; } /// \u0026lt;summary\u0026gt; /// Date key was created. /// \u0026lt;/summary\u0026gt; public DateTime Created { get; set; } /// \u0026lt;summary\u0026gt; /// The algorithm. /// \u0026lt;/summary\u0026gt; public string Algorithm { get; set; } /// \u0026lt;summary\u0026gt; /// Contains X509 certificate. /// \u0026lt;/summary\u0026gt; public bool IsX509Certificate { get; set; } /// \u0026lt;summary\u0026gt; /// Serialized data for key. /// \u0026lt;/summary\u0026gt; public string Data { get; set; } /// \u0026lt;summary\u0026gt; /// Indicates if data is protected. /// \u0026lt;/summary\u0026gt; public bool DataProtected { get; set; } } The Data property contains a copy of all of the values (and more) and is considered authoritative by IdentityServer, thus most of the other property values are considered informational and read-only.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/configuration/dcr/",
    "title": "Dynamic Client Registration",
    "tags": [],
    "description": "",
    "content": "Dynamic Client Registration Dynamic Client Registration (DCR) is the process of registering OAuth clients dynamically. The client provides information about itself and specifies its desired configuration in an HTTP request to the configuration endpoint. The endpoint will then create the necessary client configuration and return an HTTP response describing the new client, if the request is authorized and valid.\nDCR eliminates the need for a manual registration process, making it more efficient and less time-consuming to register new clients.\nInstallation and Hosting Authorization Calling the Registration Endpoint Customization Reference "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/upgrades/is4_v4_to_dis_v6/",
    "title": "IdentityServer4 v4.1 to Duende IdentityServer v6",
    "tags": [],
    "description": "",
    "content": "This upgrade guide covers upgrading from IdentityServer4 v4.1.x to Duende IdentityServer v6.\nWith any major release, there is always the possibility of some breaking changes. This issue tracks the list of updates where a breaking change might affect your use of IdentityServer. It would be useful to review it to understand if any of these changes affect you.\nStep 1: Update to .NET 6 In your IdentityServer host project, update the version of the .NET framework. For example in your project file:\n\u0026lt;TargetFramework\u0026gt;netcoreapp3.1\u0026lt;/TargetFramework\u0026gt; would change to:\n\u0026lt;TargetFramework\u0026gt;net6.0\u0026lt;/TargetFramework\u0026gt; Also, any other NuGets that you were previously using that targeted an older version of .NET should be updated. For example, Microsoft.EntityFrameworkCore.SqlServer or Microsoft.AspNetCore.Authentication.Google. Depending on what your application was using, there may or may not be code changes based on those updated NuGet packages.\nStep 2: Update the IdentityServer NuGet package In your IdentityServer host project, update the IdentityServer NuGet being used from IdentityServer4 to Duende IdentityServer. For example in your project file:\n\u0026lt;PackageReference Include=\u0026#34;IdentityServer4\u0026#34; Version=\u0026#34;4.1.1\u0026#34; /\u0026gt; would change to the latest version of Duende IdentityServer:\n\u0026lt;PackageReference Include=\u0026#34;Duende.IdentityServer\u0026#34; Version=\u0026#34;6.0.0\u0026#34; /\u0026gt; If you\u0026rsquo;re using any of the other IdentityServer4 packages, such as IdentityServer4.EntityFramework or IdentityServer4.AspNetIdentity, then there are Duende equivalents such as Duende.IdentityServer.EntityFramework and Duende.IdentityServer.AspNetIdentity, respectively.\nStep 3: Update Namespaces Anywhere IdentityServer4 was used as a namespace, replace it with Duende.IdentityServer. For example:\nusing IdentityServer4; using IdentityServer4.Models; would change to:\nusing Duende.IdentityServer; using Duende.IdentityServer.Models; Step 4: Remove AddDeveloperSigningCredential If in ConfigureServices in your Startup.cs you were previously using AddDeveloperSigningCredential, that can be removed. Automatic key management is now a built-in feature.\nStep 5: Update Database Schema (if needed) If you are using a database for your configuration and operational data, then there are database schema updates. These include:\nA new Keys table for the automatic key management feature in the operational database. A new RequireResourceIndicator boolean column on the ApiResources table in the configuration database. A new index on the ConsumedTime column in the PersistedGrants table (more details). A new table called IdentityProviders for storing the OIDC provider details (more details). Add missing columns for created, updated, etc to EF entities (more details). Add unique constraints to EF tables where duplicate records not allowed (more details). IdentityServer is abstracted from the data store on multiple levels, so the exact steps involved in updating your data store will depend on your implementation details.\nCustom Store Implementations The core of IdentityServer is written against the store interfaces, which abstract all the implementation details of actually storing data. If your IdentityServer implementation includes a custom implementation of those stores, then you will have to determine how best to include the changes in the model in the underlying data store and make any necessary changes to schemas, if your data store requires that.\nDuende.IdentityServer.EntityFramework We also provide a default implementation of the stores in the Duende.IdentityServer.EntityFramework package, but this implementation is still highly abstracted because it is usable with any database that has an EF provider. Different database vendors have very different dialects of sql that have different syntax and type systems, so we don\u0026rsquo;t provide schema changes directly. Instead, we provide the Entity Framework entities and mappings which can be used with Entity Framework\u0026rsquo;s migrations feature to generate the schema updates that are needed in your database.\nTo generate migrations, run the commands below. Note that you might need to adjust paths based on your specific organization of the migration files.\ndotnet ef migrations add UpdateToDuende_v6_0 -c PersistedGrantDbContext -o Data/Migrations/IdentityServer/PersistedGrantDb dotnet ef migrations add UpdateToDuende_v6_0 -c ConfigurationDbContext -o Data/Migrations/IdentityServer/ConfigurationDb You will likely get the warning \u0026ldquo;An operation was scaffolded that may result in the loss of data. Please review the migration for accuracy.\u0026rdquo;. This is due to the fact that in this release the column length for redirect URIs (for both login and logout) was reduced from 2000 to 400. This was needed because some database providers have limits on index size. This should not affect you unless you are using redirect URIs greater than 400 characters.\nThen to apply those changes to your database:\ndotnet ef database update -c PersistedGrantDbContext dotnet ef database update -c ConfigurationDbContext Some organizations prefer to use other tools for managing schema changes. You\u0026rsquo;re free to manage your schema however you see fit, as long as the entities can be successfully mapped. Even if you\u0026rsquo;re not going to ultimately use Entity Framework migrations to manage your database changes, generating a migration can be a useful development step to get an idea of what needs to be done.\nStep 6: Migrating signing keys (optional) In IdentityServer4, the common way to configure a signing key in Startup was to use AddSigningCredential() and provide key material (such as an X509Certificate2). In Duende IdentityServer the automatic key management feature can manage those keys for you.\nSince client apps and APIs commonly cache the key material published from the discovery document then when upgrading you need to consider how those applications will handle an upgraded token server with a new and different signing key.\nIf while upgrading you can simply restart all of the client apps and APIs that depend on those signing keys, then you can remove the old signing key and start to use the new automatic key management. When they are restarted they will reload the discovery document and thus be aware of the new signing key.\nBut if you can\u0026rsquo;t restart all the client apps and APIs then you will need to maintain the prior signing key while still publishing the new keys produced from the automatic key management feature. This can be achieved by still using AddSigningCredential(). A signing key registered with AddSigningCredential() will take precedence over any keys created by the automatic key management feature. Once the client apps and APIs have updated their caches (typically after 24 hours) then you can remove the prior signing key by removing the call to AddSigningCredential() and redeploy your IdentityServer.\nStep 7: Verify Data Protection Configuration IdentityServer depends on ASP.NET Data Protection. Data Protection encrypts and signs data using keys managed by ASP.NET. Those keys are isolated by application name, which by default is set to the content root path of the host. This prevents multiple applications from sharing encryption keys, which is necessary to protect your encryption against certain forms of attack. However, this means that if your content root path changes, the default settings for data protection will prevent you from using your old keys. Beginning in .NET 6, the content root path is now normalized so that it ends with a directory separator. This means that your content root path might change when you upgrade to .NET 6. This can be mitigated by explicitly setting the application name and removing the separator character. See Microsoft\u0026rsquo;s documentation for more information.\nStep 8: Done! That\u0026rsquo;s it. Of course, at this point you can and should test that your IdentityServer is updated and working properly.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/configuration/",
    "title": "Configuration API",
    "tags": [],
    "description": "Overview",
    "content": "(Added in 6.3)\nThe Configuration API is a collection of endpoints that allow for management and configuration of an IdentityServer implementation. The Configuration API can be hosted either separately or within the IdentityServer implementation, and is distributed through the separate Duende.IdentityServer.Configuration NuGet package.\nIn this initial release, the Configuration API supports the Dynamic Client Registration protocol.\nThe Configuration API is part of the IdentityServer Business Edition or higher. The same license and special offers apply.\nThe Configuration API\u0026rsquo;s source code is available on github.\nSamples of the Configuration API are available here.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/ui/federation/",
    "title": "Federation Gateway",
    "tags": [],
    "description": "",
    "content": "Federation means that your IdentityServer offers authentication methods that use external authentication providers.\nIf you offer a number of these external authentication methods, often the term Federation Gateway is used to describe this architectural approach.\nGenerally, this architecture allows shielding your client applications from the complexities of your authentication workflows and business requirements that go along with them.\nYour clients only need to trust the gateway, and the gateway coordinates all the communication and trust relationships with the external providers. This might involve switching between different protocols, token types, claim types etc. Also the gateway can make sure that all claims and identities that ultimately arrive at the client applications are trustworthy and in a format that the client expects.\nThere are a number of scenarios where this approach is commonly used.\nMultiple authentication methods for users Maybe your users should have multiple options how they can sign-in/up, e.g.\nusername/password or a commercial provider like Google or Microsoft Account username/password or a commercial provider for customers, and Active Directory or Azure AD for employees Integration of on-premise products with customer identity systems If you are building on-premise products, you have to integrate with a multitude of customer authentication systems. Maintaining variations of your business software for each product you have to integrate with, makes your software hard to maintain.\nWith a federation gateway, you only need to adapt to these external systems at the gateway level, all of your business applications are shielded from the technical details.\nSoftware-as-a-Service It\u0026rsquo;s very common to offer federation with your customers\u0026rsquo; authentication systems in SaaS scenarios. This way your customers get single-sign-on to your applications without having to explicitly create accounts in your identity system.\nSupport for external authentication methods IdentityServer leverages the ASP.NET Core authentication infrastructure for communicating with external providers. This means that every authentication system that is supported by ASP.NET Core, can also be used in the context of IdentityServer. This includes support for commercial providers like Google, GitHub or LinkedIn (and many more) as well as any OpenID Connect, SAML2p or WS-Federation based systems.\nSee the Integrating with External Providers section for more details.\nHome Realm Discovery The process of selecting the \u0026ldquo;best\u0026rdquo; authentication workflow for a user (especially when you have multiple authentication methods) is called Home Realm Discovery (or HRD for short).\nSince users are typically anonymous when they arrive at the gateway, you need some sort of hint to optimize the login workflow, e.g.\nyou present a list of available authentication methods to the user. This might work for simpler scenarios, but probably not if you have a lot of choices or if this would reveal your customers\u0026rsquo; authentication systems you ask the user for an identifier (e.g. email address) and have a way to infer the right external authentication method from that id. This is a common technique for SaaS systems. the client application can give a hint to the gateway via a custom protocol parameter of IdentityServer\u0026rsquo;s built-in support for the idp parameter on acr_values. In some case the client already knows the right authentication method, e.g. when your customers access your software via a customer-specific URL (see here). you restrict the available authentication methods per client in the client configuration using the IdentityProviderRestrictions property (see here) Every system is slightly different. Always start with the desired user experience, and then choose from the above options (or combinations) to implement the required flow.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/tokens/pop/",
    "title": "Proof-of-Possession Access Tokens",
    "tags": [],
    "description": "",
    "content": "Proof-of-Possession Access Tokens By default, OAuth access tokens are so called bearer tokens. This means they are not bound to a client and anybody who possesses the token can use it. The security concern here is that a leaked token could be used by a (malicious) third party to impersonate the client and/or user.\nOn the other hand, Proof-of-Possession (PoP) tokens are bound to the client that requested the token. This is also often called sender constraining. This is done by using cryptography to prove that the sender of the token knows an additional secret only known to the client.\nThis proof is called the confirmation method and is expressed via the standard cnf claim,e.g.:\n{ \u0026#34;iss\u0026#34;: \u0026#34;https://localhost:5001\u0026#34;, \u0026#34;iat\u0026#34;: 1609932801, \u0026#34;exp\u0026#34;: 1609936401, \u0026#34;aud\u0026#34;: \u0026#34;urn:resource1\u0026#34;, \u0026#34;client_id\u0026#34;: \u0026#34;web_app\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;88421113\u0026#34;, \u0026#34;cnf\u0026#34;: \u0026#34;confirmation_method\u0026#34; } When using reference tokens, the cnf claim will be returned from the introspection endpoint.\nProof-of-Possession Styles IdentityServer supports two styles of proof of possession tokens:\nMutual TLS DPoP "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/tokens/reference/",
    "title": "Reference Tokens",
    "tags": [],
    "description": "",
    "content": "When using reference tokens, Duende IdentityServer stores the contents of the token in the persisted grant store and issues a unique identifier for this token back to the client.\nThe consumer of the token must use the introspection endpoint to validate the token.\nYou can set the client\u0026rsquo;s token type using the following client setting:\nclient.AccessTokenType = AccessTokenType.Reference; Enabling an API to consume reference tokens The introspection endpoint requires authentication - since the client of an introspection endpoint is typically an API, you configure the secret on the ApiResource:\nvar api = new ApiResource(\u0026#34;api1\u0026#34;) { ApiSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) } Scopes = { \u0026#34;read\u0026#34;, \u0026#34;write\u0026#34; } } Store Keys and Handles Reference tokens have a key, which is an internal identifier used in the data store, and a handle, which is an external value that is given to the client and never stored. The handle is 32 bytes of cryptographically strong random data encoded as a hex string with a suffix to indicate the encoding (\u0026quot;-1\u0026quot;). This is the value that clients use as the access token. The handle, plus additional metadata indicating the type of grant, is hashed with the SHA-256 algorithm to produce the key. When IdentityServer is presented with a handle, it recomputes the key in order to retrieve the persisted grant record for the reference token. The intention of this separation of key and handle is that read access to the store will not reveal sensitive data. An attacker could read the keys in the data store, but those keys were produced using a one-way hash, so the attacker would not be able to use the keys to recover the handles (the actual access tokens).\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/tokens/authentication/",
    "title": "Client Authentication",
    "tags": [],
    "description": "",
    "content": "Client Authentication Overview Shared Secrets Private Key JWTs TLS Client Certificates "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/deployment/",
    "title": "Deployment",
    "tags": [],
    "description": "",
    "content": "Deployment Because IdentityServer is made up of middleware and services that you use within an ASP.NET Core application, it can be hosted and deployed with the same diversity of technology as any other ASP.NET Core application. You have the choice about\nwhere to host your IdentityServer (on-prem or in the cloud, and if in the cloud, which one?) which web server to use (IIS, Kestrel, Nginx, Apache, etc) how you\u0026rsquo;ll scale and load-balance the deployment what kind of deployment artifacts you\u0026rsquo;ll publish (files in a folder, containers, etc) how you\u0026rsquo;ll manage the environment (a managed app service in the cloud, a Kubernetes cluster, etc) While this is a lot of decisions to make, this also means that your IdentityServer implementation can be built, deployed, hosted, and managed with the same technology that you\u0026rsquo;re using for any other ASP.NET applications that you have.\nMicrosoft publishes extensive advice and documentation about deploying ASP.NET Core applications, and it is applicable to IdentityServer implementations. We\u0026rsquo;re not attempting to replace that documentation - or the documentation for other tools that you might be using in your environment. Rather, this section of our documentation focuses on IdentityServer-specific deployment and hosting considerations.\nOur experience has been that these topics are very important. Some of our most common support requests are related to Data Protection and Load Balancing, so we strongly encourage you to review those pages, along with the rest of this chapter before deploying IdentityServer to production.\nProxy Servers and Load Balancers ASP.NET Core Data Protection IdentityServer Data Stores Distributed Caching Health Checks "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/response_handling/http_response_writer/",
    "title": "IHttpResponseWriter",
    "tags": [],
    "description": "",
    "content": "The IHttpResponseWriter interface is the contract for services that can produce HTTP responses for IEndpointResults. This is a low level abstraction that is intended to be used if you need to customize the serialization, encoding, or HTTP headers in a response from a protocol endpoint.\nDuende.IdentityServer.Hosting.IHttpResponseWriter /// \u0026lt;summary\u0026gt; /// Contract for a service that writes appropriate http responses for \u0026lt;see /// cref=\u0026#34;IEndpointResult\u0026#34;/\u0026gt; objects. /// \u0026lt;/summary\u0026gt; public interface IHttpResponseWriter\u0026lt;in T\u0026gt; where T : IEndpointResult { /// \u0026lt;summary\u0026gt; /// Writes the endpoint result to the HTTP response. /// \u0026lt;/summary\u0026gt; Task WriteHttpResponse(T result, HttpContext context); } Duende.IdentityServer.Hosting.IEndpointResult /// \u0026lt;summary\u0026gt; /// An \u0026lt;see cref=\u0026#34;IEndpointResult\u0026#34;/\u0026gt; is the object model that describes the /// results that will returned by one of the protocol endpoints provided by /// IdentityServer, and can be executed to produce an HTTP response. /// \u0026lt;/summary\u0026gt; public interface IEndpointResult { /// \u0026lt;summary\u0026gt; /// Executes the result to write an http response. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;context\u0026#34;\u0026gt;The HTTP context.\u0026lt;/param\u0026gt; Task ExecuteAsync(HttpContext context); } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/stores/server_side_sessions/",
    "title": "Server-Side Session Store",
    "tags": [],
    "description": "Reference",
    "content": "Duende.IdentityServer.Stores.IServerSideSessionStore Used to persist users\u0026rsquo; authentication session data when using the server-side sessions feature.\n/// \u0026lt;summary\u0026gt; /// User session store /// \u0026lt;/summary\u0026gt; public interface IServerSideSessionStore { /// \u0026lt;summary\u0026gt; /// Retrieves a session /// \u0026lt;/summary\u0026gt; Task\u0026lt;ServerSideSession\u0026gt; GetSessionAsync(string key, CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// Creates a session /// \u0026lt;/summary\u0026gt; Task CreateSessionAsync(ServerSideSession session, CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// Updates a session /// \u0026lt;/summary\u0026gt; Task UpdateSessionAsync(ServerSideSession session, CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// Deletes a session /// \u0026lt;/summary\u0026gt; Task DeleteSessionAsync(string key, CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// Gets sessions for a specific subject id and/or session id /// \u0026lt;/summary\u0026gt; Task\u0026lt;IReadOnlyCollection\u0026lt;ServerSideSession\u0026gt;\u0026gt; GetSessionsAsync(SessionFilter filter, CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// Deletes sessions for a specific subject id and/or session id /// \u0026lt;/summary\u0026gt; Task DeleteSessionsAsync(SessionFilter filter, CancellationToken cancellationToken = default); /// \u0026lt;summary\u0026gt; /// Queries sessions based on filter /// \u0026lt;/summary\u0026gt; Task\u0026lt;QueryResult\u0026lt;ServerSideSession\u0026gt;\u0026gt; QuerySessionsAsync(SessionQuery filter = null, CancellationToken cancellationToken = default); } ServerSideSession /// \u0026lt;summary\u0026gt; /// A user session /// \u0026lt;/summary\u0026gt; public class ServerSideSession { /// \u0026lt;summary\u0026gt; /// The key /// \u0026lt;/summary\u0026gt; public string Key { get; set; } = default!; /// \u0026lt;summary\u0026gt; /// The cookie handler scheme /// \u0026lt;/summary\u0026gt; public string Scheme { get; set; } = default!; /// \u0026lt;summary\u0026gt; /// The subject ID /// \u0026lt;/summary\u0026gt; public string SubjectId { get; set; } = default!; /// \u0026lt;summary\u0026gt; /// The session ID /// \u0026lt;/summary\u0026gt; public string SessionId { get; set; } = default!; /// \u0026lt;summary\u0026gt; /// The display name for the user /// \u0026lt;/summary\u0026gt; public string DisplayName { get; set; } /// \u0026lt;summary\u0026gt; /// The creation time /// \u0026lt;/summary\u0026gt; public DateTime Created { get; set; } /// \u0026lt;summary\u0026gt; /// The renewal time /// \u0026lt;/summary\u0026gt; public DateTime Renewed { get; set; } /// \u0026lt;summary\u0026gt; /// The expiration time /// \u0026lt;/summary\u0026gt; public DateTime? Expires { get; set; } /// \u0026lt;summary\u0026gt; /// The serialized ticket /// \u0026lt;/summary\u0026gt; public string Ticket { get; set; } = default!; } The Ticket property contains a copy of all of the values (and more) and is considered authoritative by IdentityServer, thus most of the other property values are considered informational and read-only.\nSessionFilter /// \u0026lt;summary\u0026gt; /// Filter to query user sessions /// \u0026lt;/summary\u0026gt; public class SessionFilter { /// \u0026lt;summary\u0026gt; /// The subject ID /// \u0026lt;/summary\u0026gt; public string SubjectId { get; init; } /// \u0026lt;summary\u0026gt; /// The sesion ID /// \u0026lt;/summary\u0026gt; public string SessionId { get; init; } } SessionQuery /// \u0026lt;summary\u0026gt; /// Filter to query all user sessions /// \u0026lt;/summary\u0026gt; public class SessionQuery { /// \u0026lt;summary\u0026gt; /// The token indicating the prior results. /// \u0026lt;/summary\u0026gt; public string ResultsToken { get; set; } /// \u0026lt;summary\u0026gt; /// If true, requests the previous set of results relative to the ResultsToken, otherwise requests the next set of results relative to the ResultsToken. /// \u0026lt;/summary\u0026gt; public bool RequestPriorResults { get; set; } /// \u0026lt;summary\u0026gt; /// The number requested to return /// \u0026lt;/summary\u0026gt; public int CountRequested { get; set; } /// \u0026lt;summary\u0026gt; /// The subject ID used to filter the results. /// \u0026lt;/summary\u0026gt; public string SubjectId { get; init; } /// \u0026lt;summary\u0026gt; /// The sesion ID used to filter the results. /// \u0026lt;/summary\u0026gt; public string SessionId { get; init; } /// \u0026lt;summary\u0026gt; /// The user display name used to filter the results. /// \u0026lt;/summary\u0026gt; public string DisplayName { get; init; } } QueryResult /// \u0026lt;summary\u0026gt; /// Query result for paged data /// \u0026lt;/summary\u0026gt; public class QueryResult\u0026lt;T\u0026gt; { /// \u0026lt;summary\u0026gt; /// The token that indicates these results. This is used for more results in subsequent queries. /// If null, then there were no more results. /// \u0026lt;/summary\u0026gt; public string ResultsToken { get; init; } /// \u0026lt;summary\u0026gt; /// True if there is a previous set of results. /// \u0026lt;/summary\u0026gt; public bool HasPrevResults { get; set; } /// \u0026lt;summary\u0026gt; /// True if there is another set of results. /// \u0026lt;/summary\u0026gt; public bool HasNextResults { get; set; } /// \u0026lt;summary\u0026gt; /// The total count (if available). /// \u0026lt;/summary\u0026gt; public int? TotalCount { get; init; } /// \u0026lt;summary\u0026gt; /// The total pages (if available). /// \u0026lt;/summary\u0026gt; public int? TotalPages { get; init; } /// \u0026lt;summary\u0026gt; /// The current (if available). /// \u0026lt;/summary\u0026gt; public int? CurrentPage { get; init; } /// \u0026lt;summary\u0026gt; /// The results. /// \u0026lt;/summary\u0026gt; public IReadOnlyCollection\u0026lt;T\u0026gt; Results { get; init; } = default!; } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/stores/pushed_authorization_request_store/",
    "title": "Pushed Authorization Request Store",
    "tags": [],
    "description": "",
    "content": "The pushed authorization request store is responsible for creating, retrieving, and consuming pushed authorization requests.\nDuende.IdentityServer.Stores.IPushedAuthorizationRequestStore /// \u0026lt;summary\u0026gt; /// The interface for a service that stores pushed authorization requests. /// \u0026lt;/summary\u0026gt; public interface IPushedAuthorizationRequestStore { /// \u0026lt;summary\u0026gt; /// Stores the pushed authorization request. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;pushedAuthorizationRequest\u0026#34;\u0026gt;The request.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task StoreAsync(PushedAuthorizationRequest pushedAuthorizationRequest); /// \u0026lt;summary\u0026gt; /// Consumes the pushed authorization request, indicating that it should not /// be used again. Repeated use could indicate some form of replay attack, /// but also could indicate that an end user refreshed their browser or /// otherwise retried a request that consumed the pushed authorization /// request. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;referenceValueHash\u0026#34;\u0026gt;The hash of the reference value of the /// pushed authorization request. The reference value is the identifier /// within the request_uri parameter.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; Task ConsumeByHashAsync(string referenceValueHash); /// \u0026lt;summary\u0026gt; /// Gets the pushed authorization request. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;referenceValueHash\u0026#34;\u0026gt;The hash of the reference value of the /// pushed authorization request. The reference value is the identifier /// within the request_uri parameter.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;The pushed authorization request, or null if the request does /// not exist or was previously consumed. /// \u0026lt;/returns\u0026gt; Task\u0026lt;PushedAuthorizationRequest?\u0026gt; GetByHashAsync(string referenceValueHash); } Duende.IdentityServer.Models.PushedAuthorizationRequest /// \u0026lt;summary\u0026gt; /// Represents a persisted Pushed Authorization Request. /// \u0026lt;/summary\u0026gt; public class PushedAuthorizationRequest { /// \u0026lt;summary\u0026gt; /// The hash of the identifier within this pushed request\u0026#39;s request_uri /// value. Request URIs that IdentityServer produces take the form /// urn:ietf:params:oauth:request_uri:{ReferenceValue}. /// \u0026lt;/summary\u0026gt; public string ReferenceValueHash { get; set; } /// \u0026lt;summary\u0026gt; /// The UTC time at which this pushed request will expire. The Pushed /// request will be used throughout the authentication process, beginning /// when it is passed to the authorization endpoint by the client, and then /// subsequently after user interaction, such as login and/or consent occur. /// If the expiration time is exceeded before a response to the client can /// be produced, IdentityServer will raise an error, and the user will be /// redirected to the IdentityServer error page. /// \u0026lt;/summary\u0026gt; public DateTime ExpiresAtUtc { get; set; } /// \u0026lt;summary\u0026gt; /// The data protected content of the pushed authorization request. /// \u0026lt;/summary\u0026gt; public string Parameters { get; set; } } "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/ui/ciba/",
    "title": "Client Initiated Backchannel Authentication (CIBA)",
    "tags": [],
    "description": "",
    "content": "Duende IdentityServer supports the Client-Initiated Backchannel Authentication Flow (also known as CIBA). CIBA is one of the requirements to support the Financial-grade API compliance.\nCIBA is included in IdentityServer Enterprise Edition.\nDuende IdentityServer supports the poll mode to allow a client to obtain the results of a backchannel login request.\nOverview Normally when using OpenID Connect, a user accesses a client application on the same device they use to login to the OpenID Connect provider. For example, a user (via the browser) uses a web app (the client) and that same browser is redirected for the user to login at IdentityServer (the OpenID Connect provider), and this all takes place on the user\u0026rsquo;s device (e.g. their computer). Another example would be that a user uses a mobile app (the client), and it launches the browser for the user to login at IdentityServer (the OpenID Connect provider), and this all takes place on the user\u0026rsquo;s device (e.g. their mobile phone).\nCIBA allow the user to interact with the client application on a different device than the user uses to login. For example, the user can use a kiosk at the public library to access their data, but they perform the actual login on their mobile phone. Another example would be a user is at the bank and the bank teller wishes to access the user\u0026rsquo;s account, so the user logs into mobile phone to grant that access.\nA nice feature of this workflow is that the user does not enter their credentials into the device the client application is accessed from, and instead a higher trust device can be used for the login step.\nCIBA Workflow in IdentityServer Below is a diagram that shows the high level steps involved with the CIBA workflow and the supporting services involved.\nStep 1: IdentityServer exposes a backchannel authentication request endpoint that the client uses to initiate the CIBA workflow.\nStep 2: Once client authentication and basic request parameter validation is performed, the user for which the request is being made must be identified. This is done by using the IBackchannelAuthenticationUserValidator service in DI, which you are required to implement and register in the DI system. The ValidateRequestAsync method will validate the request parameters and return a result which will contain the user\u0026rsquo;s sub (subject identifier) claim.\nStep 3: Once a user has successfully been identified, then a record representing the pending login request is created in the Backchannel Authentication Request Store.\nStep 4: Next, the user needs to be notified of the login request. This is done by using the IBackchannelAuthenticationUserNotificationService service in DI, which you are required to implement and register in the DI system. The SendLoginRequestAsync method should contact the user with whatever mechanism is appropriate (e.g. email, text message, push notification, etc.), and presumably provide the user with instructions (perhaps via a link, but other approaches are conceivable) to start the login and consent process. This method is passed a BackchannelUserLoginRequest which will contain all the contextual information needed to send to the user (the InternalId being the identifier for this login request which is needed when completing the request \u0026ndash; see below).\nStep 5: Next, the user should be presented with the information for the login request (e.g. via a web page at IdentityServer, or via any other means appropriate). The IBackchannelAuthenticationInteractionService can be used to access an indivdual BackchannelUserLoginRequest by its InternalId. Once the user has consented and allows the login, then the CompleteLoginRequestAsync method should be used to record the result (including which scopes the user has granted).\nStep 6: Finally, the client, after polling for the result, will finally be issued the tokens it\u0026rsquo;s requested (or a suitable error if the user has denied the request or it has timed out).\nWe provide a sample for the interactive pages a user might be presented with for the CIBA workflow.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/upgrades/",
    "title": "Upgrading",
    "tags": [],
    "description": "",
    "content": "Upgrading Upgrading to a new IdentityServer version is done by updating the Nuget package and handling any breaking changes. Some updates contain changes to the stores used by IdentityServer that requires database schema updates. If you are using our Entity Framework based stores we recommend using Entity Framework Migrations.\nUpgrading from version 7.0 to 7.1 IdentityServer v7.1 includes support for .NET 9 and many other smaller fixes and enhancements. There are no schema changes needed for IdentityServer 7.1. There are two changes that may require small code changes for a minority of users:\nIdentityModel package renamed to Duende.IdentityModel which may require code updates to referenced namespaces and types. ClientConfigurationStore now uses IConfigurationDbContext. Upgrading from version 6 to version 7 We recommend upgrading incrementally through each minor version of the 6.x release before upgrading from 6.3 to 7.0. At each step, update the NuGet package, apply database schema changes (if any), and check for breaking changes that affect your implementation.\nUpgrading from version 6.0 There are changes to the stores which requires database schema updates. If you use the Entity Framework based stores you need to apply the upgrade and database migrations from 6.0 - 6.1. Then continue with \u0026ldquo;Upgrading from version 6.2\u0026rdquo; below. If you are experienced with the Entity Framework Migrations Tooling you may also create a single migration 6.0-7.0.\nUpgrading from version 6.1 There no schema changes or other breaking changes between 6.1 abd 6.2. Follow the \u0026ldquo;Upgrading from version 6.2\u0026rdquo; guide below.\nUpgrading from version 6.2 There are changes to the stores which requires database schema updates. If you use the Entity Framework based stores you need to apply the upgrade and database migrations from 6.2 - 6.3. If you are experienced with the Entity Framework Migrations Tooling you may also create a single migration 6.2-7.0.\nThere were minor breaking changes in 6.3, most notably rotated refresh tokens are now deleted immediately on use by default. Review the list in the upgrade guide to check if any of them affect your implementation.\nThen continue with \u0026ldquo;Upgrading from version 6.3\u0026rdquo; below.\nUpgrading from version 6.3 Follow the upgrade guide version 6.3 - 7.0\nAll upgrade guides Here is a list of all upgrade guides.\nDuende IdentityServer v7.1 to v7.2 Duende IdentityServer v7.0 to v7.1 Duende IdentityServer v6.3 to v7.0 Duende IdentityServer v6.2 to v6.3 Duende IdentityServer v6.1 to v6.2 Duende IdentityServer v6.0 to v6.1 Duende IdentityServer v5.2 to v6.0 Duende IdentityServer v5.1 to v5.2 Duende IdentityServer v5.0 to v5.1 IdentityServer4 v4.1 to Duende IdentityServer v6 IdentityServer4 v3.1 to Duende IdentityServer v6 Microsoft SPA and Blazor Templates "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/upgrades/is4_v3_to_dis_v6/",
    "title": "IdentityServer4 v3.1 to Duende IdentityServer v6",
    "tags": [],
    "description": "",
    "content": "This upgrade guide covers upgrading from IdentityServer4 v3.1.x to Duende IdentityServer v6. This upgrade is a complex one because the configuration object model had some non-trivial changes from IdentityServer4 v3 to IdentityServer4 v4.\nIn short, in IdentityServer4 v3 there was a parent-child relationship between the ApiResources and the ApiScopes. Then in IdentityServer4 v4 the ApiScopes was promoted to be its own top-level configuration. This meant that the child collection under the ApiResources was renamed to ApiResourcesScopes and it contained a reference to the new top-level ApiScopes.\nIf you were using a database for this configuration, then this means that configuration changed from a parent-child, to two top-level tables with a join table between them (to put it loosely). The new ApiResourcesScopes table was created to act as that join table.\nAlso, all the prior tables that were associated with the ApiResources were prefixed with \u0026ldquo;Api\u0026rdquo; and that prefix became \u0026ldquo;ApiResource\u0026rdquo; to better indicate the association. Then any new tables associated with the new top-level ApiScopes have the \u0026ldquo;ApiScope\u0026rdquo; prefix to indicate that association.\nIn order to properly update the database, the easiest approach is to first update to the latest of IdentityServer4 v4. Once that\u0026rsquo;s complete, then it\u0026rsquo;s very simple to move to Duende IdentityServer v5.\nThere is a sample project for this migration exercise. It is located here.\nStep 1: Update NuGet package to IdentityServer4 v4.x In your IdentityServer host project, update the IdentityServer NuGet being used from IdentityServer4 v3 to IdentityServer4 v4. For example in your project file:\n\u0026lt;PackageReference Include=\u0026#34;IdentityServer4\u0026#34; Version=\u0026#34;3.1.4\u0026#34; /\u0026gt; would change to the latest version of IdentityServer4:\n\u0026lt;PackageReference Include=\u0026#34;IdentityServer4\u0026#34; Version=\u0026#34;4.1.2\u0026#34; /\u0026gt; If you\u0026rsquo;re using any of the other IdentityServer4 packages, such as IdentityServer4.EntityFramework or IdentityServer4.AspNetIdentity, then update those as well.\nStep 2: Update Database Schema with EF Core Migrations If you are using a database for your configuration and operational data, then there is a bit of work. The reason is that for this type of schema restructuring EntityFramework Core\u0026rsquo;s migrations can lose existing data. To handle this, the conversation from the old schema to the new will be performed by custom SQL. This is only needed for the configuration database, not the operational one so normal migrations will suffice for the operational database.\nFirst for the operational database, we can simply apply EF Core migrations. Note that you might need to adjust based on your specific organization of the migration files.\ndotnet ef migrations add Grants_v4 -c PersistedGrantDbContext -o Migrations/PersistedGrantDb Then to apply those changes to your database:\ndotnet ef database update -c PersistedGrantDbContext Next for the configuration database, we\u0026rsquo;ll also add an EF Migration with:\ndotnet ef migrations add Config_v4 -c ConfigurationDbContext -o Migrations/ConfigurationDb When you run this, you should see the warnings from EF Core about this migration possibly losing data:\nBuild started... Build succeeded. info: Microsoft.EntityFrameworkCore.Infrastructure[10403] Entity Framework Core 3.1.15 initialized \u0026#39;ConfigurationDbContext\u0026#39; using provider \u0026#39;Microsoft.EntityFrameworkCore.SqlServer\u0026#39; with options: MigrationsAssembly=IdentityServerMigrationSample, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null An operation was scaffolded that may result in the loss of data. Please review the migration for accuracy. Done. To undo this action, use \u0026#39;ef migrations remove\u0026#39; To ensure we don\u0026rsquo;t lose data, we will add a custom SQL script to run instead of the generated migration. To ensure the script is available to the migration we will include the script into the project as an embedded resource. You could devise other approaches (like simply loading the SQL script from the filesystem) based on your preferences.\nThe SQL script to include is located here. Copy it into your project folder and then configure it as an embedded resource in the csproj file:\n\u0026lt;ItemGroup\u0026gt; \u0026lt;EmbeddedResource Include=\u0026#34;ConfigurationDb_v4_delta.sql\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; Then modify the migration that was just created. Remove all of the code in the Up and Down methods are replace the Up with this code, which will execute the custom SQL script:\nusing System.IO; using Microsoft.EntityFrameworkCore.Migrations; namespace IdentityServerMigrationSample.Migrations.ConfigurationDb { public partial class Config_v4 : Migration { protected override void Up(MigrationBuilder migrationBuilder) { var assembly = typeof(Program).Assembly; using (var s = assembly.GetManifestResourceStream(\u0026#34;IdentityServerMigrationSample.ConfigurationDb_v4_delta.sql\u0026#34;)) { using (StreamReader sr = new StreamReader(s)) { var sql = sr.ReadToEnd(); migrationBuilder.Sql(sql); } } } protected override void Down(MigrationBuilder migrationBuilder) { } } } Note that given that there is no Down implementation, this is a one-way update.\nAnd now run the migration:\ndotnet ef database update -c ConfigurationDbContext And your database should now be updated.\nStep 3: Verify your configuration database data At this point, you should be able to query your migrated database and see your data in tact. This script allows you to query the new restructured tables.\nStep 4: Move onto the upgrade guide for Duende IdentityServer v6 Once your project has been updated to IdentityServer4 v4, then you can work through the guide to update from IdentityServer4 v4 to Duende IdentityServer v6 (which should be far easier). Here is the link to the next upgrade guide.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/ui/server_side_sessions/",
    "title": "Server-Side Sessions",
    "tags": [],
    "description": "Overview",
    "content": "(added in 6.1)\nOverview When a user logs in interactively, their authentication session is managed by the ASP.NET Core authentication system, and more specifically the cookie authentication handler. IdentityServer uses the state in the cookie to track the user\u0026rsquo;s subject and session identifiers (i.e. the sub and sid claims), and the list of clients the user has logged into (which is used at logout time for OIDC logout notification).\nBy default, this cookie is self-contained which means it contains all the state needed to track a user\u0026rsquo;s session. While this does allow for a stateless server for session management, cookie size could be a problem, and it makes it difficult to know how many active user sessions there are in your system or revoke those sessions from an administrative standpoint.\nIdentityServer provides a server-side session feature, which extends the ASP.NET Core cookie authentication handler to maintain this state in a server-side store, rather than putting it all into the cookie itself. This implementation is specifically designed for IdentityServer to allow for more protocol related features, such as querying for active sessions based on subject id or session id, and revoking artifacts from protocol workflows as part of that session.\nSupport for Server Side Sessions is included in IdentityServer Business Edition or higher.\nSession Management With the addition and use of server-side sessions, more interesting architectural features are possible:\nthe ability to query and manage sessions from outside the browser that a user is logged into. the ability to detect session expiration and perform cleanup both in IdentityServer as well as in the client. the ability to centralize and monitor session activity in order to achieve a system-wide inactivity timeout. Enabling server-side sessions To enable server-side sessions, use the AddServerSideSessions extension method after adding IdentityServer to the DI system:\nbuilder.Services.AddIdentityServer() .AddServerSideSessions(); By default, the store for the server-side sessions will just be kept in-memory. For production scenarios you will want to configure a durable store either by using our EntityFramework Core implementation, or you can implement the store yourself.\nOrder is important in the DI system. When using AddServerSideSessions, this call needs to come after any custom IRefreshTokenService implementation that has been registered.\nData stored server-side The data stored for the user session is the data contained in the ASP.NET Core AuthenticationTicket class. This includes all claims and the AuthenticationProperties.Items collection. The Items can be used to store any custom (string) data. The AuthenticationProperties is included in the call to SignInAsync that establishes the user session in the UI code.\nThis data will be serialized and protected using ASP.NET Core\u0026rsquo;s data protection feature to protect any user PII from being directly readable in the data store. To allow querying some of the values from the user\u0026rsquo;s session are extracted and used as indices in the store. These values are the user\u0026rsquo;s:\nsubject identifier (the sub claim value) session identifier (the sid claim value) display name (an optional and configurable claim value) If you would like to query this data based on a user\u0026rsquo;s display name, then the claim type used is configurable with the ServerSideSessions.UserDisplayNameClaimType property on the IdentityServerOptions. This claim must be included in the claims when the user\u0026rsquo;s authentication session is established.\nFor example:\nbuilder.Services.AddIdentityServer(options =\u0026gt; { options.ServerSideSessions.UserDisplayNameClaimType = \u0026#34;name\u0026#34;; // or \u0026#34;email\u0026#34; perhaps }) .AddServerSideSessions(); IServerSideSessionStore The IServerSideSessionStore is the abstraction for storing the server-side session.\nA EntityFramework Core implementation is already provided as part of our operational store, but you can implement the interface yourself for other backing implementations.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/samples/",
    "title": "Samples",
    "tags": [],
    "description": "",
    "content": "Samples We have a collection of runnable samples that show how to use IdentityServer and configure client applications in a variety of scenarios. Most of the samples include both their own IdentityServer implementation and the clients and APIs needed to demonstrate the illustrated functionality. The \u0026ldquo;Basics\u0026rdquo; samples use a shared IdentityServer implementation, and some of the BFF samples use our public demo instance of IdentityServer.\nBasics User Interaction ASP.NET Identity Integration Requesting tokens Clients Diagnostics Configuration API Miscellaneous BFF (Backend For Frontend) The source code for the samples is in our samples repository.\nFeel free to ask the developer community if you are looking for a particular sample and can\u0026rsquo;t find it here.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/upgrades/spa_to_duende/",
    "title": "Microsoft SPA and Blazor Templates",
    "tags": [],
    "description": "",
    "content": "Microsoft publishes templates for securing an API with token based security backed by the ASP.NET Identity identity management library. There are several templates; a couple for JavaScript-based SPA applications using React and Angular, and one for Blazor style SPA applications. All of these use Duende IdentityServer as the token server to issue tokens to the client-side code in the browser for securing calls to an API.\nThis upgrade guide discusses the design pattern of these templates and how you would migrate them to a more recommended architecture. This guide describes the high level architecture, and doesn\u0026rsquo;t go into the specifics of any code, and as such should suffice for the SPA/JavaScript templates, as well as the Blazor WASM template.\nTemplate Architecture with a Single Host Below is a picture showing the important moving parts of the template. The most important detail is that there is a single host for many different conceptual items, and this affects the security of the overall design. The one host serves up:\nSPA Assets (HTML, CSS, and JS (React, Angular) or WASM (Blazor)) ASP.NET Identity UI Pages (for login, logout, registration, etc) Duende IdentityServer (middleware for OIDC/OAuth protocol endpoints) The API In terms of workflow for ultimately securing calls to the API, the logical steps taken are:\n1: The SPA Assets are loaded from the host into the browser.\n2: The UI logic must then navigate the user to the login page. The login session is fundamentally tracked with a cookie managed by the ASP.NET cookie authentication handler. This authentication handler is configured by ASP.NET Identity.\n3: Once the user is logged in, the SPA must make OIDC/OAuth protocol requests to the endpoints managed by Duende IdentityServer. The authentication cookie from the prior step is what is used to identify the user. The result of this step is an access token that is maintained by the code running in the browser.\n4: Finally, the UI logic can securely invoke the API by passing the access token as the Authorization HTTP header. The code on the server will validate that the access token was issued by the instance of Duende IdentityServer that is hosted from this project.\nThe picture below shows these logical steps.\nArchitecture with Separate Hosts While the above architecture works, there are some disadvantages to the design presented in the template. There is an obvious complexity in using two different credential types in the single host (cookies and tokens). There are great pains taken in the template (hidden away in various extension methods and clever configuration in the DI system) to accept the access token for the API calls, but only accept the authentication cookie to the ASP.NET Identity Pages and the Duende IdentityServer endpoints.\nRelated to this, co-hosting your token server (i.e. Duende IdentityServer) with the application and API is simply not the recommended pattern. The intent of using a token server is to enable centralization of user authentication, which enables single sign-on for users. Co-hosting the token server with the client application (and API) is counter to that goal. Thus, the recommended approach is to host Duende IdentityServer (and then also the ASP.NET Identity Pages) in its own host separate from the app and API. Doing so would produce an architectural picture as such:\nThe steps in the logical workflow would remain the same, but now the token server is independent from any one app or API. Also, each host now only has one credential type to be concerned with, which simplifies the security model. Once you decide to add a new app or API into your architecture, it\u0026rsquo;s very little effort to integrate them with the existing token server. And of course, your users would get single sign-on across all of those applications. Finally, from a deployment standpoint, each of the various hosts is separate and can be updated/versioned/patched separately, as needed.\nBFF Architecture with a Remote API There is another point about the security of the SPA invoking the API that requires discussion.\nThe design of the template utilizes an access token to secure calls to the API. It makes sense to secure APIs with access tokens when those APIs need to be accessed by a variety of applications, including those not even running in a browser. This would be an example of a shared API. But very often, an API that is co-hosted with a SPA front end really only exists to support the UI and won\u0026rsquo;t expect to be invoked by any other application. In this case, it might be overkill to design this \u0026ldquo;local\u0026rdquo; API to require an access token. Also, there are a variety of factors that make is undesirable (and sometimes impossible) for code running in the browser to fully manage tokens obtained from the OIDC/OAuth protocol.\nThus, one additional improvement to the architecture presented so far would be to introduce the BFF pattern.\nThe BFF pattern changes the credential used from the SPA to the backend to instead use a cookie (much like the cookie used in IdentityServer). This would allow securing calls to a \u0026ldquo;local\u0026rdquo; API that is co-hosted in the backend. And then if there is a \u0026ldquo;remote\u0026rdquo; API (e.g. a shared API) hosted elsewhere that accepts access tokens, it is accessible from the code running in the application.\nThe picture below illustrates:\nStep 3: This step from the prior diagrams now results in an authentication session cookie in the SPA application, and an optional access token (depending if a remote API needs to be invoked). This access token is associated with the user\u0026rsquo;s session and would only ever be available on the server-side of the SPA host (i.e. the backend, or BFF).\nStep 4a: All calls from the SPA to the backend now use the authentication cookie to authenticate the call. If a local API is the only API needed, then there is no need for an access token anywhere in the app. The benefit is that the code client-side does not have to manage anything with the OIDC/OAuth protocol or sending tokens on API calls, and thus is simpler.\nStep 4b: If a remote API needs to be invoked, then the access token associated with the user\u0026rsquo;s authentication session can be used. This access token is only available on the server. It can be used from the local API invoking a remote API, or a reverse proxy can be setup in the SPA host (e.g. using Microsoft\u0026rsquo;s YARP) to allow more of a pass-through style so the SPA code can invoke the remote API without manual coding to pass along the access token.\nThe Duende BFF Security Framework makes this architecture easy to implement.\nMigrating The last aspect of the template which requires discussion is that there is configuration required when using OIDC/OAuth. This configuration models the client application (the SPA) as well as the API being secured. Typically, all the players (the app, the API, and the token server) require their own store for their relevant configuration data. Given that the template co-hosts all three of these, more great pains were taken to hide all of this configuration from the developer. The various extension methods that are provided for the template that sets up Duende IdentityServer, that performs the automatic configuration, and the client-side code that bootstraps the security in the browser all assume this co-hosting model. While this might be convenient when co-hosting, when you split the hosts into the recommended architecture then the configuration must be more explicit.\nUnfortunately what this means is that is it non-trivial to migrate a project from the template to the recommended architecture. Rather, it makes more sense to follow the quickstart guides to setup a properly designed architecture. Once that\u0026rsquo;s in place, then it will be more obvious how to take any existing application created with the template and preserve the relevant application assets to use the token server you have setup in its own host.\nIt is recommended you start with the first quickstart (if you haven\u0026rsquo;t already), and follow through the progression. This will allow you to understand the configuration needed when using OIDC/OAuth. If you\u0026rsquo;re already familiar with hosting and configuring IdentityServer, then you can jump right to the JavaScript quickstart or the Blazor quickstart.\nIt is worth noting why the template is designed the way it is. First, at the time the template was created, the templating system from Microsoft could only support a single project. This explains why all the different logical pieces are lumped into a single host. Second, why was a token based design chosen to secure the API co-hosted with the login page. The assumption is that as projects grow and more and more applications are added to the architecture, the design would eventually require a token based architecture (presumably hosted separately). Thus, rather than require rework later on, starting with a token based design makes sense and acclimates developers to those fundamentals from the beginning. Third, it\u0026rsquo;s assumed that the automatic self-configuration done in the template would avoid 1) the hassle of explicit configuration needed for the OIDC/OAuth protocols when the template is deployed, and 2) the need to explain the mechanics of the protocols.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/tokens/jar/",
    "title": "Signed Authorize Requests",
    "tags": [],
    "description": "",
    "content": "Instead of providing the parameters for an authorize request as individual query string key/value pairs, you can package them up in signed JWTs. This makes the parameters tamper proof and you can authenticate the client already on the front-channel.\nSee here for a sample for using signed authorize requests (and JWT-based authentication) in ASP.NET Core.\nYou can either transmit them by value or by reference to the authorize endpoint - see the spec for more details.\nDuende IdentityServer requires the request JWTs to be signed. We support X509 certificates and JSON web keys, e.g.:\nvar client = new Client { ClientId = \u0026#34;foo\u0026#34;, // set this to true to accept signed requests only RequireRequestObject = true, ClientSecrets = { new Secret { // X509 cert base64-encoded Type = IdentityServerConstants.SecretTypes.X509CertificateBase64, Value = Convert.ToBase64String(cert.Export(X509ContentType.Cert)) }, new Secret { // RSA key as JWK Type = IdentityServerConstants.SecretTypes.JsonWebKey, Value = \u0026#34;{\u0026#39;e\u0026#39;:\u0026#39;AQAB\u0026#39;,\u0026#39;kid\u0026#39;:\u0026#39;...\u0026#39;,\u0026#39;kty\u0026#39;:\u0026#39;RSA\u0026#39;,\u0026#39;n\u0026#39;:\u0026#39;...\u0026#39;}\u0026#34; } } } Passing request JWTs by reference If the request_uri parameter is used, IdentityServer will make an outgoing HTTP call to fetch the JWT from the specified URL.\nYou can customize the HTTP client used for this outgoing connection, e.g. to add caching or retry logic (e.g. via the Polly library):\nidsvrBuilder.AddJwtRequestUriHttpClient(client =\u0026gt; { client.Timeout = TimeSpan.FromSeconds(30); }) .AddTransientHttpErrorPolicy(policy =\u0026gt; policy.WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(3) })); Request URI processing is disabled by default. Enable on the Endpoints on the IdentityServerOptions. Also see the security considerations from the JAR specification.\nAccessing the request object data You can access the validated data from the request object in two ways:\nWherever you have access to the ValidatedAuthorizeRequest, the RequestObjectValues dictionary holds the values. In the UI code you can call IIdentityServerInteractionService.GetAuthorizationContextAsync, the resulting AuthorizationRequest object contains the RequestObjectValues dictionary as well. "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/ui/portal/",
    "title": "Client Application Portal",
    "tags": [],
    "description": "",
    "content": "(Added in 6.3)\nYou can create a client application portal within your IdentityServer host that contains links to client applications that are configured with an InitiateLoginUri. InitiateLoginUri is an optional URI that can be used to initiate login. Your IdentityServer host can check for clients with this property and render links to those applications.\nThose links are just links to pages within your client applications that will start an OIDC challenge when the user follows them. This creates a curious pattern, where the user follows a link from the portal page in the IdentityServer host to an external application only to have that application immediately redirect back to the IdentityServer host\u0026rsquo;s /connect/authorize endpoint. However, if the user has logged in and created a session at the IdentityServer host, they will get a single sign on experience as they navigate to the various applications in the portal.\nThe quickstart UI contains an example of such a portal in the ~/portal razor page.\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/tokens/par/",
    "title": "Pushed Authorization Requests",
    "tags": [],
    "description": "",
    "content": "(Added in 7.0)\nPushed Authorization Requests (PAR) is a relatively new OAuth standard that improves the security of OAuth and OIDC flows by moving authorization parameters from the front channel to the back channel (that is, from redirect URLs in the browser to direct machine to machine http calls on the back end).\nThis prevents an attacker in the browser from\nseeing authorization parameters (which could leak PII) and from tampering with those parameters (e.g., the attacker could change the scope of access being requested). Pushing the authorization parameters also keeps request URLs short. Authorize parameters might get very long when using more complex OAuth and OIDC features, and URLs that are long cause issues in many browsers and networking infrastructure.\nThe use of PAR is encouraged by the FAPI working group within the OpenID Foundation. For example, the FAPI2.0 Security Profile requires the use of PAR. This security profile is used by many of the groups working on open banking (primarily in Europe), in health care, and in other industries with high security requirements.\nLicensing Duende.IdentityServer includes support for PAR in the Business Edition or higher license. In the starter edition, PAR requests will not be processed and instead log errors. If you have a starter edition license, you should disable the EnablePushedAuthorizationEndpoint flag so that discovery indicates that your IdentityServer does not support PAR:\nbuilder.Services.AddIdentityServer(options =\u0026gt; { options.Endpoints.EnablePushedAuthorizationEndpoint = false; }) Client Usage Using PAR is similar to other flows that use the authorization endpoint, but it adds an initial back-channel request to a new protocol endpoint for pushed authorization requests. This endpoint requires client authentication and accepts POSTed form-urlencoded data containing all of the same parameters that are accepted at the authorize endpoint.\nThe result of the PAR request is JSON containing an identifier (the request_uri property) and expiration information (the expires_in property). Clients then send that identifier to the authorize endpoint instead of the parameters that were just pushed. From there, the OAuth or OIDC flow continues as normal. For example, in the authorization code flow, the user will be redirected to login and other UI pages as necessary before being redirected back to the client with an authorization code which the client subsequently exchanges for tokens.\nA sample of how to implement this flow in an ASP.NET application is available here.\nData Store Pushed authorization requests are stored in the IPushedAuthorizationRequestStore, which includes methods to store, retrieve, and consume pushed requests. Pushed requests that are not used are removed by the token cleanup job.\nConfiguration IdentityServerOptions now includes the PushedAuthorization property to configure PAR. PushedAuthorizationOptions.Required causes PAR to be required globally. This defaults to false. PushedAuthorizationOptions.Lifetime controls the lifetime of pushed authorization requests. The pushed authorization request\u0026rsquo;s lifetime begins when the request to the PAR endpoint is received, and is validated until the authorize endpoint returns a response to the client application. Note that user interaction, such as entering credentials or granting consent, may need to occur before the authorize endpoint can do so. Setting the lifetime too low will likely cause login failures for interactive users, if pushed authorization requests expire before those users complete authentication. Some security profiles, such as the FAPI 2.0 Security Profile recommend an expiration within 10 minutes to prevent attackers from pre-generating requests. To balance these constraints, this lifetime defaults to 10 minutes. PushedAuthorizationOptions.AllowUnregisteredPushedRedirectUris controls whether clients may use redirect uris that were not previously registered. This is a relaxation of security guidance that is specifically allowed by the PAR specification because the pushed authorization requests are authenticated. It defaults to false. The Client configuration object now includes two new properties to configure PAR on a per-client basis. Client.RequirePushedAuthorization controls if this client requires PAR. PAR is required if either the global configuration is enabled or if the client\u0026rsquo;s flag is enabled (this can\u0026rsquo;t be used to opt out of the global configuration). This defaults to false, which means the global configuration will be used. Client.PushedAuthorizationLifetime controls the lifetime of pushed authorization requests for a client. If this lifetime is set, it takes precedence over the global configuration. This defaults to null, which means the global configuration is used. The EndpointOptions now includes a new flag to enable or disable the PAR endpoint: EnablePushedAuthorizationEndpoint, which defaults to true. "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/tokens/cors/",
    "title": "Calling Endpoints from JavaScript",
    "tags": [],
    "description": "",
    "content": "In JavaScript-based clients, some endpoints like the token endpoint (but also discovery) will be accessed via Ajax calls.\nGiven that your IdentityServer will most likely be hosted on a different origin than these clients, this implies that Cross-Origin Resource Sharing (CORS) will need to be configured.\nClient-based CORS Configuration One approach to configuring CORS is to use the AllowedCorsOrigins collection on the client configuration. Simply add the origin of the client to the collection and the default configuration in IdentityServer will consult these values to allow cross-origin calls from the origins.\nBe sure to use an origin (not a URL) when configuring CORS. For example: https://foo:123/ is a URL, whereas https://foo:123 is an origin.\nThis default CORS implementation will be in use if you are using either the \u0026ldquo;in-memory\u0026rdquo; or EF-based client configuration that we provide. If you define your own IClientStore, then you will need to implement your own custom CORS policy service (see below).\nCustom Cors Policy Service Duende IdentityServer allows the hosting application to implement the ICorsPolicyService to completely control the CORS policy.\nThe single method to implement is: Task IsOriginAllowedAsync(string origin). Return true if the origin is allowed, false otherwise.\nOnce implemented, simply register the implementation in DI and IdentityServer will then use your custom implementation.\nDefaultCorsPolicyService If you simply wish to hard-code a set of allowed origins, then there is a pre-built ICorsPolicyService implementation you can use called DefaultCorsPolicyService.\nThis would be configured as a singleton in DI, and hard-coded with its AllowedOrigins collection, or setting the flag AllowAll to true to allow all origins.\nFor example, in ConfigureServices:\nbuilder.Services.AddSingleton\u0026lt;ICorsPolicyService\u0026gt;((container) =\u0026gt; { var logger = container.GetRequiredService\u0026lt;ILogger\u0026lt;DefaultCorsPolicyService\u0026gt;\u0026gt;(); return new DefaultCorsPolicyService(logger) { AllowedOrigins = { \u0026#34;https://foo\u0026#34;, \u0026#34;https://bar\u0026#34; } }; }); Use AllowAll with caution.\nMixing IdentityServer\u0026rsquo;s CORS policy with ASP.NET Core\u0026rsquo;s CORS policies IdentityServer uses the CORS middleware from ASP.NET Core to provide its CORS implementation. It is possible that your application that hosts IdentityServer might also require CORS for its own custom endpoints. In general, both should work together in the same application, providing the call to app.UseCors(\u0026ldquo;mypolicy\u0026rdquo;); is called after the call to app.UseIdentityServer();.\nYour code should use the documented CORS features from ASP.NET Core without regard to IdentityServer. This means you should define policies and register the middleware as normal. If your application defines policies in ConfigureServices, then those should continue to work in the same places you are using them (either where you configure the CORS middleware or where you use the MVC EnableCors attributes in your controller code). If instead you define an inline policy in the use of the CORS middleware (via the policy builder callback), then that too should continue to work normally.\nThe one scenario where there might be a conflict between your use of the ASP.NET Core CORS services and IdentityServer is if you decide to create a custom ICorsPolicyProvider. Given the design of the ASP.NET Core\u0026rsquo;s CORS services and middleware, IdentityServer implements its own custom ICorsPolicyProvider and registers it in the DI system. Fortunately, the IdentityServer implementation is designed to use the decorator pattern to wrap any existing ICorsPolicyProvider that is already registered in DI. What this means is that you can also implement the ICorsPolicyProvider, but it simply needs to be registered prior to IdentityServer in DI (e.g. in ConfigureServices).\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/reference/",
    "title": "Reference",
    "tags": [],
    "description": "Index",
    "content": "Reference IdentityServer Options EF Options DI Extension Methods Endpoints Models Services Response Generators Stores Validators "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/configuration/dcr/reference/",
    "title": "Reference",
    "tags": [],
    "description": "Dynamic Client Registration",
    "content": "Reference Validation Request Processing Store Response Generation Models Options "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/troubleshooting/",
    "title": "Troubleshooting",
    "tags": [],
    "description": "",
    "content": "When troubleshooting an IdentityServer setup we have some tips and tricks to share. These are both ways to get more information out of the system as well as how to detect and fix some common problems.\nGeneral debugging advice Duende IdentityServer is a security product and by design the error messages returned to a user or client application are very short. The actual error message is always written to the logs. The very first step in any troubleshooting should be to review the IdentityServer logs.\nAnother common issue is that the logs are redacted and that the interesting/relevant information is overwritten with \u0026rsquo;[PII is hidden]\u0026rsquo;. (For example The \u0026lsquo;[PII is hidden]\u0026rsquo; for signing cannot be smaller than \u0026lsquo;[PII is hidden]\u0026rsquo; bits). This is a privacy feature of the Microsoft.IdentityModel libraries that we use for token handling. The definition of possible PII in those libraries is very generous and includes key sizes, URLs etc.\nThere is a static property that can be set to disable the redacting.\nIdentityModelEventSource.ShowPII = true; We recommend to always set this flag to true in any development and test environment that does not contain real personal data.\nData protection Asp.Net Core Data Protection is an encryption mechanism that is heavily used by Duende.IdentityServer and the Asp.Net Core Authentication libraries. If it is not correctly configured it might result in issues such as\nUnable to unprotect the message.State. The key {xxxxx-xxxx-xxx-xxx-xxxxxxx} was not found in the key ring. Failed to unprotect AuthenticationTicket payload for key {key} See our data protection guide for more information.\nLoad Balancing, proxies and TLS offloading When running IdentityServer behind a load balancer it is important that IdentityServer still has access to the original request URL. IdentityServer uses that to create URLs that are included in the discovery document and in protocol messages.\nTo diagnose, open the discovery document (append /.well-known/openid-configuration to your root IdentityServer host), e.g. https://demo.duendesoftware.com/.well-known/openid-configuration. Make sure that the URLs listed in there have the correct host name and are listed as https (assuming you are running under https, which you should).\nSee our proxy guide for more information.\nTaskCancellationExceptions TaskCancellationExceptions occur when the incoming HTTP connection is terminated by the requestor. We pass the cancellation token along to Entity Framework so that it can cancel database queries and hopefully reduce load on your database. Both EF itself and the EF providers log those cancellations extremely aggressively before EF re-throws the exception. That unhandled exception then is handled by the IdentityServer middleware. This creates a lot of noise in the logs for what is actually expected behavior. It is normal for some HTTP requests to be canceled.\nTo help alleviate that, in version 6.2 of IdentityServer, we added a configurable filter to our logging to remove some of these unnecessary logs. Unfortunately the log messages that are written by EF itself are outside our control. Microsoft is in the process of updating EF to not log task cancellation so aggressively. In .NET 7, they were able to update the core EF but not the providers.\nSince we know that these task cancellations are expected and safe, another thing you could do is to filter them out of your logs. Most logging tools should allow you to put filters in place. For example, in serilog, adding something like this to your configuration should do the trick:\nLog.Logger = new LoggerConfiguration() .Filter .ByExcluding(logEvent =\u0026gt; logEvent.Exception is OperationCanceledException) WAF Rules Data protected data can contain \u0026lsquo;\u0026ndash;\u0026rsquo; (two dashes) and some firewalls disallow that because it looks like a sql comment/injection. This is not an IdentityServer issue but something that should be fixed on the firewall.\nMicrosoft.IdentityModel Version Conflicts The Microsoft.IdentityModel.* libraries used by Duende IdentityServer all have to be of exactly the same version. If they are not it can cause unexpected issues reading configuration data and tokens, i.e. IDX10500: Signature validation failed. No security keys were provided to validate the signature. or System.MissingMethodException: Method not found \u0026lsquo;Boolean Microsoft.IdentityModel.Tokens.TokenUtilities.IsRecoverableConfiguration(\u0026hellip;)\u0026rsquo;\nSee our guide for more information on how to diagnose and fix version issues.\nIdentityServerOptions.EmitStaticAudienceClaim and Token Validation Some token validation implementations require that all JWTs include an audience claim with the key/value of \u0026ldquo;aud\u0026rdquo; and \u0026quot;\u0026lt;issuer\u0026gt;/resources\u0026quot;.\nTo add an audience claim to tokens created by IdentityServer, set the value of IdentityServerOptions.EmitStaticAudienceClaim to true during the setup of your IdentityServer instance (default: false).\nservices.AddIdentityServer(options =\u0026gt; { // add \u0026#34;aud\u0026#34; claim to JWT options.EmitStaticAudienceClaim = true; }) .AddClientStore\u0026lt;ClientStore\u0026gt;() .AddInMemoryIdentityResources(IdentityResources) .AddInMemoryApiScopes(ApiScopes); "
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/samples/misc/",
    "title": "Miscellaneous",
    "tags": [],
    "description": "",
    "content": "Securing Azure Functions This sample shows how to parse and validate a JWT token issued by IdentityServer inside an Azure Function.\nlink to source code\nMutual TLS using Kestrel This sample shows how to use Kestrel using MTLS for client authentication and proof of possession API access. Using Kestrel will not likely be how MTLS is configured in a production environment, but it is convenient for local testing. This approach requires DNS entries for mtls.localhost and api.localhost to resolve to 127.0.0.1, and is easily configured by modifying your local hosts file.\nlink to source code\nDPoP This sample shows how to access APIs using DPoP for proof of possession. It contains two different clients; one that uses client credentials and DPoP tokens, and another that is an interactive ASP.NET Core app using code flow to obtain the DPoP bound tokens. Both clients demonstrate the use of the Duende.AccessTokenManagement library with DPoP. The sample also contains an API using the Duende.AspNetCore.Authentication.JwtBearer library to accept and validate DPoP bound access tokens.\nlink to source code\nSession Management This sample shows how to enable server-side sessions and configure the basic settings. The sample requires all three projects to be run at once.\nThings of note:\nIn the IdentityServerHost project in Startup.cs, server-side sessions are enabled with a call to AddServerSideSessions. This only uses in-memory server-side sessions by default, so restarting the host will lose session data. Also in Startup.cs with the call to AddIdentityServer various settings are configured on the ServerSideSessions options object to control the behavior. The client application configured in Clients.cs has CoordinateLifetimeWithUserSession enabled, which causes its refresh token to slide the server-side session for the user. When launching the IdentityServerHost project, you should visit the ~/serversidesessions page to see the active sessions. Note that there is no authorization on this page (so consider adding it based on your requirements). Once you login, you should see a user\u0026rsquo;s session in the list. As the client app refreshes its access token, you should see the user\u0026rsquo;s session expiration being extended. When you revoke the user\u0026rsquo;s session, the user should be logged out of the client app. link to source code\nSession Migration This sample shows how to do seamless migration of existing cookie-based session when enabling server side sessions. Normally when server side sesssions are enabled all existing logged in sessions are invalidated and the users are forced to log in again. If the application has sessions with long lifetimes where it would be a problem to have all users log in again the sessions can be migrated. Instructions for running the sample are in the HostingExtensions.cs file.\nlink to source code\n"
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/apis/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/apis/local/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/apis/remote/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/apis/yarp/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/architecture/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/architecture/third-party-cookies/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/architecture/ui-hosting/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/extensibility/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/extensibility/http_forwarder/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/extensibility/management/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/extensibility/management/back-channel-logout/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/extensibility/management/diagnostics/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/extensibility/management/login/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/extensibility/management/logout/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/extensibility/management/silent-login-callback/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/extensibility/management/silent-login/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/extensibility/management/user/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/extensibility/sessions/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/extensibility/tokens/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/options/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/overview/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/session/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/session/handlers/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/session/management/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/session/management/back-channel-logout/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/session/management/diagnostics/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/session/management/login/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/session/management/logout/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/session/management/silent-login/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/session/management/user/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/session/server_side_sessions/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/bff/tokens/",
    "title": "",
    "tags": [],
    "description": "",
    "content": ""
  },
  {
    "uri": "https://docs.duendesoftware.com/identityserver/v7/samples/bff/",
    "title": "BFF (Backend For Frontend)",
    "tags": [],
    "description": "",
    "content": ""
  }
]